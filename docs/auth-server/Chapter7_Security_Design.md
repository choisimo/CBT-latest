# Chapter 7: Security Design

This chapter details the security mechanisms implemented and planned for the Emotion-based AI Diary Application, covering authentication, authorization, data security, and threat countermeasures.

## 7.1. Authentication

Authentication is the process of verifying the identity of a user or service.

### 7.1.1. Local User Authentication

*   **Spring Security Framework:** The application leverages the Spring Security framework as the foundation for authentication and authorization.
*   **Authentication Process:**
    1.  Users submit their credentials (User ID and password) via a login API endpoint (e.g., `POST /api/auth/login`).
    2.  The `com.authentication.auth.filter.AuthenticationFilter` (a custom filter extending `AbstractAuthenticationProcessingFilter`) intercepts this request.
    3.  It extracts the credentials and creates a `UsernamePasswordAuthenticationToken`.
    4.  This token is passed to the `AuthenticationManager` (configured in `SecurityConfig`) for authentication.
    5.  The `DaoAuthenticationProvider` (typically configured by default) utilizes a `UserDetailsService`. In this application, `com.authentication.auth.service.security.PrincipalDetailService` implements `UserDetailsService`.
    6.  `PrincipalDetailService.loadUserByUsername()` fetches the user's details (including hashed password) from the MariaDB `Users` table via `UserRepository`.
    7.  **Password Hashing:** The `BCryptPasswordEncoder` (bean defined in `SecurityConfig`) is used to securely hash passwords during registration and to compare the submitted password with the stored hash during login. This protects against rainbow table attacks and makes it computationally difficult to reverse the hash.
    8.  If authentication is successful, JWTs (Access and Refresh Tokens) are generated.
*   **Configuration:** The main security filter chain and related beans are configured in `com.authentication.auth.configuration.security.SecurityConfig`.

### 7.1.2. Social Login (OAuth 2.0/OpenID Connect)

The application supports social logins using OAuth 2.0 for Kakao, Naver, and Google.

*   **Provider Flows:**
    1.  **Initiation:** The client requests a provider-specific login URL from the backend (e.g., `GET /api/public/oauth2/login_url/{provider}`).
    2.  **Redirection:** The client redirects the user to the provider's authentication page.
    3.  **Provider Authentication:** The user authenticates with the OAuth2 provider.
    4.  **Authorization Code Grant:** The provider redirects the user back to the application's registered callback URL (e.g., `/oauth2/callback/{provider}` as per `Oauth2Controller`) with an authorization code.
*   **Server-side Logic:**
    *   `com.authentication.auth.controller.auth.Oauth2Controller`: Handles the callback requests from the OAuth2 providers. It receives the authorization code.
    *   `com.authentication.auth.service.oauth2.Oauth2Service`:
        *   Exchanges the authorization code for an OAuth2 Access Token (and potentially a Refresh Token) from the provider.
        *   Uses the provider's Access Token to fetch the user's profile information from the provider.
        *   Implements logic to find an existing user in the application's database (MariaDB) based on the social ID or email, or registers a new user if they don't exist (`saveOrUpdateOauth2User` method).
        *   Generates the application's own JWT Access and Refresh Tokens for the user.
        *   Stores the provider's refresh token in Redis if applicable.
*   **CSRF Prevention (OAuth2):**
    *   **User Feedback:** The importance of the `state` parameter in OAuth2 flows for CSRF prevention is acknowledged.
    *   **Implementation Detail:** While the generic API doc `/api/public/oauth2/callback/{provider}` mentions `state` as an optional query parameter, the provider-specific callback methods in `Oauth2Controller` (e.g., for Naver) do use a `state` parameter.
    *   **Mechanism:** The `state` parameter is an opaque value generated by the client/backend before redirecting to the OAuth provider. This same value is then included by the provider in the callback request. The application must validate that the `state` value in the callback matches the originally generated one. This ensures that the callback request is a legitimate response to a user-initiated flow from the application, not a malicious attempt to trick the user into an unintended login. `Oauth2Service` for Naver explicitly includes `state` in token requests. This should be consistently applied and validated for all OAuth2 flows if not already.

### 7.1.3. JWT (JSON Web Token) Management

JWTs are used to maintain user sessions in a stateless manner.

*   **Token Structure:**
    *   **Access Token:**
        *   Contains claims like `userId` (user's login ID) and `role` (user's authorities/roles).
        *   Used for authenticating API requests to protected resources.
        *   Generated by `com.authentication.auth.configuration.token.JwtUtility` (via `TokenProvider`).
    *   **Refresh Token:**
        *   Primarily used to obtain a new Access Token when the current one expires.
        *   It's a JWT as well but may not carry extensive user claims beyond what's needed for validation (current `JwtUtility` creates it with empty claims, its primary purpose is its value and expiration).
*   **Validity Period (Configured via `AppProperties`):**
    *   **Access Token:** Relatively short-lived (e.g., 15 minutes to 1 hour) to limit the impact of potential token leakage. `appProperties.getAccessTokenValidity()`.
    *   **Refresh Token:** Longer-lived (e.g., 7 days to 30 days). `appProperties.getRefreshTokenValidity()`.
*   **Signing Algorithm:**
    *   HMAC SHA512 (`SignatureAlgorithm.HS512`) is used for signing both Access and Refresh Tokens, as seen in `JwtUtility`. The secret key is configured via `appProperties.getJwtSecretKey()`.
*   **Token Storage:**
    *   **Access Token:**
        *   Returned in the login response body.
        *   Client-side: Typically stored in memory (e.g., JavaScript variable) or secure browser storage (like `sessionStorage` or `localStorage`, though memory is often preferred for XSS mitigation).
        *   Also set as an HttpOnly, Secure cookie by `AuthenticationFilter`, which could be an alternative way for the client to possess it if not relying on JS storage.
    *   **Refresh Token:**
        *   Server-side: Stored in Redis by `com.authentication.auth.service.redis.RedisService` (`saveRToken` method), keyed by user ID and provider. This allows for server-side validation and revocation if needed.
        *   Client-side: Sent to the client as an HttpOnly, Secure cookie to protect it from XSS attacks and ensure it's only sent over HTTPS.
*   **Token Refresh & Rotation:**
    *   **Current Re-issuance Logic:** When an Access Token expires, the client sends the expired Access Token and the Refresh Token (via cookie) to the `/auth/api/protected/refresh` endpoint (`TokenController`). The `TokenService` validates the Refresh Token against Redis and its own validity. If valid, a new Access Token is issued.
    *   **Security Implications & Recommendation (Refresh Token Rotation):**
        *   The current implementation in `TokenService` and `JwtUtility.refreshToken()` appears to reuse the existing valid Refresh Token when a new Access Token is issued.
        *   **Security Risk of Reuse:** If a Refresh Token is compromised, it can be used to generate new Access Tokens until it expires.
        *   **Recommendation:** Implement **Refresh Token Rotation**. When a Refresh Token is used to obtain a new Access Token, the server should:
            1.  Invalidate the used Refresh Token (e.g., delete it from Redis or mark it as used).
            2.  Issue a brand new Refresh Token along with the new Access Token.
            3.  Send the new Refresh Token to the client via a new HttpOnly, Secure cookie.
            This significantly reduces the window of opportunity for a compromised Refresh Token to be exploited. If an attacker tries to reuse an old (rotated) refresh token, the server can detect this (as it's no longer valid or present in Redis) and potentially invalidate all sessions for that user as a precaution.
*   **Token Hijacking and Misuse Prevention:**
    *   **Short-lived Access Tokens:** Limits the time an attacker can use a compromised Access Token.
    *   **Refresh Token Rotation (Recommended):** Makes it harder to continuously use a compromised Refresh Token.
    *   **Secure Storage:** HttpOnly cookies for Refresh Tokens prevent client-side JavaScript access. HTTPS ensures tokens are encrypted in transit.
    *   **Server-side Validation of Refresh Tokens:** Storing and validating refresh tokens in Redis allows the server to invalidate them if suspicious activity is detected or a user logs out.
    *   **(Optional) IP Address Binding:** For highly sensitive applications, refresh tokens could be bound to the IP address from which they were issued, though this can cause issues with mobile users or those with dynamic IPs.

## 7.2. Authorization

Authorization determines what an authenticated user is allowed to do.

### 7.2.1. Role-Based Access Control (RBAC)

*   **Roles:**
    *   The primary roles defined appear to be `USER` and `ADMIN`. This is inferred from `User.userRole` field (String type, defaults to "USER" in the entity builder) and checks in `AuthorizationFilter` (checks for "ROLE_ADMIN" or "ADMIN").
    *   The `User.java` entity has a `userRole` field (String). A more robust implementation would use an Enum for `UserRole` as suggested in `Data_Models_Entities.md` (`User.UserRole` enum: USER, ADMIN) to ensure type safety and consistency.
*   **Resource Mapping:**
    *   `SecurityConfig.java` uses `http.authorizeHttpRequests()` to define access rules:
        *   Static resources and paths under `/api/public/**` are permitted for all.
        *   The arrays `userRestrict`, `adminRestrict`, `companyRestrict` are currently defined as empty in `SecurityConfig`. If populated, they would restrict access to specific path patterns based on roles/authorities (e.g., `.requestMatchers(adminRestrict).hasAuthority("ADMIN")`).
        *   Currently, `.anyRequest().permitAll()` is specified after these, which means any request not matched by preceding rules is permitted. This should be reviewed and potentially changed to `.anyRequest().authenticated()` for a default deny approach for unauthenticated users on non-public paths.

### 7.2.2. Spring Security Filters for URL Pattern Control

*   **`com.authentication.auth.filter.AuthorizationFilter`:** This custom filter plays a role in authorization.
    *   It checks if the request path starts with `SecurityConstants.ADMIN_API_PATH.getValue()` (e.g., `/api/admin/`).
    *   If it's an admin path, it verifies that the authenticated user (from `SecurityContextHolder`) has an "ADMIN" or "ROLE_ADMIN" role.
    *   If not an admin path or if the user has the required role, it allows the request to proceed down the filter chain.
    *   It uses a `FilterRegistry` to potentially skip filtering for public paths.
*   **Configuration in `SecurityConfig`:** `SecurityConfig.java` does not directly add `AuthorizationFilter` or `AuthenticationFilter` to the `HttpSecurity` filter chain using `http.addFilterBefore/After()`. Instead, `SecurityFilterConfig.java` registers them using `FilterRegistrationBean`. The interaction and exact ordering need to be clear (see Section 7.6).

### 7.2.3. API Endpoint-Specific Permissions

*   **`/api/admin/**`:** Requires `ADMIN` role, as enforced by `AuthorizationFilter`.
*   **`/api/protected/**` (from API docs):** Implies these endpoints require authentication (a valid JWT). Specific role requirements beyond just being authenticated are not explicitly detailed in `SecurityConfig`'s current `userRestrict` arrays but could be added.
*   **`/api/diaries/**` (New Diary API):** Would typically require `USER` role and ownership checks (e.g., a user can only access/modify their own diaries). This ownership check would be done programmatically within the service layer.
*   **`/api/settings/**` (New Settings API):** Would require `USER` role, and operations would apply to the authenticated user's settings.

## 7.3. Data Security

### 7.3.1. Transport Layer Security (TLS/SSL)

*   **HTTPS:** All communication between the client and the server (API Gateway/Nginx) should be enforced over HTTPS. This is typically configured at the API Gateway (Nginx) or load balancer level, which would handle SSL/TLS termination. This encrypts data in transit, protecting against eavesdropping.

### 7.3.2. Stored Data Encryption

*   **Passwords:** User passwords are encrypted (hashed) using `BCryptPasswordEncoder` before being stored in the `Users` table in MariaDB. This is a one-way hashing algorithm with a salt, providing strong protection.
*   **Other Sensitive Data:**
    *   There is no evidence from the analyzed code or documentation (`Data_Models_Entities.md`, `schema.sql`) of explicit encryption for other sensitive data fields at rest in the database (e.g., diary content, user profile information beyond password).
    *   **Recommendation:** If diary content or other user data is considered highly sensitive, application-level encryption or database-level Transparent Data Encryption (TDE, if supported and configured for MariaDB) should be considered. Jasypt is included as a dependency (`com.github.ulisesbocchio:jasypt-spring-boot-starter`) which is excellent for encrypting configuration properties (like secret keys), but it's not clear if it's used for encrypting entity fields directly.

## 7.4. Key Security Threats and Countermeasures

### 7.4.1. CSRF (Cross-Site Request Forgery)

*   **Relevance for JWT APIs:** CSRF attacks primarily target stateful applications that rely on session cookies for authentication. For stateless APIs authenticated using JWTs passed in Authorization headers, the risk is generally lower because the browser doesn't automatically send the JWT header with cross-origin requests.
*   **Current Configuration:** `SecurityConfig.java` explicitly disables CSRF protection: `http.csrf(AbstractHttpConfigurer::disable)`. This is a common practice for stateless JWT-based APIs.
*   **OAuth2 CSRF:** As discussed in 7.1.2, the `state` parameter is crucial for preventing CSRF during the OAuth2 authorization code grant flow.
*   **Caution:** If any part of the application still uses session cookies for authentication or managing stateful operations (even if APIs use JWTs), those parts could be vulnerable if CSRF protection is globally disabled. Ensure that any cookie-based sessions (if any) are properly protected.

### 7.4.2. XSS (Cross-Site Scripting)

*   **Prevention:**
    *   **Input Validation:**
        *   Backend: DTOs use validation annotations (`@NotBlank`, `@Email`, etc.) to validate incoming data. Further sanitization or validation should occur in the service layer if complex HTML or script-like content is expected (though generally, it should be disallowed for fields like diary content if it's rendered as HTML without sanitization).
    *   **Output Encoding:**
        *   This is primarily a frontend responsibility. When displaying data (especially user-generated content like diary entries), the client application must properly encode or sanitize it to prevent any malicious scripts from being executed in the user's browser.
    *   **Content Security Policy (CSP):** Implementing CSP headers via Nginx or Spring Security can further mitigate XSS risks by restricting the sources from which scripts can be loaded.
    *   **Backend:** The backend should avoid reflecting unvalidated user input directly in HTML responses if it generates any HTML views (though this application appears to be primarily a JSON API backend).

### 7.4.3. SQL Injection

*   **Mitigation:** The application uses Spring Data JPA and Hibernate, which primarily use parameterized queries (prepared statements) by default. This significantly protects against SQL injection vulnerabilities as user input is treated as data, not executable SQL code.
*   **Caution:** If native SQL queries are ever used (`@Query(value = "...", nativeQuery = true)`), developers must ensure that any user input incorporated into such queries is properly sanitized or that parameters are used correctly.

### 7.4.4. API Request Limiting (Rate Limiting)

*   **Purpose:** To prevent abuse, denial-of-service (DoS) attacks, and brute-force attacks (e.g., on login or email verification endpoints).
*   **Implementation:** Not explicitly detailed in the current backend codebase.
*   **Recommendation:** Implement rate limiting. This is often best handled at the API Gateway level (e.g., using Nginx modules like `ngx_http_limit_req_module`) or with specialized services. It can also be implemented within Spring Boot using libraries like Resilience4J or Spring Cloud Gateway if it were used.

### 7.4.5. Secure Cookie Usage

*   **Refresh Token Cookie:** `AuthenticationFilter.sendFrontNewCookie()` sets the refresh token cookie with:
    *   `HttpOnly=true`: Prevents access from client-side JavaScript (mitigates XSS impact).
    *   `Secure=true`: Ensures the cookie is only sent over HTTPS.
    *   `Path=/`: Sets the cookie path.
    *   `Max-Age`: Sets the expiration time.
    *   `Domain`: Configurable via `appProperties.getCookieDomain()`.
*   **SameSite Attribute:**
    *   **Recommendation:** Explicitly set the `SameSite` attribute for cookies.
        *   `SameSite=Strict` or `SameSite=Lax` provides protection against CSRF attacks by controlling when cookies are sent with cross-origin requests. `Lax` is a good default for many applications. This should be added to the cookie configuration.

## 7.5. External API 연동 보안 - External API Integration Security

### 7.5.1. Social Login Provider API Calls

*   **Client ID/Secret Management:** For communicating with OAuth2 providers (Google, Kakao, Naver), the application uses Client IDs and Client Secrets.
    *   These credentials are sensitive and must be stored securely.
    *   `OauthProperties.java` suggests these are loaded from configuration.
    *   **Best Practices:**
        *   Store secrets outside the codebase (e.g., in environment variables, external configuration files with restricted access).
        *   Use encrypted properties files (Jasypt is a dependency and can be used for this).
        *   In production, consider using a dedicated secrets management system (e.g., HashiCorp Vault, AWS Secrets Manager, Azure Key Vault).

### 7.5.2. Other External API Keys

*   **General Principles:** If the application integrates with other external APIs that require API keys:
    *   Store keys securely, following the same principles as OAuth2 client secrets.
    *   Limit the permissions associated with API keys to the minimum required.
    *   Rotate API keys periodically if the provider supports it.
    *   Do not embed keys directly in client-side code. All calls requiring such keys should be proxied through the backend.

## 7.6. Security Configuration Consolidation

*   **Current Filter Configuration:**
    *   `SecurityConfig.java` uses `http.authorizeHttpRequests()` and other `HttpSecurity` DSL methods to configure the main Spring Security filter chain.
    *   `SecurityFilterConfig.java` uses `FilterRegistrationBean` to register `AuthenticationFilter` and `AuthorizationFilter`. `AuthenticationFilter` extends `AbstractAuthenticationProcessingFilter` (a Spring Security class) and `AuthorizationFilter` is a custom `AbstractSecurityFilter`.
*   **User Feedback & Recommendation:**
    *   The use of both `HttpSecurity` DSL in `SecurityConfig` and `FilterRegistrationBean` in `SecurityFilterConfig` for security-related filters can be confusing and make it harder to determine the exact filter order and effective security policy. `FilterRegistrationBean` is often used for filters that are not tightly integrated with Spring Security's chain or when specific servlet dispatcher types are needed.
    *   **Recommendation:** For clarity, explicitness, and centralized control over the Spring Security filter chain, it is strongly recommended to consolidate the registration and ordering of all security-specific filters (like `AuthenticationFilter` and `AuthorizationFilter`) within `SecurityConfig.java` using methods like `http.addFilterBefore(new MyCustomFilter(), UsernamePasswordAuthenticationFilter.class)` or `http.addFilterAfter()`.
        *   This makes the filter order explicit and leverages Spring Security's internal mechanisms for managing the chain.
        *   If `SecurityFilterConfig.java` is used for non-security, general-purpose servlet filters, its purpose should be clearly documented to distinguish it from Spring Security's configuration. If its purpose *is* to register these security filters, then migrating that logic to `SecurityConfig` is advised.
        *   The `AuthenticationFilter` is already designed to be a Spring Security filter (it requires an `AuthenticationManager`). The `AuthorizationFilter` also interacts with `SecurityContextHolder`. Their integration into the main `SecurityFilterChain` via `HttpSecurity` would be more idiomatic.
I have successfully drafted Chapter 7: Security Design.

This chapter covers:
-   **Authentication:** Local user authentication (Spring Security, `AuthenticationFilter`, `PrincipalDetailService`, BCrypt), Social Login (OAuth2 flows for Kakao/Naver/Google, `Oauth2Controller`, `Oauth2Service`, CSRF `state` parameter), and JWT Management (structure, validity, signing, storage, refresh/rotation recommendations, misuse prevention).
-   **Authorization:** RBAC (USER, ADMIN roles from `User.userRole`), Spring Security filters (`AuthorizationFilter`), and API endpoint permissions.
-   **Data Security:** TLS/HTTPS, stored data encryption (passwords with BCrypt, recommendation for other sensitive data).
-   **Key Security Threats and Countermeasures:** CSRF (disabled, OAuth2 state), XSS (input validation, output encoding), SQL Injection (JPA), API Rate Limiting (recommendation), Secure Cookie Usage (HttpOnly, Secure, SameSite recommendation).
-   **External API Integration Security:** Secure management of OAuth2 client secrets and general API key principles.
-   **Security Configuration Consolidation:** Addressed user feedback by recommending the consolidation of security filter definitions into `SecurityConfig.java` for clarity and explicit control over the filter chain, clarifying the role of `SecurityFilterConfig.java`.

The content was based on the analysis of security-related Java classes (`SecurityConfig`, `SecurityFilterConfig`, `AuthenticationFilter`, `AuthorizationFilter`, `JwtUtility`, `Oauth2Service`, `PrincipalDetailService`, `RedisService`, `User`), `Security_Overview.md`, and incorporated specific user feedback points.

The output is a markdown formatted file named `Chapter7_Security_Design.md`.

I am now ready to submit this subtask.
