========================================
Project Summary Report
========================================
Project Path: /workspace/Auth-Server_Spring-Security
Generated: Sun May 18 08:07:42 PM KST 2025

Exclusion Patterns Applied: .git .idea .vscode

========================================
Project Directory Structure
========================================
[01;34m/workspace/Auth-Server_Spring-Security[0m
|-- [01;34mauth-server-refactoring[0m
|   `-- [01;34msrc[0m
|       `-- [01;34mmain[0m
|           `-- [01;34mjava[0m
|               `-- [01;34mcom[0m
|                   `-- [01;34mauthentication[0m
|                       `-- [01;34mauth[0m
|                           |-- [01;34mconfiguration[0m
|                           |   |-- SecurityConfig.java
|                           |   `-- [01;34mtoken[0m
|                           |       `-- JwtUtility.java
|                           |-- [01;34mconstants[0m
|                           |   |-- ErrorType.java
|                           |   |-- FilterOrder.java
|                           |   `-- SecurityConstants.java
|                           |-- [01;34mdomain[0m
|                           |   |-- AuthProvider.java
|                           |   |-- UserAuthentication.java
|                           |   `-- User.java
|                           |-- [01;34mdto[0m
|                           |   |-- [01;34memail[0m
|                           |   |   |-- CustomEmailRequest.java
|                           |   |   |-- EmailCheckRequest.java
|                           |   |   `-- EmailRequest.java
|                           |   |-- [01;34mresponse[0m
|                           |   |   `-- ApiResponse.java
|                           |   |-- [01;34mtoken[0m
|                           |   |   |-- TokenDto.java
|                           |   |   `-- TokenRefreshRequest.java
|                           |   `-- [01;34musers[0m
|                           |       |-- JoinRequest.java
|                           |       |-- LoginRequest.java
|                           |       `-- UserProfileResponse.java
|                           |-- [01;34mfilter[0m
|                           |   |-- AbstractSecurityFilter.java
|                           |   |-- AuthenticationFilter.java
|                           |   |-- AuthorizationFilter.java
|                           |   |-- FilterCondition.java
|                           |   |-- FilterRegistry.java
|                           |   |-- JwtVerificationFilter.java
|                           |   |-- PathPatternFilterCondition.java
|                           |   |-- PluggableFilter.java
|                           |   `-- SecurityFilterOrder.java
|                           `-- [01;34mservice[0m
|                               `-- [01;34mredis[0m
|                                   `-- RedisService.java
|-- [01;34mbackend[0m
|   |-- [01;34mbin[0m
|   |   |-- [01;34mdefault[0m
|   |   |-- [01;34mgenerated-sources[0m
|   |   |   `-- [01;34mannotations[0m
|   |   |-- [01;34mgenerated-test-sources[0m
|   |   |   `-- [01;34mannotations[0m
|   |   |-- [01;34mmain[0m
|   |   |   |-- [01;32mapplication-database.properties[0m
|   |   |   |-- [01;32mapplication-oauth-google.properties[0m
|   |   |   |-- [01;32mapplication-oauth-kakao.properties[0m
|   |   |   |-- [01;32mapplication-oauth-naver.properties[0m
|   |   |   |-- [01;32mapplication.properties[0m
|   |   |   |-- [01;34mcom[0m
|   |   |   |   `-- [01;34mauthentication[0m
|   |   |   |       `-- [01;34mauth[0m
|   |   |   |           |-- AuthApplication.class
|   |   |   |           |-- [01;34mconfig[0m
|   |   |   |           |   `-- SecurityFilterConfig.class
|   |   |   |           |-- [01;34mconfiguration[0m
|   |   |   |           |   |-- [01;34mredis[0m
|   |   |   |           |   |   `-- redisConfig.class
|   |   |   |           |   |-- [01;34mresource[0m
|   |   |   |           |   |   `-- webMvcConfig.class
|   |   |   |           |   |-- [01;34msecurity[0m
|   |   |   |           |   |   |-- corsConfig.class
|   |   |   |           |   |   |-- publicAPI.class
|   |   |   |           |   |   `-- SecurityConfig.class
|   |   |   |           |   |-- SecurityConfig.class
|   |   |   |           |   |-- [01;34msmtp[0m
|   |   |   |           |   |   `-- smtpConfig.class
|   |   |   |           |   `-- [01;34mtoken[0m
|   |   |   |           |       `-- jwtUtility.class
|   |   |   |           |-- [01;34mcontroller[0m
|   |   |   |           |   |-- [01;34mauth[0m
|   |   |   |           |   |   |-- AuthController.class
|   |   |   |           |   |   |-- oauth2Controller.class
|   |   |   |           |   |   `-- tokenController.class
|   |   |   |           |   |-- emailController.class
|   |   |   |           |   |-- sseController.class
|   |   |   |           |   `-- usersController.class
|   |   |   |           |-- [01;34mdocument[0m
|   |   |   |           |   `-- [01;32mDev-Schedule.md[0m
|   |   |   |           |-- [01;34mdomain[0m
|   |   |   |           |   |-- AuthProvider.class
|   |   |   |           |   |-- DiaryAnswer$EmotionStatus.class
|   |   |   |           |   |-- DiaryAnswer.class
|   |   |   |           |   |-- Diary.class
|   |   |   |           |   |-- SettingsOption$DataType.class
|   |   |   |           |   |-- SettingsOption.class
|   |   |   |           |   |-- User$UserRole.class
|   |   |   |           |   |-- User$UserStatus.class
|   |   |   |           |   |-- UserAuthentication.class
|   |   |   |           |   |-- UserAuthenticationId.class
|   |   |   |           |   |-- User.class
|   |   |   |           |   |-- UserCustomSetting.class
|   |   |   |           |   `-- UserCustomSettingId.class
|   |   |   |           |-- [01;34mDTO[0m
|   |   |   |           |   |-- [01;34msmtp[0m
|   |   |   |           |   |   |-- customEmailRequest.class
|   |   |   |           |   |   |-- customEmailToAllRequest.class
|   |   |   |           |   |   |-- emailCheckDto.class
|   |   |   |           |   |   |-- emailFindById.class
|   |   |   |           |   |   `-- emailRequest.class
|   |   |   |           |   |-- [01;34mtoken[0m
|   |   |   |           |   |   |-- principalDetails.class
|   |   |   |           |   |   |-- TokenDto.class
|   |   |   |           |   |   `-- tokenRefreshRequest.class
|   |   |   |           |   `-- [01;34musers[0m
|   |   |   |           |       |-- JoinRequest.class
|   |   |   |           |       |-- LoginRequest.class
|   |   |   |           |       |-- userStat$userStatBuilder.class
|   |   |   |           |       `-- userStat.class
|   |   |   |           |-- [01;34mfilter[0m
|   |   |   |           |   |-- AbstractAuthenticationFilter.class
|   |   |   |           |   |-- AbstractSecurityFilter.class
|   |   |   |           |   |-- ApiChecker.class
|   |   |   |           |   |-- AuthenticationFilter.class
|   |   |   |           |   |-- authorizationFilter.class
|   |   |   |           |   |-- AuthorizationFilter.class
|   |   |   |           |   |-- FilterCondition.class
|   |   |   |           |   |-- filterRegistry$FilterWrapper.class
|   |   |   |           |   |-- filterRegistry.class
|   |   |   |           |   |-- FilterRegistry.class
|   |   |   |           |   |-- JwtVerificationFilter.class
|   |   |   |           |   |-- PathPatternFilterCondition.class
|   |   |   |           |   |-- PluggableFilter.class
|   |   |   |           |   |-- [01;32mREADME.md[0m
|   |   |   |           |   |-- RoleBasedAccessFilter.class
|   |   |   |           |   |-- SecurityFilterOrder.class
|   |   |   |           |   |-- snsRequestFilter.class
|   |   |   |           |   `-- SnsRequestFilter.class
|   |   |   |           |-- [01;34mothers[0m
|   |   |   |           |   `-- [01;34mconstants[0m
|   |   |   |           |       `-- SecurityConstants.class
|   |   |   |           |-- [01;34mrepository[0m
|   |   |   |           |   `-- usersRepository.class
|   |   |   |           `-- [01;34mservice[0m
|   |   |   |               |-- [01;34moauth2[0m
|   |   |   |               |   |-- oauth2Service.class
|   |   |   |               |   `-- snsTokenValidator.class
|   |   |   |               |-- [01;34mredis[0m
|   |   |   |               |   `-- redisService.class
|   |   |   |               |-- [01;34msecurity[0m
|   |   |   |               |   `-- principalDetailService.class
|   |   |   |               |-- [01;34msmtp[0m
|   |   |   |               |   `-- emailService.class
|   |   |   |               |-- [01;34msse[0m
|   |   |   |               |   `-- sseService.class
|   |   |   |               |-- [01;34mtoken[0m
|   |   |   |               |   `-- tokenService.class
|   |   |   |               `-- [01;34musers[0m
|   |   |   |                   `-- userService.class
|   |   |   |-- [01;32mlog4j2.xml[0m
|   |   |   |-- [01;32mschema.sql[0m
|   |   |   `-- [01;34mtemplates[0m
|   |   |       |-- [01;32merror.html[0m
|   |   |       |-- [01;32mnotExist.html[0m
|   |   |       `-- [01;32munauthorized.html[0m
|   |   `-- [01;34mtest[0m
|   |       |-- [01;34mcom[0m
|   |       |   `-- [01;34mauthentication[0m
|   |       |       `-- [01;34mauth[0m
|   |       |           |-- AuthApplicationTests.class
|   |       |           |-- [01;34mdomain[0m
|   |       |           |   `-- EntitySqlValidationTest.class
|   |       |           |-- [01;34mtoken[0m
|   |       |           |   `-- JwtUtilityTest.class
|   |       |           |-- [01;34mutility[0m
|   |       |           |   `-- SqlSchemaLoader.class
|   |       |           `-- [01;34mvalidator[0m
|   |       |               |-- EntitySqlValidator$ValidationResult.class
|   |       |               |-- EntitySqlValidator$ValidationStatus.class
|   |       |               |-- EntitySqlValidator.class
|   |       |               `-- EntityValidationOutput.class
|   |       `-- [01;32mtest-schema.sql[0m
|   |-- [01;34mbuild[0m
|   |   |-- [01;34mclasses[0m
|   |   |   `-- [01;34mjava[0m
|   |   |       |-- [01;34mmain[0m
|   |   |       `-- [01;34mtest[0m
|   |   |-- [01;34mgenerated[0m
|   |   |   `-- [01;34msources[0m
|   |   |       |-- [01;34mannotationProcessor[0m
|   |   |       |   `-- [01;34mjava[0m
|   |   |       |       `-- [01;34mmain[0m
|   |   |       `-- [01;34mheaders[0m
|   |   |           `-- [01;34mjava[0m
|   |   |               `-- [01;34mmain[0m
|   |   |-- [01;34mresources[0m
|   |   |   |-- [01;34mmain[0m
|   |   |   `-- [01;34mtest[0m
|   |   `-- [01;34mtmp[0m
|   |       `-- [01;34mcompileJava[0m
|   |-- [01;32mbuild.gradle[0m
|   |-- [01;34m.gradle[0m
|   |   |-- [01;34m8.10.1[0m
|   |   |   |-- [01;34mchecksums[0m
|   |   |   |   |-- [01;32mchecksums.lock[0m
|   |   |   |   |-- [01;32mmd5-checksums.bin[0m
|   |   |   |   `-- [01;32msha1-checksums.bin[0m
|   |   |   |-- [01;34mdependencies-accessors[0m
|   |   |   |   `-- [01;32mgc.properties[0m
|   |   |   |-- [01;34mexecutionHistory[0m
|   |   |   |   |-- [01;32mexecutionHistory.bin[0m
|   |   |   |   `-- [01;32mexecutionHistory.lock[0m
|   |   |   |-- [01;34mexpanded[0m
|   |   |   |-- [01;34mfileChanges[0m
|   |   |   |   `-- [01;32mlast-build.bin[0m
|   |   |   |-- [01;34mfileHashes[0m
|   |   |   |   |-- [01;32mfileHashes.bin[0m
|   |   |   |   |-- [01;32mfileHashes.lock[0m
|   |   |   |   `-- [01;32mresourceHashesCache.bin[0m
|   |   |   |-- [01;32mgc.properties[0m
|   |   |   `-- [01;34mvcsMetadata[0m
|   |   |-- [01;34mbuildOutputCleanup[0m
|   |   |   |-- [01;32mbuildOutputCleanup.lock[0m
|   |   |   |-- [01;32mcache.properties[0m
|   |   |   `-- [01;32moutputFiles.bin[0m
|   |   |-- [01;32mfile-system.probe[0m
|   |   `-- [01;34mvcs-1[0m
|   |       `-- [01;32mgc.properties[0m
|   |-- [01;34mgradle[0m
|   |   `-- [01;34mwrapper[0m
|   |       |-- [01;32mgradle-wrapper.jar[0m
|   |       `-- [01;32mgradle-wrapper.properties[0m
|   |-- [01;32mgradlew[0m
|   |-- [01;32mgradlew.bat[0m
|   |-- [01;32msettings.gradle[0m
|   `-- [01;34msrc[0m
|       |-- [01;34mmain[0m
|       |   |-- [01;34mjava[0m
|       |   |   `-- [01;34mcom[0m
|       |   |       `-- [01;34mauthentication[0m
|       |   |           `-- [01;34mauth[0m
|       |   |               |-- [01;32mAuthApplication.java[0m
|       |   |               |-- [01;34mconfig[0m
|       |   |               |   `-- [01;32mSecurityFilterConfig.java[0m
|       |   |               |-- [01;34mconfiguration[0m
|       |   |               |   |-- [01;34mredis[0m
|       |   |               |   |   `-- [01;32mredisConfig.java[0m
|       |   |               |   |-- [01;34mresource[0m
|       |   |               |   |   `-- [01;32mwebMvcConfig.java[0m
|       |   |               |   |-- [01;34msecurity[0m
|       |   |               |   |   |-- [01;32mcorsConfig.java[0m
|       |   |               |   |   |-- [01;32mpublicAPI.java[0m
|       |   |               |   |   `-- [01;32mSecurityConfig.java[0m
|       |   |               |   |-- [01;32mSecurityConfig.java[0m
|       |   |               |   |-- [01;34msmtp[0m
|       |   |               |   |   `-- [01;32msmtpConfig.java[0m
|       |   |               |   `-- [01;34mtoken[0m
|       |   |               |       |-- JwtProperties.record
|       |   |               |       `-- [01;32mjwtUtility.java[0m
|       |   |               |-- [01;34mcontroller[0m
|       |   |               |   |-- [01;34mauth[0m
|       |   |               |   |   |-- [01;32mAuthController.java[0m
|       |   |               |   |   |-- [01;32moauth2Controller.java[0m
|       |   |               |   |   `-- [01;32mtokenController.java[0m
|       |   |               |   |-- [01;32memailController.java[0m
|       |   |               |   |-- [01;32merrorController.java[0m
|       |   |               |   |-- [01;32msseController.java[0m
|       |   |               |   `-- [01;32musersController.java[0m
|       |   |               |-- [01;34mdocument[0m
|       |   |               |   `-- [01;32mDev-Schedule.md[0m
|       |   |               |-- [01;34mdomain[0m
|       |   |               |   |-- [01;32mAuthProvider.java[0m
|       |   |               |   |-- [01;32mDiaryAnswer.java[0m
|       |   |               |   |-- [01;32mDiary.java[0m
|       |   |               |   |-- [01;32mSettingsOption.java[0m
|       |   |               |   |-- [01;32mUserAuthentication.java[0m
|       |   |               |   |-- [01;32mUserCustomSetting.java[0m
|       |   |               |   `-- [01;32mUser.java[0m
|       |   |               |-- [01;34mDTO[0m
|       |   |               |   |-- [01;34msmtp[0m
|       |   |               |   |   |-- [01;32mcustomEmailRequest.java[0m
|       |   |               |   |   |-- [01;32mcustomEmailToAllRequest.java[0m
|       |   |               |   |   |-- [01;32memailCheckDto.java[0m
|       |   |               |   |   |-- [01;32memailFindById.java[0m
|       |   |               |   |   `-- [01;32memailRequest.java[0m
|       |   |               |   |-- [01;34mtoken[0m
|       |   |               |   |   |-- [01;32mprincipalDetails.java[0m
|       |   |               |   |   |-- [01;32mTokenDto.java[0m
|       |   |               |   |   `-- [01;32mtokenRefreshRequest.java[0m
|       |   |               |   `-- [01;34musers[0m
|       |   |               |       |-- [01;32mJoinRequest.java[0m
|       |   |               |       |-- [01;32mloginRequest.java[0m
|       |   |               |       `-- [01;32muserStat.java[0m
|       |   |               |-- [01;34mfilter[0m
|       |   |               |   |-- [01;32mAbstractAuthenticationFilter.java[0m
|       |   |               |   |-- [01;32mAbstractSecurityFilter.java[0m
|       |   |               |   |-- [01;32mApiChecker.java[0m
|       |   |               |   |-- [01;32mauthenticationFilter.java[0m
|       |   |               |   |-- [01;32mAuthenticationFilter.java[0m
|       |   |               |   |-- [01;32mauthorizationFilter.java[0m
|       |   |               |   |-- [01;32mAuthorizationFilter.java[0m
|       |   |               |   |-- [01;32mFilterCondition.java[0m
|       |   |               |   |-- [01;32mfilterRegistry.java[0m
|       |   |               |   |-- [01;32mFilterRegistry.java[0m
|       |   |               |   |-- [01;32mJwtVerificationFilter.java[0m
|       |   |               |   |-- [01;32mPathPatternFilterCondition.java[0m
|       |   |               |   |-- [01;32mPluggableFilter.java[0m
|       |   |               |   |-- [01;32mREADME.md[0m
|       |   |               |   |-- [01;32mRoleBasedAccessFilter.java[0m
|       |   |               |   |-- [01;32msecurityFilterOrder.java[0m
|       |   |               |   |-- [01;32mSecurityFilterOrder.java[0m
|       |   |               |   |-- [01;32msnsRequestFilter.java[0m
|       |   |               |   `-- [01;32mSnsRequestFilter.java[0m
|       |   |               |-- [01;34mothers[0m
|       |   |               |   `-- [01;34mconstants[0m
|       |   |               |       `-- [01;32mSecurityConstants.java[0m
|       |   |               |-- [01;34mrepository[0m
|       |   |               |   |-- [01;32mAuthProviderRepository.java[0m
|       |   |               |   `-- [01;32musersRepository.java[0m
|       |   |               `-- [01;34mservice[0m
|       |   |                   |-- [01;34moauth2[0m
|       |   |                   |   |-- [01;32moauth2Service.java[0m
|       |   |                   |   `-- [01;32msnsTokenValidator.java[0m
|       |   |                   |-- [01;34mredis[0m
|       |   |                   |   `-- [01;32mredisService.java[0m
|       |   |                   |-- [01;34msecurity[0m
|       |   |                   |   `-- [01;32mprincipalDetailService.java[0m
|       |   |                   |-- [01;34msmtp[0m
|       |   |                   |   `-- [01;32memailService.java[0m
|       |   |                   |-- [01;34msse[0m
|       |   |                   |   `-- [01;32msseService.java[0m
|       |   |                   |-- [01;34mtoken[0m
|       |   |                   |   `-- [01;32mtokenService.java[0m
|       |   |                   `-- [01;34musers[0m
|       |   |                       `-- [01;32muserService.java[0m
|       |   `-- [01;34mresources[0m
|       |       |-- [01;32mapplication-database.properties[0m
|       |       |-- [01;32mapplication-oauth-google.properties[0m
|       |       |-- [01;32mapplication-oauth-kakao.properties[0m
|       |       |-- [01;32mapplication-oauth-naver.properties[0m
|       |       |-- [01;32mapplication.properties[0m
|       |       |-- [01;32mlog4j2.xml[0m
|       |       |-- [01;32mschema.sql[0m
|       |       `-- [01;34mtemplates[0m
|       |           |-- [01;32merror.html[0m
|       |           |-- [01;32mnotExist.html[0m
|       |           `-- [01;32munauthorized.html[0m
|       `-- [01;34mtest[0m
|           |-- [01;34mjava[0m
|           |   `-- [01;34mcom[0m
|           |       `-- [01;34mauthentication[0m
|           |           `-- [01;34mauth[0m
|           |               |-- [01;32mAuthApplicationTests.java[0m
|           |               |-- [01;34mdomain[0m
|           |               |   `-- [01;32mEntitySqlValidationTest.java[0m
|           |               |-- [01;34mtoken[0m
|           |               |   `-- [01;32mJwtUtilityTest.java[0m
|           |               |-- [01;34mutility[0m
|           |               |   `-- [01;32mSqlSchemaLoader.java[0m
|           |               `-- [01;34mvalidator[0m
|           |                   |-- [01;32mEntitySqlValidator.java[0m
|           |                   `-- [01;32mEntityValidationOutput.java[0m
|           `-- [01;34mresources[0m
|               `-- [01;32mtest-schema.sql[0m
|-- [01;34mconcat[0m
|   |-- backend.txt
|   `-- frontend.txt
|-- [01;32mconcat.sh[0m
|-- [01;34mfile_concat[0m
|   |-- [01;32mgo1.22.0.linux-amd64.tar.gz[0m
|   |-- [01;32mgo.mod[0m
|   |-- [01;32mmain.go[0m
|   `-- [01;32mmerged_source_files.txt[0m
|-- find_stderr.log
|-- [01;34m.github[0m
|   `-- [01;34mworkflows[0m
|       `-- [01;32mdeploy.yml[0m
|-- [01;32m.gitignore[0m
|-- [01;32mproject-summary.sh[0m
|-- project_summary.txt
`-- [01;32mREADME.md[0m

147 directories, 235 files

========================================
Essential Files Content
========================================

[0;34mProcessing essential files matching patterns: README.md readme.md README.rst README.txt package.json composer.json pom.xml build.gradle requirements.txt Pipfile Gemfile Dockerfile docker-compose.yml docker-compose.yaml Makefile Jenkinsfile .gitlab-ci.yml .travis.yml *.config.js *.config.ts *.config.mjs *.config.cjs webpack.config.* vite.config.* rollup.config.* tsconfig.json jsconfig.json next.config.* manage.py app.py main.py server.js index.js main.go .env.example .env.sample settings.py config.py src*/*.js src*/*.ts src*/*.jsx src*/*.tsx src*/*.py src*/*.java src*/*.go src*/*.rb src*/*.php app*/*.js app*/*.ts app*/*.jsx app*/*.tsx app*/*.py components*/*.js components*/*.jsx components*/*.ts components*/*.tsx pages*/*.js pages*/*.jsx pages*/*.ts pages*/*.tsx lib*/*.js lib*/*.ts lib*/*.py api*/*.ts api*/*.js api*/*.py routes*/*.js routes*/*.ts routes*/*.py controllers*/*.js controllers*/*.ts controllers*/*.py models*/*.js models*/*.ts models*/*.py types*/*.d.ts css*/*.css scss*/*.scss sass*/*.sass app*/globals.css tailwind.config.* postcss.config.* .gitignore .dockerignore components.json next-env.d.ts[0m

# File: auth-server-refactoring/src/main/java/com/authentication/auth/constants/ErrorType.java
#=============================================================================

    1 | package com.authentication.auth.constants;
    2 | 
    3 | import org.springframework.http.HttpStatus;
    4 | 
    5 | /**
    6 |  * 오류 유형을 정의하는 열거형
    7 |  */
    8 | public enum ErrorType {
    9 |     AUTHENTICATION_FAILED("인증 실패", "사용자 인증에 실패했습니다", HttpStatus.UNAUTHORIZED),
   10 |     INVALID_TOKEN("유효하지 않은 토큰", "제공된 토큰이 유효하지 않습니다", HttpStatus.UNAUTHORIZED),
   11 |     TOKEN_EXPIRED("토큰 만료", "토큰이 만료되었습니다", HttpStatus.UNAUTHORIZED),
   12 |     ACCESS_DENIED("접근 거부", "해당 리소스에 접근할 권한이 없습니다", HttpStatus.FORBIDDEN),
   13 |     INVALID_REQUEST("잘못된 요청", "요청 형식이 올바르지 않습니다", HttpStatus.BAD_REQUEST),
   14 |     RESOURCE_NOT_FOUND("리소스 없음", "요청한 리소스를 찾을 수 없습니다", HttpStatus.NOT_FOUND),
   15 |     SERVER_ERROR("서버 오류", "서버 내부 오류가 발생했습니다", HttpStatus.INTERNAL_SERVER_ERROR);
   16 |     
   17 |     private final String title;
   18 |     private final String message;
   19 |     private final HttpStatus status;
   20 |     
   21 |     ErrorType(String title, String message, HttpStatus status) {
   22 |         this.title = title;
   23 |         this.message = message;
   24 |         this.status = status;
   25 |     }
   26 |     
   27 |     public String getTitle() {
   28 |         return title;
   29 |     }
   30 |     
   31 |     public String getMessage() {
   32 |         return message;
   33 |     }
   34 |     
   35 |     public HttpStatus getStatus() {
   36 |         return status;
   37 |     }
   38 |     
   39 |     public int getStatusCode() {
   40 |         return status.value();
   41 |     }
   42 | }

#--------------------------------------------------------------------------------


# File: auth-server-refactoring/src/main/java/com/authentication/auth/constants/SecurityConstants.java
#=============================================================================

    1 | package com.authentication.auth.constants;
    2 | 
    3 | import java.util.Arrays;
    4 | import java.util.List;
    5 | 
    6 | /**
    7 |  * 보안 관련 상수를 정의하는 열거형 클래스
    8 |  * 하드코딩 방지 및 중앙화된 상수 관리
    9 |  */
   10 | public enum SecurityConstants {
   11 |     // 토큰 관련 상수
   12 |     TOKEN_TYPE("JWT"),
   13 |     TOKEN_HEADER("Authorization"),
   14 |     TOKEN_PREFIX("Bearer "),
   15 |     REFRESH_TOKEN_TYPE("refreshJWT"),
   16 |     
   17 |     // 쿠키 관련 상수
   18 |     COOKIE_REFRESH_TOKEN("refreshToken"),
   19 |     COOKIE_ACCESS_TOKEN("access_token"),
   20 |     COOKIE_PATH("/"),
   21 |     
   22 |     // URL 패턴 관련 상수
   23 |     PUBLIC_API_PATH("/api/public/**"),
   24 |     AUTH_API_PATH("/api/auth/**"),
   25 |     LOGIN_PATH("/api/auth/login"),
   26 |     REGISTER_PATH("/api/auth/register"),
   27 |     REFRESH_PATH("/api/auth/refresh"),
   28 |     ADMIN_API_PATH("/api/admin/**"),
   29 |     SWAGGER_UI_PATH("/swagger-ui/**"),
   30 |     API_DOCS_PATH("/v3/api-docs/**"),
   31 |     
   32 |     // 제공자 관련 상수
   33 |     DEFAULT_PROVIDER("server"),
   34 |     
   35 |     // 오류 메시지
   36 |     ERROR_INVALID_TOKEN("유효하지 않은 토큰입니다"),
   37 |     ERROR_TOKEN_EXPIRED("토큰이 만료되었습니다"),
   38 |     ERROR_NO_REFRESH_TOKEN("리프레시 토큰이 없습니다"),
   39 |     ERROR_NO_COOKIES("쿠키가 없습니다"),
   40 |     ERROR_ADMIN_REQUIRED("관리자 권한이 필요합니다"),
   41 |     ERROR_AUTHENTICATION_FAILED("인증에 실패했습니다");
   42 |     
   43 |     private final String value;
   44 |     
   45 |     SecurityConstants(String value) {
   46 |         this.value = value;
   47 |     }
   48 |     
   49 |     public String getValue() {
   50 |         return value;
   51 |     }
   52 |     
   53 |     /**
   54 |      * 공개 API 경로 목록 반환
   55 |      * @return 공개 API 경로 목록
   56 |      */
   57 |     public static List<String> getPublicPaths() {
   58 |         return Arrays.asList(
   59 |             PUBLIC_API_PATH.getValue(),
   60 |             LOGIN_PATH.getValue(),
   61 |             REGISTER_PATH.getValue(),
   62 |             REFRESH_PATH.getValue(),
   63 |             SWAGGER_UI_PATH.getValue(),
   64 |             API_DOCS_PATH.getValue()
   65 |         );
   66 |     }
   67 |     
   68 |     /**
   69 |      * 관리자 전용 API 경로 목록 반환
   70 |      * @return 관리자 전용 API 경로 목록
   71 |      */
   72 |     public static List<String> getAdminPaths() {
   73 |         return Arrays.asList(
   74 |             ADMIN_API_PATH.getValue()
   75 |         );
   76 |     }
   77 | }

#--------------------------------------------------------------------------------


# File: auth-server-refactoring/src/main/java/com/authentication/auth/constants/FilterOrder.java
#=============================================================================

    1 | package com.authentication.auth.constants;
    2 | 
    3 | /**
    4 |  * 필터 실행 순서를 정의하는 열거형
    5 |  * 값이 낮을수록 먼저 실행됨
    6 |  */
    7 | public enum FilterOrder {
    8 |     REQUEST_LOGGING(50),
    9 |     CORS(100),
   10 |     CSRF(200),
   11 |     AUTHENTICATION(300),
   12 |     JWT_VERIFICATION(400),
   13 |     AUTHORIZATION(500),
   14 |     SESSION_MANAGEMENT(600),
   15 |     EXCEPTION_TRANSLATION(700),
   16 |     SNS_REQUEST(800);
   17 |     
   18 |     private final int order;
   19 |     
   20 |     FilterOrder(int order) {
   21 |         this.order = order;
   22 |     }
   23 |     
   24 |     public int getOrder() {
   25 |         return order;
   26 |     }
   27 | }

#--------------------------------------------------------------------------------


# File: auth-server-refactoring/src/main/java/com/authentication/auth/filter/PathPatternFilterCondition.java
#=============================================================================

    1 | package com.authentication.auth.filter;
    2 | 
    3 | import jakarta.servlet.http.HttpServletRequest;
    4 | import org.springframework.http.HttpMethod;
    5 | import org.springframework.util.AntPathMatcher;
    6 | 
    7 | import java.util.Arrays;
    8 | import java.util.HashSet;
    9 | import java.util.Set;
   10 | 
   11 | /**
   12 |  * 경로 패턴 기반 필터 조건
   13 |  * URL 패턴과 HTTP 메소드 기반으로 필터 적용 여부를 결정
   14 |  */
   15 | public record PathPatternFilterCondition(
   16 |     String description,
   17 |     Set<String> patterns,
   18 |     Set<HttpMethod> methods
   19 | ) implements FilterCondition {
   20 |     
   21 |     private static final AntPathMatcher PATH_MATCHER = new AntPathMatcher();
   22 |     
   23 |     /**
   24 |      * 경로 패턴만 지정하는 생성자
   25 |      * @param description 조건 설명
   26 |      * @param patterns 포함할 URL 패턴 (Ant-style)
   27 |      */
   28 |     public PathPatternFilterCondition(String description, String... patterns) {
   29 |         this(description, new HashSet<>(Arrays.asList(patterns)), new HashSet<>());
   30 |     }
   31 |     
   32 |     /**
   33 |      * 경로 패턴과 HTTP 메소드를 지정하는 생성자
   34 |      * @param description 조건 설명
   35 |      * @param methods 포함할 HTTP 메소드
   36 |      * @param patterns 포함할 URL 패턴 (Ant-style)
   37 |      */
   38 |     public PathPatternFilterCondition(String description, HttpMethod[] methods, String... patterns) {
   39 |         this(description, new HashSet<>(Arrays.asList(patterns)), new HashSet<>(Arrays.asList(methods)));
   40 |     }
   41 |     
   42 |     /**
   43 |      * 패턴 추가
   44 |      * @param pattern 추가할 패턴
   45 |      * @return 새 조건 객체
   46 |      */
   47 |     public PathPatternFilterCondition withPattern(String pattern) {
   48 |         Set<String> newPatterns = new HashSet<>(this.patterns);
   49 |         newPatterns.add(pattern);
   50 |         return new PathPatternFilterCondition(this.description, newPatterns, this.methods);
   51 |     }
   52 |     
   53 |     /**
   54 |      * HTTP 메소드 추가
   55 |      * @param method 추가할 HTTP 메소드
   56 |      * @return 새 조건 객체
   57 |      */
   58 |     public PathPatternFilterCondition withMethod(HttpMethod method) {
   59 |         Set<HttpMethod> newMethods = new HashSet<>(this.methods);
   60 |         newMethods.add(method);
   61 |         return new PathPatternFilterCondition(this.description, this.patterns, newMethods);
   62 |     }
   63 | 
   64 |     @Override
   65 |     public boolean shouldNotFilter(HttpServletRequest request) {
   66 |         String requestPath = request.getRequestURI();
   67 |         
   68 |         // 어느 하나의 패턴이라도 맞으면 필터 제외
   69 |         boolean matchesPattern = patterns.stream()
   70 |                 .anyMatch(pattern -> PATH_MATCHER.match(pattern, requestPath));
   71 |         
   72 |         // HTTP 메소드 제한이 없거나, 요청 메소드가 지정된 메소드 중 하나와 일치하면 필터 제외
   73 |         boolean matchesMethod = methods.isEmpty() || 
   74 |                                methods.contains(HttpMethod.valueOf(request.getMethod()));
   75 |         
   76 |         return matchesPattern && matchesMethod;
   77 |     }
   78 | 
   79 |     @Override
   80 |     public String getDescription() {
   81 |         return description;
   82 |     }
   83 | }

#--------------------------------------------------------------------------------


# File: auth-server-refactoring/src/main/java/com/authentication/auth/filter/FilterCondition.java
#=============================================================================

    1 | package com.authentication.auth.filter;
    2 | 
    3 | import jakarta.servlet.http.HttpServletRequest;
    4 | 
    5 | /**
    6 |  * 필터 조건 인터페이스
    7 |  * 필터 적용 조건을 정의하는 인터페이스
    8 |  */
    9 | public interface FilterCondition {
   10 |     
   11 |     /**
   12 |      * 요청에 필터를 적용할지 여부를 결정
   13 |      * @param request HTTP 요청
   14 |      * @return true이면 필터를 적용하지 않음, false이면 필터 적용
   15 |      */
   16 |     boolean shouldNotFilter(HttpServletRequest request);
   17 |     
   18 |     /**
   19 |      * 조건에 설명을 제공
   20 |      * @return 조건 설명
   21 |      */
   22 |     String getDescription();
   23 | }

#--------------------------------------------------------------------------------


# File: auth-server-refactoring/src/main/java/com/authentication/auth/filter/JwtVerificationFilter.java
#=============================================================================

    1 | package com.authentication.auth.filter;
    2 | 
    3 | import com.authentication.auth.constants.ErrorType;
    4 | import com.authentication.auth.constants.FilterOrder;
    5 | import com.authentication.auth.constants.SecurityConstants;
    6 | import com.authentication.auth.configuration.token.JwtUtility;
    7 | import com.authentication.auth.dto.response.ApiResponse;
    8 | import com.fasterxml.jackson.databind.ObjectMapper;
    9 | import jakarta.annotation.PostConstruct;
   10 | import jakarta.servlet.Filter;
   11 | import jakarta.servlet.FilterChain;
   12 | import jakarta.servlet.ServletException;
   13 | import jakarta.servlet.http.HttpServletRequest;
   14 | import jakarta.servlet.http.HttpServletResponse;
   15 | import lombok.extern.slf4j.Slf4j;
   16 | import org.springframework.beans.factory.annotation.Autowired;
   17 | import org.springframework.http.MediaType;
   18 | import org.springframework.security.authentication.UsernamePasswordAuthenticationToken;
   19 | import org.springframework.security.core.authority.SimpleGrantedAuthority;
   20 | import org.springframework.security.core.context.SecurityContextHolder;
   21 | import org.springframework.stereotype.Component;
   22 | 
   23 | import java.io.IOException;
   24 | import java.util.Set;
   25 | import java.util.stream.Collectors;
   26 | 
   27 | /**
   28 |  * JWT 토큰 검증 필터
   29 |  * 요청에 포함된 JWT 토큰을 검증하고 사용자 인증 정보를 설정
   30 |  */
   31 | @Slf4j
   32 | @Component
   33 | public class JwtVerificationFilter extends AbstractSecurityFilter {
   34 | 
   35 |     private final JwtUtility jwtUtility;
   36 |     private final ObjectMapper objectMapper;
   37 |     private final FilterRegistry filterRegistry;
   38 | 
   39 |     @Autowired
   40 |     public JwtVerificationFilter(
   41 |             JwtUtility jwtUtility,
   42 |             ObjectMapper objectMapper,
   43 |             FilterRegistry filterRegistry) {
   44 |         super(FilterOrder.JWT_VERIFICATION);
   45 |         this.jwtUtility = jwtUtility;
   46 |         this.objectMapper = objectMapper;
   47 |         this.filterRegistry = filterRegistry;
   48 |     }
   49 | 
   50 |     /**
   51 |      * 필터 초기화 및 레지스트리에 등록
   52 |      */
   53 |     @PostConstruct
   54 |     public void init() {
   55 |         // 필터 레지스트리에 이 필터 등록
   56 |         filterRegistry.registerFilter(this);
   57 | 
   58 |         // 기본 필터 조건 설정 - 공개 API는 JWT 검증 필터 적용하지 않음
   59 |         PathPatternFilterCondition publicApiCondition = new PathPatternFilterCondition(
   60 |                 "JWT 검증 불필요 경로",
   61 |                 SecurityConstants.getPublicPaths().toArray(new String[0])
   62 |         );
   63 | 
   64 |         // 필터 레지스트리에 조건 추가
   65 |         filterRegistry.addCondition(getFilterId(), publicApiCondition);
   66 |     }
   67 | 
   68 |     @Override
   69 |     protected void doFilterInternal(HttpServletRequest request, HttpServletResponse response, FilterChain chain)
   70 |             throws IOException, ServletException {
   71 |         
   72 |         String path = request.getRequestURI();
   73 |         log.debug("JWT 검증 필터 실행: {}", path);
   74 |         
   75 |         try {
   76 |             String token = extractToken(request);
   77 |             
   78 |             if (token != null) {
   79 |                 if (jwtUtility.validateToken(token)) {
   80 |                     String username = jwtUtility.getUsernameFromToken(token);
   81 |                     Set<String> roles = jwtUtility.getRolesFromToken(token);
   82 |                     
   83 |                     // 권한 설정
   84 |                     Set<SimpleGrantedAuthority> authorities = roles.stream()
   85 |                             .map(SimpleGrantedAuthority::new)
   86 |                             .collect(Collectors.toSet());
   87 |                     
   88 |                     UsernamePasswordAuthenticationToken authToken = 
   89 |                             new UsernamePasswordAuthenticationToken(username, null, authorities);
   90 |                     
   91 |                     SecurityContextHolder.getContext().setAuthentication(authToken);
   92 |                     log.debug("JWT 토큰 검증 성공: {}", username);
   93 |                 } else {
   94 |                     log.warn("유효하지 않은 JWT 토큰");
   95 |                     sendErrorResponse(response, ErrorType.INVALID_TOKEN);
   96 |                     return;
   97 |                 }
   98 |             } else {
   99 |                 log.debug("JWT 토큰이 없음");
  100 |             }
  101 |             
  102 |             chain.doFilter(request, response);
  103 |         } catch (Exception e) {
  104 |             log.error("JWT 검증 중 오류 발생: {}", e.getMessage());
  105 |             SecurityContextHolder.clearContext();
  106 |             sendErrorResponse(response, ErrorType.AUTHENTICATION_FAILED);
  107 |         }
  108 |     }
  109 | 
  110 |     /**
  111 |      * 요청에서 JWT 토큰 추출
  112 |      */
  113 |     private String extractToken(HttpServletRequest request) {
  114 |         String authHeader = request.getHeader(SecurityConstants.TOKEN_HEADER.getValue());
  115 |         
  116 |         if (authHeader != null && authHeader.startsWith(SecurityConstants.TOKEN_PREFIX.getValue())) {
  117 |             return authHeader.substring(SecurityConstants.TOKEN_PREFIX.getValue().length());
  118 |         }
  119 |         
  120 |         return null;
  121 |     }
  122 | 
  123 |     /**
  124 |      * 오류 응답 전송
  125 |      */
  126 |     private void sendErrorResponse(HttpServletResponse response, ErrorType errorType) throws IOException {
  127 |         response.setStatus(errorType.getStatusCode());
  128 |         response.setContentType(MediaType.APPLICATION_JSON_VALUE);
  129 |         
  130 |         objectMapper.writeValue(response.getOutputStream(), 
  131 |                                ApiResponse.error(errorType));
  132 |     }
  133 | 
  134 |     @Override
  135 |     protected boolean shouldSkipFilter(HttpServletRequest request) {
  136 |         return filterRegistry.shouldNotFilter(getFilterId(), request);
  137 |     }
  138 | 
  139 |     @Override
  140 |     public void configure(HttpSecurity http) throws Exception {
  141 |         http.addFilterAfter(this, AuthenticationFilter.class);
  142 |         log.debug("JWT 검증 필터 HttpSecurity에 구성됨");
  143 |     }
  144 | 
  145 |     @Override
  146 |     public Class<? extends Filter> getBeforeFilter() {
  147 |         return AuthenticationFilter.class;
  148 |     }
  149 | 
  150 |     @Override
  151 |     public Class<? extends Filter> getAfterFilter() {
  152 |         return AuthorizationFilter.class;
  153 |     }
  154 | }

#--------------------------------------------------------------------------------


# File: auth-server-refactoring/src/main/java/com/authentication/auth/filter/PluggableFilter.java
#=============================================================================

    1 | package com.authentication.auth.filter;
    2 | 
    3 | import jakarta.servlet.Filter;
    4 | import org.springframework.security.config.annotation.web.builders.HttpSecurity;
    5 | 
    6 | /**
    7 |  * 플러그형 필터 인터페이스
    8 |  * 동적으로 추가/제거 가능한 필터를 위한 인터페이스
    9 |  */
   10 | public interface PluggableFilter extends Filter {
   11 |     
   12 |     /**
   13 |      * HttpSecurity에 이 필터를 구성
   14 |      * @param http HttpSecurity 객체
   15 |      * @throws Exception 구성 중 예외 발생 시
   16 |      */
   17 |     void configure(HttpSecurity http) throws Exception;
   18 |     
   19 |     /**
   20 |      * 필터의 실행 순서 반환
   21 |      * 낮은 값이 높은 우선순위를 의미함
   22 |      * @return 필터 실행 순서
   23 |      */
   24 |     int getOrder();
   25 |     
   26 |     /**
   27 |      * 이 필터 이전에 실행되어야 하는 필터 클래스 반환
   28 |      * @return 이전 필터 클래스, 없으면 null
   29 |      */
   30 |     Class<? extends Filter> getBeforeFilter();
   31 |     
   32 |     /**
   33 |      * 이 필터 이후에 실행되어야 하는 필터 클래스 반환
   34 |      * @return 이후 필터 클래스, 없으면 null
   35 |      */
   36 |     Class<? extends Filter> getAfterFilter();
   37 |     
   38 |     /**
   39 |      * 필터 ID 반환 (기본 구현은 클래스명)
   40 |      * @return 필터 ID
   41 |      */
   42 |     default String getFilterId() {
   43 |         return this.getClass().getSimpleName();
   44 |     }
   45 | }

#--------------------------------------------------------------------------------


# File: auth-server-refactoring/src/main/java/com/authentication/auth/filter/FilterRegistry.java
#=============================================================================

    1 | package com.authentication.auth.filter;
    2 | 
    3 | import lombok.extern.slf4j.Slf4j;
    4 | import org.springframework.security.config.annotation.web.builders.HttpSecurity;
    5 | import org.springframework.stereotype.Component;
    6 | 
    7 | import java.util.*;
    8 | import java.util.concurrent.ConcurrentHashMap;
    9 | import java.util.concurrent.CopyOnWriteArrayList;
   10 | 
   11 | /**
   12 |  * 필터 레지스트리
   13 |  * 플러그인 방식의 필터를 등록하고 관리하는 중앙 컴포넌트
   14 |  */
   15 | @Slf4j
   16 | @Component
   17 | public class FilterRegistry {
   18 | 
   19 |     // 필터 인스턴스 저장 맵 (필터 ID -> 필터 인스턴스)
   20 |     private final Map<String, PluggableFilter> filterMap = new ConcurrentHashMap<>();
   21 |     
   22 |     // 필터 우선순위 순서대로 저장된 리스트
   23 |     private final List<PluggableFilter> orderedFilters = new CopyOnWriteArrayList<>();
   24 |     
   25 |     // 필터 조건 저장 맵 (필터 ID -> 필터 조건 리스트)
   26 |     private final Map<String, List<FilterCondition>> filterConditions = new ConcurrentHashMap<>();
   27 | 
   28 |     /**
   29 |      * 필터 등록
   30 |      * @param filter 등록할 필터
   31 |      */
   32 |     public void registerFilter(PluggableFilter filter) {
   33 |         String filterId = filter.getFilterId();
   34 |         filterMap.put(filterId, filter);
   35 |         
   36 |         // 우선순위에 따라 정렬된 위치에 필터 삽입
   37 |         insertFilterInOrder(filter);
   38 |         
   39 |         log.info("필터 등록 완료: {}, 우선순위: {}", filterId, filter.getOrder());
   40 |     }
   41 | 
   42 |     /**
   43 |      * 필터에 조건 추가
   44 |      * @param filterId 필터 ID
   45 |      * @param condition 필터 조건
   46 |      */
   47 |     public void addCondition(String filterId, FilterCondition condition) {
   48 |         filterConditions.computeIfAbsent(filterId, k -> new CopyOnWriteArrayList<>())
   49 |                         .add(condition);
   50 |         log.info("필터 '{}' 에 조건 추가: {}", filterId, condition.getDescription());
   51 |     }
   52 | 
   53 |     /**
   54 |      * 필터에 조건 제거
   55 |      * @param filterId 필터 ID
   56 |      * @param condition 제거할 조건
   57 |      * @return 제거 성공 여부
   58 |      */
   59 |     public boolean removeCondition(String filterId, FilterCondition condition) {
   60 |         List<FilterCondition> conditions = filterConditions.get(filterId);
   61 |         if (conditions != null) {
   62 |             boolean result = conditions.remove(condition);
   63 |             if (result) {
   64 |                 log.info("필터 '{}' 에서 조건 제거: {}", filterId, condition.getDescription());
   65 |             }
   66 |             return result;
   67 |         }
   68 |         return false;
   69 |     }
   70 | 
   71 |     /**
   72 |      * 특정 요청에 대해 필터를 적용해야 하는지 확인
   73 |      * @param filterId 필터 ID
   74 |      * @param request HTTP 요청
   75 |      * @return true면 필터를 적용하지 않음, false면 필터 적용
   76 |      */
   77 |     public boolean shouldNotFilter(String filterId, jakarta.servlet.http.HttpServletRequest request) {
   78 |         List<FilterCondition> conditions = filterConditions.get(filterId);
   79 |         if (conditions == null || conditions.isEmpty()) {
   80 |             return false; // 조건이 없으면 항상 필터 적용
   81 |         }
   82 |         
   83 |         // 어느 하나의 조건이라도 true를 반환하면 필터를 적용하지 않음 (OR 조건)
   84 |         return conditions.stream().anyMatch(condition -> condition.shouldNotFilter(request));
   85 |     }
   86 | 
   87 |     /**
   88 |      * 우선순위에 따라 정렬된 위치에 필터 삽입
   89 |      * @param filter 삽입할 필터
   90 |      */
   91 |     private void insertFilterInOrder(PluggableFilter filter) {
   92 |         // 기존 필터가 있으면 제거
   93 |         orderedFilters.remove(filter);
   94 |         
   95 |         // 새 필터의 순서
   96 |         int newFilterOrder = filter.getOrder();
   97 |         
   98 |         int insertIndex = 0;
   99 |         while (insertIndex < orderedFilters.size() && 
  100 |                orderedFilters.get(insertIndex).getOrder() <= newFilterOrder) {
  101 |             insertIndex++;
  102 |         }
  103 |         
  104 |         orderedFilters.add(insertIndex, filter);
  105 |     }
  106 | 
  107 |     /**
  108 |      * 등록된 모든 필터를 SecurityConfig에 등록
  109 |      * @param http HttpSecurity 객체
  110 |      * @throws Exception 설정 중 예외 발생 시
  111 |      */
  112 |     public void configureFilters(HttpSecurity http) throws Exception {
  113 |         for (PluggableFilter filter : orderedFilters) {
  114 |             filter.configure(http);
  115 |             log.debug("필터 구성 적용: {}", filter.getFilterId());
  116 |         }
  117 |         log.info("총 {}개의 필터가 SecurityConfig에 등록됨", orderedFilters.size());
  118 |     }
  119 | 
  120 |     /**
  121 |      * 등록된 모든 필터 목록 반환
  122 |      * @return 필터 목록
  123 |      */
  124 |     public List<PluggableFilter> getRegisteredFilters() {
  125 |         return Collections.unmodifiableList(orderedFilters);
  126 |     }
  127 |     
  128 |     /**
  129 |      * 특정 필터 조회
  130 |      * @param filterId 필터 ID
  131 |      * @return 찾은 필터, 없으면 null
  132 |      */
  133 |     public PluggableFilter getFilter(String filterId) {
  134 |         return filterMap.get(filterId);
  135 |     }
  136 | }

#--------------------------------------------------------------------------------


# File: auth-server-refactoring/src/main/java/com/authentication/auth/filter/AuthorizationFilter.java
#=============================================================================

    1 | package com.authentication.auth.filter;
    2 | 
    3 | import com.authentication.auth.constants.ErrorType;
    4 | import com.authentication.auth.constants.FilterOrder;
    5 | import com.authentication.auth.constants.SecurityConstants;
    6 | import com.authentication.auth.dto.response.ApiResponse;
    7 | import com.fasterxml.jackson.databind.ObjectMapper;
    8 | import jakarta.annotation.PostConstruct;
    9 | import jakarta.servlet.Filter;
   10 | import jakarta.servlet.FilterChain;
   11 | import jakarta.servlet.ServletException;
   12 | import jakarta.servlet.http.HttpServletRequest;
   13 | import jakarta.servlet.http.HttpServletResponse;
   14 | import lombok.extern.slf4j.Slf4j;
   15 | import org.springframework.beans.factory.annotation.Autowired;
   16 | import org.springframework.http.MediaType;
   17 | import org.springframework.security.core.Authentication;
   18 | import org.springframework.security.core.context.SecurityContextHolder;
   19 | import org.springframework.stereotype.Component;
   20 | 
   21 | import java.io.IOException;
   22 | import java.util.Set;
   23 | 
   24 | /**
   25 |  * 권한 부여 필터
   26 |  * JWT 토큰의 유효성을 검증하고 사용자 권한을 검사하는 필터
   27 |  */
   28 | @Slf4j
   29 | @Component
   30 | public class AuthorizationFilter extends AbstractSecurityFilter {
   31 | 
   32 |     private final ObjectMapper objectMapper;
   33 |     private final FilterRegistry filterRegistry;
   34 |     private final Set<String> adminRoles = Set.of("ROLE_ADMIN", "ADMIN");
   35 | 
   36 |     @Autowired
   37 |     public AuthorizationFilter(
   38 |             ObjectMapper objectMapper,
   39 |             FilterRegistry filterRegistry) {
   40 |         super(FilterOrder.AUTHORIZATION);
   41 |         this.objectMapper = objectMapper;
   42 |         this.filterRegistry = filterRegistry;
   43 |     }
   44 | 
   45 |     /**
   46 |      * 필터 초기화 및 레지스트리에 등록
   47 |      */
   48 |     @PostConstruct
   49 |     public void init() {
   50 |         // 필터 레지스트리에 이 필터 등록
   51 |         filterRegistry.registerFilter(this);
   52 | 
   53 |         // 기본 필터 조건 설정 - 공개 API는 권한 필터 적용하지 않음
   54 |         PathPatternFilterCondition publicApiCondition = new PathPatternFilterCondition(
   55 |                 "권한 확인 불필요 경로",
   56 |                 SecurityConstants.getPublicPaths().toArray(new String[0])
   57 |         );
   58 | 
   59 |         // 필터 레지스트리에 조건 추가
   60 |         filterRegistry.addCondition(getFilterId(), publicApiCondition);
   61 |     }
   62 | 
   63 |     @Override
   64 |     protected void doFilterInternal(HttpServletRequest request, HttpServletResponse response, FilterChain chain)
   65 |             throws IOException, ServletException {
   66 |         
   67 |         String path = request.getRequestURI();
   68 |         log.debug("권한 부여 필터 실행: {}", path);
   69 |         
   70 |         try {
   71 |             // 토큰에서 인증 정보 추출
   72 |             Authentication authentication = SecurityContextHolder.getContext().getAuthentication();
   73 |             
   74 |             if (authentication != null && authentication.isAuthenticated()) {
   75 |                 // 관리자 전용 API 접근 제한
   76 |                 if (path.startsWith(SecurityConstants.ADMIN_API_PATH.getValue()) && !hasAdminRole(authentication)) {
   77 |                     sendErrorResponse(response, ErrorType.ACCESS_DENIED);
   78 |                     return;
   79 |                 }
   80 |                 
   81 |                 log.debug("사용자 '{}' 권한 확인 성공", authentication.getName());
   82 |             }
   83 |             
   84 |             chain.doFilter(request, response);
   85 |         } catch (Exception e) {
   86 |             log.error("권한 부여 필터 실행 중 오류 발생: {}", e.getMessage());
   87 |             sendErrorResponse(response, ErrorType.AUTHENTICATION_FAILED);
   88 |         }
   89 |     }
   90 | 
   91 |     /**
   92 |      * 사용자가 관리자 권한을 가지고 있는지 확인
   93 |      */
   94 |     private boolean hasAdminRole(Authentication authentication) {
   95 |         return authentication.getAuthorities().stream()
   96 |                 .anyMatch(authority -> adminRoles.contains(authority.getAuthority()));
   97 |     }
   98 | 
   99 |     /**
  100 |      * 오류 응답 전송
  101 |      */
  102 |     private void sendErrorResponse(HttpServletResponse response, ErrorType errorType) throws IOException {
  103 |         response.setStatus(errorType.getStatusCode());
  104 |         response.setContentType(MediaType.APPLICATION_JSON_VALUE);
  105 |         
  106 |         objectMapper.writeValue(response.getOutputStream(), 
  107 |                                ApiResponse.error(errorType));
  108 |     }
  109 | 
  110 |     @Override
  111 |     protected boolean shouldSkipFilter(HttpServletRequest request) {
  112 |         return filterRegistry.shouldNotFilter(getFilterId(), request);
  113 |     }
  114 | 
  115 |     @Override
  116 |     public void configure(HttpSecurity http) throws Exception {
  117 |         http.addFilterAfter(this, JwtVerificationFilter.class);
  118 |         log.debug("권한 부여 필터 HttpSecurity에 구성됨");
  119 |     }
  120 | 
  121 |     @Override
  122 |     public Class<? extends Filter> getBeforeFilter() {
  123 |         return JwtVerificationFilter.class;
  124 |     }
  125 | 
  126 |     @Override
  127 |     public Class<? extends Filter> getAfterFilter() {
  128 |         return null;
  129 |     }
  130 | }

#--------------------------------------------------------------------------------


# File: auth-server-refactoring/src/main/java/com/authentication/auth/filter/AuthenticationFilter.java
#=============================================================================

    1 | package com.authentication.auth.filter;
    2 | 
    3 | import com.authentication.auth.constants.ErrorType;
    4 | import com.authentication.auth.constants.FilterOrder;
    5 | import com.authentication.auth.constants.SecurityConstants;
    6 | import com.authentication.auth.configuration.token.JwtUtility;
    7 | import com.authentication.auth.dto.response.ApiResponse;
    8 | import com.authentication.auth.dto.token.TokenDto;
    9 | import com.authentication.auth.service.redis.RedisService;
   10 | import com.fasterxml.jackson.databind.ObjectMapper;
   11 | import jakarta.annotation.PostConstruct;
   12 | import jakarta.servlet.Filter;
   13 | import jakarta.servlet.FilterChain;
   14 | import jakarta.servlet.ServletException;
   15 | import jakarta.servlet.http.Cookie;
   16 | import jakarta.servlet.http.HttpServletRequest;
   17 | import jakarta.servlet.http.HttpServletResponse;
   18 | import lombok.extern.slf4j.Slf4j;
   19 | import org.springframework.beans.factory.annotation.Autowired;
   20 | import org.springframework.beans.factory.annotation.Value;
   21 | import org.springframework.http.HttpMethod;
   22 | import org.springframework.http.MediaType;
   23 | import org.springframework.security.authentication.AuthenticationManager;
   24 | import org.springframework.security.authentication.UsernamePasswordAuthenticationToken;
   25 | import org.springframework.security.core.Authentication;
   26 | import org.springframework.security.core.AuthenticationException;
   27 | import org.springframework.security.core.context.SecurityContextHolder;
   28 | import org.springframework.security.web.authentication.UsernamePasswordAuthenticationFilter;
   29 | import org.springframework.stereotype.Component;
   30 | 
   31 | import java.io.IOException;
   32 | import java.util.HashMap;
   33 | import java.util.Map;
   34 | 
   35 | /**
   36 |  * 사용자 인증 필터
   37 |  * 사용자 로그인 요청을 처리하고 JWT 토큰을 생성하는 필터
   38 |  */
   39 | @Slf4j
   40 | @Component
   41 | public class AuthenticationFilter extends UsernamePasswordAuthenticationFilter implements PluggableFilter {
   42 |     
   43 |     private final AuthenticationManager authenticationManager;
   44 |     private final JwtUtility jwtUtility;
   45 |     private final ObjectMapper objectMapper;
   46 |     private final RedisService redisService;
   47 |     private final String domain;
   48 |     private final String cookieDomain;
   49 |     private final FilterRegistry filterRegistry;
   50 |     
   51 |     @Autowired
   52 |     public AuthenticationFilter(
   53 |             AuthenticationManager authenticationManager,
   54 |             JwtUtility jwtUtility,
   55 |             ObjectMapper objectMapper,
   56 |             RedisService redisService,
   57 |             @Value("${site.domain}") String domain,
   58 |             @Value("${server.cookie.domain}") String cookieDomain,
   59 |             FilterRegistry filterRegistry) {
   60 |         this.authenticationManager = authenticationManager;
   61 |         this.jwtUtility = jwtUtility;
   62 |         this.objectMapper = objectMapper;
   63 |         this.redisService = redisService;
   64 |         this.domain = domain;
   65 |         this.cookieDomain = cookieDomain;
   66 |         this.filterRegistry = filterRegistry;
   67 |         setFilterProcessesUrl(SecurityConstants.LOGIN_PATH.getValue());
   68 |         setAuthenticationManager(authenticationManager);
   69 |     }
   70 |     
   71 |     /**
   72 |      * 필터 초기화 및 레지스트리에 등록
   73 |      */
   74 |     @PostConstruct
   75 |     public void init() {
   76 |         // 필터 레지스트리에 이 필터 등록
   77 |         filterRegistry.registerFilter(this);
   78 |         
   79 |         // 기본 필터 조건 설정 - 공개 API는 인증 필터 적용하지 않음
   80 |         PathPatternFilterCondition publicApiCondition = new PathPatternFilterCondition(
   81 |                 "공개 API 경로 제외",
   82 |                 SecurityConstants.getPublicPaths().toArray(new String[0])
   83 |         );
   84 |         
   85 |         // 로그인 경로에는 POST 메소드만 허용하고 다른 메소드는 필터링
   86 |         PathPatternFilterCondition loginPathCondition = new PathPatternFilterCondition(
   87 |                 "로그인 경로 메소드 제한",
   88 |                 new HttpMethod[] {HttpMethod.GET, HttpMethod.PUT, HttpMethod.DELETE},
   89 |                 SecurityConstants.LOGIN_PATH.getValue()
   90 |         );
   91 |         
   92 |         // 필터 레지스트리에 조건 추가
   93 |         filterRegistry.addCondition(getFilterId(), publicApiCondition);
   94 |         filterRegistry.addCondition(getFilterId(), loginPathCondition);
   95 |     }
   96 | 
   97 |     @Override
   98 |     public Authentication attemptAuthentication(HttpServletRequest request, HttpServletResponse response) 
   99 |             throws AuthenticationException {
  100 |         log.info("인증 시도: {}", request.getRequestURI());
  101 |         
  102 |         try {
  103 |             // 요청 바디에서 사용자 자격 증명 추출
  104 |             Map<String, String> credentials = objectMapper.readValue(request.getInputStream(), Map.class);
  105 |             String username = credentials.get("username");
  106 |             String password = credentials.get("password");
  107 |             
  108 |             log.debug("사용자 인증 시도: {}", username);
  109 |             
  110 |             // 인증 토큰 생성 및 인증 시도
  111 |             UsernamePasswordAuthenticationToken authToken = 
  112 |                 new UsernamePasswordAuthenticationToken(username, password);
  113 |                 
  114 |             return authenticationManager.authenticate(authToken);
  115 |         } catch (IOException e) {
  116 |             log.error("인증 요청 처리 중 오류 발생: {}", e.getMessage());
  117 |             throw new AuthenticationException(ErrorType.AUTHENTICATION_FAILED.getMessage()) {};
  118 |         }
  119 |     }
  120 | 
  121 |     @Override
  122 |     protected void successfulAuthentication(HttpServletRequest request, HttpServletResponse response,
  123 |                                            FilterChain chain, Authentication authResult) 
  124 |                                            throws IOException, ServletException {
  125 |         log.info("인증 성공: 토큰 생성 시작");
  126 |         
  127 |         // 사용자 정보 추출
  128 |         String username = authResult.getName();
  129 |         
  130 |         // 토큰 생성
  131 |         TokenDto tokenDto = jwtUtility.createTokenDto(username, authResult.getAuthorities());
  132 |         
  133 |         // 리프레시 토큰을 Redis에 저장
  134 |         redisService.saveRToken(username, SecurityConstants.DEFAULT_PROVIDER.getValue(), tokenDto.refreshToken());
  135 |         redisService.saveAccessToken(tokenDto.refreshToken(), tokenDto.accessToken(), username);
  136 |         
  137 |         // 토큰을 쿠키에 저장
  138 |         Cookie refreshTokenCookie = new Cookie(SecurityConstants.COOKIE_REFRESH_TOKEN.getValue(), tokenDto.refreshToken());
  139 |         refreshTokenCookie.setHttpOnly(true);
  140 |         refreshTokenCookie.setPath(SecurityConstants.COOKIE_PATH.getValue());
  141 |         refreshTokenCookie.setDomain(cookieDomain);
  142 |         refreshTokenCookie.setSecure(true);
  143 |         
  144 |         response.addCookie(refreshTokenCookie);
  145 |         response.addHeader(SecurityConstants.TOKEN_HEADER.getValue(), 
  146 |                           SecurityConstants.TOKEN_PREFIX.getValue() + tokenDto.accessToken());
  147 |         
  148 |         // 응답 본문에도 토큰 정보 포함
  149 |         Map<String, String> tokens = new HashMap<>();
  150 |         tokens.put("access_token", tokenDto.accessToken());
  151 |         
  152 |         response.setContentType(MediaType.APPLICATION_JSON_VALUE);
  153 |         objectMapper.writeValue(response.getOutputStream(), 
  154 |                                ApiResponse.success(tokens, "로그인 성공"));
  155 |         
  156 |         // SecurityContext에 인증 정보 설정
  157 |         SecurityContextHolder.getContext().setAuthentication(authResult);
  158 |         
  159 |         log.info("인증 성공: 토큰 생성 완료 및 쿠키 설정");
  160 |     }
  161 |     
  162 |     @Override
  163 |     protected void unsuccessfulAuthentication(HttpServletRequest request, HttpServletResponse response,
  164 |                                              AuthenticationException failed) throws IOException, ServletException {
  165 |         log.error("인증 실패: {}", failed.getMessage());
  166 |         
  167 |         SecurityContextHolder.clearContext();
  168 |         
  169 |         response.setStatus(ErrorType.AUTHENTICATION_FAILED.getStatusCode());
  170 |         response.setContentType(MediaType.APPLICATION_JSON_VALUE);
  171 |         
  172 |         objectMapper.writeValue(response.getOutputStream(), 
  173 |                                ApiResponse.error(ErrorType.AUTHENTICATION_FAILED));
  174 |     }
  175 |     
  176 |     @Override
  177 |     public void configure(HttpSecurity http) throws Exception {
  178 |         http.addFilterAt(this, UsernamePasswordAuthenticationFilter.class);
  179 |         log.debug("인증 필터 HttpSecurity에 구성됨");
  180 |     }
  181 |     
  182 |     @Override
  183 |     public int getOrder() {
  184 |         return FilterOrder.AUTHENTICATION.getOrder();
  185 |     }
  186 |     
  187 |     @Override
  188 |     public Class<? extends Filter> getBeforeFilter() {
  189 |         return null; // 이 필터 이전에 실행되어야 하는 필터가 없음
  190 |     }
  191 |     
  192 |     @Override
  193 |     public Class<? extends Filter> getAfterFilter() {
  194 |         return JwtVerificationFilter.class; // JWT 검증 필터 이전에 실행
  195 |     }
  196 |     
  197 |     @Override
  198 |     public String getFilterId() {
  199 |         return this.getClass().getSimpleName();
  200 |     }
  201 | }

#--------------------------------------------------------------------------------


# File: auth-server-refactoring/src/main/java/com/authentication/auth/filter/SecurityFilterOrder.java
#=============================================================================

    1 | package com.authentication.auth.filter;
    2 | 
    3 | /**
    4 |  * 보안 필터 순서 상수
    5 |  * 필터 체인 내에서 필터의 실행 순서를 정의하는 열거형
    6 |  */
    7 | public enum SecurityFilterOrder {
    8 |     
    9 |     // 값이 낮을수록 먼저 실행됨
   10 |     REQUEST_LOGGING_FILTER(50),
   11 |     CORS_FILTER(100),
   12 |     CSRF_FILTER(200),
   13 |     AUTHENTICATION_FILTER(300),
   14 |     JWT_VERIFICATION_FILTER(400),
   15 |     AUTHORIZATION_FILTER(500),
   16 |     SESSION_MANAGEMENT_FILTER(600),
   17 |     EXCEPTION_TRANSLATION_FILTER(700);
   18 |     
   19 |     private final int order;
   20 |     
   21 |     SecurityFilterOrder(int order) {
   22 |         this.order = order;
   23 |     }
   24 |     
   25 |     public int getOrder() {
   26 |         return order;
   27 |     }
   28 | }

#--------------------------------------------------------------------------------


# File: auth-server-refactoring/src/main/java/com/authentication/auth/filter/AbstractSecurityFilter.java
#=============================================================================

    1 | package com.authentication.auth.filter;
    2 | 
    3 | import jakarta.servlet.FilterChain;
    4 | import jakarta.servlet.ServletException;
    5 | import jakarta.servlet.http.HttpServletRequest;
    6 | import jakarta.servlet.http.HttpServletResponse;
    7 | import lombok.extern.slf4j.Slf4j;
    8 | import org.springframework.web.filter.OncePerRequestFilter;
    9 | 
   10 | import java.io.IOException;
   11 | 
   12 | /**
   13 |  * 모든 보안 필터의 기본 추상 클래스
   14 |  * 필터 실행 흐름 제어 및 공통 기능 제공
   15 |  */
   16 | @Slf4j
   17 | public abstract class AbstractSecurityFilter extends OncePerRequestFilter implements PluggableFilter {
   18 | 
   19 |     // 필터 실행 순서
   20 |     private final SecurityFilterOrder securityFilterOrder;
   21 | 
   22 |     /**
   23 |      * 생성자
   24 |      * @param securityFilterOrder 필터 실행 순서
   25 |      */
   26 |     protected AbstractSecurityFilter(SecurityFilterOrder securityFilterOrder) {
   27 |         this.securityFilterOrder = securityFilterOrder;
   28 |     }
   29 | 
   30 |     @Override
   31 |     protected final void doFilterInternal(HttpServletRequest request, HttpServletResponse response, FilterChain chain)
   32 |             throws ServletException, IOException {
   33 |         
   34 |         String path = request.getRequestURI();
   35 |         log.debug("필터 시작: {} - {}", securityFilterOrder.name(), path);
   36 |         
   37 |         try {
   38 |             doFilterInternal(request, response, chain);
   39 |             log.debug("필터 종료: {} - {}", securityFilterOrder.name(), path);
   40 |         } catch (Exception e) {
   41 |             log.error("필터 실행 중 오류 발생: {} - {}", securityFilterOrder.name(), e.getMessage(), e);
   42 |             handleFilterException(request, response, e);
   43 |         }
   44 |     }
   45 |     
   46 |     /**
   47 |      * 필터의 주요 비즈니스 로직 구현
   48 |      */
   49 |     protected abstract void doFilterInternal(HttpServletRequest request, HttpServletResponse response, 
   50 |                                            FilterChain chain) throws IOException, ServletException;
   51 |     
   52 |     /**
   53 |      * 필터 예외 처리 메서드
   54 |      */
   55 |     protected void handleFilterException(HttpServletRequest request, HttpServletResponse response, Exception e) 
   56 |             throws IOException, ServletException {
   57 |         // 기본 구현에서는 예외를 전파
   58 |         // 필요시 하위 클래스에서 재정의
   59 |         if (e instanceof IOException) {
   60 |             throw (IOException) e;
   61 |         } else if (e instanceof ServletException) {
   62 |             throw (ServletException) e;
   63 |         } else {
   64 |             throw new ServletException("필터 처리 중 오류 발생", e);
   65 |         }
   66 |     }
   67 |     
   68 |     @Override
   69 |     public int getOrder() {
   70 |         return securityFilterOrder.getOrder();
   71 |     }
   72 |     
   73 |     /**
   74 |      * 필터 적용 여부 결정 메서드
   75 |      * @param request HTTP 요청
   76 |      * @return 필터 적용 여부
   77 |      */
   78 |     protected abstract boolean shouldSkipFilter(HttpServletRequest request);
   79 | }

#--------------------------------------------------------------------------------


# File: auth-server-refactoring/src/main/java/com/authentication/auth/domain/AuthProvider.java
#=============================================================================

    1 | package com.authentication.auth.domain;
    2 | 
    3 | import jakarta.persistence.*;
    4 | import lombok.AllArgsConstructor;
    5 | import lombok.Builder;
    6 | import lombok.Data;
    7 | import lombok.NoArgsConstructor;
    8 | 
    9 | import java.util.ArrayList;
   10 | import java.util.List;
   11 | 
   12 | @Entity
   13 | @Table(name = "Auth_Provider")
   14 | @Data
   15 | @NoArgsConstructor
   16 | @AllArgsConstructor
   17 | @Builder
   18 | public class AuthProvider {
   19 |     @Id
   20 |     @GeneratedValue(strategy = GenerationType.IDENTITY)
   21 |     private Integer id;
   22 |     
   23 |     @Column(name = "provider_name", nullable = false, length = 50)
   24 |     private String providerName;
   25 |     
   26 |     private String description;
   27 |     
   28 |     @Column(name = "is_active")
   29 |     private Boolean isActive = true;
   30 |     
   31 |     @OneToMany(mappedBy = "authProvider", cascade = CascadeType.ALL)
   32 |     private List<UserAuthentication> userAuthentications = new ArrayList<>();
   33 |     
   34 |     /**
   35 |      * 인증 제공자 유형을 나타내는 열거형
   36 |      */
   37 |     public enum ProviderType {
   38 |         SERVER("server", "내부 서버 인증"),
   39 |         GOOGLE("google", "구글 OAuth2"),
   40 |         KAKAO("kakao", "카카오 OAuth2"),
   41 |         NAVER("naver", "네이버 OAuth2"),
   42 |         FACEBOOK("facebook", "페이스북 OAuth2"),
   43 |         GITHUB("github", "깃허브 OAuth2");
   44 |         
   45 |         private final String code;
   46 |         private final String description;
   47 |         
   48 |         ProviderType(String code, String description) {
   49 |             this.code = code;
   50 |             this.description = description;
   51 |         }
   52 |         
   53 |         public String getCode() {
   54 |             return code;
   55 |         }
   56 |         
   57 |         public String getDescription() {
   58 |             return description;
   59 |         }
   60 |         
   61 |         public static ProviderType fromCode(String code) {
   62 |             for (ProviderType type : values()) {
   63 |                 if (type.code.equals(code)) {
   64 |                     return type;
   65 |                 }
   66 |             }
   67 |             return SERVER; // 기본값
   68 |         }
   69 |     }
   70 | }

#--------------------------------------------------------------------------------


# File: auth-server-refactoring/src/main/java/com/authentication/auth/domain/User.java
#=============================================================================

    1 | package com.authentication.auth.domain;
    2 | 
    3 | import jakarta.persistence.*;
    4 | import lombok.AllArgsConstructor;
    5 | import lombok.Builder;
    6 | import lombok.Data;
    7 | import lombok.NoArgsConstructor;
    8 | import java.time.LocalDateTime;
    9 | import java.util.ArrayList;
   10 | import java.util.List;
   11 | 
   12 | @Entity
   13 | @Table(name = "Users")
   14 | @Data
   15 | @NoArgsConstructor
   16 | @AllArgsConstructor
   17 | @Builder
   18 | public class User {
   19 |     @Id
   20 |     @GeneratedValue(strategy = GenerationType.IDENTITY)
   21 |     private Long id;
   22 | 
   23 |     @Column(nullable = false)
   24 |     private String password;
   25 | 
   26 |     @Column(name = "created_at")
   27 |     private LocalDateTime createdAt;
   28 | 
   29 |     @Column(name = "updated_at")
   30 |     private LocalDateTime updatedAt;
   31 | 
   32 |     @Column(name = "user_name", nullable = false, length = 30)
   33 |     private String userName;
   34 | 
   35 |     @Enumerated(EnumType.STRING)
   36 |     @Column(name = "user_role", nullable = false)
   37 |     private UserRole userRole = UserRole.USER;
   38 | 
   39 |     @Column(name = "is_premium")
   40 |     private Boolean isPremium = false;
   41 | 
   42 |     @Column(name = "last_login")
   43 |     private LocalDateTime lastLogin;
   44 | 
   45 |     @Enumerated(EnumType.STRING)
   46 |     @Column(name = "is_active", nullable = false)
   47 |     private UserStatus isActive = UserStatus.WAITING;
   48 | 
   49 |     @OneToMany(mappedBy = "user")
   50 |     private List<Diary> diaries = new ArrayList<>();
   51 | 
   52 |     @OneToMany(mappedBy = "user", cascade = CascadeType.ALL, orphanRemoval = true)
   53 |     private List<UserAuthentication> authentications = new ArrayList<>();
   54 | 
   55 |     @OneToMany(mappedBy = "user", cascade = CascadeType.ALL, orphanRemoval = true)
   56 |     private List<UserCustomSetting> customSettings = new ArrayList<>();
   57 | 
   58 |     @PrePersist
   59 |     protected void onCreate() {
   60 |         createdAt = LocalDateTime.now();
   61 |         updatedAt = LocalDateTime.now();
   62 |     }
   63 | 
   64 |     @PreUpdate
   65 |     protected void onUpdate() {
   66 |         updatedAt = LocalDateTime.now();
   67 |     }
   68 | 
   69 |     /**
   70 |      * 사용자 역할을 나타내는 열거형
   71 |      */
   72 |     public enum UserRole {
   73 |         USER("일반 사용자"),
   74 |         ADMIN("관리자");
   75 |         
   76 |         private final String description;
   77 |         
   78 |         UserRole(String description) {
   79 |             this.description = description;
   80 |         }
   81 |         
   82 |         public String getDescription() {
   83 |             return description;
   84 |         }
   85 |     }
   86 | 
   87 |     /**
   88 |      * 사용자 상태를 나타내는 열거형
   89 |      */
   90 |     public enum UserStatus {
   91 |         ACTIVE("active", "활성화된 계정"),
   92 |         WAITING("waiting", "이메일 인증 대기 중"),
   93 |         BLOCKED("blocked", "차단된 계정"),
   94 |         SUSPEND("suspend", "일시 정지된 계정"),
   95 |         DELETE("delete", "삭제된 계정");
   96 |         
   97 |         private final String value;
   98 |         private final String description;
   99 |         
  100 |         UserStatus(String value, String description) {
  101 |             this.value = value;
  102 |             this.description = description;
  103 |         }
  104 |         
  105 |         public String getValue() {
  106 |             return value;
  107 |         }
  108 |         
  109 |         public String getDescription() {
  110 |             return description;
  111 |         }
  112 |         
  113 |         @Override
  114 |         public String toString() {
  115 |             return value;
  116 |         }
  117 |     }
  118 | }

#--------------------------------------------------------------------------------


# File: auth-server-refactoring/src/main/java/com/authentication/auth/domain/UserAuthentication.java
#=============================================================================

    1 | package com.authentication.auth.domain;
    2 | 
    3 | import jakarta.persistence.*;
    4 | import lombok.AllArgsConstructor;
    5 | import lombok.Builder;
    6 | import lombok.Data;
    7 | import lombok.NoArgsConstructor;
    8 | 
    9 | import java.io.Serializable;
   10 | import java.time.LocalDateTime;
   11 | 
   12 | @Entity
   13 | @Table(name = "User_Authentication", uniqueConstraints = {
   14 |     @UniqueConstraint(columnNames = {"auth_provider_id", "social_id"})
   15 | })
   16 | @Data
   17 | @NoArgsConstructor
   18 | @AllArgsConstructor
   19 | @Builder
   20 | public class UserAuthentication {
   21 |     @EmbeddedId
   22 |     private UserAuthenticationId id;
   23 |     
   24 |     @ManyToOne(fetch = FetchType.LAZY)
   25 |     @MapsId("userId")
   26 |     @JoinColumn(name = "user_id")
   27 |     private User user;
   28 |     
   29 |     @ManyToOne(fetch = FetchType.LAZY)
   30 |     @MapsId("authProviderId")
   31 |     @JoinColumn(name = "auth_provider_id")
   32 |     private AuthProvider authProvider;
   33 |     
   34 |     @Column(name = "social_id", nullable = false)
   35 |     private String socialId;
   36 |     
   37 |     private String email;
   38 |     
   39 |     @Column(name = "created_at")
   40 |     private LocalDateTime createdAt;
   41 |     
   42 |     @Column(name = "updated_at")
   43 |     private LocalDateTime updatedAt;
   44 |     
   45 |     @PrePersist
   46 |     protected void onCreate() {
   47 |         createdAt = LocalDateTime.now();
   48 |         updatedAt = LocalDateTime.now();
   49 |     }
   50 | 
   51 |     @PreUpdate
   52 |     protected void onUpdate() {
   53 |         updatedAt = LocalDateTime.now();
   54 |     }
   55 | }
   56 | 
   57 | @Embeddable
   58 | @Data
   59 | @NoArgsConstructor
   60 | @AllArgsConstructor
   61 | class UserAuthenticationId implements Serializable {
   62 |     @Column(name = "user_id")
   63 |     private Long userId;
   64 |     
   65 |     @Column(name = "auth_provider_id")
   66 |     private Integer authProviderId;
   67 | }

#--------------------------------------------------------------------------------


# File: auth-server-refactoring/src/main/java/com/authentication/auth/dto/response/ApiResponse.java
#=============================================================================

    1 | package com.authentication.auth.dto.response;
    2 | 
    3 | import com.authentication.auth.constants.ErrorType;
    4 | import org.springframework.http.HttpStatus;
    5 | import org.springframework.http.ResponseEntity;
    6 | 
    7 | import java.time.LocalDateTime;
    8 | import java.util.HashMap;
    9 | import java.util.Map;
   10 | 
   11 | /**
   12 |  * API 응답 형식을 표준화하는 레코드
   13 |  * @param status 상태 (success/error)
   14 |  * @param message 메시지
   15 |  * @param data 응답 데이터
   16 |  * @param timestamp 타임스탬프
   17 |  */
   18 | public record ApiResponse<T>(
   19 |     String status,
   20 |     String message,
   21 |     T data,
   22 |     LocalDateTime timestamp
   23 | ) {
   24 |     /**
   25 |      * 성공 응답 생성
   26 |      * @param data 응답 데이터
   27 |      * @param message 메시지
   28 |      * @return API 응답
   29 |      */
   30 |     public static <T> ApiResponse<T> success(T data, String message) {
   31 |         return new ApiResponse<>("success", message, data, LocalDateTime.now());
   32 |     }
   33 |     
   34 |     /**
   35 |      * 성공 응답 생성 (기본 메시지)
   36 |      * @param data 응답 데이터
   37 |      * @return API 응답
   38 |      */
   39 |     public static <T> ApiResponse<T> success(T data) {
   40 |         return success(data, "요청이 성공적으로 처리되었습니다");
   41 |     }
   42 |     
   43 |     /**
   44 |      * 오류 응답 생성
   45 |      * @param errorType 오류 유형
   46 |      * @param details 추가 세부 정보
   47 |      * @return API 응답
   48 |      */
   49 |     public static ApiResponse<Map<String, Object>> error(ErrorType errorType, Map<String, Object> details) {
   50 |         Map<String, Object> errorData = new HashMap<>();
   51 |         errorData.put("code", errorType.name());
   52 |         errorData.put("title", errorType.getTitle());
   53 |         if (details != null) {
   54 |             errorData.put("details", details);
   55 |         }
   56 |         
   57 |         return new ApiResponse<>("error", errorType.getMessage(), errorData, LocalDateTime.now());
   58 |     }
   59 |     
   60 |     /**
   61 |      * 오류 응답 생성 (세부 정보 없음)
   62 |      * @param errorType 오류 유형
   63 |      * @return API 응답
   64 |      */
   65 |     public static ApiResponse<Map<String, Object>> error(ErrorType errorType) {
   66 |         return error(errorType, null);
   67 |     }
   68 |     
   69 |     /**
   70 |      * ResponseEntity로 변환
   71 |      * @param httpStatus HTTP 상태
   72 |      * @return ResponseEntity
   73 |      */
   74 |     public ResponseEntity<ApiResponse<T>> toResponseEntity(HttpStatus httpStatus) {
   75 |         return ResponseEntity.status(httpStatus).body(this);
   76 |     }
   77 |     
   78 |     /**
   79 |      * 성공 응답을 ResponseEntity로 변환 (HTTP 200)
   80 |      * @return ResponseEntity
   81 |      */
   82 |     public ResponseEntity<ApiResponse<T>> toSuccessResponseEntity() {
   83 |         return toResponseEntity(HttpStatus.OK);
   84 |     }
   85 |     
   86 |     /**
   87 |      * 오류 응답을 ResponseEntity로 변환
   88 |      * @param errorType 오류 유형
   89 |      * @return ResponseEntity
   90 |      */
   91 |     public static ResponseEntity<ApiResponse<Map<String, Object>>> toErrorResponseEntity(ErrorType errorType) {
   92 |         return error(errorType).toResponseEntity(errorType.getStatus());
   93 |     }
   94 | }

#--------------------------------------------------------------------------------


# File: auth-server-refactoring/src/main/java/com/authentication/auth/dto/users/UserProfileResponse.java
#=============================================================================

    1 | package com.authentication.auth.dto.users;
    2 | 
    3 | import com.authentication.auth.domain.User;
    4 | import com.fasterxml.jackson.annotation.JsonProperty;
    5 | 
    6 | import java.time.LocalDateTime;
    7 | import java.util.Date;
    8 | 
    9 | /**
   10 |  * 사용자 프로필 응답 정보를 담는 불변 레코드
   11 |  */
   12 | public record UserProfileResponse(
   13 |     String userId,
   14 |     String userName,
   15 |     String nickname,
   16 |     String email,
   17 |     String phone,
   18 |     String role,
   19 |     Date birthDate,
   20 |     String gender,
   21 |     @JsonProperty("isPrivate") boolean isPrivate,
   22 |     String profile,
   23 |     LocalDateTime createdAt,
   24 |     LocalDateTime lastLogin
   25 | ) {
   26 |     /**
   27 |      * 사용자 엔티티에서 응답 객체 생성
   28 |      */
   29 |     public static UserProfileResponse fromEntity(User user) {
   30 |         return new UserProfileResponse(
   31 |             user.getId().toString(),
   32 |             user.getUserName(),
   33 |             user.getUserName(), // nickname 필드가 없어서 userName으로 대체
   34 |             "", // email 필드가 없어서 빈 문자열로 대체
   35 |             "", // phone 필드가 없어서 빈 문자열로 대체
   36 |             user.getUserRole().name(),
   37 |             null, // birthDate 필드가 없어서 null로 대체
   38 |             "", // gender 필드가 없어서 빈 문자열로 대체
   39 |             false, // isPrivate 필드가 없어서 false로 대체
   40 |             "", // profile 필드가 없어서 빈 문자열로 대체
   41 |             user.getCreatedAt(),
   42 |             user.getLastLogin()
   43 |         );
   44 |     }
   45 | }

#--------------------------------------------------------------------------------


# File: auth-server-refactoring/src/main/java/com/authentication/auth/dto/users/LoginRequest.java
#=============================================================================

    1 | package com.authentication.auth.dto.users;
    2 | 
    3 | import jakarta.validation.constraints.NotBlank;
    4 | 
    5 | /**
    6 |  * 로그인 요청 정보를 담는 불변 레코드
    7 |  */
    8 | public record LoginRequest(
    9 |     @NotBlank(message = "사용자 ID는 필수입니다")
   10 |     String userId,
   11 |     
   12 |     @NotBlank(message = "비밀번호는 필수입니다")
   13 |     String password
   14 | ) {
   15 |     /**
   16 |      * 유효성 검사
   17 |      */
   18 |     public boolean isValid() {
   19 |         return userId != null && !userId.isBlank() &&
   20 |                password != null && !password.isBlank();
   21 |     }
   22 | }

#--------------------------------------------------------------------------------


# File: auth-server-refactoring/src/main/java/com/authentication/auth/dto/users/JoinRequest.java
#=============================================================================

    1 | package com.authentication.auth.dto.users;
    2 | 
    3 | import com.authentication.auth.domain.User;
    4 | import com.fasterxml.jackson.annotation.JsonProperty;
    5 | import jakarta.validation.constraints.Email;
    6 | import jakarta.validation.constraints.NotBlank;
    7 | import jakarta.validation.constraints.Pattern;
    8 | import jakarta.validation.constraints.Size;
    9 | 
   10 | import java.util.Date;
   11 | 
   12 | /**
   13 |  * 회원 가입 요청 정보를 담는 불변 레코드
   14 |  */
   15 | public record JoinRequest(
   16 |     @NotBlank(message = "사용자 ID는 필수입니다") 
   17 |     @Size(min = 4, max = 20, message = "사용자 ID는 4~20자 사이여야 합니다")
   18 |     String userId,
   19 |     
   20 |     @NotBlank(message = "비밀번호는 필수입니다")
   21 |     @Size(min = 8, message = "비밀번호는 최소 8자 이상이어야 합니다")
   22 |     String userPw,
   23 |     
   24 |     @NotBlank(message = "이름은 필수입니다")
   25 |     String userName,
   26 |     
   27 |     @NotBlank(message = "닉네임은 필수입니다")
   28 |     @Size(min = 2, max = 20, message = "닉네임은 2~20자 사이여야 합니다")
   29 |     String nickname,
   30 |     
   31 |     @NotBlank(message = "전화번호는 필수입니다")
   32 |     @Pattern(regexp = "^\\d{3}-\\d{3,4}-\\d{4}$", message = "전화번호 형식이 올바르지 않습니다")
   33 |     String phone,
   34 |     
   35 |     @Email(message = "이메일 형식이 올바르지 않습니다")
   36 |     String email,
   37 |     
   38 |     User.UserRole role,
   39 |     
   40 |     Date birthDate,
   41 |     
   42 |     @NotBlank(message = "성별은 필수입니다")
   43 |     String gender,
   44 |     
   45 |     @JsonProperty("isPrivate") 
   46 |     boolean isPrivate,
   47 |     
   48 |     String profile,
   49 |     
   50 |     @NotBlank(message = "인증 코드는 필수입니다")
   51 |     String code
   52 | ) {
   53 |     /**
   54 |      * 기본 프로필 이미지를 사용하는 팩토리 메서드
   55 |      */
   56 |     public static JoinRequest of(
   57 |             String userId, String userPw, String userName, String nickname, 
   58 |             String phone, String email, User.UserRole role, Date birthDate, 
   59 |             String gender, boolean isPrivate, String code) {
   60 |         return new JoinRequest(
   61 |                 userId, userPw, userName, nickname, phone, email, role, 
   62 |                 birthDate, gender, isPrivate, "https://zrr.kr/iPHf", code);
   63 |     }
   64 | 
   65 |     /**
   66 |      * 사용자 엔티티로 변환
   67 |      */
   68 |     public User toEntity(String encodedPassword) {
   69 |         return User.builder()
   70 |                 .password(encodedPassword)
   71 |                 .userName(this.userName)
   72 |                 .userRole(this.role != null ? this.role : User.UserRole.USER)
   73 |                 .isPremium(false)
   74 |                 .isActive(User.UserStatus.WAITING)
   75 |                 .build();
   76 |     }
   77 |     
   78 |     /**
   79 |      * 유효성 검사
   80 |      */
   81 |     public boolean isValid() {
   82 |         return userId != null && !userId.isBlank() &&
   83 |                userPw != null && !userPw.isBlank() &&
   84 |                userName != null && !userName.isBlank() &&
   85 |                nickname != null && !nickname.isBlank() &&
   86 |                phone != null && !phone.isBlank() &&
   87 |                code != null && !code.isBlank();
   88 |     }
   89 | }

#--------------------------------------------------------------------------------


# File: auth-server-refactoring/src/main/java/com/authentication/auth/dto/email/EmailRequest.java
#=============================================================================

    1 | package com.authentication.auth.dto.email;
    2 | 
    3 | import jakarta.validation.constraints.Email;
    4 | import jakarta.validation.constraints.NotBlank;
    5 | 
    6 | /**
    7 |  * 이메일 요청 정보를 담는 불변 레코드
    8 |  */
    9 | public record EmailRequest(
   10 |     @NotBlank(message = "이메일은 필수입니다")
   11 |     @Email(message = "이메일 형식이 올바르지 않습니다")
   12 |     String email
   13 | ) {
   14 |     /**
   15 |      * 유효성 검사
   16 |      */
   17 |     public boolean isValid() {
   18 |         return email != null && !email.isBlank();
   19 |     }
   20 | }

#--------------------------------------------------------------------------------


# File: auth-server-refactoring/src/main/java/com/authentication/auth/dto/email/EmailCheckRequest.java
#=============================================================================

    1 | package com.authentication.auth.dto.email;
    2 | 
    3 | import jakarta.validation.constraints.Email;
    4 | import jakarta.validation.constraints.NotBlank;
    5 | 
    6 | /**
    7 |  * 이메일 인증 코드 확인 요청 정보를 담는 불변 레코드
    8 |  */
    9 | public record EmailCheckRequest(
   10 |     @NotBlank(message = "이메일은 필수입니다")
   11 |     @Email(message = "이메일 형식이 올바르지 않습니다")
   12 |     String email,
   13 |     
   14 |     @NotBlank(message = "인증 코드는 필수입니다")
   15 |     String code
   16 | ) {
   17 |     /**
   18 |      * 유효성 검사
   19 |      */
   20 |     public boolean isValid() {
   21 |         return email != null && !email.isBlank() &&
   22 |                code != null && !code.isBlank();
   23 |     }
   24 | }

#--------------------------------------------------------------------------------


# File: auth-server-refactoring/src/main/java/com/authentication/auth/dto/email/CustomEmailRequest.java
#=============================================================================

    1 | package com.authentication.auth.dto.email;
    2 | 
    3 | import jakarta.validation.constraints.Email;
    4 | import jakarta.validation.constraints.NotBlank;
    5 | 
    6 | /**
    7 |  * 커스텀 이메일 요청 정보를 담는 불변 레코드
    8 |  */
    9 | public record CustomEmailRequest(
   10 |     @NotBlank(message = "이메일은 필수입니다")
   11 |     @Email(message = "이메일 형식이 올바르지 않습니다")
   12 |     String email,
   13 |     
   14 |     @NotBlank(message = "제목은 필수입니다")
   15 |     String title,
   16 |     
   17 |     @NotBlank(message = "내용은 필수입니다")
   18 |     String content
   19 | ) {
   20 |     /**
   21 |      * 유효성 검사
   22 |      */
   23 |     public boolean isValid() {
   24 |         return email != null && !email.isBlank() &&
   25 |                title != null && !title.isBlank() &&
   26 |                content != null && !content.isBlank();
   27 |     }
   28 | }

#--------------------------------------------------------------------------------


# File: auth-server-refactoring/src/main/java/com/authentication/auth/dto/token/TokenDto.java
#=============================================================================

    1 | package com.authentication.auth.dto.token;
    2 | 
    3 | /**
    4 |  * 토큰 정보를 담는 불변 레코드
    5 |  * @param accessToken 액세스 토큰
    6 |  * @param refreshToken 리프레시 토큰
    7 |  * @param expiresIn 액세스 토큰 만료 시간(초)
    8 |  * @param tokenType 토큰 타입
    9 |  */
   10 | public record TokenDto(
   11 |     String accessToken,
   12 |     String refreshToken,
   13 |     long expiresIn,
   14 |     String tokenType
   15 | ) {
   16 |     /**
   17 |      * 기본 토큰 생성 팩토리 메서드
   18 |      */
   19 |     public static TokenDto of(String accessToken, String refreshToken, long expiresIn) {
   20 |         return new TokenDto(accessToken, refreshToken, expiresIn, "Bearer");
   21 |     }
   22 |     
   23 |     /**
   24 |      * 액세스 토큰만 포함하는 DTO 생성
   25 |      */
   26 |     public static TokenDto accessTokenOnly(String accessToken, long expiresIn) {
   27 |         return new TokenDto(accessToken, null, expiresIn, "Bearer");
   28 |     }
   29 | }

#--------------------------------------------------------------------------------


# File: auth-server-refactoring/src/main/java/com/authentication/auth/dto/token/TokenRefreshRequest.java
#=============================================================================

    1 | package com.authentication.auth.dto.token;
    2 | 
    3 | /**
    4 |  * 토큰 갱신 요청 정보를 담는 불변 레코드
    5 |  * @param expiredToken 만료된 토큰
    6 |  * @param provider 인증 제공자
    7 |  */
    8 | public record TokenRefreshRequest(
    9 |     String expiredToken,
   10 |     String provider
   11 | ) {
   12 |     /**
   13 |      * 유효성 검사
   14 |      * @return 유효 여부
   15 |      */
   16 |     public boolean isValid() {
   17 |         return expiredToken != null && !expiredToken.isBlank() && 
   18 |                provider != null && !provider.isBlank();
   19 |     }
   20 | }

#--------------------------------------------------------------------------------


# File: auth-server-refactoring/src/main/java/com/authentication/auth/configuration/SecurityConfig.java
#=============================================================================

    1 | package com.authentication.auth.configuration;
    2 | 
    3 | import com.authentication.auth.filter.FilterRegistry;
    4 | import lombok.RequiredArgsConstructor;
    5 | import lombok.extern.slf4j.Slf4j;
    6 | import org.springframework.context.annotation.Bean;
    7 | import org.springframework.context.annotation.Configuration;
    8 | import org.springframework.security.config.annotation.web.builders.HttpSecurity;
    9 | import org.springframework.security.config.annotation.web.configuration.EnableWebSecurity;
   10 | import org.springframework.security.config.http.SessionCreationPolicy;
   11 | import org.springframework.security.crypto.bcrypt.BCryptPasswordEncoder;
   12 | import org.springframework.security.web.SecurityFilterChain;
   13 | 
   14 | /**
   15 |  * Spring Security 구성 클래스
   16 |  * 보안 필터 체인 및 인증/인가 설정을 관리
   17 |  */
   18 | @Configuration
   19 | @EnableWebSecurity
   20 | @RequiredArgsConstructor
   21 | @Slf4j
   22 | public class SecurityConfig {
   23 | 
   24 |     private final FilterRegistry filterRegistry;
   25 |     
   26 |     @Bean
   27 |     public SecurityFilterChain securityFilterChain(HttpSecurity http) throws Exception {
   28 |         log.info("보안 필터 체인 구성 중...");
   29 |         
   30 |         http
   31 |             .csrf(csrf -> csrf.disable())
   32 |             .formLogin(form -> form.disable())
   33 |             .httpBasic(basic -> basic.disable())
   34 |             .sessionManagement(session -> session.sessionCreationPolicy(SessionCreationPolicy.STATELESS))
   35 |             .authorizeHttpRequests(auth -> auth
   36 |                 .requestMatchers("/auth/**", "/login", "/signup", "/public/**").permitAll()
   37 |                 .anyRequest().authenticated()
   38 |             );
   39 |         
   40 |         // 플러그형 필터 등록
   41 |         filterRegistry.configureFilters(http);
   42 |         
   43 |         return http.build();
   44 |     }
   45 |     
   46 |     @Bean
   47 |     public BCryptPasswordEncoder passwordEncoder() {
   48 |         return new BCryptPasswordEncoder();
   49 |     }
   50 | }

#--------------------------------------------------------------------------------


# File: auth-server-refactoring/src/main/java/com/authentication/auth/configuration/token/JwtUtility.java
#=============================================================================

    1 | package com.authentication.auth.configuration.token;
    2 | 
    3 | import com.authentication.auth.constants.ErrorType;
    4 | import com.authentication.auth.constants.SecurityConstants;
    5 | import com.authentication.auth.dto.token.TokenDto;
    6 | import io.jsonwebtoken.*;
    7 | import io.jsonwebtoken.security.Keys;
    8 | import jakarta.servlet.http.Cookie;
    9 | import jakarta.servlet.http.HttpServletRequest;
   10 | import jakarta.servlet.http.HttpServletResponse;
   11 | import lombok.extern.slf4j.Slf4j;
   12 | import org.springframework.beans.factory.annotation.Value;
   13 | import org.springframework.security.authentication.UsernamePasswordAuthenticationToken;
   14 | import org.springframework.security.core.Authentication;
   15 | import org.springframework.security.core.GrantedAuthority;
   16 | import org.springframework.security.core.authority.SimpleGrantedAuthority;
   17 | import org.springframework.security.core.userdetails.User;
   18 | import org.springframework.security.core.userdetails.UserDetails;
   19 | import org.springframework.stereotype.Component;
   20 | 
   21 | import java.io.IOException;
   22 | import java.io.PrintWriter;
   23 | import java.security.Key;
   24 | import java.time.Instant;
   25 | import java.util.*;
   26 | import java.util.stream.Collectors;
   27 | 
   28 | @Slf4j
   29 | @Component
   30 | public class JwtUtility {
   31 | 
   32 |     private final String domain;
   33 |     private final String cookieDomain;
   34 |     private final Key accessTokenKey;
   35 |     private final Key refreshTokenKey;
   36 |     private final long accessTokenValidity;
   37 |     private final long refreshTokenValidity;
   38 | 
   39 |     public JwtUtility(
   40 |             @Value("${site.domain}") String domain,
   41 |             @Value("${server.cookie.domain}") String cookieDomain,
   42 |             @Value("${jwt.secret-key}") String accessTokenSecret,
   43 |             @Value("${jwt.secret-key2}") String refreshTokenSecret,
   44 |             @Value("${ACCESS_TOKEN_VALIDITY}") Long accessTokenValidity,
   45 |             @Value("${REFRESH_TOKEN_VALIDITY}") Long refreshTokenValidity) {
   46 |         this.domain = domain;
   47 |         this.cookieDomain = cookieDomain;
   48 |         this.accessTokenKey = Keys.hmacShaKeyFor(accessTokenSecret.getBytes());
   49 |         this.refreshTokenKey = Keys.hmacShaKeyFor(refreshTokenSecret.getBytes());
   50 |         this.accessTokenValidity = accessTokenValidity;
   51 |         this.refreshTokenValidity = refreshTokenValidity;
   52 |     }
   53 | 
   54 |     /**
   55 |      * 토큰 DTO 생성
   56 |      * @param username 사용자 이름
   57 |      * @param authorities 권한 목록
   58 |      * @return 토큰 DTO
   59 |      */
   60 |     public TokenDto createTokenDto(String username, Collection<? extends GrantedAuthority> authorities) {
   61 |         String accessToken = generateAccessToken(username, authorities);
   62 |         String refreshToken = generateRefreshToken(username);
   63 |         
   64 |         return TokenDto.of(accessToken, refreshToken, accessTokenValidity);
   65 |     }
   66 | 
   67 |     /**
   68 |      * 액세스 토큰 생성
   69 |      * @param username 사용자 이름
   70 |      * @param authorities 권한 목록
   71 |      * @return 생성된 액세스 토큰
   72 |      */
   73 |     public String generateAccessToken(String username, Collection<? extends GrantedAuthority> authorities) {
   74 |         Instant now = Instant.now();
   75 |         Instant expiry = now.plusSeconds(accessTokenValidity);
   76 |         
   77 |         Claims claims = Jwts.claims();
   78 |         claims.setSubject(username);
   79 |         claims.put("authorities", authorities.stream()
   80 |                 .map(GrantedAuthority::getAuthority)
   81 |                 .collect(Collectors.toList()));
   82 |         
   83 |         return Jwts.builder()
   84 |                 .setClaims(claims)
   85 |                 .setIssuedAt(Date.from(now))
   86 |                 .setExpiration(Date.from(expiry))
   87 |                 .signWith(accessTokenKey, SignatureAlgorithm.HS512)
   88 |                 .compact();
   89 |     }
   90 | 
   91 |     /**
   92 |      * 리프레시 토큰 생성
   93 |      * @param username 사용자 이름
   94 |      * @return 생성된 리프레시 토큰
   95 |      */
   96 |     public String generateRefreshToken(String username) {
   97 |         Instant now = Instant.now();
   98 |         Instant expiry = now.plusSeconds(refreshTokenValidity);
   99 |         
  100 |         Claims claims = Jwts.claims();
  101 |         claims.setSubject(username);
  102 |         claims.setId(UUID.randomUUID().toString());
  103 |         
  104 |         return Jwts.builder()
  105 |                 .setClaims(claims)
  106 |                 .setIssuedAt(Date.from(now))
  107 |                 .setExpiration(Date.from(expiry))
  108 |                 .signWith(refreshTokenKey, SignatureAlgorithm.HS512)
  109 |                 .compact();
  110 |     }
  111 | 
  112 |     /**
  113 |      * 토큰 유효성 검증
  114 |      * @param token 검증할 토큰
  115 |      * @return 유효 여부
  116 |      */
  117 |     public boolean validateToken(String token) {
  118 |         try {
  119 |             Jws<Claims> claims = Jwts.parserBuilder()
  120 |                     .setSigningKey(accessTokenKey)
  121 |                     .build()
  122 |                     .parseClaimsJws(token);
  123 |             
  124 |             return !claims.getBody().getExpiration().before(new Date());
  125 |         } catch (ExpiredJwtException e) {
  126 |             log.error("JWT 만료: {}", e.getMessage());
  127 |             return false;
  128 |         } catch (JwtException e) {
  129 |             log.error("JWT 예외: {}", e.getMessage());
  130 |             return false;
  131 |         } catch (Exception e) {
  132 |             log.error("JWT 처리 중 일반 예외: {}", e.getMessage());
  133 |             return false;
  134 |         }
  135 |     }
  136 | 
  137 |     /**
  138 |      * 리프레시 토큰 유효성 검증
  139 |      * @param refreshToken 검증할 리프레시 토큰
  140 |      * @return 유효 여부
  141 |      */
  142 |     public boolean validateRefreshToken(String refreshToken) {
  143 |         try {
  144 |             Jws<Claims> claims = Jwts.parserBuilder()
  145 |                     .setSigningKey(refreshTokenKey)
  146 |                     .build()
  147 |                     .parseClaimsJws(refreshToken);
  148 |             
  149 |             return !claims.getBody().getExpiration().before(new Date());
  150 |         } catch (JwtException | NullPointerException e) {
  151 |             log.error("리프레시 토큰 검증 실패: {}", e.getMessage());
  152 |             return false;
  153 |         }
  154 |     }
  155 | 
  156 |     /**
  157 |      * 토큰에서 사용자 이름 추출
  158 |      * @param token JWT 토큰
  159 |      * @return 사용자 이름
  160 |      */
  161 |     public String getUsernameFromToken(String token) {
  162 |         Claims claims = Jwts.parserBuilder()
  163 |                 .setSigningKey(accessTokenKey)
  164 |                 .build()
  165 |                 .parseClaimsJws(token)
  166 |                 .getBody();
  167 |         
  168 |         return claims.getSubject();
  169 |     }
  170 | 
  171 |     /**
  172 |      * 토큰에서 권한 목록 추출
  173 |      * @param token JWT 토큰
  174 |      * @return 권한 목록
  175 |      */
  176 |     @SuppressWarnings("unchecked")
  177 |     public Set<String> getRolesFromToken(String token) {
  178 |         Claims claims = Jwts.parserBuilder()
  179 |                 .setSigningKey(accessTokenKey)
  180 |                 .build()
  181 |                 .parseClaimsJws(token)
  182 |                 .getBody();
  183 |         
  184 |         List<String> authorities = claims.get("authorities", List.class);
  185 |         return authorities != null ? new HashSet<>(authorities) : Collections.emptySet();
  186 |     }
  187 | 
  188 |     /**
  189 |      * 토큰에서 클레임 추출
  190 |      * @param token JWT 토큰
  191 |      * @return 클레임
  192 |      */
  193 |     public Claims getClaims(String token) {
  194 |         return Jwts.parserBuilder()
  195 |                 .setSigningKey(accessTokenKey)
  196 |                 .build()
  197 |                 .parseClaimsJws(token)
  198 |                 .getBody();
  199 |     }
  200 | 
  201 |     /**
  202 |      * 인증 객체 생성
  203 |      * @param token JWT 토큰
  204 |      * @return 인증 객체
  205 |      */
  206 |     public Authentication getAuthentication(String token) {
  207 |         Claims claims = getClaims(token);
  208 |         
  209 |         @SuppressWarnings("unchecked")
  210 |         List<String> authorities = claims.get("authorities", List.class);
  211 |         
  212 |         List<SimpleGrantedAuthority> grantedAuthorities = authorities.stream()
  213 |                 .map(SimpleGrantedAuthority::new)
  214 |                 .collect(Collectors.toList());
  215 |         
  216 |         UserDetails principal = new User(claims.getSubject(), "", grantedAuthorities);
  217 |         
  218 |         return new UsernamePasswordAuthenticationToken(principal, token, grantedAuthorities);
  219 |     }
  220 | 
  221 |     /**
  222 |      * 쿠키에서 리프레시 토큰 확인
  223 |      * @param request HTTP 요청
  224 |      * @param response HTTP 응답
  225 |      * @param provider 제공자
  226 |      * @return 리프레시 토큰
  227 |      */
  228 |     public String checkCookie(HttpServletRequest request, HttpServletResponse response, String provider) throws IOException {
  229 |         Cookie[] cookies = request.getCookies();
  230 |         String refreshToken = null;
  231 | 
  232 |         if (cookies == null) {
  233 |             sendErrorResponse(response, ErrorType.AUTHENTICATION_FAILED);
  234 |             return null;
  235 |         }
  236 | 
  237 |         String cookieName = SecurityConstants.DEFAULT_PROVIDER.getValue().equals(provider) 
  238 |                 ? SecurityConstants.COOKIE_REFRESH_TOKEN.getValue()
  239 |                 : provider + "_" + SecurityConstants.COOKIE_REFRESH_TOKEN.getValue();
  240 | 
  241 |         for (Cookie cookie : cookies) {
  242 |             if (cookie.getName().equals(cookieName)) {
  243 |                 refreshToken = cookie.getValue();
  244 |                 break;
  245 |             }
  246 |         }
  247 | 
  248 |         if (refreshToken == null) {
  249 |             sendErrorResponse(response, ErrorType.AUTHENTICATION_FAILED);
  250 |         }
  251 | 
  252 |         return refreshToken;
  253 |     }
  254 | 
  255 |     /**
  256 |      * SNS 쿠키 확인
  257 |      * @param request HTTP 요청
  258 |      * @param response HTTP 응답
  259 |      * @return 리프레시 토큰
  260 |      */
  261 |     public String checkSnsCookie(HttpServletRequest request, HttpServletResponse response) throws IOException {
  262 |         String providerHeader = request.getHeader("provider");
  263 |         Cookie[] cookies = request.getCookies();
  264 |         String refreshToken = null;
  265 |         
  266 |         if (cookies != null) {
  267 |             for (Cookie cookie : cookies) {
  268 |                 if (cookie.getName().equals(providerHeader + "_" + SecurityConstants.COOKIE_REFRESH_TOKEN.getValue())) {
  269 |                     refreshToken = cookie.getValue();
  270 |                     break;
  271 |                 }
  272 |             }
  273 |         }
  274 |         
  275 |         if (refreshToken == null) {
  276 |             sendErrorResponse(response, ErrorType.AUTHENTICATION_FAILED);
  277 |         }
  278 |         
  279 |         return refreshToken;
  280 |     }
  281 | 
  282 |     /**
  283 |      * 오류 응답 전송
  284 |      * @param response HTTP 응답
  285 |      * @param errorType 오류 유형
  286 |      */
  287 |     private void sendErrorResponse(HttpServletResponse response, ErrorType errorType)
  288 |             throws IOException {
  289 |         response.setStatus(errorType.getStatusCode());
  290 |         PrintWriter writer = response.getWriter();
  291 |         response.setContentType("application/json");
  292 |         response.setCharacterEncoding("UTF-8");
  293 |         writer.print("{\"error\":\"" + errorType.getTitle() + "\",\"message\":\"" + errorType.getMessage() + "\"}");
  294 |         writer.flush();
  295 |     }
  296 | 
  297 |     /**
  298 |      * 액세스 토큰 만료 시간 반환
  299 |      * @return 만료 시간 (초)
  300 |      */
  301 |     public long getAccessTokenExpiration() {
  302 |         return accessTokenValidity * 1000; // 밀리초로 변환
  303 |     }
  304 | 
  305 |     /**
  306 |      * 리프레시 토큰 만료 시간 반환
  307 |      * @return 만료 시간 (초)
  308 |      */
  309 |     public long getRefreshTokenExpiration() {
  310 |         return refreshTokenValidity * 1000; // 밀리초로 변환
  311 |     }
  312 | }

#--------------------------------------------------------------------------------


# File: auth-server-refactoring/src/main/java/com/authentication/auth/service/redis/RedisService.java
#=============================================================================

    1 | package com.authentication.auth.service.redis;
    2 | 
    3 | import com.authentication.auth.constants.SecurityConstants;
    4 | import lombok.RequiredArgsConstructor;
    5 | import lombok.extern.slf4j.Slf4j;
    6 | import org.springframework.beans.factory.annotation.Value;
    7 | import org.springframework.data.redis.core.RedisTemplate;
    8 | import org.springframework.stereotype.Component;
    9 | import org.springframework.transaction.annotation.Transactional;
   10 | 
   11 | import java.util.concurrent.TimeUnit;
   12 | 
   13 | /**
   14 |  * Redis 서비스
   15 |  * 토큰 및 인증 관련 데이터를 Redis에 저장하고 관리
   16 |  */
   17 | @Slf4j
   18 | @RequiredArgsConstructor
   19 | @Component
   20 | public class RedisService {
   21 | 
   22 |     private static final String TOKEN_PREFIX = "TOKEN:";
   23 |     private static final String REFRESH_TOKEN_PREFIX = "REFRESH:";
   24 |     private static final String ACCESS_TOKEN_PREFIX = "ACCESS:";
   25 |     private static final String EMAIL_CODE_PREFIX = "EMAIL_CODE:";
   26 |     
   27 |     @Value("${REFRESH_TOKEN_VALIDITY}")
   28 |     private long refreshExpire;
   29 | 
   30 |     @Value("${ACCESS_TOKEN_VALIDITY}")
   31 |     private long accessExpire;
   32 | 
   33 |     private final RedisTemplate<String, String> redisTemplate;
   34 | 
   35 |     /**
   36 |      * 리프레시 토큰을 Redis 키로 변환
   37 |      * @param userId 사용자 ID
   38 |      * @param provider 제공자
   39 |      * @return Redis 키
   40 |      */
   41 |     private String refreshTokenToRedisKey(String userId, String provider) {
   42 |         if (userId == null || provider == null || 
   43 |                 userId.isEmpty() || provider.isEmpty()) {
   44 |             throw new IllegalArgumentException("Redis 키 생성에 필요한 파라미터가 누락되었습니다");
   45 |         }
   46 |         return REFRESH_TOKEN_PREFIX + provider + ":" + userId;
   47 |     }
   48 | 
   49 |     /**
   50 |      * 액세스 토큰을 Redis 키로 변환
   51 |      * @param refreshToken 리프레시 토큰
   52 |      * @return Redis 키
   53 |      */
   54 |     private String accessTokenToRedisKey(String refreshToken) {
   55 |         if (refreshToken == null || refreshToken.isEmpty()){
   56 |             throw new IllegalArgumentException("Redis 키 생성에 필요한 리프레시 토큰이 누락되었습니다");
   57 |         }
   58 |         return ACCESS_TOKEN_PREFIX + refreshToken.substring(0, Math.min(refreshToken.length(), 20));
   59 |     }
   60 | 
   61 |     /**
   62 |      * 이메일 코드를 Redis 키로 변환
   63 |      * @param email 이메일
   64 |      * @return Redis 키
   65 |      */
   66 |     private String emailCodeToRedisKey(String email) {
   67 |         if (email == null || email.isEmpty()) {
   68 |             throw new IllegalArgumentException("Redis 키 생성에 필요한 이메일이 누락되었습니다");
   69 |         }
   70 |         return EMAIL_CODE_PREFIX + email;
   71 |     }
   72 | 
   73 |     /**
   74 |      * 리프레시 토큰 저장
   75 |      * @param userId 사용자 ID
   76 |      * @param provider 제공자
   77 |      * @param refreshToken 리프레시 토큰
   78 |      * @return 저장 성공 여부
   79 |      */
   80 |     @Transactional
   81 |     public boolean saveRToken(String userId, String provider, String refreshToken) {
   82 |         String redisKey = refreshTokenToRedisKey(userId, provider);
   83 |         try {
   84 |             redisTemplate.opsForValue().set(redisKey, refreshToken, refreshExpire, TimeUnit.SECONDS);
   85 |             log.info("Redis에 리프레시 토큰 저장 성공: 제공자={}, 사용자={}", provider, userId);
   86 |             return true;
   87 |         } catch (Exception e) {
   88 |             log.error("Redis에 리프레시 토큰 저장 실패: 제공자={}, 사용자={}", provider, userId, e);
   89 |             return false;
   90 |         }
   91 |     }
   92 | 
   93 |     /**
   94 |      * 액세스 토큰 저장
   95 |      * @param refreshToken 리프레시 토큰
   96 |      * @param accessToken 액세스 토큰
   97 |      * @param userId 사용자 ID
   98 |      * @return 저장 성공 여부
   99 |      */
  100 |     @Transactional
  101 |     public boolean saveAccessToken(String refreshToken, String accessToken, String userId) {
  102 |         String redisKey = accessTokenToRedisKey(refreshToken);
  103 |         try {
  104 |             redisTemplate.opsForValue().set(redisKey, accessToken, accessExpire, TimeUnit.SECONDS);
  105 |             log.info("Redis에 액세스 토큰 저장 성공: 사용자={}", userId);
  106 |             return true;
  107 |         } catch (Exception e) {
  108 |             log.error("Redis에 액세스 토큰 저장 실패: 사용자={}", userId, e);
  109 |             return false;
  110 |         }
  111 |     }
  112 | 
  113 |     /**
  114 |      * 액세스 토큰 조회
  115 |      * @param refreshToken 리프레시 토큰
  116 |      * @return 액세스 토큰
  117 |      */
  118 |     @Transactional(readOnly = true)
  119 |     public String getAccessToken(String refreshToken) {
  120 |         String redisKey = accessTokenToRedisKey(refreshToken);
  121 |         try {
  122 |             String accessToken = redisTemplate.opsForValue().get(redisKey);
  123 | 
  124 |             if (accessToken == null) {
  125 |                 log.warn("Redis에서 액세스 토큰을 찾을 수 없습니다");
  126 |                 return null;
  127 |             }
  128 | 
  129 |             return accessToken;
  130 |         } catch (Exception e) {
  131 |             log.error("Redis에서 액세스 토큰 조회 실패", e);
  132 |             return null;
  133 |         }
  134 |     }
  135 | 
  136 |     /**
  137 |      * 리프레시 토큰 존재 여부 확인
  138 |      * @param userId 사용자 ID
  139 |      * @param provider 제공자
  140 |      * @param refreshToken 리프레시 토큰
  141 |      * @return 존재 여부
  142 |      */
  143 |     @Transactional(readOnly = true)
  144 |     public boolean isRTokenExist(String userId, String provider, String refreshToken) {
  145 |         String redisKey = refreshTokenToRedisKey(userId, provider);
  146 |         try {
  147 |             String storedToken = redisTemplate.opsForValue().get(redisKey);
  148 |             return storedToken != null && storedToken.equals(refreshToken);
  149 |         } catch (Exception e) {
  150 |             log.error("Redis에서 리프레시 토큰 확인 실패: 제공자={}", provider, e);
  151 |             return false;
  152 |         }
  153 |     }
  154 | 
  155 |     /**
  156 |      * 리프레시 토큰 삭제
  157 |      * @param userId 사용자 ID
  158 |      * @param provider 제공자
  159 |      * @return 삭제 성공 여부
  160 |      */
  161 |     @Transactional
  162 |     public boolean deleteRToken(String userId, String provider) {
  163 |         String redisKey = refreshTokenToRedisKey(userId, provider);
  164 |         try {
  165 |             Boolean removed = redisTemplate.delete(redisKey);
  166 |             if (removed != null && removed) {
  167 |                 log.info("Redis에서 리프레시 토큰 삭제 성공: 제공자={}, 사용자={}", provider, userId);
  168 |             }
  169 |             return removed != null && removed;
  170 |         } catch (Exception e) {
  171 |             log.error("Redis에서 리프레시 토큰 삭제 실패: 제공자={}", provider, e);
  172 |             return false;
  173 |         }
  174 |     }
  175 | 
  176 |     /**
  177 |      * 리프레시 토큰 변경
  178 |      * @param userId 사용자 ID
  179 |      * @param provider 제공자
  180 |      * @param oldRefreshToken 기존 리프레시 토큰
  181 |      * @param newRefreshToken 새 리프레시 토큰
  182 |      * @return 변경 성공 여부
  183 |      */
  184 |     @Transactional
  185 |     public boolean changeRToken(String userId, String provider, String oldRefreshToken, String newRefreshToken) {
  186 |         try {
  187 |             // 기존 토큰이 유효한지 확인
  188 |             if (!isRTokenExist(userId, provider, oldRefreshToken)) {
  189 |                 log.warn("기존 리프레시 토큰이 유효하지 않습니다: 제공자={}, 사용자={}", provider, userId);
  190 |                 return false;
  191 |             }
  192 |             
  193 |             // 기존 토큰 삭제 후 새 토큰 저장
  194 |             deleteRToken(userId, provider);
  195 |             saveRToken(userId, provider, newRefreshToken);
  196 |             
  197 |             log.info("리프레시 토큰 변경 성공: 제공자={}, 사용자={}", provider, userId);
  198 |             return true;
  199 |         } catch (Exception e) {
  200 |             log.error("리프레시 토큰 변경 실패: 제공자={}", provider, e);
  201 |             return false;
  202 |         }
  203 |     }
  204 | 
  205 |     /**
  206 |      * 이메일 인증 코드 저장
  207 |      * @param email 이메일
  208 |      * @param code 인증 코드
  209 |      * @return 저장 성공 여부
  210 |      */
  211 |     @Transactional
  212 |     public boolean saveEmailCode(String email, String code) {
  213 |         if (email == null || email.isEmpty() || code == null || code.isEmpty()){
  214 |             log.error("이메일 또는 인증 코드가 누락되었습니다");
  215 |             return false;
  216 |         }
  217 |         try {
  218 |             String redisKey = emailCodeToRedisKey(email);
  219 |             redisTemplate.opsForValue().set(redisKey, code, 1800, TimeUnit.SECONDS); // 30분 유효
  220 |             log.info("이메일 인증 코드 저장 성공: 이메일={}", email);
  221 |             return true;
  222 |         } catch (Exception e) {
  223 |             log.error("이메일 인증 코드 저장 실패: 이메일={}", email, e);
  224 |             return false;
  225 |         }
  226 |     }
  227 | 
  228 |     /**
  229 |      * 이메일 인증 코드 확인
  230 |      * @param email 이메일
  231 |      * @param code 인증 코드
  232 |      * @return 일치 여부
  233 |      */
  234 |     @Transactional(readOnly = true)
  235 |     public boolean checkEmailCode(String email, String code) {
  236 |         if (email == null || email.isEmpty() || code == null || code.isEmpty()){
  237 |             log.error("이메일 또는 인증 코드가 누락되었습니다");
  238 |             return false;
  239 |         }
  240 |         try {
  241 |             String redisKey = emailCodeToRedisKey(email);
  242 |             String storedCode = redisTemplate.opsForValue().get(redisKey);
  243 |             return code.equals(storedCode);
  244 |         } catch (Exception e) {
  245 |             log.error("이메일 인증 코드 확인 실패: 이메일={}", email, e);
  246 |             return false;
  247 |         }
  248 |     }
  249 | 
  250 |     /**
  251 |      * 리프레시 토큰 찾기
  252 |      * @param userId 사용자 ID
  253 |      * @param provider 제공자
  254 |      * @param refreshToken 리프레시 토큰
  255 |      * @return 존재 여부
  256 |      */
  257 |     @Transactional(readOnly = true)
  258 |     public boolean findRToken(String userId, String provider, String refreshToken) {
  259 |         return isRTokenExist(userId, provider, refreshToken);
  260 |     }
  261 | }

#--------------------------------------------------------------------------------


# File: README.md
#=============================================================================

    1 | # Refactoring (2025-04-18) : 시작

#--------------------------------------------------------------------------------


# File: backend/bin/main/com/authentication/auth/filter/README.md
#=============================================================================

    1 | # 인증(Authentication) 및 인가(Authorization) 필터 시스템
    2 | 
    3 | ## 개요
    4 | 이 시스템은 Jakarta EE와 Spring Security를 기반으로 하며, 플러그형 필터 아키텍처를 사용하여 인증 및 인가 로직을 분리하고 확장 가능하게 구현합니다.
    5 | 
    6 | ## 플러그형 필터 아키텍처
    7 | 
    8 | ### 구조적 특징
    9 | - `PluggableFilter` 인터페이스: 모든 필터의 기본 인터페이스로, 필터 순서와 의존성을 정의
   10 | - `filterRegistry`: 필터 등록 및 순서 관리를 위한 클래스
   11 | - 위상 정렬(Topological Sort): 필터 간 의존성을 고려한 실행 순서 결정
   12 | 
   13 | ### 주요 인증/인가 필터
   14 | 
   15 | #### 1. 인증(Authentication) 필터
   16 | - **AuthenticationFilter**: 사용자 로그인 및 자격 증명 검증 담당
   17 | - **JwtVerificationFilter**: JWT 토큰 유효성 검증 담당
   18 | - **SnsRequestFilter**: 소셜 로그인 요청 처리 담당
   19 | 
   20 | #### 2. 인가(Authorization) 필터
   21 | - **AuthorizationFilter**: 사용자 권한 확인 및 접근 제어 담당
   22 | - **RoleBasedAccessFilter**: 역할 기반 리소스 접근 제어 담당
   23 | 
   24 | ## 필터 적용 흐름
   25 | 1. 요청 접수
   26 | 2. 인증(Authentication) 필터를 통한 사용자 신원 확인
   27 |    - JWT 토큰 검증 또는 소셜 로그인 인증
   28 |    - 인증 성공 시 `SecurityContext`에 인증 정보 설정
   29 | 3. 인가(Authorization) 필터를 통한 권한 확인
   30 |    - 사용자 역할 및 권한 확인
   31 |    - 접근 가능한 리소스인지 검증
   32 | 4. 적절한 권한이 있는 경우 요청 처리, 없는 경우 접근 거부
   33 | 
   34 | ## 필터 등록 방법
   35 | 
   36 | 필터를 등록하려면 다음 단계를 따르세요:
   37 | 
   38 | 1. `PluggableFilter` 인터페이스를 구현한 필터 클래스 작성
   39 | 2. 필터의 우선순위(`getOrder()`) 및 의존 관계(`getBeforeFilter()`, `getAfterFilter()`) 정의
   40 | 3. Spring Bean으로 등록하여 자동으로 `filterRegistry`에 등록되도록 함
   41 | 
   42 | ## 확장 및 커스터마이징
   43 | 
   44 | 새로운 인증/인가 방식을 추가하려면:
   45 | 
   46 | 1. `PluggableFilter` 인터페이스를 구현한 새 필터 클래스 생성
   47 | 2. 적절한 실행 순서와 의존성 정의
   48 | 3. Spring Bean으로 등록
   49 | 
   50 | ## 주의사항
   51 | - 필터 간 순환 의존성이 없도록 주의해야 함
   52 | - 성능을 위해 불필요한 필터 중복 적용 방지
   53 | - 보안에 민감한 경로는 항상 적절한 인증/인가 필터를 통과하도록 설정

#--------------------------------------------------------------------------------


# File: backend/src/test/java/com/authentication/auth/validator/EntityValidationOutput.java
#=============================================================================

    1 | package com.authentication.auth.validator;
    2 | 
    3 | import java.util.List;
    4 | 
    5 | public class EntityValidationOutput {
    6 |     
    7 |     /**
    8 |      * 검증 결과를 테이블 형식으로 표시
    9 |      */
   10 |     public static void displayResults(List<EntitySqlValidator.ValidationResult> results) {
   11 |         // 테이블 헤더
   12 |         System.out.println("+------------------------+------------------------+-----------+------------------------------------+");
   13 |         System.out.println("| 필드                    | 현재 값                | 상태      | 메시지                               |");
   14 |         System.out.println("+------------------------+------------------------+-----------+------------------------------------+");
   15 |         
   16 |         // 각 결과 행 출력
   17 |         for (EntitySqlValidator.ValidationResult result : results) {
   18 |             System.out.printf("| %-22s | %-22s | %-9s | %-34s |\n", 
   19 |                     truncate(result.getFieldName(), 22),
   20 |                     truncate(result.getCurrentValue(), 22), 
   21 |                     result.getStatus().getSymbol(),
   22 |                     truncate(result.getMessage(), 34));
   23 |         }
   24 |         
   25 |         // 테이블 푸터
   26 |         System.out.println("+------------------------+------------------------+-----------+------------------------------------+");
   27 |         
   28 |         // 요약 통계
   29 |         long errorCount = results.stream()
   30 |                 .filter(r -> r.getStatus() == EntitySqlValidator.ValidationStatus.ERROR)
   31 |                 .count();
   32 |         long warningCount = results.stream()
   33 |                 .filter(r -> r.getStatus() == EntitySqlValidator.ValidationStatus.WARNING)
   34 |                 .count();
   35 |         
   36 |         System.out.println("\n요약: " + 
   37 |                 errorCount + " 오류, " + 
   38 |                 warningCount + " 경고, " + 
   39 |                 (results.size() - errorCount - warningCount) + " 유효한 검사");
   40 |     }
   41 |     
   42 |     private static String truncate(String value, int maxLength) {
   43 |         if (value == null) {
   44 |             return "";
   45 |         }
   46 |         return value.length() <= maxLength ? value : value.substring(0, maxLength - 3) + "...";
   47 |     }
   48 | }

#--------------------------------------------------------------------------------


# File: backend/src/test/java/com/authentication/auth/validator/EntitySqlValidator.java
#=============================================================================

    1 | package com.authentication.auth.validator;
    2 | 
    3 | import java.lang.reflect.Field;
    4 | import java.util.ArrayList;
    5 | import java.util.HashMap;
    6 | import java.util.List;
    7 | import java.util.Map;
    8 | 
    9 | import net.sf.jsqlparser.parser.CCJSqlParserUtil;
   10 | import net.sf.jsqlparser.statement.create.table.ColumnDefinition;
   11 | import net.sf.jsqlparser.statement.create.table.CreateTable;
   12 | 
   13 | /**
   14 |  * JPA 엔티티와 SQL 생성 구문을 비교 검증하는 검증기
   15 |  */
   16 | public class EntitySqlValidator {
   17 | 
   18 |     public enum ValidationStatus {
   19 |         VALID("✅"),
   20 |         WARNING("⚠️"),
   21 |         ERROR("❌");
   22 | 
   23 |         private final String symbol;
   24 | 
   25 |         ValidationStatus(String symbol) {
   26 |             this.symbol = symbol;
   27 |         }
   28 | 
   29 |         public String getSymbol() {
   30 |             return symbol;
   31 |         }
   32 |     }
   33 | 
   34 |     /**
   35 |      * 필드 검증 결과
   36 |      */
   37 |     public static class ValidationResult {
   38 |         private String fieldName;
   39 |         private String currentValue;
   40 |         private ValidationStatus status;
   41 |         private String message;
   42 | 
   43 |         public ValidationResult(String fieldName, String currentValue, ValidationStatus status, String message) {
   44 |             this.fieldName = fieldName;
   45 |             this.currentValue = currentValue;
   46 |             this.status = status;
   47 |             this.message = message;
   48 |         }
   49 | 
   50 |         // Getters
   51 |         public String getFieldName() { return fieldName; }
   52 |         public String getCurrentValue() { return currentValue; }
   53 |         public ValidationStatus getStatus() { return status; }
   54 |         public String getMessage() { return message; }
   55 |     }
   56 | 
   57 |     /**
   58 |      * JPA 엔티티와 SQL 생성 구문 검증
   59 |      */
   60 |     public static List<ValidationResult> validate(Class<?> entityClass, String sqlStatement) {
   61 |         List<ValidationResult> results = new ArrayList<>();
   62 | 
   63 |         try {
   64 |             // SQL 파싱
   65 |             Statement statement = CCJSqlParserUtil.parse(sqlStatement);
   66 |             if (!(statement instanceof CreateTable)) {
   67 |                 results.add(new ValidationResult("SQL", sqlStatement, ValidationStatus.ERROR,
   68 |                             "유효한 CREATE TABLE 구문이 아닙니다"));
   69 |                 return results;
   70 |             }
   71 | 
   72 |             CreateTable createTable = (CreateTable) statement;
   73 | 
   74 |             // 테이블 이름 검증
   75 |             validateTableName(entityClass, createTable, results);
   76 | 
   77 |             // SQL에서 컬럼 추출
   78 |             Map<String, ColumnDefinition> sqlColumns = extractSqlColumns(createTable);
   79 | 
   80 |             // 엔티티 필드 검증
   81 |             validateEntityFields(entityClass, sqlColumns, results);
   82 | 
   83 |             // SQL에 있는 컬럼 중 엔티티에 없는 컬럼 확인
   84 |             validateSqlColumns(entityClass, sqlColumns, results);
   85 | 
   86 |             // 기본 키 검증
   87 |             validatePrimaryKey(entityClass, createTable, results);
   88 | 
   89 |         } catch (JSQLParserException e) {
   90 |             results.add(new ValidationResult("SQL 파싱 오류", e.getMessage(),
   91 |                        ValidationStatus.ERROR, "SQL 구문 파싱에 실패했습니다"));
   92 |         }
   93 | 
   94 |         return results;
   95 |     }
   96 | 
   97 |     private static Map<String, ColumnDefinition> extractSqlColumns(CreateTable createTable) {
   98 |         Map<String, ColumnDefinition> columns = new HashMap<>();
   99 | 
  100 |         if (createTable.getColumnDefinitions() != null) {
  101 |             for (ColumnDefinition colDef : createTable.getColumnDefinitions()) {
  102 |                 columns.put(colDef.getColumnName().replaceAll("[`\"]", ""), colDef);
  103 |             }
  104 |         }
  105 | 
  106 |         return columns;
  107 |     }
  108 | 
  109 |     private static void validateTableName(Class<?> entityClass, CreateTable createTable,
  110 |                                        List<ValidationResult> results) {
  111 |         javax.persistence.Table tableAnnotation = entityClass.getAnnotation(javax.persistence.Table.class);
  112 |         String entityTableName = tableAnnotation != null && !tableAnnotation.name().isEmpty() ?
  113 |                 tableAnnotation.name() : entityClass.getSimpleName();
  114 | 
  115 |         String sqlTableName = createTable.getTable().getName().replaceAll("[`\"]", "");
  116 | 
  117 |         if (entityTableName.equals(sqlTableName)) {
  118 |             results.add(new ValidationResult("테이블 이름", entityTableName, ValidationStatus.VALID,
  119 |                        "테이블 이름이 일치합니다"));
  120 |         } else {
  121 |             results.add(new ValidationResult("테이블 이름", entityTableName, ValidationStatus.ERROR,
  122 |                        "엔티티 테이블 이름이 SQL 테이블 이름과 일치하지 않습니다: " + sqlTableName));
  123 |         }
  124 |     }
  125 | 
  126 |     // 엔티티 필드 검증
  127 |     private static void validateEntityFields(Class<?> entityClass, Map<String, ColumnDefinition> sqlColumns,
  128 |                                          List<ValidationResult> results) {
  129 |         for (Field field : getAllFields(entityClass)) {
  130 |             // 정적, 임시 및 관계 필드 건너뛰기
  131 |             if (java.lang.reflect.Modifier.isStatic(field.getModifiers()) ||
  132 |                 field.isAnnotationPresent(Transient.class) ||
  133 |                 isRelationshipField(field)) {
  134 |                 continue;
  135 |             }
  136 | 
  137 |             // 엔티티에서 컬럼 이름 가져오기
  138 |             String columnName = getColumnName(field);
  139 | 
  140 |             // SQL에 컬럼이 존재하는지 확인
  141 |             if (!sqlColumns.containsKey(columnName)) {
  142 |                 results.add(new ValidationResult(field.getName(), "컬럼: " + columnName,
  143 |                           ValidationStatus.ERROR, "SQL 정의에서 컬럼을 찾을 수 없습니다"));
  144 |                 continue;
  145 |             }
  146 | 
  147 |             ColumnDefinition sqlColumn = sqlColumns.get(columnName);
  148 | 
  149 |             // 데이터 타입 검증
  150 |             validateColumnType(field, sqlColumn, results);
  151 | 
  152 |             // null 허용 제약 조건 검증
  153 |             validateNullable(field, sqlColumn, results);
  154 | 
  155 |             // 문자열 길이 검증
  156 |             validateLength(field, sqlColumn, results);
  157 | 
  158 |             // 기본값 검증
  159 |             validateDefaultValue(field, sqlColumn, results);
  160 |         }
  161 |     }
  162 | 
  163 |         private static void validateColumnType(Field field, ColumnDefinition sqlColumn,
  164 |                                        List<ValidationResult> results) {
  165 |         String javaType = field.getType().getSimpleName();
  166 |         String sqlType = sqlColumn.getColDataType().getDataType().toUpperCase();
  167 | 
  168 |         if (isTypeCompatible(field.getType(), sqlType)) {
  169 |             results.add(new ValidationResult(field.getName(), "타입: " + javaType,
  170 |                       ValidationStatus.VALID, "SQL 타입과 호환됩니다: " + sqlType));
  171 |         } else {
  172 |             results.add(new ValidationResult(field.getName(), "타입: " + javaType,
  173 |                       ValidationStatus.WARNING, "SQL 타입과 호환되지 않을 수 있습니다: " + sqlType));
  174 |         }
  175 |     }
  176 | 
  177 |     private static void validateNullable(Field field, ColumnDefinition sqlColumn,
  178 |                                      List<ValidationResult> results) {
  179 |         Column columnAnnotation = field.getAnnotation(Column.class);
  180 |         boolean entityNullable = columnAnnotation == null || columnAnnotation.nullable();
  181 | 
  182 |         // @Id가 있는 필드는 null이 될 수 없음
  183 |         if (field.isAnnotationPresent(Id.class)) {
  184 |             entityNullable = false;
  185 |         }
  186 | 
  187 |         boolean sqlNullable = !hasNotNullConstraint(sqlColumn);
  188 | 
  189 |         if (entityNullable == sqlNullable) {
  190 |             results.add(new ValidationResult(field.getName(), "Null 허용: " + entityNullable,
  191 |                       ValidationStatus.VALID, "Null 허용 여부가 SQL 정의와 일치합니다"));
  192 |         } else {
  193 |             results.add(new ValidationResult(field.getName(), "Null 허용: " + entityNullable,
  194 |                       ValidationStatus.ERROR, "Null 허용 여부가 SQL 정의와 일치하지 않습니다 (SQL: " + sqlNullable + ")"));
  195 |         }
  196 |     }
  197 | 
  198 |     private static void validateLength(Field field, ColumnDefinition sqlColumn,
  199 |                                    List<ValidationResult> results) {
  200 |         if (String.class.isAssignableFrom(field.getType())) {
  201 |             Column columnAnnotation = field.getAnnotation(Column.class);
  202 |             if (columnAnnotation != null && columnAnnotation.length() > 0) {
  203 |                 int entityLength = columnAnnotation.length();
  204 |                 Integer sqlLength = getColumnLength(sqlColumn);
  205 | 
  206 |                 if (sqlLength == null) {
  207 |                     results.add(new ValidationResult(field.getName(), "길이: " + entityLength,
  208 |                               ValidationStatus.WARNING, "엔티티는 길이를 지정하지만 SQL 컬럼은 길이를 지정하지 않습니다"));
  209 |                 } else if (entityLength == sqlLength) {
  210 |                     results.add(new ValidationResult(field.getName(), "길이: " + entityLength,
  211 |                               ValidationStatus.VALID, "길이가 SQL 정의와 일치합니다"));
  212 |                 } else {
  213 |                     results.add(new ValidationResult(field.getName(), "길이: " + entityLength,
  214 |                               ValidationStatus.ERROR, "길이가 SQL 정의와 일치하지 않습니다 (SQL: " + sqlLength + ")"));
  215 |                 }
  216 |             }
  217 |         }
  218 |     }
  219 | 
  220 | 
  221 |     private static boolean isTypeCompatible(Class<?> javaType, String sqlType) {
  222 |         sqlType = sqlType.toUpperCase();
  223 | 
  224 |         if (String.class.isAssignableFrom(javaType)) {
  225 |             return sqlType.contains("VARCHAR") || sqlType.contains("TEXT") || sqlType.contains("CHAR");
  226 |         } else if (Integer.class.isAssignableFrom(javaType) || int.class.isAssignableFrom(javaType)) {
  227 |             return sqlType.contains("INT");
  228 |         } else if (Long.class.isAssignableFrom(javaType) || long.class.isAssignableFrom(javaType)) {
  229 |             return sqlType.contains("BIGINT") || sqlType.contains("INT");
  230 |         } else if (Boolean.class.isAssignableFrom(javaType) || boolean.class.isAssignableFrom(javaType)) {
  231 |             return sqlType.contains("BOOLEAN") || sqlType.contains("BIT") || sqlType.contains("TINYINT");
  232 |         } else if (Double.class.isAssignableFrom(javaType) || double.class.isAssignableFrom(javaType)) {
  233 |             return sqlType.contains("DOUBLE") || sqlType.contains("DECIMAL");
  234 |         } else if (Float.class.isAssignableFrom(javaType) || float.class.isAssignableFrom(javaType)) {
  235 |             return sqlType.contains("FLOAT") || sqlType.contains("DECIMAL");
  236 |         } else if (java.util.Date.class.isAssignableFrom(javaType)) {
  237 |             return sqlType.contains("DATE") || sqlType.contains("TIMESTAMP");
  238 |         }
  239 | 
  240 |         return false;
  241 |     }
  242 | 
  243 |     private static boolean hasNotNullConstraint(ColumnDefinition columnDef) {
  244 |         if (columnDef.getColumnSpecStrings() != null) {
  245 |             String specs = String.join(" ", columnDef.getColumnSpecStrings()).toUpperCase();
  246 |             return specs.contains("NOT NULL");
  247 |         }
  248 |         return false;
  249 |     }
  250 | 
  251 |     private static Integer getColumnLength(ColumnDefinition columnDef) {
  252 |         if (columnDef.getColDataType().getArgumentsStringList() != null &&
  253 |             !columnDef.getColDataType().getArgumentsStringList().isEmpty()) {
  254 |             try {
  255 |                 return Integer.parseInt(columnDef.getColDataType().getArgumentsStringList().get(0));
  256 |             } catch (NumberFormatException e) {
  257 |                 return null;
  258 |             }
  259 |         }
  260 |         return null;
  261 |     }
  262 | }

#--------------------------------------------------------------------------------


# File: backend/src/test/java/com/authentication/auth/domain/EntitySqlValidationTest.java
#=============================================================================

    1 | package com.authentication.auth.domain;
    2 | 
    3 | import static org.junit.jupiter.api.Assertions.*;
    4 | 
    5 | import java.util.List;
    6 | 
    7 | import org.junit.jupiter.api.DisplayName;
    8 | import org.junit.jupiter.api.Test;
    9 | import org.springframework.boot.test.context.SpringBootTest;
   10 | 
   11 | import com.authentication.auth.utility.SqlSchemaLoader;
   12 | import com.authentication.auth.validator.EntitySqlValidator;
   13 | import com.authentication.auth.validator.EntityValidationOutput;
   14 | 
   15 | @SpringBootTest
   16 | public class EntitySqlValidationTest {
   17 | 
   18 |     @Test
   19 |     @DisplayName("AuthProvider 엔티티와 SQL 정의가 일치하는지 검증")
   20 |     public void testAuthProviderEntityAgainstSql() {
   21 |         // SQL 생성 구문
   22 |         String sqlStatement = SqlSchemaLoader.loadSqlFromApi("AuthProvider");
   23 |         
   24 |         // 엔티티와 SQL 검증
   25 |         List<EntitySqlValidator.ValidationResult> results = 
   26 |                 EntitySqlValidator.validate(AuthProvider.class, sqlStatement);
   27 |         
   28 |         // 결과 표시
   29 |         EntityValidationDisplayService.displayResults(results);
   30 |         
   31 |         // 오류가 없는지 확인
   32 |         long errorCount = results.stream()
   33 |                 .filter(r -> r.getStatus() == EntitySqlValidator.ValidationStatus.ERROR)
   34 |                 .count();
   35 |         
   36 |         assertEquals(0, errorCount, "엔티티는 SQL에 대해 검증 오류가 없어야 합니다");
   37 |         
   38 |         // 특정 검사 확인
   39 |         assertTrue(results.stream()
   40 |                 .anyMatch(r -> r.getFieldName().equals("테이블 이름") && 
   41 |                          r.getStatus() == EntitySqlValidator.ValidationStatus.VALID),
   42 |                 "테이블 이름이 성공적으로 검증되어야 합니다");
   43 |         
   44 |         assertTrue(results.stream()
   45 |                 .anyMatch(r -> r.getFieldName().equals("providerName") && 
   46 |                          r.getStatus() == EntitySqlValidator.ValidationStatus.VALID),
   47 |                 "providerName 필드가 성공적으로 검증되어야 합니다");
   48 |     }
   49 | }

#--------------------------------------------------------------------------------


# File: backend/src/test/java/com/authentication/auth/AuthApplicationTests.java
#=============================================================================

    1 | package com.authentication.auth;
    2 | 
    3 | import org.junit.jupiter.api.Test;
    4 | import org.springframework.boot.test.context.SpringBootTest;
    5 | 
    6 | @SpringBootTest
    7 | class AuthApplicationTests {
    8 | 
    9 | 	@Test
   10 | 	void contextLoads() {
   11 | 	}
   12 | 
   13 | }

#--------------------------------------------------------------------------------


# File: backend/src/test/java/com/authentication/auth/utility/SqlSchemaLoader.java
#=============================================================================

    1 | package com.authentication.auth.utility;
    2 | 
    3 | import org.springframework.core.io.ClassPathResource;
    4 | import org.springframework.util.FileCopyUtils;
    5 | 
    6 | import java.io.IOException;
    7 | import java.io.InputStreamReader;
    8 | import java.io.Reader;
    9 | import java.nio.charset.StandardCharsets;
   10 | 
   11 | public class SqlSchemaLoader {
   12 | 
   13 |     /**
   14 |      * ClassPathReource 에서 SQL 파일을 읽어옴
   15 |      */
   16 |     public static String loadSqlFromClasspath(String path) throws IOException {
   17 |         ClassPathResource resource = new ClassPathResource(path);
   18 |         try (Reader reader = new InputStreamReader(resource.getInputStream(), StandardCharsets.UTF_8)) {
   19 |             return FileCopyUtils.copyToString(reader);
   20 |         }
   21 |     }
   22 |     
   23 |     /**
   24 |      * API에서 SQL 스키마를 가져옴 (Mock 구현)
   25 |      */
   26 |     public static String loadSqlFromApi(String entityName) {
   27 |         // 실제 구현에서는 API 호출 코드로 대체
   28 |         if ("AuthProvider".equals(entityName)) {
   29 |             return "CREATE TABLE Auth_Provider (\n" +
   30 |                    "    id INT AUTO_INCREMENT,\n" +
   31 |                    "    provider_name VARCHAR(50) NOT NULL DEFAULT 'SERVER',\n" +
   32 |                    "    description VARCHAR(255),\n" +
   33 |                    "    is_active BOOLEAN DEFAULT TRUE,\n" +
   34 |                    "    PRIMARY KEY (id)\n" +
   35 |                    ");";
   36 |         }
   37 |         return "";
   38 |     }
   39 | }

#--------------------------------------------------------------------------------


# File: backend/src/test/java/com/authentication/auth/token/JwtUtilityTest.java
#=============================================================================

    1 | package com.authentication.auth.token;
    2 | 
    3 | import org.junit.jupiter.api.Test;
    4 | import org.springframework.security.core.authority.SimpleGrantedAuthority;
    5 | 
    6 | import com.authentication.auth.DTO.token.tokenDto;
    7 | import com.authentication.auth.configuration.token.jwtUtility;
    8 | 
    9 | import java.util.Collections;
   10 | 
   11 | public class JwtUtilityTest {
   12 | 
   13 |     @Test
   14 |     void testShortLivedAccessToken() throws InterruptedException {
   15 |         // 만료 시간 10초로 설정
   16 |         jwtUtility jwtUtility = new jwtUtility(
   17 |                 "eyJraWQiOiJlZjdlY2JkMy0xODcyLTRkMGUtYjYyZC03NzJkZjU2ZDcyMjEiLCJhbGciOiJSUzUxMiJ9.ew0KICAic3ViIjogIjExMzI0M2ZkaDRzZGZoMCIsDQogICJuYW1lIjogImFzZGFzZGcxMjROYXQ0MzUzNGgiLA0KICAiaWF0IjogMTUxNjEyNDVmZ2g5MDIyZXINCn0.cvsTbjRw-DWUQcrgacNmpBFzSYO8rjEvY6oMlTFcicizb1VFVVgGPf1wOJHwkc09rxzmExD7wC2q9WG_VVQ05lqzTUUJ_OVUxiJ2KNHPL3ysvpCQH5i70zCoqkCNqTu_-WHF09HXV_VEZNsGBSHQokOGqdZr8cdpSVeo2Y2u2Bx_LKf7j6XbW0xL_QJeV1c1GZt6El1lbC01tptfLYc43KGhW7fpktxbyuPito3QCx7oYgi4IESABpDWGNAVTidt1v-TE-cEhoo8D5sv6zlAR49M-8ITj8BoRJdTqb-v85d2K-jJaG10bjRQxN16LphaD5vFNb7LvcyJdre15HTYJw",  // 32바이트 이상의 문자열
   18 |                 "eyJlZjdlY2JkMy0xODcyLTRkMGUtYjYQ1MTYtODU0My0zYjM3ZWNhYzViM2EiLCJhbGciOiJSUzUxMiJ9.ew0KICAic3ViIjogIjExMzI0M2ZkZ2pnZmpkZmgwIiwNCiAgIm5hbWUiOiAiYTEyM3NkNDU3OTg5amhtZGdmaGpqNE5hdDQzNTM0aCIsDQogICJpYXQiOiAxNTE2MTI0NWZnamRnaHlqa2R5Z2ZnaGc5MGRmZ2gyMmVyDQp9.f0XpFz2rJ97kW4-jEodL5jQ79Tre5tY3sScViI6b9m3grk5nZm8EQd1wmu6u55ckageOvVLqg1SaWpqKTgIL6Dknv6Bh4K-kOEuHl5S6WzxNSyIk4B-dYu4n644ZVuhF54UeFoRfRjQ1kB2RfqXi_ekwtc4Q2ff-KU15EtEV_AN4R_gerSzC7VAwqj9BN4G1rbHTvSLsozcsGi4r1aSihXpaq4nrkad48TpLVSbkGWovdaVuR4aY9RARHDPvm5x1WG8bjaDMu7PB5at2LAayvd3yXRF9Xjr5MypX9AUg6Ne0VodeppFwah-PRjob8-5hb3l1yqTU8Ht6ml-dVO7UVw",      // 32바이트 이상의 문자열
   19 |                 10L,  // ACCESS_TOKEN_VALIDITY (10초)
   20 |                 3600L // REFRESH_TOKEN_VALIDITY (1시간)
   21 |         );
   22 | 
   23 |         // 유저 정보 설정
   24 |         String userId = "admin";
   25 |         String nickname = "관리자";
   26 |         SimpleGrantedAuthority role = new SimpleGrantedAuthority("ROLE_USER");
   27 | 
   28 |         // 토큰 생성
   29 |         tokenDto token = jwtUtility.buildToken(userId, nickname, Collections.singletonList(role));
   30 | 
   31 |         System.out.println("Generated Access Token: " + token.getAccessToken());
   32 |         System.out.println("Generated Refresh Token: " + token.getRefreshToken());
   33 | 
   34 |         // 생성된 토큰을 바로 검증 (유효해야 함)
   35 |         boolean isValid = jwtUtility.validateJWT(token.getAccessToken());
   36 |         System.out.println("Access Token is valid: " + isValid);
   37 | 
   38 |         // 10초 대기 후 토큰 만료 여부 검증
   39 |         System.out.println("Waiting for 10 seconds...");
   40 |         Thread.sleep(10000);
   41 | 
   42 |         // 만료된 토큰을 검증 (유효하지 않아야 함)
   43 |         isValid = jwtUtility.validateJWT(token.getAccessToken());
   44 |         System.out.println("Access Token is valid after 10 seconds: " + isValid);
   45 |     }
   46 | }

#--------------------------------------------------------------------------------


# File: backend/src/main/java/com/authentication/auth/others/constants/SecurityConstants.java
#=============================================================================

    1 | package com.authentication.auth.others.constants;
    2 | 
    3 | import java.util.HashMap;
    4 | import java.util.Map;
    5 | import java.util.Optional;
    6 | 
    7 | /**
    8 |  * 보안 관련 상수를 정의하는 Enum 클래스
    9 |  * JWT 토큰, 인증, 인가 관련 상수 정의
   10 |  */
   11 | public enum SecurityConstants {
   12 | 
   13 |     TOKEN_TYPE("TOKEN_TYPE", "JWT"),
   14 |     TOKEN_HEADER("TOKEN_HEADER", "Authorization"),
   15 |     TOKEN_PREFIX("TOKEN_PREFIX", "Bearer "),
   16 |     TOKEN_TYPE_REFRESH("TOKEN_TYPE_REFRESH", "refreshJWT"),
   17 |     
   18 |     ACCESS_TOKEN_EXPIRATION("ACCESS_TOKEN_EXPIRATION", "1800"), // 30분(초 단위)
   19 |     REFRESH_TOKEN_EXPIRATION("REFRESH_TOKEN_EXPIRATION", "2592000"), // 30일(초 단위)
   20 |     COOKIE_NAME("COOKIE_NAME", "refresh_token"),
   21 |     COOKIE_SECURE("COOKIE_SECURE", "true"),
   22 |     COOKIE_HTTP_ONLY("COOKIE_HTTP_ONLY", "true"),
   23 |     COOKIE_PATH("COOKIE_PATH", "/"),
   24 |     COOKIE_DOMAIN("COOKIE_DOMAIN", ""),
   25 |     REMEMBER_ME_KEY("REMEMBER_ME_KEY", "rememberMeKey"),
   26 |     REMEMBER_ME_VALIDITY("REMEMBER_ME_VALIDITY", "1209600"), // 14일(초 단위)
   27 |     CORS_ALLOWED_ORIGINS("CORS_ALLOWED_ORIGINS", "*"),
   28 |     CORS_ALLOWED_METHODS("CORS_ALLOWED_METHODS", "GET,POST,PUT,DELETE,OPTIONS"),
   29 |     CSRF_HEADER_NAME("CSRF_HEADER_NAME", "X-CSRF-TOKEN"),
   30 |     CSRF_PARAMETER_NAME("CSRF_PARAMETER_NAME", "_csrf"),
   31 |     LOGIN_URL("LOGIN_URL", "/api/auth/login"),
   32 |     LOGOUT_URL("LOGOUT_URL", "/api/auth/logout"),
   33 |     SIGNUP_URL("SIGNUP_URL", "/api/auth/signup"),
   34 |     AUTH_WHITE_LIST("AUTH_WHITE_LIST", "/api/auth/**,/public/**,/api/v1/health,/swagger-ui/**,/v3/api-docs/**");
   35 |     
   36 |     private final String key;
   37 |     private final String value;
   38 |     
   39 |     // 값 탐색을 위한 매핑
   40 |     private static final Map<String, SecurityConstants> BY_KEY = new HashMap<>();
   41 |     private static final Map<String, SecurityConstants> BY_VALUE = new HashMap<>();
   42 |     
   43 |     // 정적 초기화 블록으로 매핑 초기화
   44 |     static {
   45 |         for (SecurityConstants constant : values()) {
   46 |             BY_KEY.put(constant.getKey(), constant);
   47 |             BY_VALUE.put(constant.getValue(), constant);
   48 |         }
   49 |     }
   50 |     
   51 |     /**
   52 |      * SecurityConstants 생성자
   53 |      * @param key 상수 키
   54 |      * @param value 상수 값
   55 |      */
   56 |     SecurityConstants(String key, String value) {
   57 |         if (key == null || key.isEmpty() || value == null || value.isEmpty()) {
   58 |             throw new IllegalArgumentException("키와 값은 null이거나 빈 문자열일 수 없습니다.");
   59 |         }
   60 |         this.key = key;
   61 |         this.value = value;
   62 |     }
   63 |     
   64 |     /**
   65 |      * 상수 키를 반환합니다.
   66 |      * @return 상수 키
   67 |      */
   68 |     public String getKey() {
   69 |         return key;
   70 |     }
   71 |     
   72 |     /**
   73 |      * 상수 값을 반환합니다.
   74 |      * @return 상수 값
   75 |      */
   76 |     public String getValue() {
   77 |         return value;
   78 |     }
   79 |     
   80 |     /**
   81 |      * 상수 값을 정수로 반환합니다.
   82 |      * @return 정수로 변환된 상수 값
   83 |      * @throws NumberFormatException 상수 값이 정수로 변환될 수 없는 경우
   84 |      */
   85 |     public int getIntValue() {
   86 |         return Integer.parseInt(value);
   87 |     }
   88 |     
   89 |     /**
   90 |      * 상수 값을 long으로 반환합니다.
   91 |      * @return long으로 변환된 상수 값
   92 |      * @throws NumberFormatException 상수 값이 long으로 변환될 수 없는 경우
   93 |      */
   94 |     public long getLongValue() {
   95 |         return Long.parseLong(value);
   96 |     }
   97 |     
   98 |     /**
   99 |      * 상수 값을 boolean으로 반환합니다.
  100 |      * @return boolean으로 변환된 상수 값
  101 |      */
  102 |     public boolean getBooleanValue() {
  103 |         return Boolean.parseBoolean(value);
  104 |     }
  105 |     
  106 |     /**
  107 |      * 키로 SecurityConstants를 찾습니다.
  108 |      * @param key 찾으려는 상수의 키
  109 |      * @return 해당 키에 매핑된 SecurityConstants 또는 null
  110 |      */
  111 |     public static SecurityConstants fromKey(String key) {
  112 |         return BY_KEY.get(key);
  113 |     }
  114 |     
  115 |     /**
  116 |      * 값으로 SecurityConstants를 찾습니다.
  117 |      * @param value 찾으려는 상수의 값
  118 |      * @return 해당 값을 가진 SecurityConstants 또는 null
  119 |      */
  120 |     public static SecurityConstants fromValue(String value) {
  121 |         return BY_VALUE.get(value);
  122 |     }
  123 |     
  124 |     /**
  125 |      * 키로 SecurityConstants를 안전하게 찾습니다.
  126 |      * @param key 찾으려는 상수의 키
  127 |      * @return 해당 키에 매핑된 SecurityConstants를 담고 있는 Optional
  128 |      */
  129 |     public static Optional<SecurityConstants> getByKey(String key) {
  130 |         return Optional.ofNullable(fromKey(key));
  131 |     }
  132 |     
  133 |     /**
  134 |      * 값으로 SecurityConstants를 안전하게 찾습니다.
  135 |      * @param value 찾으려는 상수의 값
  136 |      * @return 해당 값을 가진 SecurityConstants를 담고 있는 Optional
  137 |      */
  138 |     public static Optional<SecurityConstants> getByValue(String value) {
  139 |         return Optional.ofNullable(fromValue(value));
  140 |     }
  141 |     
  142 |     /**
  143 |      * Enum 상수를 문자열로 반환합니다.
  144 |      * @return 키와 값을 포함한 문자열 표현
  145 |      */
  146 |     @Override
  147 |     public String toString() {
  148 |         return String.format("%s[key=%s, value=%s]", name(), key, value);
  149 |     }
  150 |     
  151 |     /**
  152 |      * 모든 SecurityConstants를 문자열로 출력합니다.
  153 |      * 디버깅 용도로 유용합니다.
  154 |      * @return 모든 보안 상수에 대한 문자열 표현
  155 |      */
  156 |     public static String printAll() {
  157 |         StringBuilder sb = new StringBuilder("SecurityConstants:\n");
  158 |         for (SecurityConstants constant : values()) {
  159 |             sb.append(constant.toString()).append("\n");
  160 |         }
  161 |         return sb.toString();
  162 |     }
  163 | }
  164 |     }
  165 | }

#--------------------------------------------------------------------------------


# File: backend/src/main/java/com/authentication/auth/config/SecurityFilterConfig.java
#=============================================================================

    1 | package com.authentication.auth.config;
    2 | 
    3 | import com.authentication.auth.filter.AuthenticationFilter;
    4 | import com.authentication.auth.filter.AuthorizationFilter;
    5 | import com.authentication.auth.filter.SnsRequestFilter;
    6 | import lombok.RequiredArgsConstructor;
    7 | import org.springframework.boot.web.servlet.FilterRegistrationBean;
    8 | import org.springframework.context.annotation.Bean;
    9 | import org.springframework.context.annotation.Configuration;
   10 | 
   11 | /**
   12 |  * 보안 필터 설정 클래스
   13 |  * 필터의 등록 및 순서 설정을 담당
   14 |  */
   15 | @Configuration
   16 | @RequiredArgsConstructor
   17 | public class SecurityFilterConfig {
   18 | 
   19 |     private final AuthenticationFilter authenticationFilter;
   20 |     private final AuthorizationFilter authorizationFilter;
   21 |     private final SnsRequestFilter snsRequestFilter;
   22 | 
   23 |     /**
   24 |      * 인증 필터 등록
   25 |      */
   26 |     @Bean
   27 |     public FilterRegistrationBean<AuthenticationFilter> authenticationFilterRegistration() {
   28 |         FilterRegistrationBean<AuthenticationFilter> registrationBean = new FilterRegistrationBean<>();
   29 |         registrationBean.setFilter(authenticationFilter);
   30 |         registrationBean.addUrlPatterns("/*");
   31 |         registrationBean.setOrder(authenticationFilter.getOrder());
   32 |         registrationBean.setName("authenticationFilter");
   33 |         return registrationBean;
   34 |     }
   35 | 
   36 |     /**
   37 |      * 권한 필터 등록
   38 |      */
   39 |     @Bean
   40 |     public FilterRegistrationBean<AuthorizationFilter> authorizationFilterRegistration() {
   41 |         FilterRegistrationBean<AuthorizationFilter> registrationBean = new FilterRegistrationBean<>();
   42 |         registrationBean.setFilter(authorizationFilter);
   43 |         registrationBean.addUrlPatterns("/*");
   44 |         registrationBean.setOrder(authorizationFilter.getOrder());
   45 |         registrationBean.setName("authorizationFilter");
   46 |         return registrationBean;
   47 |     }
   48 | 
   49 |     /**
   50 |      * SNS 요청 필터 등록
   51 |      */
   52 |     @Bean
   53 |     public FilterRegistrationBean<SnsRequestFilter> snsRequestFilterRegistration() {
   54 |         FilterRegistrationBean<SnsRequestFilter> registrationBean = new FilterRegistrationBean<>();
   55 |         registrationBean.setFilter(snsRequestFilter);
   56 |         registrationBean.addUrlPatterns("/*");
   57 |         registrationBean.setOrder(snsRequestFilter.getOrder());
   58 |         registrationBean.setName("snsRequestFilter");
   59 |         return registrationBean;
   60 |     }
   61 | }

#--------------------------------------------------------------------------------


# File: backend/src/main/java/com/authentication/auth/DTO/users/loginRequest.java
#=============================================================================

    1 | package com.authentication.auth.DTO.users;
    2 | 
    3 | import lombok.Data;
    4 | 
    5 | public record LoginRequest(String userId, String password) {}

#--------------------------------------------------------------------------------


# File: backend/src/main/java/com/authentication/auth/DTO/users/userStat.java
#=============================================================================

    1 | package com.career_block.auth.DTO.users;
    2 | 
    3 | import jakarta.validation.constraints.NotBlank;
    4 | import lombok.Builder;
    5 | import lombok.Data;
    6 | 
    7 | import java.time.LocalDateTime;
    8 | import java.util.Date;
    9 | import java.util.List;
   10 | 
   11 | import com.authentication.auth.domain.Role;
   12 | 
   13 | @Data
   14 | @Builder
   15 | public class userStat {
   16 |     @NotBlank
   17 |     private String userId;
   18 |     @NotBlank
   19 |     private String nickname;
   20 |     private Role role;
   21 |     private Date birthDate;
   22 |     //private String gender;
   23 |     private boolean isPrivate;
   24 |     private String profile;
   25 |     private List<String> hashtags;
   26 |     private List<String> certifications;
   27 |     private List<String> groups;
   28 |     private LocalDateTime userActivites;
   29 | }

#--------------------------------------------------------------------------------


# File: backend/src/main/java/com/authentication/auth/DTO/users/JoinRequest.java
#=============================================================================

    1 | package com.authentication.auth.DTO.users;
    2 | 
    3 | import com.authentication.auth.domain.User;
    4 | import com.fasterxml.jackson.annotation.JsonProperty;
    5 | import jakarta.validation.constraints.NotBlank;
    6 | 
    7 | import java.util.Date;
    8 | 
    9 | /**
   10 |  * @author: nodove
   11 |  * 기존 class -> record 으로 변경 
   12 |  * record 매개변수에 직접 @NotBlank 추가
   13 |  * 
   14 |  * */
   15 | public record JoinRequest(
   16 |     @NotBlank String userId,
   17 |     @NotBlank String userPw,
   18 |     @NotBlank String userName,
   19 |     @NotBlank String nickname,
   20 |     @NotBlank String phone,
   21 |     String email,
   22 |     User.UserRole role,
   23 |     Date birthDate,
   24 |     @NotBlank String gender,
   25 |     @JsonProperty("isPrivate") boolean isPrivate,
   26 |     String profile,
   27 |     String code
   28 | ) {
   29 |     // default 프로필 이미지를 위한 정적 팩토리 메서드 -> 불필요한 객체 생성 방지(생성자 활용, immutable) 목적
   30 |     public static JoinRequest of(String userId, String userPw, String userName, String nickname, 
   31 |                               String phone, String email, User.UserRole role, Date birthDate, 
   32 |                               String gender, boolean isPrivate, String code) {
   33 |         return new JoinRequest(userId, userPw, userName, nickname, phone, email, role, 
   34 |                             birthDate, gender, isPrivate, "https://zrr.kr/iPHf", code);
   35 |     }
   36 | 
   37 |     // 사용자 엔티티로 변환하는 메서드
   38 |     public User toEntity() {
   39 |         return User.builder()
   40 |                 .userId(this.userId)
   41 |                 .userPw(this.userPw)
   42 |                 .userName(this.userName)
   43 |                 .nickname(this.nickname)
   44 |                 .phone(this.phone)
   45 |                 .email(this.email)
   46 |                 .role(this.role)
   47 |                 .birthDate(this.birthDate)
   48 |                 .gender(this.gender)
   49 |                 .isPrivate(this.isPrivate)
   50 |                 .profile(this.profile)
   51 |                 .build();
   52 |     }
   53 | }

#--------------------------------------------------------------------------------


# File: backend/src/main/java/com/authentication/auth/DTO/smtp/emailCheckDto.java
#=============================================================================

    1 | package com.career_block.auth.DTO.smtp;
    2 | 
    3 | import jakarta.validation.constraints.Email;
    4 | import jakarta.validation.constraints.NotBlank;
    5 | import lombok.Getter;
    6 | 
    7 | @Getter
    8 | public class emailCheckDto {
    9 |     @Email
   10 |     @NotBlank
   11 |     private String email;
   12 |     @NotBlank
   13 |     private String code;
   14 | }

#--------------------------------------------------------------------------------


# File: backend/src/main/java/com/authentication/auth/DTO/smtp/emailFindById.java
#=============================================================================

    1 | package com.career_block.auth.DTO.smtp;
    2 | 
    3 | import jakarta.validation.constraints.NotBlank;
    4 | import lombok.Data;
    5 | 
    6 | @Data
    7 | public class emailFindById {
    8 |     @NotBlank
    9 |     private String userId;
   10 | }

#--------------------------------------------------------------------------------


# File: backend/src/main/java/com/authentication/auth/DTO/smtp/customEmailRequest.java
#=============================================================================

    1 | package com.career_block.auth.DTO.smtp;
    2 | 
    3 | import lombok.Data;
    4 | 
    5 | @Data
    6 | public class customEmailRequest {
    7 |     private String email;
    8 |     private String content;
    9 |     private String title;
   10 | }

#--------------------------------------------------------------------------------


# File: backend/src/main/java/com/authentication/auth/DTO/smtp/emailRequest.java
#=============================================================================

    1 | package com.career_block.auth.DTO.smtp;
    2 | 
    3 | import jakarta.validation.constraints.Email;
    4 | import jakarta.validation.constraints.NotBlank;
    5 | import lombok.Data;
    6 | 
    7 | @Data
    8 | public class emailRequest {
    9 |     @Email
   10 |     @NotBlank
   11 |     private String email;
   12 | }

#--------------------------------------------------------------------------------


# File: backend/src/main/java/com/authentication/auth/DTO/smtp/customEmailToAllRequest.java
#=============================================================================

    1 | package com.career_block.auth.DTO.smtp;
    2 | 
    3 | import lombok.Data;
    4 | 
    5 | @Data
    6 | public class customEmailToAllRequest {
    7 |     private String title;
    8 |     private String content;
    9 | }

#--------------------------------------------------------------------------------


# File: backend/src/main/java/com/authentication/auth/DTO/token/TokenDto.java
#=============================================================================

    1 | package com.authentication.auth.DTO.token;
    2 | 
    3 | 
    4 | /**
    5 |  * @Author : choisimo
    6 |  * @Date : 2025.05.08
    7 |  * @Description : Token Data Transfer Object
    8 |  * @Detail : accessToken, refreshToken
    9 |  * @Refactor : change class type to record type
   10 |  * */
   11 | 
   12 | public record TokenDto(String accessToken, String refreshToken) {}
   13 | 
   14 | // same as
   15 | /**
   16 |  * class TokenDto {
   17 |  *     String accessToken;
   18 |  *     String refreshToken;
   19 |  *
   20 |  *     public TokenDto(String accessToken, String refreshToken) {
   21 |  *         this.accessToken = accessToken;
   22 |  *         this.refreshToken = refreshToken;
   23 |  *     }
   24 |  *
   25 |  *     public String getAccessToken() {
   26 |  *         return accessToken;
   27 |  *     }
   28 |  *
   29 |  *     public void setAccessToken(String accessToken) {
   30 |  *         this.accessToken = accessToken;
   31 |  *     }
   32 |  *
   33 |  *     public String getRefreshToken() {
   34 |  *         return refreshToken;
   35 |  *     }
   36 |  *
   37 |  *     public void setRefreshToken(String refreshToken) {
   38 |  *         this.refreshToken = refreshToken;
   39 |  *     }
   40 |  *
   41 |  *     public String toString() {
   42 |  *         return "TokenDto [accessToken=" + accessToken + ", refreshToken=" + refreshToken + "]";
   43 |  *     }
   44 |  *
   45 |  *     public int hashCode() {
   46 |  *
   47 |  *     }
   48 |  * }
   49 |  *
   50 |  * */

#--------------------------------------------------------------------------------


# File: backend/src/main/java/com/authentication/auth/DTO/token/principalDetails.java
#=============================================================================

    1 | package com.career_block.auth.DTO.token;
    2 | 
    3 | import lombok.RequiredArgsConstructor;
    4 | import lombok.extern.slf4j.Slf4j;
    5 | import org.springframework.security.core.GrantedAuthority;
    6 | import org.springframework.security.core.authority.SimpleGrantedAuthority;
    7 | import org.springframework.security.core.userdetails.UserDetails;
    8 | 
    9 | import com.authentication.auth.domain.users;
   10 | 
   11 | import java.util.Collection;
   12 | import java.util.Collections;
   13 | 
   14 | @Slf4j
   15 | @RequiredArgsConstructor
   16 | public class principalDetails implements UserDetails{
   17 | 
   18 |     private final users user;
   19 | 
   20 |     @Override
   21 |     public Collection<? extends GrantedAuthority> getAuthorities() {
   22 |         return Collections.singletonList(new SimpleGrantedAuthority(user.getRole().name()));
   23 |     }
   24 |     @Override
   25 |     public String getPassword() {
   26 |         return user.getUserPw();
   27 |     }
   28 |     @Override
   29 |     public String getUsername() {
   30 |         return user.getUserName();
   31 |     }
   32 |     @Override
   33 |     public boolean isAccountNonExpired() {
   34 |         return true;
   35 |     }
   36 |     @Override
   37 |     public boolean isAccountNonLocked() {
   38 |         return true;
   39 |     }
   40 |     @Override
   41 |     public boolean isCredentialsNonExpired() {
   42 |         return true;
   43 |     }
   44 |     @Override
   45 |     public boolean isEnabled() {
   46 |         return true;
   47 |     }
   48 |     public String getNickname(){
   49 |         return user.getNickname();
   50 |     }
   51 |     public String getUserId(){
   52 |         return user.getUserId();
   53 |     }
   54 | 
   55 | }

#--------------------------------------------------------------------------------


# File: backend/src/main/java/com/authentication/auth/DTO/token/tokenRefreshRequest.java
#=============================================================================

    1 | package com.career_block.auth.DTO.token;
    2 | 
    3 | import lombok.Data;
    4 | 
    5 | @Data
    6 | public class tokenRefreshRequest {
    7 |     private String expiredToken;
    8 |     private String provider;
    9 | }

#--------------------------------------------------------------------------------


# File: backend/src/main/java/com/authentication/auth/filter/PathPatternFilterCondition.java
#=============================================================================

    1 | package com.authentication.auth.filter;
    2 | 
    3 | import jakarta.servlet.http.HttpServletRequest;
    4 | import org.springframework.http.HttpMethod;
    5 | import org.springframework.util.AntPathMatcher;
    6 | 
    7 | import java.util.HashSet;
    8 | import java.util.Set;
    9 | 
   10 | /**
   11 |  * @Author: choisimo
   12 |  * @Date: 2025-05-05
   13 |  * @Description: 경로 패턴 기반 필터 조건
   14 |  * @Details: URL 패턴과 HTTP 메소드 기반으로 필터 적용 여부를 결정
   15 |  */
   16 | public class PathPatternFilterCondition implements FilterCondition {
   17 |     
   18 |     private final Set<String> patterns = new HashSet<>();
   19 |     private final Set<HttpMethod> methods = new HashSet<>();
   20 |     private final AntPathMatcher pathMatcher = new AntPathMatcher();
   21 |     private final String description;
   22 |     
   23 |     /**
   24 |      * 경로 패턴만 지정하는 생성자
   25 |      * @param description 조건 설명
   26 |      * @param patterns 포함할 URL 패턴 (Ant-style)
   27 |      */
   28 |     public PathPatternFilterCondition(String description, String... patterns) {
   29 |         this.description = description;
   30 |         for (String pattern : patterns) {
   31 |             this.patterns.add(pattern);
   32 |         }
   33 |     }
   34 |     
   35 |     /**
   36 |      * 경로 패턴과 HTTP 메소드를 지정하는 생성자
   37 |      * @param description 조건 설명
   38 |      * @param methods 포함할 HTTP 메소드
   39 |      * @param patterns 포함할 URL 패턴 (Ant-style)
   40 |      */
   41 |     public PathPatternFilterCondition(String description, HttpMethod[] methods, String... patterns) {
   42 |         this(description, patterns);
   43 |         for (HttpMethod method : methods) {
   44 |             this.methods.add(method);
   45 |         }
   46 |     }
   47 |     
   48 |     /**
   49 |      * 패턴 추가
   50 |      * @param pattern 추가할 패턴
   51 |      * @return 현재 객체 (체이닝용)
   52 |      */
   53 |     public PathPatternFilterCondition addPattern(String pattern) {
   54 |         this.patterns.add(pattern);
   55 |         return this;
   56 |     }
   57 |     
   58 |     /**
   59 |      * HTTP 메소드 추가
   60 |      * @param method 추가할 HTTP 메소드
   61 |      * @return 현재 객체 (체이닝용)
   62 |      */
   63 |     public PathPatternFilterCondition addMethod(HttpMethod method) {
   64 |         this.methods.add(method);
   65 |         return this;
   66 |     }
   67 | 
   68 |     @Override
   69 |     public boolean shouldNotFilter(HttpServletRequest request) {
   70 |         String requestPath = request.getRequestURI();
   71 |         
   72 |         // 어느 하나의 패턴이라도 맞으면 필터 제외
   73 |         boolean matchesPattern = patterns.stream()
   74 |                 .anyMatch(pattern -> pathMatcher.match(pattern, requestPath));
   75 |         
   76 |         // HTTP 메소드 제한이 없거나, 요청 메소드가 지정된 메소드 중 하나와 일치하면 필터 제외
   77 |         boolean matchesMethod = methods.isEmpty() || 
   78 |                                methods.contains(HttpMethod.valueOf(request.getMethod()));
   79 |         
   80 |         return matchesPattern && matchesMethod;
   81 |     }
   82 | 
   83 |     @Override
   84 |     public String getDescription() {
   85 |         return description;
   86 |     }
   87 |     
   88 |     @Override
   89 |     public String toString() {
   90 |         return "PathPatternFilterCondition{" +
   91 |                 "description='" + description + '\'' +
   92 |                 ", patterns=" + patterns +
   93 |                 ", methods=" + methods +
   94 |                 '}';
   95 |     }
   96 | }

#--------------------------------------------------------------------------------


# File: backend/src/main/java/com/authentication/auth/filter/RoleBasedAccessFilter.java
#=============================================================================

    1 | package com.authentication.auth.filter;
    2 | 
    3 | import jakarta.servlet.FilterChain;
    4 | import jakarta.servlet.ServletException;
    5 | import jakarta.servlet.http.HttpServletRequest;
    6 | import jakarta.servlet.http.HttpServletResponse;
    7 | import lombok.RequiredArgsConstructor;
    8 | import lombok.extern.slf4j.Slf4j;
    9 | import org.springframework.security.access.AccessDeniedException;
   10 | import org.springframework.security.core.Authentication;
   11 | import org.springframework.security.core.context.SecurityContextHolder;
   12 | import org.springframework.stereotype.Component;
   13 | import org.springframework.web.filter.OncePerRequestFilter;
   14 | 
   15 | import java.io.IOException;
   16 | import java.util.HashMap;
   17 | import java.util.Map;
   18 | import java.util.function.Predicate;
   19 | 
   20 | /**
   21 |  * @Author: choisimo
   22 |  * @Date: 2025-05-05
   23 |  * @Description: 역할 기반 접근 제어 필터
   24 |  * @Details: 더 세분화된 역할 기반 접근 제어를 구현한 필터
   25 |  */
   26 | @Slf4j
   27 | @Component
   28 | @RequiredArgsConstructor
   29 | public class RoleBasedAccessFilter extends OncePerRequestFilter implements PluggableFilter {
   30 | 
   31 |     // URI 패턴에 따른 접근 제어 규칙 맵
   32 |     private final Map<Predicate<String>, Predicate<Authentication>> accessRules = new HashMap<>();
   33 |     
   34 |     // 생성자에서 접근 제어 규칙 초기화
   35 |     public RoleBasedAccessFilter() {
   36 |         // 관리자 전용 경로 설정
   37 |         accessRules.put(
   38 |             uri -> uri.startsWith("/admin"),
   39 |             auth -> auth.getAuthorities().stream()
   40 |                         .anyMatch(a -> a.getAuthority().equals("ROLE_ADMIN"))
   41 |         );
   42 |         
   43 |         // 사용자 전용 경로 설정
   44 |         accessRules.put(
   45 |             uri -> uri.startsWith("/user"),
   46 |             auth -> auth.getAuthorities().stream()
   47 |                         .anyMatch(a -> a.getAuthority().equals("ROLE_USER") || 
   48 |                                        a.getAuthority().equals("ROLE_ADMIN"))
   49 |         );
   50 |         
   51 |         // API 경로 설정
   52 |         accessRules.put(
   53 |             uri -> uri.startsWith("/api/reports"),
   54 |             auth -> auth.getAuthorities().stream()
   55 |                         .anyMatch(a -> a.getAuthority().equals("ROLE_ANALYST") || 
   56 |                                        a.getAuthority().equals("ROLE_ADMIN"))
   57 |         );
   58 |     }
   59 | 
   60 |     @Override
   61 |     protected void doFilterInternal(HttpServletRequest request, HttpServletResponse response,
   62 |                                    FilterChain filterChain) throws ServletException, IOException {
   63 |         
   64 |         String uri = request.getRequestURI();
   65 |         Authentication authentication = SecurityContextHolder.getContext().getAuthentication();
   66 |         
   67 |         // 인증되지 않은 요청은 다음 필터로 넘김 (인증 필터에서 처리)
   68 |         if (authentication == null || !authentication.isAuthenticated()) {
   69 |             filterChain.doFilter(request, response);
   70 |             return;
   71 |         }
   72 |         
   73 |         // URI에 맞는 접근 규칙 적용
   74 |         for (Map.Entry<Predicate<String>, Predicate<Authentication>> rule : accessRules.entrySet()) {
   75 |             if (rule.getKey().test(uri)) {
   76 |                 if (!rule.getValue().test(authentication)) {
   77 |                     log.warn("역할 기반 접근 거부: 사용자={}, URI={}", 
   78 |                             authentication.getName(), uri);
   79 |                     throw new AccessDeniedException("해당 리소스에 접근할 권한이 없습니다.");
   80 |                 }
   81 |                 break;
   82 |             }
   83 |         }
   84 |         
   85 |         filterChain.doFilter(request, response);
   86 |     }
   87 |     
   88 |     @Override
   89 |     public void configure(HttpSecurity http) throws Exception {
   90 |         http.addFilterAfter(this, AuthorizationFilter.class);
   91 |     }
   92 | 
   93 |     @Override
   94 |     public int getOrder() {
   95 |         return 400; // AuthorizationFilter 다음 순서
   96 |     }
   97 | 
   98 |     @Override
   99 |     public Class<? extends Filter> getBeforeFilter() {
  100 |         return AuthorizationFilter.class;
  101 |     }
  102 | 
  103 |     @Override
  104 |     public Class<? extends Filter> getAfterFilter() {
  105 |         return null;
  106 |     }
  107 | }

#--------------------------------------------------------------------------------


# File: backend/src/main/java/com/authentication/auth/filter/authenticationFilter.java
#=============================================================================

    1 | package com.career_block.auth.filter;
    2 | 
    3 | import com.authentication.auth.DTO.token.principalDetails;
    4 | import com.authentication.auth.DTO.token.tokenDto;
    5 | import com.authentication.auth.DTO.users.loginRequest;
    6 | import com.authentication.auth.configuration.token.jwtUtility;
    7 | import com.authentication.auth.others.constants.SecurityConstants;
    8 | import com.authentication.auth.service.redis.redisService;
    9 | import com.fasterxml.jackson.databind.ObjectMapper;
   10 | import jakarta.servlet.FilterChain;
   11 | import jakarta.servlet.http.Cookie;
   12 | import jakarta.servlet.http.HttpServletRequest;
   13 | import jakarta.servlet.http.HttpServletResponse;
   14 | import lombok.extern.slf4j.Slf4j;
   15 | import org.springframework.http.HttpStatus;
   16 | package com.authentication.auth.filter;
   17 | 
   18 | import com.authentication.auth.domain.User;
   19 | import com.authentication.auth.service.redis.RedisService;
   20 | import com.authentication.auth.utility.JwtUtility;
   21 | import jakarta.servlet.ServletException;
   22 | import jakarta.servlet.ServletRequest;
   23 | import jakarta.servlet.ServletResponse;
   24 | import org.springframework.http.MediaType;
   25 | import org.springframework.security.authentication.AuthenticationManager;
   26 | import org.springframework.security.authentication.BadCredentialsException;
   27 | import org.springframework.security.authentication.UsernamePasswordAuthenticationToken;
   28 | import org.springframework.security.core.Authentication;
   29 | import org.springframework.security.core.AuthenticationException;
   30 | import org.springframework.security.core.userdetails.UserDetails;
   31 | import org.springframework.security.web.authentication.UsernamePasswordAuthenticationFilter;
   32 | import org.springframework.security.web.util.matcher.AntPathRequestMatcher;
   33 | 
   34 | import java.io.IOException;
   35 | import java.time.LocalDateTime;
   36 | import java.util.HashMap;
   37 | import java.util.Map;
   38 | import java.util.Objects;
   39 | import java.util.UUID;
   40 | 
   41 | /**
   42 |  * @Author: choisimo
   43 |  * @Date: 2025-05-05
   44 |  * @Description: JWT 인증 필터
   45 |  * @Details: 사용자 로그인 요청을 처리하고, 인증 성공 시 JWT 토큰을 발급하는 필터
   46 |  * @Usage: Spring Security 필터 체인에 등록하여 사용
   47 |  */
   48 | @Slf4j
   49 | public class AuthenticationFilter extends UsernamePasswordAuthenticationFilter implements PluggableFilter {
   50 | 
   51 |     private final AuthenticationManager authenticationManager;
   52 |     private final JwtUtility jwtUtility;
   53 |     private final ObjectMapper objectMapper;
   54 |     private final RedisService redisService;
   55 |     private final String domain;
   56 |     private final String cookieDomain;
   57 | 
   58 |     /**
   59 |      * 인증 필터 생성자
   60 |      * @param authenticationManager Spring Security 인증 관리자
   61 |      * @param jwtUtility JWT 토큰 유틸리티
   62 |      * @param objectMapper JSON 변환용 객체 매퍼
   63 |      * @param redisService Redis 서비스 (토큰 저장용)
   64 |      * @param domain 애플리케이션 도메인
   65 |      * @param cookieDomain 쿠키에 사용할 도메인
   66 |      */
   67 |     public AuthenticationFilter(AuthenticationManager authenticationManager, JwtUtility jwtUtility, ObjectMapper objectMapper, RedisService redisService, String domain, String cookieDomain) {
   68 |         this.authenticationManager = authenticationManager;
   69 |         this.jwtUtility = jwtUtility;
   70 |         this.objectMapper = objectMapper;
   71 |         this.redisService = redisService;
   72 |         this.domain = domain;
   73 |         this.cookieDomain = cookieDomain;
   74 |         // 로그인 URL 설정 - POST /api/auth/login으로 변경
   75 |         setRequiresAuthenticationRequestMatcher(new AntPathRequestMatcher("/api/auth/login", "POST"));
   76 |     }
   77 | 
   78 |     /**
   79 |      * 사용자 인증 시도 메서드
   80 |      * 요청에서 사용자 자격 증명을 추출하고 인증을 시도합니다.
   81 |      * @param request HTTP 요청
   82 |      * @param response HTTP 응답
   83 |      * @return 인증 객체
   84 |      * @throws AuthenticationException 인증 예외
   85 |      */
   86 |     @Override
   87 |     public Authentication attemptAuthentication(HttpServletRequest request, HttpServletResponse response)
   88 |             throws AuthenticationException {
   89 |         log.info("인증 시도: {}", request.getRequestURI());
   90 |         
   91 |         try {
   92 |             // 요청 바디에서 사용자 자격 증명 추출
   93 |             Map<String, String> credentials = objectMapper.readValue(request.getInputStream(), Map.class);
   94 |             String username = credentials.get("username");
   95 |             String password = credentials.get("password");
   96 |             
   97 |             if (username == null || password == null) {
   98 |                 throw new BadCredentialsException("사용자 이름 또는 비밀번호가 누락되었습니다.");
   99 |             }
  100 |             
  101 |             log.debug("사용자 인증 시도: {}", username);
  102 |             
  103 |             // 인증 토큰 생성 및 인증 시도
  104 |             UsernamePasswordAuthenticationToken authenticationToken = 
  105 |                 new UsernamePasswordAuthenticationToken(username, password);
  106 |                 
  107 |             return authenticationManager.authenticate(authenticationToken);
  108 |         } catch (IOException e) {
  109 |             log.error("인증 요청 처리 중 오류 발생: {}", e.getMessage());
  110 |             throw new BadCredentialsException("인증 요청을 처리할 수 없습니다.");
  111 |         }
  112 |     }
  113 | 
  114 |     /**
  115 |      * 인증 성공 처리 메서드
  116 |      * 인증 성공 시 JWT 토큰을 생성하고 클라이언트에게 제공합니다.
  117 |      * @param request HTTP 요청
  118 |      * @param response HTTP 응답
  119 |      * @param chain 필터 체인
  120 |      * @param authResult 인증 결과
  121 |      * @throws IOException IO 예외
  122 |      * @throws ServletException 서블릿 예외
  123 |      */
  124 |     @Override
  125 |     protected void successfulAuthentication(HttpServletRequest request, HttpServletResponse response,
  126 |                                            FilterChain chain, Authentication authResult) 
  127 |                                            throws IOException, ServletException {
  128 |         log.info("인증 성공 처리");
  129 |         
  130 |         UserDetails userDetails = (UserDetails) authResult.getPrincipal();
  131 |         String username = userDetails.getUsername();
  132 |         
  133 |         // 액세스 토큰 생성
  134 |         String accessToken = jwtUtility.generateAccessToken(username, userDetails.getAuthorities());
  135 |         
  136 |         // 리프레시 토큰 생성 및 Redis에 저장
  137 |         String refreshTokenId = UUID.randomUUID().toString();
  138 |         String refreshToken = jwtUtility.generateRefreshToken(username, refreshTokenId);
  139 |         
  140 |         // 사용자 ID 정보 추출
  141 |         User user = (User) userDetails;
  142 |         String userId = user.getId().toString();
  143 |         
  144 |         // Redis에 리프레시 토큰 저장 (사용자 ID와 함께)
  145 |         String redisKey = "JWT_RToken_" + userId + "_" + refreshTokenId;
  146 |         redisService.setValueWithExpiration(redisKey, refreshToken, jwtUtility.getRefreshTokenExpiration());
  147 |         
  148 |         // 액세스 토큰과 리프레시 토큰을 쿠키에 설정
  149 |         Cookie accessTokenCookie = createCookie("access_token", accessToken, jwtUtility.getAccessTokenExpiration() / 1000);
  150 |         Cookie refreshTokenCookie = createCookie("refresh_token", refreshToken, jwtUtility.getRefreshTokenExpiration() / 1000);
  151 |         
  152 |         response.addCookie(accessTokenCookie);
  153 |         response.addCookie(refreshTokenCookie);
  154 |         
  155 |         // 응답 데이터 구성
  156 |         Map<String, Object> responseData = new HashMap<>();
  157 |         responseData.put("status", "success");
  158 |         responseData.put("message", "로그인 성공");
  159 |         responseData.put("timestamp", LocalDateTime.now().toString());
  160 |         
  161 |         // JSON 응답 전송
  162 |         response.setContentType(MediaType.APPLICATION_JSON_VALUE);
  163 |         response.setStatus(HttpStatus.OK.value());
  164 |         objectMapper.writeValue(response.getWriter(), responseData);
  165 |         
  166 |         log.debug("사용자 {} 인증 완료, 토큰 발급 성공", username);
  167 |     }
  168 | 
  169 |     /**
  170 |      * 쿠키 생성 헬퍼 메서드
  171 |      * @param name 쿠키 이름
  172 |      * @param value 쿠키 값
  173 |      * @param maxAge 쿠키 만료 시간 (초)
  174 |      * @return 생성된 쿠키
  175 |      */
  176 |     private Cookie createCookie(String name, String value, long maxAge) {
  177 |         Cookie cookie = new Cookie(name, value);
  178 |         cookie.setHttpOnly(true);
  179 |         cookie.setSecure(true); // HTTPS에서만 전송
  180 |         cookie.setPath("/");
  181 |         cookie.setDomain(cookieDomain);
  182 |         cookie.setMaxAge((int) maxAge);
  183 |         return cookie;
  184 |     }
  185 | 
  186 |     /**
  187 |      * 인증 실패 처리 메서드
  188 |      * 인증 실패 시 적절한 오류 메시지를 클라이언트에게 제공합니다.
  189 |      * @param request HTTP 요청
  190 |      * @param response HTTP 응답
  191 |      * @param failed 인증 예외
  192 |      * @throws IOException IO 예외
  193 |      * @throws ServletException 서블릿 예외
  194 |      */
  195 |     @Override
  196 |     protected void unsuccessfulAuthentication(HttpServletRequest request, HttpServletResponse response,
  197 |                                              AuthenticationException failed) 
  198 |                                              throws IOException, ServletException {
  199 |         log.warn("인증 실패: {}", failed.getMessage());
  200 |         
  201 |         Map<String, Object> errorResponse = new HashMap<>();
  202 |         errorResponse.put("status", "error");
  203 |         errorResponse.put("message", "로그인 실패: 사용자 이름 또는 비밀번호가 올바르지 않습니다.");
  204 |         errorResponse.put("timestamp", LocalDateTime.now().toString());
  205 |         
  206 |         response.setContentType(MediaType.APPLICATION_JSON_VALUE);
  207 |         response.setStatus(HttpStatus.UNAUTHORIZED.value());
  208 |         objectMapper.writeValue(response.getWriter(), errorResponse);
  209 |     }
  210 | 
  211 |     /**
  212 |      * PluggableFilter 인터페이스 구현
  213 |      * 필터 설정 메서드
  214 |      */
  215 |     @Override
  216 |     public void configure(HttpSecurity http) throws Exception {
  217 |         http.addFilter(this);
  218 |     }
  219 | 
  220 |     /**
  221 |      * PluggableFilter 인터페이스 구현
  222 |      * 필터 순서 반환 메서드
  223 |      */
  224 |     @Override
  225 |     public int getOrder() {
  226 |         return 2; // 인증 필터는 우선순위가 비교적 높아야 함
  227 |     }
  228 | 
  229 |     /**
  230 |      * PluggableFilter 인터페이스 구현
  231 |      * 이 필터 이전에 적용될 필터 클래스 반환
  232 |      */
  233 |     @Override
  234 |     public Class<? extends Filter> getBeforeFilter() {
  235 |         return UsernamePasswordAuthenticationFilter.class;
  236 |     }
  237 | 
  238 |     /**
  239 |      * PluggableFilter 인터페이스 구현
  240 |      * 이 필터 이후에 적용될 필터 클래스 반환
  241 |      */
  242 |     @Override
  243 |     public Class<? extends Filter> getAfterFilter() {
  244 |         return null; // 현재 필터 이후에 특정 필터가 없음
  245 |     }
  246 | 
  247 |     /**
  248 |      * PluggableFilter 인터페이스 구현
  249 |      * 필터 체인 로직 실행 메서드
  250 |      */
  251 |     @Override
  252 |     public void doFilter(ServletRequest request, ServletResponse response, FilterChain chain) 
  253 |             throws IOException, ServletException {
  254 |         // 기본 필터 로직은 UsernamePasswordAuthenticationFilter에서 상속됨
  255 |         // 추가 필터 로직이 필요한 경우 여기에 구현
  256 |         super.doFilter(request, response, chain);
  257 |     }
  258 | }
  259 |             throws AuthenticationException {
  260 |         log.info("╔═══════════════════════════════════════════════════════════════╗");
  261 |         log.info("║                       Authentication Filter                   ║");
  262 |         log.info("╚═══════════════════════════════════════════════════════════════╝");
  263 |         if (request.getCookies() != null) log.debug("request.getCookies() is not null");//jwtutility.deleteHttpOnlyCookie(request, response);
  264 | 
  265 |         // JSON 요청에서 사용자 로그인 정보 읽기
  266 |         loginRequest loginRequest;
  267 |         try {
  268 |             log.info("get loginRequest");
  269 |             loginRequest = objectMapper.readValue(request.getInputStream(), loginRequest.class);
  270 |         } catch (IOException e) {
  271 |             throw new RuntimeException(e);
  272 |         }
  273 | 
  274 |         log.info("login, userId : {}",loginRequest.getUserId());
  275 | 
  276 |         UsernamePasswordAuthenticationToken authenticationToken =
  277 |                 new UsernamePasswordAuthenticationToken(loginRequest.getUserId(), loginRequest.getPassword());
  278 | 
  279 |         log.info("login, authentication token created successfully");
  280 | 
  281 |         // 사용자 인증 시도
  282 |         Authentication authentication = null;
  283 |         try{
  284 |             authentication = authenticationManager.authenticate(authenticationToken);
  285 |         } catch (Exception e){
  286 |             log.error("authentication processing error", e);
  287 |         }
  288 | 
  289 |         if(!Objects.requireNonNull(authentication).isAuthenticated()){
  290 |             log.error("authentication failed");
  291 |             response.setStatus(401);
  292 |         }
  293 | 
  294 |         return authentication;
  295 |     }
  296 | 
  297 | 
  298 |     @Override
  299 |     protected void successfulAuthentication(HttpServletRequest request, HttpServletResponse response,
  300 |                                             FilterChain filterChain, Authentication authentication) throws  IOException{
  301 | 
  302 |         principalDetails principalDetails = (principalDetails) authentication.getPrincipal();
  303 |         tokenDto tokendto = jwtUtility.buildToken(principalDetails.getUserId(),
  304 |                 principalDetails.getNickname(), principalDetails.getAuthorities());
  305 | 
  306 |         log.info("Authentication successful for userId : {}", principalDetails.getUserId());
  307 |         log.info("Authentication token dto created");
  308 | 
  309 |         boolean RTokenSave = redisService.saveRToken(principalDetails.getUserId(), "server", tokendto.getRefreshToken());
  310 |         boolean accessTokenSave = redisService.saveAccessToken(tokendto.getRefreshToken(), tokendto.getAccessToken(), principalDetails.getUserId());
  311 |         log.info("redis save result R : {}, A : {} for userId {}", RTokenSave, accessTokenSave, principalDetails.getUserId());
  312 |         if (accessTokenSave && RTokenSave && jwtUtility.validateRefreshJWT(tokendto.getRefreshToken())){
  313 | 
  314 |             loginResponse(response, tokendto);
  315 | 
  316 |             response.setContentType("application/json");
  317 |             response.setCharacterEncoding("UTF-8");
  318 |             response.setStatus(HttpStatus.OK.value());
  319 | 
  320 |             // JSON 형식으로 응답 생성 및 전송 (access_token)
  321 |             String jsonResponse = new ObjectMapper().writeValueAsString(Map.of(
  322 |                     "access_token", tokendto.getAccessToken()
  323 |             ));
  324 |             response.getWriter().write(jsonResponse);
  325 | 
  326 |         } else {
  327 |             log.error("REDIS token save failed return SERVER_INTERNAL_ERROR");
  328 |             response.setStatus(HttpStatus.INTERNAL_SERVER_ERROR.value());
  329 |         }
  330 |     }
  331 | 
  332 | 
  333 |     private void loginResponse(HttpServletResponse response, tokenDto tokendto){
  334 |         Cookie newCookie = new Cookie("refreshToken", tokendto.getRefreshToken());
  335 |         newCookie.setHttpOnly(true);
  336 |         newCookie.setDomain(cookieDomain);
  337 |         newCookie.setPath("/");
  338 |         response.addCookie(newCookie);
  339 |         response.addHeader(SecurityConstants.TOKEN_HEADER,
  340 |                 SecurityConstants.TOKEN_PREFIX + tokendto.getAccessToken());
  341 |     }
  342 | 
  343 | }
  344 | 

#--------------------------------------------------------------------------------


# File: backend/src/main/java/com/authentication/auth/filter/snsRequestFilter.java
#=============================================================================

    1 | package com.authentication.auth.filter;
    2 | 
    3 | import com.authentication.auth.DTO.token.tokenDto;
    4 | import com.authentication.auth.configuration.token.jwtUtility;
    5 | import com.authentication.auth.domain.users;
    6 | import com.authentication.auth.others.constants.SecurityConstants;
    7 | import com.authentication.auth.service.oauth2.oauth2Service;
    8 | import com.authentication.auth.service.oauth2.snsTokenValidator;
    9 | import com.authentication.auth.service.redis.redisService;
   10 | 
   11 | import jakarta.servlet.FilterChain;
   12 | import jakarta.servlet.ServletException;
   13 | import jakarta.servlet.http.Cookie;
   14 | import jakarta.servlet.http.HttpServletRequest;
   15 | import jakarta.servlet.http.HttpServletResponse;
   16 | import lombok.extern.slf4j.Slf4j;
   17 | import org.springframework.beans.factory.annotation.Value;
   18 | import org.springframework.security.core.Authentication;
   19 | import org.springframework.security.core.authority.SimpleGrantedAuthority;
   20 | import org.springframework.security.core.context.SecurityContextHolder;
   21 | import org.springframework.stereotype.Component;
   22 | import org.springframework.web.filter.OncePerRequestFilter;
   23 | 
   24 | import java.io.IOException;
   25 | import java.security.SecureRandom;
   26 | import java.text.ParseException;
   27 | import java.text.SimpleDateFormat;
   28 | import java.util.Collections;
   29 | import java.util.Date;
   30 | import java.util.Map;
   31 | import java.util.Random;
   32 | 
   33 | @Slf4j
   34 | @Component
   35 | public class snsRequestFilter implements PluggableFilter {
   36 | 
   37 |     private final JwtUtility jwtUtility;
   38 |     private final RedisService redisService;
   39 | 
   40 | 
   41 |     @Value("${site.domain}")
   42 |     private String domain;
   43 | 
   44 |     public snsRequestFilter(jwtUtility jwtUtility, redisService redisService, snsTokenValidator snsTokenValidator, oauth2Service oauth2Service) {
   45 |         this.jwtUtility = jwtUtility;
   46 |         this.redisService = redisService;
   47 |         this.snsTokenValidator = snsTokenValidator;
   48 |         this.oauth2Service = oauth2Service;
   49 |     }
   50 | 
   51 |     @Override
   52 |     protected void doFilterInternal(HttpServletRequest request, HttpServletResponse response, FilterChain filterChain) throws ServletException, IOException {
   53 | 
   54 |         String providerHeader = request.getHeader("provider"); // SNS 정보 제공자 추가하기
   55 |         String authorizationHolder = request.getHeader(SecurityConstants.TOKEN_HEADER);
   56 |         log.info("authorizationHolder logging for test {}", authorizationHolder);
   57 | 
   58 |         log.info("current SNS providerHeader is {} ", providerHeader);
   59 | 
   60 |         if (providerHeader == null || "server".equals(providerHeader)) {
   61 |             filterChain.doFilter(request, response);
   62 |             return;
   63 |         }
   64 | 
   65 |         if (!isBearerToken(authorizationHolder)) {
   66 |             log.error("authorization is null");
   67 |             filterChain.doFilter(request, response);
   68 |             return;
   69 |         }
   70 | 
   71 |         String JWT = extractToken(authorizationHolder);
   72 | 
   73 |         if (JWT == null) {
   74 |             filterChain.doFilter(request, response);
   75 |             return;
   76 |         }
   77 | 
   78 |         if (jwtUtility.validateJWT(JWT)) {
   79 |             setAuthentication(JWT);
   80 |         } else {
   81 |             handleRefreshToken(request, response, JWT, providerHeader);
   82 |         }
   83 | 
   84 |         filterChain.doFilter(request, response);
   85 |     }
   86 | 
   87 | 
   88 |     private void handleRefreshToken(HttpServletRequest request, HttpServletResponse response, String JWT, String providerHeader) throws IOException {
   89 |         String snsRefreshToken = jwtUtility.checkSnsCookie(request, response);
   90 |         if (snsRefreshToken == null) {
   91 |             log.warn("no refresh token exists in cookies .. ");
   92 |             return;
   93 |         }
   94 | 
   95 |         String userId = getUserIdFromJWT(JWT);
   96 |         if (RedisMatchSnsRToken(userId, snsRefreshToken)) {
   97 |             refreshTokenAndAuthenticate(request, response, snsRefreshToken, providerHeader, userId);
   98 |         } else {
   99 |             log.warn("sns refreshToken does not exist in redis .. ");
  100 |         }
  101 |     }
  102 | 
  103 |     private void refreshTokenAndAuthenticate(HttpServletRequest request, HttpServletResponse response, String snsRefreshToken, String providerHeader, String userId) throws IOException {
  104 |         Map<String, String> newTokens = snsTokenValidator.getNewTokenByRefreshToken(snsRefreshToken, providerHeader);
  105 |         String newSnsAccessToken = newTokens.get("access_token");
  106 | 
  107 |         if (newSnsAccessToken == null) {
  108 |             log.error("access token does not exist");
  109 |             return;
  110 |         }
  111 | 
  112 |         Map<String, Object> snsUserProfile = getSnsUserProfile(newSnsAccessToken, providerHeader);
  113 |         if (snsUserProfile == null) {
  114 |             log.error("cannot get any sns userProfiles");
  115 |             return;
  116 |         }
  117 | 
  118 |         String oauthId = extractOauthId(snsUserProfile, providerHeader);
  119 |         redisService.saveRToken(oauthId, providerHeader, snsRefreshToken);
  120 | 
  121 |         users user = oauth2Service.saveOrUpdateOauth2User(providerHeader, oauthId, snsUserProfile);
  122 |         tokenDto accessToken = jwtUtility.createToken(user.getUserId(), user.getNickname(), Collections.singletonList(new SimpleGrantedAuthority(user.getRole().name())));
  123 |         loginResponse(response, accessToken.getAccessToken(), snsRefreshToken, providerHeader);
  124 | 
  125 |         setAuthentication(accessToken.getAccessToken());
  126 |     }
  127 | 
  128 |     private String extractOauthId(Map<String, Object> snsUserProfile, String providerHeader) {
  129 |         return switch (providerHeader) {
  130 |             case "naver" -> ((Map<String, Object>) snsUserProfile.get("response")).get("id").toString();
  131 |             case "kakao" -> snsUserProfile.get("id").toString();
  132 |             default -> snsUserProfile.get("sub").toString();
  133 |         };
  134 |     }
  135 | 
  136 | 
  137 |     private String getUserIdFromJWT(String JWT) {
  138 |         return (String) jwtUtility.getClaimsFromAccessToken(JWT).get("userId");
  139 |     }
  140 | 
  141 | 
  142 | 
  143 |     private boolean RedisMatchSnsRToken(String userId, String RToken) {
  144 |         return redisService.findRToken(userId, "server", RToken);
  145 |     }
  146 | 
  147 |     private Map<String, Object> getSnsUserProfile(String access_token, String provider) {
  148 |         Map<String, Object> userProfile = null;
  149 |         switch (provider) {
  150 |             case "kakao" :
  151 |                 userProfile = oauth2Service.getKakaoUserProfile(access_token);
  152 |                 break;
  153 |             case "naver" :
  154 |                 userProfile = oauth2Service.getNaverUserProfile(access_token);
  155 |                 break;
  156 |             case "google" :
  157 |                 userProfile = oauth2Service.getGoogleUserProfile(access_token);
  158 |                 break;
  159 |             default:
  160 |                 throw new IllegalArgumentException("Unsupported provider: " + provider);
  161 |         }
  162 |         return userProfile;
  163 |     }
  164 | 
  165 |     private void loginResponse(HttpServletResponse response, String accessToken, String refreshToken, String provider) {
  166 |         Cookie newCookie = new Cookie(provider + "_refreshToken", refreshToken);
  167 |         newCookie.setHttpOnly(true);
  168 |         newCookie.setDomain(domain);
  169 |         newCookie.setPath("/");
  170 |         response.addCookie(newCookie);
  171 | 
  172 |         response.addHeader(SecurityConstants.TOKEN_HEADER, SecurityConstants.TOKEN_PREFIX + accessToken);
  173 |     }
  174 | 
  175 | 
  176 |     private Date parseBirthday(String birthday) {
  177 |         if (birthday != null && birthday.length() == 5) {
  178 |             try {
  179 |                 SimpleDateFormat sdf = new SimpleDateFormat("MM-dd");
  180 |                 Date date = sdf.parse(birthday);
  181 |                 return date;
  182 |             } catch (ParseException e) {
  183 |                 log.error("Error parsing birthday: ", e);
  184 |             }
  185 |         }
  186 |         return null; // Implement proper parsing if different format
  187 |     }
  188 | 
  189 | 
  190 |     private String generateRandomString(int length) {
  191 |         final String characters = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789";
  192 |         Random random = new SecureRandom();
  193 |         StringBuilder sb = new StringBuilder(length);
  194 | 
  195 |         for (int i = 0; i < length; i++) {
  196 |             sb.append(characters.charAt(random.nextInt(characters.length())));
  197 |         }
  198 | 
  199 |         return sb.toString();
  200 |     }
  201 | 
  202 |     private String extractToken(String authorizationHolder) {
  203 |         return authorizationHolder != null ? authorizationHolder.split(" ")[1] : null;
  204 |     }
  205 | 
  206 | 
  207 |     private boolean isBearerToken(String authorization) {
  208 |         return authorization != null && authorization.startsWith("Bearer ");
  209 |     }
  210 | 
  211 |     private void setAuthentication(String JWT) {
  212 |         try {
  213 |             Authentication authentication = jwtUtility.getAuthentication(JWT);
  214 |             SecurityContextHolder.getContext().setAuthentication(authentication);
  215 |             log.info("유효한 SNS authorization access_token");
  216 |         } catch (Exception e) {
  217 |             log.error("인증 실패!!");
  218 |         }
  219 |     }
  220 |         
  221 |         @Override
  222 |         public void configure(HttpSecurity http) throws Exception {
  223 |             http.addFilterBefore(this, JwtVerificationFilter.class);
  224 |         }
  225 |     
  226 |         @Override
  227 |         public int getOrder() {
  228 |             return 150; // AuthenticationFilter와 JwtVerificationFilter 사이 순서
  229 |         }
  230 |     
  231 |         @Override
  232 |         public Class<? extends Filter> getBeforeFilter() {
  233 |             return AuthenticationFilter.class;
  234 |         }
  235 |     
  236 |         @Override
  237 |         public Class<? extends Filter> getAfterFilter() {
  238 |             return JwtVerificationFilter.class;
  239 |         }
  240 | }

#--------------------------------------------------------------------------------


# File: backend/src/main/java/com/authentication/auth/filter/securityFilterOrder.java
#=============================================================================

    1 | package com.authentication.auth.filter;
    2 | 
    3 | import java.util.HashMap;
    4 | import java.util.Map;
    5 | 
    6 | import lombok.Getter;
    7 | 
    8 | /**
    9 |  * @Author : choisimo 
   10 |  * @Date : 2025-05-05
   11 |  * @Description : SecurityFilterOrder enum class
   12 |  * @Details : 필터 체인에서 필터의 순서를 지정하는 열거형 클래스
   13 |  */
   14 | 
   15 | @Getter
   16 | public enum SecurityFilterOrder {
   17 |     /**
   18 |      * 필터 실행 순서를 나타내는 enum
   19 |      * order 값이 낮을수록 우선순위가 높음
   20 |      */
   21 |     AUTHENTICATION_FILTER(100),
   22 |     AUTHORIZATION_FILTER(200),
   23 |     SNS_REQUEST_FILTER(300);
   24 | 
   25 |     // 필터 순서 값
   26 |     private final int order;
   27 |     
   28 |     // order 값으로 필터를 빠르게 조회하기 위한 맵 (BigO(1))
   29 |     private static final Map<Integer, SecurityFilterOrder> ORDER_MAP = new HashMap<>();
   30 | 
   31 |     static {
   32 |         for (SecurityFilterOrder filter : SecurityFilterOrder.values()) {
   33 |             ORDER_MAP.put(filter.order, filter);
   34 |         }
   35 |     }
   36 | 
   37 |     SecurityFilterOrder(int order) {
   38 |         this.order = order;
   39 |     }
   40 | 
   41 |     /**
   42 |      * 순서 값으로 필터 열거형을 조회
   43 |      * @param order 필터 순서 값
   44 |      * @return 해당 순서의 필터 열거형
   45 |      * @throws IllegalArgumentException 유효하지 않은 순서값 입력 시
   46 |      */
   47 |     public static SecurityFilterOrder fromOrder(int order) {
   48 |         SecurityFilterOrder filter = ORDER_MAP.get(order);
   49 |         if (filter == null) {
   50 |             throw new IllegalArgumentException("유효하지 않은 필터 순서: " + order);
   51 |         }
   52 |         return filter;
   53 |     }
   54 | 
   55 |     /**
   56 |      * 문자열을 안전하게 필터 열거형으로 변환
   57 |      * @param name 필터 이름
   58 |      * @return 해당 이름의 필터 열거형, 없으면 기본값 반환
   59 |      */
   60 |     public static SecurityFilterOrder safeValueOf(String name) {
   61 |         try {
   62 |             return SecurityFilterOrder.valueOf(name);
   63 |         } catch (IllegalArgumentException e) {
   64 |             return SecurityFilterOrder.AUTHENTICATION_FILTER; // 기본값
   65 |         }
   66 |     }
   67 | }

#--------------------------------------------------------------------------------


# File: backend/src/main/java/com/authentication/auth/filter/FilterCondition.java
#=============================================================================

    1 | package com.authentication.auth.filter;
    2 | 
    3 | import jakarta.servlet.http.HttpServletRequest;
    4 | 
    5 | /**
    6 |  * @Author: choisimo
    7 |  * @Date: 2025-05-05
    8 |  * @Description: 필터 조건 인터페이스
    9 |  * @Details: 필터 적용 조건을 정의하는 인터페이스
   10 |  */
   11 | public interface FilterCondition {
   12 |     
   13 |     /**
   14 |      * 요청에 필터를 적용할지 여부를 결정
   15 |      * @param request HTTP 요청
   16 |      * @return true이면 필터를 적용하지 않음, false이면 필터 적용
   17 |      */
   18 |     boolean shouldNotFilter(HttpServletRequest request);
   19 |     
   20 |     /**
   21 |      * 조건에 설명을 제공
   22 |      * @return 조건 설명
   23 |      */
   24 |     String getDescription();
   25 | }

#--------------------------------------------------------------------------------


# File: backend/src/main/java/com/authentication/auth/filter/AbstractAuthenticationFilter.java
#=============================================================================

    1 | package com.authentication.auth.filter;
    2 | 
    3 | import com.authentication.auth.configuration.token.JwtUtility;
    4 | import com.authentication.auth.service.RedisService;
    5 | import com.fasterxml.jackson.databind.ObjectMapper;
    6 | import jakarta.servlet.Filter;
    7 | import jakarta.servlet.FilterChain;
    8 | import jakarta.servlet.ServletException;
    9 | import jakarta.servlet.http.HttpServletRequest;
   10 | import jakarta.servlet.http.HttpServletResponse;
   11 | import lombok.RequiredArgsConstructor;
   12 | import lombok.extern.slf4j.Slf4j;
   13 | import org.springframework.security.authentication.AuthenticationManager;
   14 | import org.springframework.security.authentication.UsernamePasswordAuthenticationToken;
   15 | import org.springframework.security.config.annotation.web.builders.HttpSecurity;
   16 | import org.springframework.security.core.Authentication;
   17 | import org.springframework.security.core.AuthenticationException;
   18 | import org.springframework.security.web.authentication.UsernamePasswordAuthenticationFilter;
   19 | import org.springframework.stereotype.Component;
   20 | 
   21 | import java.io.IOException;
   22 | 
   23 | /**
   24 |  * @Author: choisimo
   25 |  * @Date: 2025-05-05
   26 |  * @Description: 인증 필터 추상 클래스
   27 |  * @Details: 사용자 로그인 요청을 처리하고 JWT 토큰을 생성하는 필터의 기본 구조 정의
   28 |  * 
   29 |  * 추상(abstract) 클래스 vs 구체적 구현 클래스 차이점:
   30 |  * 1. 추상 클래스: 
   31 |  *    - 불완전한 설계를 제공하며 상속을 통해 구체적 구현을 강제합니다.
   32 |  *    - 자식 클래스가 반드시 구현해야 하는 메소드를 정의할 수 있습니다.
   33 |  *    - 공통 기능을 제공하면서 확장성을 보장합니다.
   34 |  *    - 이 방식은 프레임워크나 라이브러리를 설계할 때 유용합니다.
   35 |  *    
   36 |  * 2. 구체적 구현 클래스: 
   37 |  *    - 직접 인스턴스화 가능하고 모든 메소드가 구현되어 있습니다.
   38 |  *    - 특정한 비즈니스 로직에 맞게 최적화되어 있습니다.
   39 |  *    - 상속보다는 특정 인터페이스 구현에 중점을 둡니다.
   40 |  *    - 이 방식은 실제 애플리케이션 로직을 구현할 때 적합합니다.
   41 |  *    
   42 |  * 접근 제한자 사용:
   43 |  * - private: 클래스 내부에서만 접근 가능한 필드들(authenticationManager 등)은 캡슐화를 위해 사용
   44 |  * - protected: 상속 관계에서 자식 클래스에게 접근을 허용하기 위해 일부 메소드에 사용
   45 |  * - public: 외부에서 호출 가능한 API를 제공하기 위해 사용
   46 |  */
   47 | @Slf4j
   48 | @Component
   49 | @RequiredArgsConstructor
   50 | public abstract class AbstractAuthenticationFilter extends UsernamePasswordAuthenticationFilter implements PluggableFilter {
   51 |     
   52 |     private final AuthenticationManager authenticationManager;
   53 |     private final JwtUtility jwtUtility;
   54 |     private final ObjectMapper objectMapper;
   55 |     private final RedisService redisService;
   56 |     private final String domain;
   57 |     private final String cookieDomain;
   58 |     
   59 |     /**
   60 |      * 추상 클래스 구현에서는 공통된 인증 로직을 제공합니다.
   61 |      * 이 메소드는 public으로 선언되어 Spring Security 필터 체인에서 직접 호출될 수 있습니다.
   62 |      * 
   63 |      * 반면 구체적 구현 클래스에서는 doFilterInternal 메소드를 활용해 더 세부적인 인증 로직을 구현합니다.
   64 |      * 이 방식은 JWT 토큰 검증과 같은 특정 인증 방식에 최적화되어 있습니다.
   65 |      */
   66 |     @Override
   67 |     public Authentication attemptAuthentication(HttpServletRequest request, HttpServletResponse response) throws AuthenticationException {
   68 |         log.info("인증 시도");
   69 |         try {
   70 |             // 사용자 인증 로직
   71 |             // 로그인 요청에서 사용자 이름과 비밀번호 추출
   72 |             // 인증 관리자를 통해 인증 시도
   73 |             return authenticationManager.authenticate(
   74 |                     new UsernamePasswordAuthenticationToken(request.getParameter("username"), request.getParameter("password"))
   75 |             );
   76 |         } catch (Exception e) {
   77 |             log.error("인증 시도 중 오류 발생: ", e);
   78 |             throw new AuthenticationException("인증 실패") {};
   79 |         }
   80 |     }
   81 | package com.authentication.auth.filter;
   82 | 
   83 | import com.authentication.auth.configuration.token.JwtUtility;
   84 | import com.authentication.auth.service.RedisService;
   85 | import com.fasterxml.jackson.databind.ObjectMapper;
   86 | import jakarta.servlet.FilterChain;
   87 | import jakarta.servlet.ServletException;
   88 | import jakarta.servlet.http.HttpServletRequest;
   89 | import jakarta.servlet.http.HttpServletResponse;
   90 | import lombok.extern.slf4j.Slf4j;
   91 | import org.springframework.security.authentication.AuthenticationManager;
   92 | import org.springframework.security.authentication.UsernamePasswordAuthenticationToken;
   93 | import org.springframework.security.core.Authentication;
   94 | import org.springframework.security.core.AuthenticationException;
   95 | import org.springframework.security.web.authentication.UsernamePasswordAuthenticationFilter;
   96 | 
   97 | import java.io.IOException;
   98 | import java.util.Map;
   99 | 
  100 | /**
  101 |  * @Author: choisimo
  102 |  * @Date: 2025-05-05
  103 |  * @Description: 추상 인증 필터
  104 |  * @Details: 인증 처리를 위한 기본 기능을 제공하는 추상 필터 클래스
  105 |  */
  106 | @Slf4j
  107 | public abstract class AbstractAuthenticationFilter extends UsernamePasswordAuthenticationFilter implements PluggableFilter {
  108 |     
  109 |     protected final AuthenticationManager authenticationManager;
  110 |     protected final JwtUtility jwtUtility;
  111 |     protected final ObjectMapper objectMapper;
  112 |     protected final RedisService redisService;
  113 |     protected final String domain;
  114 |     protected final String cookieDomain;
  115 |     
  116 |     protected AbstractAuthenticationFilter(
  117 |             AuthenticationManager authenticationManager,
  118 |             JwtUtility jwtUtility,
  119 |             ObjectMapper objectMapper,
  120 |             RedisService redisService,
  121 |             String domain,
  122 |             String cookieDomain) {
  123 |         this.authenticationManager = authenticationManager;
  124 |         this.jwtUtility = jwtUtility;
  125 |         this.objectMapper = objectMapper;
  126 |         this.redisService = redisService;
  127 |         this.domain = domain;
  128 |         this.cookieDomain = cookieDomain;
  129 |         
  130 |         setAuthenticationManager(authenticationManager);
  131 |     }
  132 |     
  133 |     @Override
  134 |     public Authentication attemptAuthentication(HttpServletRequest request, HttpServletResponse response) 
  135 |             throws AuthenticationException {
  136 |         try {
  137 |             // 요청 본문에서 사용자 정보 파싱
  138 |             Map<String, String> credentials = objectMapper.readValue(
  139 |                     request.getInputStream(), Map.class);
  140 |             
  141 |             String username = credentials.get("username");
  142 |             String password = credentials.get("password");
  143 |             
  144 |             log.debug("사용자 로그인 시도: {}", username);
  145 |             
  146 |             // 인증 토큰 생성 및 인증 요청
  147 |             UsernamePasswordAuthenticationToken authToken = 
  148 |                     new UsernamePasswordAuthenticationToken(username, password);
  149 |             
  150 |             return authenticationManager.authenticate(authToken);
  151 |         } catch (IOException e) {
  152 |             log.error("인증 요청 처리 중 오류 발생", e);
  153 |             throw new RuntimeException("인증 요청을 처리할 수 없습니다", e);
  154 |         }
  155 |     }
  156 |     
  157 |     @Override
  158 |     public String getFilterId() {
  159 |         return this.getClass().getSimpleName();
  160 |     }
  161 | }
  162 |     @Override
  163 |     protected void successfulAuthentication(HttpServletRequest request, HttpServletResponse response,
  164 |                                            FilterChain chain, Authentication authResult) throws IOException, ServletException {
  165 |         log.info("인증 성공");
  166 |         // JWT 토큰 생성 및 응답에 추가
  167 |         // SecurityContext에 인증 정보 설정
  168 |     }

#--------------------------------------------------------------------------------


# File: backend/src/main/java/com/authentication/auth/filter/authorizationFilter.java
#=============================================================================

    1 | package com.authentication.auth.filter;
    2 | package com.authentication.auth.filter;
    3 | 
    4 | import com.authentication.auth.configuration.token.JwtUtility;
    5 | import com.fasterxml.jackson.databind.ObjectMapper;
    6 | import jakarta.annotation.PostConstruct;
    7 | import jakarta.servlet.Filter;
    8 | import jakarta.servlet.FilterChain;
    9 | import jakarta.servlet.ServletException;
   10 | import jakarta.servlet.http.HttpServletRequest;
   11 | import jakarta.servlet.http.HttpServletResponse;
   12 | import lombok.extern.slf4j.Slf4j;
   13 | import org.springframework.beans.factory.annotation.Autowired;
   14 | import org.springframework.http.HttpMethod;
   15 | import org.springframework.http.MediaType;
   16 | import org.springframework.security.authentication.UsernamePasswordAuthenticationToken;
   17 | import org.springframework.security.config.annotation.web.builders.HttpSecurity;
   18 | import org.springframework.security.core.Authentication;
   19 | import org.springframework.security.core.authority.SimpleGrantedAuthority;
   20 | import org.springframework.security.core.context.SecurityContextHolder;
   21 | import org.springframework.stereotype.Component;
   22 | 
   23 | import java.io.IOException;
   24 | import java.util.Collections;
   25 | import java.util.HashMap;
   26 | import java.util.Map;
   27 | import java.util.Set;
   28 | 
   29 | /**
   30 |  * @Author: choisimo
   31 |  * @Date: 2025-05-05
   32 |  * @Description: 권한 부여 필터
   33 |  * @Details: JWT 토큰의 유효성을 검증하고 사용자 권한을 검사하는 필터
   34 |  */
   35 | @Slf4j
   36 | @Component
   37 | public class authorizationFilter extends AbstractSecurityFilter {
   38 | 
   39 |     private final JwtUtility jwtUtility;
   40 |     private final ObjectMapper objectMapper;
   41 |     private final FilterRegistry filterRegistry;
   42 |     private final Set<String> adminRoles = Set.of("ROLE_ADMIN", "ADMIN");
   43 | 
   44 |     @Autowired
   45 |     public authorizationFilter(
   46 |             JwtUtility jwtUtility,
   47 |             ObjectMapper objectMapper,
   48 |             FilterRegistry filterRegistry) {
   49 |         super(SecurityFilterOrder.AUTHORIZATION_FILTER);
   50 |         this.jwtUtility = jwtUtility;
   51 |         this.objectMapper = objectMapper;
   52 |         this.filterRegistry = filterRegistry;
   53 |     }
   54 | 
   55 |     /**
   56 |      * 필터 초기화 및 레지스트리에 등록
   57 |      */
   58 |     @PostConstruct
   59 |     public void init() {
   60 |         // 필터 레지스트리에 이 필터 등록
   61 |         filterRegistry.registerFilter(this);
   62 | 
   63 |         // 기본 필터 조건 설정 - 공개 API는 권한 필터 적용하지 않음
   64 |         PathPatternFilterCondition publicApiCondition = new PathPatternFilterCondition(
   65 |                 "권한 확인 불필요 경로",
   66 |                 "/api/public/**",
   67 |                 "/api/auth/login",
   68 |                 "/api/auth/register",
   69 |                 "/api/auth/refresh",
   70 |                 "/swagger-ui/**",
   71 |                 "/v3/api-docs/**"
   72 |         );
   73 | 
   74 |         // 관리자 전용 API는 ADMIN 역할 필요
   75 |         PathPatternFilterCondition adminApiCondition = new PathPatternFilterCondition(
   76 |                 "관리자 전용 API",
   77 |                 "/api/admin/**"
   78 |         );
   79 | 
   80 |         // 필터 레지스트리에 조건 추가
   81 |         filterRegistry.addCondition(getFilterId(), publicApiCondition);
   82 |     }
   83 | 
   84 |     @Override
   85 |     protected void doFilterInternal(HttpServletRequest request, HttpServletResponse response, FilterChain chain)
   86 |             throws IOException, ServletException {
   87 |         
   88 |         String path = request.getRequestURI();
   89 |         log.debug("권한 부여 필터 실행: {}", path);
   90 |         
   91 |         try {
   92 |             // 토큰에서 인증 정보 추출
   93 |             String token = extractToken(request);
   94 |             
   95 |             if (token != null && jwtUtility.validateToken(token)) {
   96 |                 String username = jwtUtility.getUsernameFromToken(token);
   97 |                 Set<String> roles = jwtUtility.getRolesFromToken(token);
   98 |                 
   99 |                 // 관리자 전용 API 접근 제한
  100 |                 if (path.startsWith("/api/admin") && !hasAdminRole(roles)) {
  101 |                     sendForbiddenResponse(response, "관리자 권한이 필요합니다.");
  102 |                     return;
  103 |                 }
  104 |                 
  105 |                 // 인증 정보 설정
  106 |                 Authentication authentication = createAuthentication(username, roles);
  107 |                 SecurityContextHolder.getContext().setAuthentication(authentication);
  108 |                 
  109 |                 log.debug("사용자 '{}' 인증 성공, 권한: {}", username, roles);
  110 |             }
  111 |             
  112 |             chain.doFilter(request, response);
  113 |         } catch (Exception e) {
  114 |             log.error("권한 부여 필터 실행 중 오류 발생: {}", e.getMessage());
  115 |             sendErrorResponse(response, "인증 처리 중 오류가 발생했습니다: " + e.getMessage());
  116 |         } finally {
  117 |             // 이미 응답이 커밋되지 않은 경우에만 필터 체인 계속 진행
  118 |             if (!response.isCommitted()) {
  119 |                 chain.doFilter(request, response);
  120 |             }
  121 |         }
  122 |     }
  123 | 
  124 |     /**
  125 |      * 요청에서 JWT 토큰 추출
  126 |      */
  127 |     private String extractToken(HttpServletRequest request) {
  128 |         String authHeader = request.getHeader("Authorization");
  129 |         
  130 |         if (authHeader != null && authHeader.startsWith("Bearer ")) {
  131 |             return authHeader.substring(7);
  132 |         }
  133 |         
  134 |         return null;
  135 |     }
  136 | 
  137 |     /**
  138 |      * 사용자가 관리자 권한을 가지고 있는지 확인
  139 |      */
  140 |     private boolean hasAdminRole(Set<String> roles) {
  141 |         return roles.stream().anyMatch(adminRoles::contains);
  142 |     }
  143 | 
  144 |     /**
  145 |      * 인증 객체 생성
  146 |      */
  147 |     private Authentication createAuthentication(String username, Set<String> roles) {
  148 |         Set<SimpleGrantedAuthority> authorities = roles.stream()
  149 |                 .map(SimpleGrantedAuthority::new)
  150 |                 .collect(Collections.toSet());
  151 |         
  152 |         return new UsernamePasswordAuthenticationToken(
  153 |                 username, null, authorities);
  154 |     }
  155 | 
  156 |     /**
  157 |      * 권한 없음 응답 전송
  158 |      */
  159 |     private void sendForbiddenResponse(HttpServletResponse response, String message) throws IOException {
  160 |         response.setStatus(HttpServletResponse.SC_FORBIDDEN);
  161 |         response.setContentType(MediaType.APPLICATION_JSON_VALUE);
  162 |         
  163 |         Map<String, String> error = new HashMap<>();
  164 |         error.put("error", "접근 거부");
  165 |         error.put("message", message);
  166 |         
  167 |         objectMapper.writeValue(response.getOutputStream(), error);
  168 |     }
  169 | 
  170 |     /**
  171 |      * 오류 응답 전송
  172 |      */
  173 |     private void sendErrorResponse(HttpServletResponse response, String message) throws IOException {
  174 |         response.setStatus(HttpServletResponse.SC_UNAUTHORIZED);
  175 |         response.setContentType(MediaType.APPLICATION_JSON_VALUE);
  176 |         
  177 |         Map<String, String> error = new HashMap<>();
  178 |         error.put("error", "인증 오류");
  179 |         error.put("message", message);
  180 |         
  181 |         objectMapper.writeValue(response.getOutputStream(), error);
  182 |     }
  183 | 
  184 |     @Override
  185 |     protected boolean shouldSkipFilter(HttpServletRequest request) {
  186 |         return filterRegistry.shouldNotFilter(getFilterId(), request);
  187 |     }
  188 | 
  189 |     @Override
  190 |     public void configure(HttpSecurity http) throws Exception {
  191 |         http.addFilterAfter(this, JwtVerificationFilter.class);
  192 |         log.debug("권한 부여 필터 HttpSecurity에 구성됨");
  193 |     }
  194 | 
  195 |     @Override
  196 |     public Class<? extends Filter> getBeforeFilter() {
  197 |         return JwtVerificationFilter.class;
  198 |     }
  199 | 
  200 |     @Override
  201 |     public Class<? extends Filter> getAfterFilter() {
  202 |         return null;
  203 |     }
  204 | 
  205 |     /**
  206 |      * 필터에 새로운 조건 추가
  207 |      */
  208 |     public void addFilterCondition(FilterCondition condition) {
  209 |         filterRegistry.addCondition(getFilterId(), condition);
  210 |     }
  211 | 
  212 |     /**
  213 |      * 필터에서 조건 제거
  214 |      */
  215 |     public boolean removeFilterCondition(FilterCondition condition) {
  216 |         return filterRegistry.removeCondition(getFilterId(), condition);
  217 |     }
  218 | }
  219 | import com.authentication.auth.DTO.token.tokenDto;
  220 | import com.authentication.auth.DTO.users.loginRequest;
  221 | import com.authentication.auth.configuration.security.publicAPI;
  222 | import com.authentication.auth.configuration.token.jwtUtility;
  223 | import com.fasterxml.jackson.databind.ObjectMapper;
  224 | import jakarta.servlet.FilterChain;
  225 | import jakarta.servlet.ServletException;
  226 | import jakarta.servlet.http.Cookie;
  227 | import jakarta.servlet.http.HttpServletRequest;
  228 | import jakarta.servlet.http.HttpServletResponse;
  229 | import lombok.extern.slf4j.Slf4j;
  230 | import org.springframework.beans.factory.annotation.Value;
  231 | import org.springframework.security.core.Authentication;
  232 | import org.springframework.security.core.GrantedAuthority;
  233 | import org.springframework.security.core.context.SecurityContextHolder;
  234 | import org.springframework.web.filter.OncePerRequestFilter;
  235 | 
  236 | import java.io.IOException;
  237 | import java.io.PrintWriter;
  238 | import java.util.Collection;
  239 | import java.util.Collections;
  240 | import java.util.Map;
  241 | import java.util.Objects;
  242 | 
  243 | @Slf4j
  244 | public class authorizationFilter extends OncePerRequestFilter {
  245 | 
  246 |     @Value("${site.domain}")
  247 |     private String domain;
  248 | 
  249 |     @Value("${server.cookie.domain}")
  250 |     private String cookieDomain;
  251 | 
  252 |     @Value("${auth_proxy_header}")
  253 |     private String AuthorizedProxyHeader;
  254 | 
  255 | 
  256 |     private final jwtUtility  jwtUtility;
  257 |     private final redisService  redisService;
  258 |     private final ObjectMapper objectMapper;
  259 |     private final publicAPI apiChecker;
  260 |     public authorizationFilter(jwtUtility jwtUtility, redisService redisService, ObjectMapper objectMapper, publicAPI apiChecker) {
  261 |         this.jwtUtility = jwtUtility;
  262 |         this.redisService = redisService;
  263 |         this.objectMapper = objectMapper;
  264 |         this.apiChecker = apiChecker;
  265 |     }
  266 |     @Override
  267 |     protected boolean shouldNotFilter(HttpServletRequest request){
  268 |         // true 일 경우 filter 작동 skip.
  269 |         return apiChecker.checkRequestAPI(request);
  270 |     }
  271 | 
  272 | 
  273 |     @Override
  274 |     protected void doFilterInternal(HttpServletRequest request, HttpServletResponse response, FilterChain filterChain) throws ServletException, IOException {
  275 | 
  276 |         // Authorization Header 확인 : Bearer Token 확인
  277 |         String authorizationHeader = request.getHeader(SecurityConstants.TOKEN_HEADER);
  278 | 
  279 |         if (authorizationHeader == null || !authorizationHeader.startsWith("Bearer ")) {
  280 |             log.warn("Invalid or missing Authorization header. Skipping filter.");
  281 |             return;
  282 |         }
  283 | 
  284 |         log.info("╔═══════════════════════════════════════════════════════════════╗");
  285 |         log.info("║                       Authorization Filter                    ║");
  286 |         log.info("╚═══════════════════════════════════════════════════════════════╝");
  287 | 
  288 |         String RToken = null;
  289 |         if (requiresCookieCheck(request)) {
  290 |             RToken = checkCookie(request, response);
  291 | 
  292 |             if (RToken == null) {
  293 |                 log.error("cookie 필요 request 에 쿠키가 없어 401 오류를 반환합니다");
  294 |                 return;
  295 |             }
  296 |         }
  297 | 
  298 |         String provider = request.getHeader("provider");
  299 | 
  300 |         if (provider != null) {
  301 |             log.info("{} 의 토큰입니다.", provider);
  302 |         }
  303 | 
  304 |         if (!authorizationHeader.startsWith(SecurityConstants.TOKEN_PREFIX)){
  305 | 
  306 |             if (Objects.requireNonNull(RToken).isEmpty()) {
  307 |                 log.warn("refresh token 없음 -> 임시로 검사 안함 [수정 필요]");
  308 |                 filterChain.doFilter(request, response);
  309 |                 return;
  310 |             }
  311 | 
  312 |             // RToken 으로 AccessToken 찾기
  313 |             String findAccessToken = redisService.getAccessToken(RToken);
  314 | 
  315 |             if(findAccessToken != null && !findAccessToken.isEmpty()){
  316 |                 response.addHeader(SecurityConstants.TOKEN_HEADER,
  317 |                         SecurityConstants.TOKEN_PREFIX + findAccessToken);
  318 |             }
  319 | 
  320 |         }
  321 | 
  322 |         String JWT = null;
  323 |         if(authorizationHeader.startsWith(SecurityConstants.TOKEN_PREFIX)){
  324 |             JWT = authorizationHeader.split(" ")[1];
  325 |         }
  326 | 
  327 |         if(JWT == null) {
  328 |             filterChain.doFilter(request, response);
  329 |             return;
  330 |         }
  331 | 
  332 |         // 기존 JWT 검증 및 인증 처리
  333 |         // Authorized Token 생성 및 Response Header 에 추가
  334 |         if (jwtUtility.validateJWT(JWT)) {
  335 |             log.info("유효한 토큰입니다.");
  336 |             Authentication getAuth = authenticateUser(JWT);
  337 | 
  338 |             log.info("인증 정보 : {}", getAuth);
  339 |             // 인증 실패 처리
  340 |             if (getAuth != null && getAuth.isAuthenticated()) {
  341 |                 // 인증 성공: 필터 체인으로 요청 전달
  342 |                 response.setStatus(HttpServletResponse.SC_OK);
  343 |             } else {
  344 |                 // 인증 실패: 상태와 메시지 반환
  345 |                 sendResponseStatus(response, HttpServletResponse.SC_UNAUTHORIZED, "Authentication failed");
  346 |             }
  347 |             return;
  348 |         } else if (RToken == null) {
  349 |             log.error("there is no refreshToken in cookie");
  350 |             sendResponseStatus(response, HttpServletResponse.SC_UNAUTHORIZED, "no refresh token in cookie");
  351 |         } else if (jwtUtility.validateRefreshJWT(RToken)) {
  352 |             handleRefreshToken(request, response, filterChain, RToken, JWT);
  353 |         } else {
  354 |             sendResponseStatus(response, HttpServletResponse.SC_UNAUTHORIZED, "Invalid or expired JWT");
  355 |         }
  356 | 
  357 |         filterChain.doFilter(request, response);
  358 |     }
  359 | 
  360 |     private String checkCookie(HttpServletRequest request, HttpServletResponse response) throws IOException {
  361 |         Cookie[] cookies = request.getCookies();
  362 |         String RToken = null;
  363 |         if (cookies != null){
  364 |             for (Cookie cookie : cookies){
  365 |                 if (cookie.getName().equals("refreshToken")){
  366 |                     RToken = cookie.getValue();
  367 |                     break;
  368 |                 }
  369 |             }
  370 |         }
  371 |         if (RToken == null){
  372 |             sendResponseStatus(response, 403, "ㅠㅠㅠㅠㅠㅠㅠㅠㅠㅠㅠㅠㅠㅠㅠㅠㅠㅠㅠㅠㅠㅠㅠㅠㅠㅠㅠ");
  373 |         }
  374 |         return RToken;
  375 |     }
  376 | 
  377 | 
  378 |     private void sendResponseStatus(HttpServletResponse response, int status, String message)
  379 |             throws IOException{
  380 |         response.setStatus(status);
  381 |         PrintWriter writer = response.getWriter();
  382 |         response.setContentType("application/json");
  383 |         response.setCharacterEncoding("UTF-8");
  384 |         Map<String, String> responseBody = Collections.singletonMap("message", message);
  385 |         objectMapper.writeValue(response.getWriter(), responseBody);
  386 |     }
  387 | 
  388 |     private void sendFrontNewCookie(HttpServletResponse response, int status, tokenDto tokendto){
  389 |         response.setStatus(status);
  390 |         response.addHeader(SecurityConstants.TOKEN_HEADER, SecurityConstants.TOKEN_PREFIX + tokendto.getAccessToken());
  391 |         Cookie refreshTokenCookie = new Cookie("refreshToken", tokendto.getRefreshToken());
  392 |         refreshTokenCookie.setHttpOnly(true);
  393 |         refreshTokenCookie.setDomain(this.cookieDomain);
  394 |         refreshTokenCookie.setPath("/");
  395 |         response.addCookie(refreshTokenCookie);
  396 |     }
  397 | 
  398 |     private boolean RedisMatchRToken(String userId, String RToken){
  399 |         return redisService.findRToken(userId, "server", RToken);
  400 |     }
  401 | 
  402 | 
  403 |     private boolean requiresCookieCheck(HttpServletRequest request) {
  404 |         return !apiChecker.checkRequestAPI(request);
  405 |     }
  406 | 
  407 | 
  408 |     // JWT 토큰을 이용하여 사용자 인증 처리
  409 |     // Spring Security Context 에 인증 정보를 저장
  410 |     private Authentication authenticateUser(String JWT) {
  411 |         try {
  412 |             Authentication authentication = jwtUtility.getAuthentication(JWT);
  413 |             SecurityContextHolder.getContext().setAuthentication(authentication);
  414 |             return authentication;
  415 |         } catch (Exception e) {
  416 |             log.error("인증 실패");
  417 |             return null;
  418 |         }
  419 |     }
  420 | 
  421 |     private void handleRefreshToken(HttpServletRequest request, HttpServletResponse response, FilterChain filterChain, String RToken, String JWT) throws IOException, ServletException {
  422 |         Map<String, Object> pToken = jwtUtility.getClaimsFromAccessToken(JWT);
  423 |         String userId = (String) pToken.get("userId");
  424 | 
  425 |         if (RedisMatchRToken(userId, RToken)) {
  426 |             log.info("refresh token is exist in redis");
  427 |             tokenDto tokendto = jwtUtility.buildToken(userId, (String) pToken.get("nickname"), (Collection<? extends GrantedAuthority>) pToken.get("role"));
  428 | 
  429 |             if (redisService.changeRToken(userId, "server", RToken, tokendto.getRefreshToken())) {
  430 |                 log.info("access token and refresh token have been changed");
  431 |                 sendFrontNewCookie(response, HttpServletResponse.SC_CREATED, tokendto);
  432 |                 authenticateUser(tokendto.getAccessToken());
  433 |                 filterChain.doFilter(request, response);
  434 |             } else {
  435 |                 log.error("refresh token change failed");
  436 |                 sendResponseStatus(response, HttpServletResponse.SC_UNAUTHORIZED, "refresh token change failed");
  437 |             }
  438 |         } else {
  439 |             log.error("refresh token from redis does not exist");
  440 |             sendResponseStatus(response, HttpServletResponse.SC_UNAUTHORIZED, "refresh token from redis does not exist");
  441 |         }
  442 |     }
  443 | 
  444 | }

#--------------------------------------------------------------------------------


# File: backend/src/main/java/com/authentication/auth/filter/JwtVerificationFilter.java
#=============================================================================

    1 | package com.authentication.auth.filter;
    2 | package com.authentication.auth.filter;
    3 | 
    4 | import com.authentication.auth.configuration.token.JwtUtility;
    5 | import com.fasterxml.jackson.databind.ObjectMapper;
    6 | import jakarta.annotation.PostConstruct;
    7 | import jakarta.servlet.Filter;
    8 | import jakarta.servlet.FilterChain;
    9 | import jakarta.servlet.ServletException;
   10 | import jakarta.servlet.http.HttpServletRequest;
   11 | import jakarta.servlet.http.HttpServletResponse;
   12 | import lombok.extern.slf4j.Slf4j;
   13 | import org.springframework.beans.factory.annotation.Autowired;
   14 | import org.springframework.http.MediaType;
   15 | import org.springframework.security.authentication.UsernamePasswordAuthenticationToken;
   16 | import org.springframework.security.config.annotation.web.builders.HttpSecurity;
   17 | import org.springframework.security.core.authority.SimpleGrantedAuthority;
   18 | import org.springframework.security.core.context.SecurityContextHolder;
   19 | import org.springframework.stereotype.Component;
   20 | 
   21 | import java.io.IOException;
   22 | import java.util.HashMap;
   23 | import java.util.Map;
   24 | import java.util.Set;
   25 | import java.util.stream.Collectors;
   26 | 
   27 | /**
   28 |  * @Author: choisimo
   29 |  * @Date: 2025-05-05
   30 |  * @Description: JWT 토큰 검증 필터
   31 |  * @Details: 요청에 포함된 JWT 토큰을 검증하고 사용자 인증 정보를 설정
   32 |  */
   33 | @Slf4j
   34 | @Component
   35 | public class JwtVerificationFilter extends AbstractSecurityFilter {
   36 | 
   37 |     private final JwtUtility jwtUtility;
   38 |     private final ObjectMapper objectMapper;
   39 |     private final FilterRegistry filterRegistry;
   40 | 
   41 |     @Autowired
   42 |     public JwtVerificationFilter(
   43 |             JwtUtility jwtUtility,
   44 |             ObjectMapper objectMapper,
   45 |             FilterRegistry filterRegistry) {
   46 |         super(SecurityFilterOrder.JWT_VERIFICATION_FILTER);
   47 |         this.jwtUtility = jwtUtility;
   48 |         this.objectMapper = objectMapper;
   49 |         this.filterRegistry = filterRegistry;
   50 |     }
   51 | 
   52 |     /**
   53 |      * 필터 초기화 및 레지스트리에 등록
   54 |      */
   55 |     @PostConstruct
   56 |     public void init() {
   57 |         // 필터 레지스트리에 이 필터 등록
   58 |         filterRegistry.registerFilter(this);
   59 | 
   60 |         // 기본 필터 조건 설정 - 공개 API는 JWT 검증 필터 적용하지 않음
   61 |         PathPatternFilterCondition publicApiCondition = new PathPatternFilterCondition(
   62 |                 "JWT 검증 불필요 경로",
   63 |                 "/api/public/**",
   64 |                 "/api/auth/login",
   65 |                 "/api/auth/register",
   66 |                 "/api/auth/refresh",
   67 |                 "/swagger-ui/**",
   68 |                 "/v3/api-docs/**"
   69 |         );
   70 | 
   71 |         // 필터 레지스트리에 조건 추가
   72 |         filterRegistry.addCondition(getFilterId(), publicApiCondition);
   73 |     }
   74 | 
   75 |     @Override
   76 |     protected void doFilterInternal(HttpServletRequest request, HttpServletResponse response, FilterChain chain)
   77 |             throws IOException, ServletException {
   78 |         
   79 |         String path = request.getRequestURI();
   80 |         log.debug("JWT 검증 필터 실행: {}", path);
   81 |         
   82 |         try {
   83 |             String token = extractToken(request);
   84 |             
   85 |             if (token != null) {
   86 |                 if (jwtUtility.validateToken(token)) {
   87 |                     String username = jwtUtility.getUsernameFromToken(token);
   88 |                     Set<String> roles = jwtUtility.getRolesFromToken(token);
   89 |                     
   90 |                     // 권한 설정
   91 |                     Set<SimpleGrantedAuthority> authorities = roles.stream()
   92 |                             .map(SimpleGrantedAuthority::new)
   93 |                             .collect(Collectors.toSet());
   94 |                     
   95 |                     UsernamePasswordAuthenticationToken authToken = 
   96 |                             new UsernamePasswordAuthenticationToken(username, null, authorities);
   97 |                     
   98 |                     SecurityContextHolder.getContext().setAuthentication(authToken);
   99 |                     log.debug("JWT 토큰 검증 성공: {}", username);
  100 |                 } else {
  101 |                     log.warn("유효하지 않은 JWT 토큰");
  102 |                     sendErrorResponse(response, "유효하지 않은 토큰입니다.");
  103 |                     return;
  104 |                 }
  105 |             } else {
  106 |                 log.debug("JWT 토큰이 없음");
  107 |             }
  108 |             
  109 |             chain.doFilter(request, response);
  110 |         } catch (Exception e) {
  111 |             log.error("JWT 검증 중 오류 발생: {}", e.getMessage());
  112 |             SecurityContextHolder.clearContext();
  113 |             sendErrorResponse(response, "토큰 검증 중 오류가 발생했습니다: " + e.getMessage());
  114 |         }
  115 |     }
  116 | 
  117 |     /**
  118 |      * 요청에서 JWT 토큰 추출
  119 |      */
  120 |     private String extractToken(HttpServletRequest request) {
  121 |         String authHeader = request.getHeader("Authorization");
  122 |         
  123 |         if (authHeader != null && authHeader.startsWith("Bearer ")) {
  124 |             return authHeader.substring(7);
  125 |         }
  126 |         
  127 |         return null;
  128 |     }
  129 | 
  130 |     /**
  131 |      * 오류 응답 전송
  132 |      */
  133 |     private void sendErrorResponse(HttpServletResponse response, String message) throws IOException {
  134 |         response.setStatus(HttpServletResponse.SC_UNAUTHORIZED);
  135 |         response.setContentType(MediaType.APPLICATION_JSON_VALUE);
  136 |         
  137 |         Map<String, String> error = new HashMap<>();
  138 |         error.put("error", "인증 오류");
  139 |         error.put("message", message);
  140 |         
  141 |         objectMapper.writeValue(response.getOutputStream(), error);
  142 |     }
  143 | 
  144 |     @Override
  145 |     protected boolean shouldSkipFilter(HttpServletRequest request) {
  146 |         return filterRegistry.shouldNotFilter(getFilterId(), request);
  147 |     }
  148 | 
  149 |     @Override
  150 |     public void configure(HttpSecurity http) throws Exception {
  151 |         http.addFilterAfter(this, AuthenticationFilter.class);
  152 |         log.debug("JWT 검증 필터 HttpSecurity에 구성됨");
  153 |     }
  154 | 
  155 |     @Override
  156 |     public Class<? extends Filter> getBeforeFilter() {
  157 |         return AuthenticationFilter.class;
  158 |     }
  159 | 
  160 |     @Override
  161 |     public Class<? extends Filter> getAfterFilter() {
  162 |         return authorizationFilter.class;
  163 |     }
  164 | }
  165 | import com.authentication.auth.service.redis.RedisService;
  166 | import com.authentication.auth.utility.JwtUtility;
  167 | import com.fasterxml.jackson.databind.ObjectMapper;
  168 | import io.jsonwebtoken.Claims;
  169 | import io.jsonwebtoken.ExpiredJwtException;
  170 | import io.jsonwebtoken.JwtException;
  171 | import jakarta.servlet.FilterChain;
  172 | import jakarta.servlet.ServletException;
  173 | import jakarta.servlet.ServletRequest;
  174 | import jakarta.servlet.ServletResponse;
  175 | import jakarta.servlet.http.Cookie;
  176 | import jakarta.servlet.http.HttpServletRequest;
  177 | import jakarta.servlet.http.HttpServletResponse;
  178 | import lombok.RequiredArgsConstructor;
  179 | import lombok.extern.slf4j.Slf4j;
  180 | import org.springframework.http.HttpHeaders;
  181 | import org.springframework.http.HttpStatus;
  182 | import org.springframework.http.MediaType;
  183 | import org.springframework.security.authentication.UsernamePasswordAuthenticationToken;
  184 | import org.springframework.security.core.authority.SimpleGrantedAuthority;
  185 | import org.springframework.security.core.context.SecurityContextHolder;
  186 | import org.springframework.security.core.userdetails.UserDetailsService;
  187 | import org.springframework.security.web.authentication.WebAuthenticationDetailsSource;
  188 | import org.springframework.security.web.util.matcher.AntPathRequestMatcher;
  189 | import org.springframework.security.web.util.matcher.OrRequestMatcher;
  190 | import org.springframework.security.web.util.matcher.RequestMatcher;
  191 | import org.springframework.web.filter.OncePerRequestFilter;
  192 | 
  193 | import javax.security.auth.login.CredentialExpiredException;
  194 | import java.io.IOException;
  195 | import java.time.LocalDateTime;
  196 | import java.util.*;
  197 | import java.util.stream.Collectors;
  198 | 
  199 | /**
  200 |  * @Author: choisimo
  201 |  * @Date: 2025-05-05
  202 |  * @Description: JWT 토큰 검증 필터
  203 |  * @Details: 요청에서 JWT 토큰을 추출하고 유효성을 검사하는 필터
  204 |  * @Usage: Spring Security 필터 체인에 등록하여 사용
  205 |  */
  206 | @Slf4j
  207 | @RequiredArgsConstructor
  208 | public class JwtVerificationFilter extends OncePerRequestFilter implements PluggableFilter {
  209 |     
  210 |     private final JwtUtility jwtUtility;
  211 |     private final RedisService redisService;
  212 |     private final UserDetailsService userDetailsService;
  213 |     private final ObjectMapper objectMapper;
  214 |     private final RequestMatcher excludePathMatcher;
  215 | 
  216 |     /**
  217 |      * JWT 검증 필터 생성자
  218 |      * @param jwtUtility JWT 토큰 유틸리티
  219 |      * @param redisService Redis 서비스
  220 |      * @param userDetailsService 사용자 세부정보 서비스
  221 |      * @param objectMapper JSON 변환용 객체 매퍼
  222 |      * @param excludePaths 필터 적용을 제외할 경로 목록
  223 |      */
  224 |     public JwtVerificationFilter(JwtUtility jwtUtility, RedisService redisService, 
  225 |                                 UserDetailsService userDetailsService, ObjectMapper objectMapper,
  226 |                                 List<String> excludePaths) {
  227 |         this.jwtUtility = jwtUtility;
  228 |         this.redisService = redisService;
  229 |         this.userDetailsService = userDetailsService;
  230 |         this.objectMapper = objectMapper;
  231 |         
  232 |         // 제외 경로 패턴 매처 설정
  233 |         List<RequestMatcher> matchers = excludePaths.stream()
  234 |                 .map(path -> new AntPathRequestMatcher(path))
  235 |                 .collect(Collectors.toList());
  236 |         this.excludePathMatcher = new OrRequestMatcher(matchers.toArray(new RequestMatcher[0]));
  237 |     }
  238 | 
  239 |     /**
  240 |      * 필터 적용 여부 결정 메서드
  241 |      * 특정 경로는 JWT 검증에서 제외
  242 |      * @param request 현재 요청
  243 |      * @return 필터 적용 여부
  244 |      */
  245 |     @Override
  246 |     protected boolean shouldNotFilter(HttpServletRequest request) {
  247 |         return excludePathMatcher.matches(request);
  248 |     }
  249 |         
  250 |         @Override
  251 |         public void configure(HttpSecurity http) throws Exception {
  252 |             http.addFilterBefore(this, AuthorizationFilter.class);
  253 |         }
  254 |     
  255 |         @Override
  256 |         public int getOrder() {
  257 |             return 200; // AuthenticationFilter 다음 순서
  258 |         }
  259 |     
  260 |         @Override
  261 |         public Class<? extends Filter> getBeforeFilter() {
  262 |             return AuthenticationFilter.class;
  263 |         }
  264 |     
  265 |         @Override
  266 |         public Class<? extends Filter> getAfterFilter() {
  267 |             return AuthorizationFilter.class;
  268 |         }
  269 | 
  270 |     /**
  271 |      * JWT 토큰 검증 및 인증 처리 메서드
  272 |      * @param request 요청
  273 |      * @param response 응답
  274 |      * @param filterChain 필터 체인
  275 |      * @throws ServletException 서블릿 예외
  276 |      * @throws IOException IO 예외
  277 |      */
  278 |     @Override
  279 |     protected void doFilterInternal(HttpServletRequest request, HttpServletResponse response, FilterChain filterChain)
  280 |             throws ServletException, IOException {
  281 |         
  282 |         log.debug("JWT 검증 필터 시작: {}", request.getRequestURI());
  283 |         
  284 |         try {
  285 |             // 토큰 추출
  286 |             String token = extractToken(request);
  287 |             
  288 |             if (token == null) {
  289 |                 log.debug("토큰이 없음, 인증 생략");
  290 |                 filterChain.doFilter(request, response);
  291 |                 return;
  292 |             }
  293 |             
  294 |             // 토큰 유효성 검증
  295 |             if (jwtUtility.validateToken(token)) {
  296 |                 // 토큰에서 사용자 정보 추출
  297 |                 Claims claims = jwtUtility.getClaims(token);
  298 |                 String username = claims.getSubject();
  299 |                 
  300 |                 // 블랙리스트 확인 (로그아웃된 토큰인지)
  301 |                 String tokenId = claims.getId();
  302 |                 if (tokenId != null && redisService.hasKey("JWT_Blacklist_" + tokenId)) {
  303 |                     throw new CredentialExpiredException("로그아웃된 토큰입니다.");
  304 |                 }
  305 |                 
  306 |                 // 사용자 권한 추출
  307 |                 List<String> authorities = claims.get("authorities", List.class);
  308 |                 List<SimpleGrantedAuthority> grantedAuthorities = null;
  309 |                 
  310 |                 if (authorities != null) {
  311 |                     grantedAuthorities = authorities.stream()
  312 |                             .map(SimpleGrantedAuthority::new)
  313 |                             .collect(Collectors.toList());
  314 |                 }
  315 |                 
  316 |                 // 인증 객체 생성 및 설정
  317 |                 UsernamePasswordAuthenticationToken authentication = 
  318 |                         new UsernamePasswordAuthenticationToken(username, null, grantedAuthorities);
  319 |                 authentication.setDetails(new WebAuthenticationDetailsSource().buildDetails(request));
  320 |                 
  321 |                 // 보안 컨텍스트에 인증 객체 설정
  322 |                 SecurityContextHolder.getContext().setAuthentication(authentication);
  323 |                 log.debug("사용자 {} 인증 완료", username);
  324 |             }
  325 |             
  326 |             // 필터 체인 계속 진행
  327 |             filterChain.doFilter(request, response);
  328 |             
  329 |         } catch (ExpiredJwtException e) {
  330 |             log.warn("만료된 JWT 토큰: {}", e.getMessage());
  331 |             handleExpiredToken(request, response, e);
  332 |         } catch (JwtException | CredentialExpiredException e) {
  333 |             log.warn("유효하지 않은 JWT 토큰: {}", e.getMessage());
  334 |             handleInvalidToken(response, e);
  335 |         }
  336 |     }
  337 | 
  338 |     /**
  339 |      * 요청에서 JWT 토큰 추출 메서드
  340 |      * Authorization 헤더 또는 쿠키에서 토큰 추출
  341 |      * @param request HTTP 요청
  342 |      * @return 추출된 토큰 또는 null
  343 |      */
  344 |     private String extractToken(HttpServletRequest request) {
  345 |         // Authorization 헤더에서 토큰 추출 시도
  346 |         String bearerToken = request.getHeader(HttpHeaders.AUTHORIZATION);
  347 |         if (bearerToken != null && bearerToken.startsWith("Bearer ")) {
  348 |             return bearerToken.substring(7);
  349 |         }
  350 |         
  351 |         // 쿠키에서 토큰 추출 시도
  352 |         Cookie[] cookies = request.getCookies();
  353 |         if (cookies != null) {
  354 |             return Arrays.stream(cookies)
  355 |                     .filter(cookie -> "access_token".equals(cookie.getName()))
  356 |                     .map(Cookie::getValue)
  357 |                     .findFirst()
  358 |                     .orElse(null);
  359 |         }
  360 |         
  361 |         return null;
  362 |     }
  363 | 
  364 |     /**
  365 |      * 만료된 토큰 처리 메서드
  366 |      * 리프레시 토큰을 사용하여 새 액세스 토큰 발급 시도
  367 |      * @param request HTTP 요청
  368 |      * @param response HTTP 응답
  369 |      * @param e 만료 예외
  370 |      * @throws IOException IO 예외
  371 |      */
  372 |     private void handleExpiredToken(HttpServletRequest request, HttpServletResponse response, ExpiredJwtException e) 
  373 |             throws IOException {
  374 |         log.info("만료된 토큰 처리 시도");
  375 |         
  376 |         // 리프레시 토큰 추출
  377 |         String refreshToken = null;
  378 |         Cookie[] cookies = request.getCookies();
  379 |         
  380 |         if (cookies != null) {
  381 |             Optional<Cookie> refreshCookie = Arrays.stream(cookies)
  382 |                     .filter(cookie -> "refresh_token".equals(cookie.getName()))
  383 |                     .findFirst();
  384 |                     
  385 |             if (refreshCookie.isPresent()) {
  386 |                 refreshToken = refreshCookie.get().getValue();
  387 |             }
  388 |         }
  389 |         
  390 |         // 리프레시 토큰이 없거나 유효하지 않은 경우
  391 |         if (refreshToken == null || !jwtUtility.validateToken(refreshToken)) {
  392 |             handleInvalidToken(response, e);
  393 |             return;
  394 |         }
  395 |         
  396 |         try {
  397 |             // 리프레시 토큰에서 정보 추출
  398 |             Claims refreshClaims = jwtUtility.getClaims(refreshToken);
  399 |             String username = refreshClaims.getSubject();
  400 |             String tokenId = refreshClaims.getId();
  401 |             
  402 |             // Redis에서 리프레시 토큰 유효성 검증
  403 |             String redisKey = "JWT_RToken_" + username + "_" + tokenId;
  404 |             if (!redisService.hasKey(redisKey)) {
  405 |                 throw new JwtException("유효하지 않은 리프레시 토큰");
  406 |             }
  407 |             
  408 |             // 사용자 정보 로드 및 새 액세스 토큰 생성
  409 |             var userDetails = userDetailsService.loadUserByUsername(username);
  410 |             String newAccessToken = jwtUtility.generateAccessToken(username, userDetails.getAuthorities());
  411 |             
  412 |             // 새 액세스 토큰을 쿠키에 설정
  413 |             Cookie newAccessTokenCookie = new Cookie("access_token", newAccessToken);
  414 |             newAccessTokenCookie.setHttpOnly(true);
  415 |             newAccessTokenCookie.setSecure(true);
  416 |             newAccessTokenCookie.setPath("/");
  417 |             newAccessTokenCookie.setMaxAge((int) (jwtUtility.getAccessTokenExpiration() / 1000));
  418 |             response.addCookie(newAccessTokenCookie);
  419 |             
  420 |             // 클라이언트에게 토큰 갱신 응답
  421 |             Map<String, Object> tokenResponse = new HashMap<>();
  422 |             tokenResponse.put("status", "renewed");
  423 |             tokenResponse.put("message", "액세스 토큰이 갱신되었습니다");
  424 |             tokenResponse.put("timestamp", LocalDateTime.now().toString());
  425 |             
  426 |             response.setContentType(MediaType.APPLICATION_JSON_VALUE);
  427 |             response.setStatus(HttpStatus.OK.value());
  428 |             objectMapper.writeValue(response.getWriter(), tokenResponse);
  429 |             
  430 |             log.info("액세스 토큰 갱신 완료: 사용자 {}", username);
  431 |             
  432 |         } catch (Exception refreshError) {
  433 |             log.error("토큰 갱신 실패: {}", refreshError.getMessage());
  434 |             handleInvalidToken(response, refreshError);
  435 |         }
  436 |     }
  437 | 
  438 |     /**
  439 |      * 유효하지 않은 토큰 처리 메서드
  440 |      * 인증 오류 응답 반환
  441 |      * @param response HTTP 응답
  442 |      * @param e 예외
  443 |      * @throws IOException IO 예외
  444 |      */
  445 |     private void handleInvalidToken(HttpServletResponse response, Exception e) throws IOException {
  446 |         Map<String, Object> errorResponse = new HashMap<>();
  447 |         errorResponse.put("status", "error");
  448 |         errorResponse.put("message", "인증 오류: " + e.getMessage());
  449 |         errorResponse.put("timestamp", LocalDateTime.now().toString());
  450 |         
  451 |         response.setContentType(MediaType.APPLICATION_JSON_VALUE);
  452 |         response.setStatus(HttpStatus.UNAUTHORIZED.value());
  453 |         objectMapper.writeValue(response.getWriter(), errorResponse);
  454 |     }
  455 | 
  456 |     /**
  457 |      * PluggableFilter 인터페이스 구현
  458 |      * 필터 설정 메서드
  459 |      */
  460 |     @Override
  461 |     public void configure(HttpSecurity http) throws Exception {
  462 |         http.addFilterBefore(this, UsernamePasswordAuthenticationFilter.class);
  463 |     }
  464 | 
  465 |     /**
  466 |      * PluggableFilter 인터페이스 구현
  467 |      * 필터 순서 반환 메서드
  468 |      */
  469 |     @Override
  470 |     public int getOrder() {
  471 |         return 1; // JWT 검증은 다른 필터보다 먼저 실행되어야 함
  472 |     }
  473 | 
  474 |     /**
  475 |      * PluggableFilter 인터페이스 구현
  476 |      * 이 필터 이전에 적용될 필터 클래스 반환
  477 |      */
  478 |     @Override
  479 |     public Class<? extends Filter> getBeforeFilter() {
  480 |         return null; // 이 필터 이전에 적용될 특정 필터가 없음
  481 |     }
  482 | 
  483 |     /**
  484 |      * PluggableFilter 인터페이스 구현
  485 |      * 이 필터 이후에 적용될 필터 클래스 반환
  486 |      */
  487 |     @Override
  488 |     public Class<? extends Filter> getAfterFilter() {
  489 |         return UsernamePasswordAuthenticationFilter.class;
  490 |     }
  491 | }

#--------------------------------------------------------------------------------


# File: backend/src/main/java/com/authentication/auth/filter/PluggableFilter.java
#=============================================================================

    1 | package com.authentication.auth.filter;
    2 | import jakarta.servlet.Filter;
    3 | import org.springframework.security.config.annotation.web.builders.HttpSecurity;
    4 | package com.authentication.auth.filter;
    5 | 
    6 | import jakarta.servlet.Filter;
    7 | import org.springframework.security.config.annotation.web.builders.HttpSecurity;
    8 | 
    9 | /**
   10 |  * @Author: choisimo
   11 |  * @Date: 2025-05-05
   12 |  * @Description: 플러그형 필터 인터페이스
   13 |  * @Details: 동적으로 추가/제거 가능한 필터를 위한 인터페이스
   14 |  */
   15 | public interface PluggableFilter extends Filter {
   16 |     
   17 |     /**
   18 |      * HttpSecurity에 이 필터를 구성
   19 |      * @param http HttpSecurity 객체
   20 |      * @throws Exception 구성 중 예외 발생 시
   21 |      */
   22 |     void configure(HttpSecurity http) throws Exception;
   23 |     
   24 |     /**
   25 |      * 필터의 실행 순서 반환
   26 |      * 낮은 값이 높은 우선순위를 의미함
   27 |      * @return 필터 실행 순서
   28 |      */
   29 |     int getOrder();
   30 |     
   31 |     /**
   32 |      * 이 필터 이전에 실행되어야 하는 필터 클래스 반환
   33 |      * @return 이전 필터 클래스, 없으면 null
   34 |      */
   35 |     Class<? extends Filter> getBeforeFilter();
   36 |     
   37 |     /**
   38 |      * 이 필터 이후에 실행되어야 하는 필터 클래스 반환
   39 |      * @return 이후 필터 클래스, 없으면 null
   40 |      */
   41 |     Class<? extends Filter> getAfterFilter();
   42 |     
   43 |     /**
   44 |      * 필터 ID 반환 (기본 구현은 클래스명)
   45 |      * @return 필터 ID
   46 |      */
   47 |     default String getFilterId() {
   48 |         return this.getClass().getSimpleName();
   49 |     }
   50 | }
   51 | /**
   52 |  * @Author: choisimo
   53 |  * @Date: 2025-05-05
   54 |  * @Description: 플러그형 필터 인터페이스
   55 |  * @Details: Spring Security 필터 체인에 쉽게 통합될 수 있는 필터 정의
   56 |  */
   57 | public interface PluggableFilter extends Filter {
   58 |     
   59 |     /**
   60 |      * HttpSecurity 구성에 현재 필터를 추가
   61 |      * @param http HttpSecurity 구성 객체
   62 |      * @throws Exception 구성 중 발생할 수 있는 예외
   63 |      */
   64 |     void configure(HttpSecurity http) throws Exception;
   65 |     
   66 |     /**
   67 |      * 필터 체인 내 순서를 결정하는 우선순위 값
   68 |      * 값이 낮을수록 높은 우선순위(먼저 실행)를 가짐
   69 |      * @return 순서 값
   70 |      */
   71 |     int getOrder();
   72 |     
   73 |     /**
   74 |      * 이 필터 이전에 적용되어야 하는 필터 클래스
   75 |      * @return 이전 필터 클래스 또는 null
   76 |      */
   77 |     Class<? extends Filter> getBeforeFilter();
   78 |     
   79 |     /**
   80 |      * 이 필터 이후에 적용되어야 하는 필터 클래스
   81 |      * @return 이후 필터 클래스 또는 null
   82 |      */
   83 |     Class<? extends Filter> getAfterFilter();
   84 | }

#--------------------------------------------------------------------------------


# File: backend/src/main/java/com/authentication/auth/filter/FilterRegistry.java
#=============================================================================

    1 | package com.authentication.auth.filter;
    2 | 
    3 | import lombok.extern.slf4j.Slf4j;
    4 | import org.springframework.security.config.annotation.web.builders.HttpSecurity;
    5 | import org.springframework.stereotype.Component;
    6 | 
    7 | import java.util.*;
    8 | import java.util.concurrent.ConcurrentHashMap;
    9 | import java.util.concurrent.CopyOnWriteArrayList;
   10 | 
   11 | /**
   12 |  * @Author: choisimo
   13 |  * @Date: 2025-05-05
   14 |  * @Description: 필터 레지스트리
   15 |  * @Details: 보안 필터 등록 및 관리를 위한 중앙 레지스트리
   16 |  */
   17 | @Slf4j
   18 | @Component
   19 | public class FilterRegistry {
   20 | 
   21 |     // 필터 인스턴스 저장 맵 (필터 이름 -> 필터 인스턴스)
   22 |     private final Map<String, PluggableFilter> filterMap = new ConcurrentHashMap<>();
   23 |     
   24 |     // 필터 우선순위 순서대로 저장된 리스트
   25 |     private final List<PluggableFilter> orderedFilters = new CopyOnWriteArrayList<>();
   26 |     
   27 |     // 필터 조건 저장 맵 (필터 이름 -> 필터 조건 리스트)
   28 |     private final Map<String, List<FilterCondition>> filterConditions = new ConcurrentHashMap<>();
   29 | 
   30 |     /**
   31 |      * 필터 등록
   32 |      * @param filter 등록할 필터
   33 |      */
   34 |     public void registerFilter(PluggableFilter filter) {
   35 |         String filterName = filter.getClass().getSimpleName();
   36 |         filterMap.put(filterName, filter);
   37 |         
   38 |         // 우선순위에 따라 정렬된 위치에 필터 삽입
   39 |         insertFilterInOrder(filter);
   40 |         
   41 |         log.info("필터 등록 완료: {}, 우선순위: {}", filterName, filter.getOrder());
   42 |     }
   43 | 
   44 |     /**
   45 |      * 필터에 조건 추가
   46 |      * @param filterName 필터 이름
   47 |      * @param condition 필터 조건
   48 |      */
   49 |     public void addCondition(String filterName, FilterCondition condition) {
   50 |         filterConditions.computeIfAbsent(filterName, k -> new CopyOnWriteArrayList<>())
   51 |                         .add(condition);
   52 |         log.info("필터 '{}' 에 조건 추가: {}", filterName, condition.getDescription());
   53 |     }
   54 | 
   55 |     /**
   56 |      * 필터에 조건 제거
   57 |      * @param filterName 필터 이름
   58 |      * @param condition 제거할 조건
   59 |      * @return 제거 성공 여부
   60 |      */
   61 |     public boolean removeCondition(String filterName, FilterCondition condition) {
   62 |         List<FilterCondition> conditions = filterConditions.get(filterName);
   63 |         if (conditions != null) {
   64 |             boolean result = conditions.remove(condition);
   65 |             if (result) {
   66 |                 log.info("필터 '{}' 에서 조건 제거: {}", filterName, condition.getDescription());
   67 |             }
   68 |             return result;
   69 |         }
   70 |         return false;
   71 |     }
   72 | 
   73 |     /**
   74 |      * 필터 제거
   75 |      * @param filterName 제거할 필터 이름
   76 |      * @return 제거된 필터, 없으면 null
   77 |      */
   78 |     public PluggableFilter unregisterFilter(String filterName) {
   79 |         PluggableFilter filter = filterMap.remove(filterName);
   80 |         if (filter != null) {
   81 |             orderedFilters.remove(filter);
   82 |             filterConditions.remove(filterName);
   83 |             log.info("필터 제거 완료: {}", filterName);
   84 |         }
   85 |         return filter;
   86 |     }
   87 | 
   88 |     /**
   89 |      * 특정 요청에 대해 필터를 적용해야 하는지 확인
   90 |      * @param filterName 필터 이름
   91 |      * @param request HTTP 요청
   92 |      * @return true면 필터를 적용하지 않음, false면 필터 적용
   93 |      */
   94 |     public boolean shouldNotFilter(String filterName, jakarta.servlet.http.HttpServletRequest request) {
   95 |         List<FilterCondition> conditions = filterConditions.get(filterName);
   96 |         if (conditions == null || conditions.isEmpty()) {
   97 |             return false; // 조건이 없으면 항상 필터 적용
   98 |         }
   99 |         
  100 |         // 어느 하나의 조건이라도 true를 반환하면 필터를 적용하지 않음 (OR 조건)
  101 |         return conditions.stream().anyMatch(condition -> condition.shouldNotFilter(request));
  102 |     }
  103 | 
  104 |     /**
  105 |      * 우선순위에 따라 정렬된 위치에 필터 삽입
  106 |      * @param filter 삽입할 필터
  107 |      */
  108 |     private void insertFilterInOrder(PluggableFilter filter) {
  109 |         // 기존 필터가 있으면 제거
  110 |         orderedFilters.remove(filter);
  111 |         
  112 |         // 새 필터의 순서
  113 |         int newFilterOrder = filter.getOrder();
  114 |         
  115 |         int insertIndex = 0;
  116 |         while (insertIndex < orderedFilters.size() && 
  117 |                orderedFilters.get(insertIndex).getOrder() <= newFilterOrder) {
  118 |             insertIndex++;
  119 |         }
  120 |         
  121 |         orderedFilters.add(insertIndex, filter);
  122 |     }
  123 | 
  124 |     /**
  125 |      * 등록된 모든 필터를 SecurityConfig에 등록
  126 |      * @param http HttpSecurity 객체
  127 |      * @throws Exception 설정 중 예외 발생 시
  128 |      */
  129 |     public void registerFilters(HttpSecurity http) throws Exception {
  130 |         for (PluggableFilter filter : orderedFilters) {
  131 |             filter.configure(http);
  132 |             log.debug("필터 구성 적용: {}", filter.getClass().getSimpleName());
  133 |         }
  134 |         log.info("총 {}개의 필터가 SecurityConfig에 등록됨", orderedFilters.size());
  135 |     }
  136 | 
  137 |     /**
  138 |      * 등록된 모든 필터 목록 반환
  139 |      * @return 필터 목록
  140 |      */
  141 |     public List<PluggableFilter> getRegisteredFilters() {
  142 |         return Collections.unmodifiableList(orderedFilters);
  143 |     }
  144 |     
  145 |     /**
  146 |      * 특정 필터 조회
  147 |      * @param filterName 필터 이름
  148 |      * @return 찾은 필터, 없으면 null
  149 |      */
  150 |     public PluggableFilter getFilter(String filterName) {
  151 |         return filterMap.get(filterName);
  152 |     }
  153 | }

#--------------------------------------------------------------------------------


# File: backend/src/main/java/com/authentication/auth/filter/README.md
#=============================================================================

    1 | # 인증(Authentication) 및 인가(Authorization) 필터 시스템
    2 | 
    3 | ## 개요
    4 | 이 시스템은 Jakarta EE와 Spring Security를 기반으로 하며, 플러그형 필터 아키텍처를 사용하여 인증 및 인가 로직을 분리하고 확장 가능하게 구현합니다.
    5 | 
    6 | ## 플러그형 필터 아키텍처
    7 | 
    8 | ### 구조적 특징
    9 | - `PluggableFilter` 인터페이스: 모든 필터의 기본 인터페이스로, 필터 순서와 의존성을 정의
   10 | - `filterRegistry`: 필터 등록 및 순서 관리를 위한 클래스
   11 | - 위상 정렬(Topological Sort): 필터 간 의존성을 고려한 실행 순서 결정
   12 | 
   13 | ### 주요 인증/인가 필터
   14 | 
   15 | #### 1. 인증(Authentication) 필터
   16 | - **AuthenticationFilter**: 사용자 로그인 및 자격 증명 검증 담당
   17 | - **JwtVerificationFilter**: JWT 토큰 유효성 검증 담당
   18 | - **SnsRequestFilter**: 소셜 로그인 요청 처리 담당
   19 | 
   20 | #### 2. 인가(Authorization) 필터
   21 | - **AuthorizationFilter**: 사용자 권한 확인 및 접근 제어 담당
   22 | - **RoleBasedAccessFilter**: 역할 기반 리소스 접근 제어 담당
   23 | 
   24 | ## 필터 적용 흐름
   25 | 1. 요청 접수
   26 | 2. 인증(Authentication) 필터를 통한 사용자 신원 확인
   27 |    - JWT 토큰 검증 또는 소셜 로그인 인증
   28 |    - 인증 성공 시 `SecurityContext`에 인증 정보 설정
   29 | 3. 인가(Authorization) 필터를 통한 권한 확인
   30 |    - 사용자 역할 및 권한 확인
   31 |    - 접근 가능한 리소스인지 검증
   32 | 4. 적절한 권한이 있는 경우 요청 처리, 없는 경우 접근 거부
   33 | 
   34 | ## 필터 등록 방법
   35 | 
   36 | 필터를 등록하려면 다음 단계를 따르세요:
   37 | 
   38 | 1. `PluggableFilter` 인터페이스를 구현한 필터 클래스 작성
   39 | 2. 필터의 우선순위(`getOrder()`) 및 의존 관계(`getBeforeFilter()`, `getAfterFilter()`) 정의
   40 | 3. Spring Bean으로 등록하여 자동으로 `filterRegistry`에 등록되도록 함
   41 | 
   42 | ## 확장 및 커스터마이징
   43 | 
   44 | 새로운 인증/인가 방식을 추가하려면:
   45 | 
   46 | 1. `PluggableFilter` 인터페이스를 구현한 새 필터 클래스 생성
   47 | 2. 적절한 실행 순서와 의존성 정의
   48 | 3. Spring Bean으로 등록
   49 | 
   50 | ## 주의사항
   51 | - 필터 간 순환 의존성이 없도록 주의해야 함
   52 | - 성능을 위해 불필요한 필터 중복 적용 방지
   53 | - 보안에 민감한 경로는 항상 적절한 인증/인가 필터를 통과하도록 설정

#--------------------------------------------------------------------------------


# File: backend/src/main/java/com/authentication/auth/filter/AuthorizationFilter.java
#=============================================================================

    1 | package com.authentication.auth.filter;
    2 | 
    3 | import jakarta.servlet.FilterChain;
    4 | import jakarta.servlet.ServletException;
    5 | import jakarta.servlet.http.HttpServletRequest;
    6 | import jakarta.servlet.http.HttpServletResponse;
    7 | import lombok.RequiredArgsConstructor;
    8 | import lombok.extern.slf4j.Slf4j;
    9 | import org.springframework.security.access.AccessDeniedException;
   10 | import org.springframework.security.core.Authentication;
   11 | import org.springframework.security.core.GrantedAuthority;
   12 | import org.springframework.security.core.context.SecurityContextHolder;
   13 | import org.springframework.security.web.access.intercept.AuthorizationFilter;
   14 | import org.springframework.security.web.util.matcher.AntPathRequestMatcher;
   15 | import org.springframework.security.web.util.matcher.RequestMatcher;
   16 | import org.springframework.stereotype.Component;
   17 | import org.springframework.web.filter.OncePerRequestFilter;
   18 | 
   19 | import java.io.IOException;
   20 | import java.util.Collection;
   21 | import java.util.HashMap;
   22 | import java.util.List;
   23 | import java.util.Map;
   24 | 
   25 | /**
   26 |  * @Author: choisimo
   27 |  * @Date: 2025-05-05
   28 |  * @Description: 인가 필터
   29 |  * @Details: 사용자의 권한에 따라 특정 리소스 접근 제어를 담당하는 필터
   30 |  */
   31 | @Slf4j
   32 | @Component
   33 | @RequiredArgsConstructor
   34 | public class AuthorizationFilter extends OncePerRequestFilter implements PluggableFilter {
   35 | 
   36 |     // URL 패턴별 필요 권한 매핑
   37 |     private final Map<RequestMatcher, List<String>> urlAuthorizationMap = new HashMap<>();
   38 |     
   39 |     // 생성자에서 URL 패턴별 필요 권한 초기화
   40 |     public AuthorizationFilter() {
   41 |         // 예시: 관리자 전용 URL 패턴
   42 |         urlAuthorizationMap.put(
   43 |             new AntPathRequestMatcher("/admin/**"),
   44 |             List.of("ROLE_ADMIN")
   45 |         );
   46 |         
   47 |         // 예시: 사용자 및 관리자 접근 가능 URL 패턴
   48 |         urlAuthorizationMap.put(
   49 |             new AntPathRequestMatcher("/api/users/**"),
   50 |             List.of("ROLE_USER", "ROLE_ADMIN")
   51 |         );
   52 |     }
   53 | 
   54 |     @Override
   55 |     protected void doFilterInternal(HttpServletRequest request, HttpServletResponse response,
   56 |                                    FilterChain filterChain) throws ServletException, IOException {
   57 |         Authentication authentication = SecurityContextHolder.getContext().getAuthentication();
   58 |         
   59 |         // 인증 정보가 없거나 익명 사용자인 경우 바로 통과 (인증 필터에서 처리)
   60 |         if (authentication == null || !authentication.isAuthenticated()) {
   61 |             filterChain.doFilter(request, response);
   62 |             return;
   63 |         }
   64 |         
   65 |         // URL 패턴별 권한 확인
   66 |         for (Map.Entry<RequestMatcher, List<String>> entry : urlAuthorizationMap.entrySet()) {
   67 |             if (entry.getKey().matches(request)) {
   68 |                 if (!hasAnyAuthority(authentication.getAuthorities(), entry.getValue())) {
   69 |                     log.warn("접근 권한 없음. 사용자: {}, URL: {}", authentication.getName(), request.getRequestURI());
   70 |                     throw new AccessDeniedException("접근 권한이 없습니다.");
   71 |                 }
   72 |                 break;
   73 |             }
   74 |         }
   75 |         
   76 |         // 권한 검사를 통과하면 다음 필터로 진행
   77 |         filterChain.doFilter(request, response);
   78 |     }
   79 |     
   80 |     // 사용자가 필요한 권한 중 하나라도 가지고 있는지 확인
   81 |     private boolean hasAnyAuthority(Collection<? extends GrantedAuthority> authorities, List<String> requiredAuthorities) {
   82 |         return authorities.stream()
   83 |                 .map(GrantedAuthority::getAuthority)
   84 |                 .anyMatch(requiredAuthorities::contains);
   85 |     }
   86 |     
   87 |     @Override
   88 |     public void configure(HttpSecurity http) throws Exception {
   89 |         http.addFilterAfter(this, JwtVerificationFilter.class);
   90 |     }
   91 | 
   92 |     @Override
   93 |     public int getOrder() {
   94 |         return 300; // JwtVerificationFilter 다음 순서
   95 |     }
   96 | 
   97 |     @Override
   98 |     public Class<? extends Filter> getBeforeFilter() {
   99 |         return JwtVerificationFilter.class;
  100 |     }
  101 | 
  102 |     @Override
  103 |     public Class<? extends Filter> getAfterFilter() {
  104 |         return null; // 이 필터 이후에 실행되어야 하는 특정 필터가 없음
  105 |     }
  106 | }

#--------------------------------------------------------------------------------


# File: backend/src/main/java/com/authentication/auth/filter/ApiChecker.java
#=============================================================================

    1 | package com.authentication.auth.filter;
    2 | 
    3 | import jakarta.servlet.http.HttpServletRequest;
    4 | import lombok.extern.slf4j.Slf4j;
    5 | import org.springframework.stereotype.Component;
    6 | 
    7 | import java.util.Arrays;
    8 | import java.util.List;
    9 | 
   10 | /**
   11 |  * 필터 적용 여부를 결정하는 API 요청 검사 클래스
   12 |  */
   13 | @Slf4j
   14 | @Component
   15 | public class ApiChecker {
   16 | 
   17 |     // 인증 필터를 적용하지 않을 공개 경로 목록
   18 |     private final List<String> PUBLIC_PATHS = Arrays.asList(
   19 |         "/api/auth/login",
   20 |         "/api/auth/register",
   21 |         "/api/auth/refresh",
   22 |         "/swagger-ui",
   23 |         "/v3/api-docs",
   24 |         "/h2-console",
   25 |         "/error",
   26 |         "/favicon.ico"
   27 |     );
   28 | 
   29 |     /**
   30 |      * 요청이 필터를 적용하지 않아도 되는지 검사
   31 |      * @param request HTTP 요청
   32 |      * @return true일 경우 필터 적용 제외
   33 |      */
   34 |     public boolean checkRequestAPI(HttpServletRequest request) {
   35 |         String requestURI = request.getRequestURI();
   36 |         
   37 |         // 허용된 경로인지 확인
   38 |         for (String path : PUBLIC_PATHS) {
   39 |             if (requestURI.startsWith(path)) {
   40 |                 log.debug("필터 적용 제외 경로: {}", requestURI);
   41 |                 return true;
   42 |             }
   43 |         }
   44 |         
   45 |         // OPTIONS 메서드는 필터링 제외 (CORS preflight 요청)
   46 |         if ("OPTIONS".equalsIgnoreCase(request.getMethod())) {
   47 |             return true;
   48 |         }
   49 |         
   50 |         return false;
   51 |     }
   52 | }

#--------------------------------------------------------------------------------


# File: backend/src/main/java/com/authentication/auth/filter/filterRegistry.java
#=============================================================================

    1 | package com.authentication.auth.filter;
    2 | package com.authentication.auth.filter;
    3 | 
    4 | import com.authentication.auth.service.redis.RedisService;
    5 | import com.authentication.auth.utility.JwtUtility;
    6 | import com.fasterxml.jackson.databind.ObjectMapper;
    7 | import lombok.extern.slf4j.Slf4j;
    8 | import org.springframework.beans.factory.annotation.Value;
    9 | import org.springframework.context.annotation.Bean;
   10 | import org.springframework.context.annotation.Configuration;
   11 | import org.springframework.security.authentication.AuthenticationManager;
   12 | import org.springframework.security.config.annotation.web.builders.HttpSecurity;
   13 | import org.springframework.security.core.userdetails.UserDetailsService;
   14 | 
   15 | import java.util.ArrayList;
   16 | import java.util.Arrays;
   17 | import java.util.List;
   18 | 
   19 | /**
   20 |  * @Author: choisimo
   21 |  * @Date: 2025-05-05
   22 |  * @Description: 필터 레지스트리 구성 클래스
   23 |  * @Details: 애플리케이션에서 사용할 보안 필터를 등록하고 관리합니다.
   24 |  */
   25 | @Slf4j
   26 | @Configuration
   27 | public class FilterRegistry {
   28 | 
   29 |     @Value("${application.domain:localhost}")
   30 |     private String domain;
   31 | 
   32 |     @Value("${application.cookie.domain:localhost}")
   33 |     private String cookieDomain;
   34 | 
   35 |     /**
   36 |      * JWT 검증 필터 빈 생성
   37 |      * @param jwtUtility JWT 유틸리티
   38 |      * @param redisService Redis 서비스
   39 |      * @param userDetailsService 사용자 세부 정보 서비스
   40 |      * @param objectMapper 객체 매퍼
   41 |      * @return 구성된 JWT 검증 필터
   42 |      */
   43 |     @Bean
   44 |     public JwtVerificationFilter jwtVerificationFilter(
   45 |             JwtUtility jwtUtility,
   46 |             RedisService redisService,
   47 |             UserDetailsService userDetailsService,
   48 |             ObjectMapper objectMapper) {
   49 |         
   50 |         List<String> excludePaths = Arrays.asList(
   51 |             "/api/auth/login",
   52 |             "/api/auth/register",
   53 |             "/api/auth/password/reset",
   54 |             "/api/health",
   55 |             "/swagger-ui/**",
   56 |             "/v3/api-docs/**",
   57 |             "/error"
   58 |         );
   59 |         
   60 |         log.info("JWT 검증 필터 등록. 제외 경로: {}", excludePaths);
   61 |         return new JwtVerificationFilter(jwtUtility, redisService, userDetailsService, objectMapper, excludePaths);
   62 |     }
   63 | 
   64 |     /**
   65 |      * 인증 필터 빈 생성
   66 |      * @param authenticationManager 인증 관리자
   67 |      * @param jwtUtility JWT 유틸리티
   68 |      * @param objectMapper 객체 매퍼
   69 |      * @param redisService Redis 서비스
   70 |      * @return 구성된 인증 필터
   71 |      */
   72 |     @Bean
   73 |     public AuthenticationFilter authenticationFilter(
   74 |             AuthenticationManager authenticationManager,
   75 |             JwtUtility jwtUtility,
   76 |             ObjectMapper objectMapper,
   77 |             RedisService redisService) {
   78 |         
   79 |         log.info("인증 필터 등록. 도메인: {}, 쿠키 도메인: {}", domain, cookieDomain);
   80 |         return new AuthenticationFilter(authenticationManager, jwtUtility, objectMapper, redisService, domain, cookieDomain);
   81 |     }
   82 | 
   83 |     /**
   84 |      * 모든 필터를 등록하여 보안 구성에 적용
   85 |      * @param http HTTP 보안 구성
   86 |      * @param filters 등록할 필터 목록
   87 |      * @throws Exception 보안 구성 예외
   88 |      */
   89 |     public void registerFilters(HttpSecurity http, List<PluggableFilter> filters) throws Exception {
   90 |         log.info("{} 필터 등록 중...", filters.size());
   91 |         
   92 |         // 필터를 order 기준으로 정렬
   93 |         filters.sort((f1, f2) -> Integer.compare(f1.getOrder(), f2.getOrder()));
   94 |         
   95 |         // 각 필터를 구성에 적용
   96 |         for (PluggableFilter filter : filters) {
   97 |             log.debug("필터 등록: {}, 순서: {}", filter.getClass().getSimpleName(), filter.getOrder());
   98 |             filter.configure(http);
   99 |         }
  100 |     }
  101 | 
  102 |     /**
  103 |      * 구성 가능한 모든 필터 수집
  104 |      * @param authenticationFilter 인증 필터
  105 |      * @param jwtVerificationFilter JWT 검증 필터
  106 |      * @return 구성 가능한 필터 목록
  107 |      */
  108 |     @Bean
  109 |     public List<PluggableFilter> pluggableFilters(
  110 |             AuthenticationFilter authenticationFilter,
  111 |             JwtVerificationFilter jwtVerificationFilter) {
  112 |         
  113 |         List<PluggableFilter> filters = new ArrayList<>();
  114 |         filters.add(jwtVerificationFilter);
  115 |         filters.add(authenticationFilter);
  116 |         
  117 |         log.info("총 {} 필터가 등록되었습니다.", filters.size());
  118 |         return filters;
  119 |     }
  120 | }
  121 | import java.util.ArrayList;
  122 | import java.util.Collections;
  123 | import java.util.HashMap;
  124 | import java.util.LinkedList;
  125 | import java.util.List;
  126 | import java.util.Map;
  127 | import java.util.Queue;
  128 | 
  129 | import org.springframework.security.config.annotation.web.builders.HttpSecurity;
  130 | import org.springframework.security.web.authentication.UsernamePasswordAuthenticationFilter;
  131 | import org.springframework.stereotype.Component;
  132 | import org.springframework.web.filter.GenericFilterBean;
  133 | 
  134 | import jakarta.servlet.FilterChain;
  135 | import jakarta.servlet.ServletException;
  136 | import jakarta.servlet.ServletRequest;
  137 | import jakarta.servlet.ServletResponse;
  138 | import jakarta.servlet.Filter;
  139 | import java.io.IOException;
  140 | 
  141 | /**
  142 |  * @Author : choisimo 
  143 |  * @Date : 2025-05-05
  144 |  * @Description : filterRegistry class
  145 |  * @Details : 등록된 필터들을 순서대로 등록하는 클래스 (order 기반)
  146 |  * @Usage : Spring Security 의 addFilterBefore, addFilterAfter, addFilter 메소드를 사용하여 필터를 등록할 때 사용
  147 |  */
  148 | 
  149 | @Component
  150 | @RequiredArgsConstructor
  151 | @Slf4j
  152 | public class filterRegistry {
  153 |     private final List<PluggableFilter> filters = new ArrayList<>();
  154 |     
  155 |     @Autowired
  156 |     public filterRegistry(List<PluggableFilter> pluggableFilters) {
  157 |         // 자동으로 모든 PluggableFilter 구현체를 주입받음
  158 |         this.filters.addAll(pluggableFilters);
  159 |         log.info("총 {} 개의 필터가 등록되었습니다.", filters.size());
  160 |     }
  161 | 
  162 |     public void addFilter(PluggableFilter filter) {
  163 |         filters.add(filter);
  164 |     }
  165 | 
  166 |     /**
  167 |      * 정렬된 필터를 Spring Security 필터 체인에 등록합니다.
  168 |      * 필터 순서는 위상 정렬 알고리즘을 통해 결정됩니다.
  169 |      * @param http HttpSecurity 구성 객체
  170 |      * @throws Exception 구성 중 발생할 수 있는 예외
  171 |      */
  172 |     public void configureFilters(HttpSecurity http) throws Exception {
  173 |         List<PluggableFilter> sortedFilters = topologicalSort();
  174 |         
  175 |         for (PluggableFilter filter : sortedFilters) {
  176 |             log.info("필터 등록: {}, 순서: {}", filter.getClass().getSimpleName(), filter.getOrder());
  177 |             filter.configure(http);
  178 |         }
  179 |     }
  180 |     
  181 |     /**
  182 |      * 필터 의존성을 기반으로 위상 정렬을 수행합니다.
  183 |      * @return 정렬된 필터 목록
  184 |      */
  185 |     private List<PluggableFilter> topologicalSort() {
  186 |         Map<Class<?>, PluggableFilter> filterMap = new HashMap<>();
  187 |         Map<PluggableFilter, List<PluggableFilter>> graph = new HashMap<>();
  188 |         Set<PluggableFilter> visited = new HashSet<>();
  189 |         List<PluggableFilter> result = new ArrayList<>();
  190 |         
  191 |         // 필터 맵 초기화
  192 |         for (PluggableFilter filter : filters) {
  193 |             filterMap.put(filter.getClass(), filter);
  194 |             graph.put(filter, new ArrayList<>());
  195 |         }
  196 |         
  197 |         // 그래프 구성
  198 |         for (PluggableFilter filter : filters) {
  199 |             // 이 필터 이전에 실행되어야 하는 필터
  200 |             Class<? extends Filter> beforeFilter = filter.getBeforeFilter();
  201 |             if (beforeFilter != null && filterMap.containsKey(beforeFilter)) {
  202 |                 graph.get(filterMap.get(beforeFilter)).add(filter);
  203 |             }
  204 |             
  205 |             // 이 필터 이후에 실행되어야 하는 필터
  206 |             Class<? extends Filter> afterFilter = filter.getAfterFilter();
  207 |             if (afterFilter != null && filterMap.containsKey(afterFilter)) {
  208 |                 graph.get(filter).add(filterMap.get(afterFilter));
  209 |             }
  210 |         }
  211 |         
  212 |         // DFS를 통한 위상 정렬
  213 |         for (PluggableFilter filter : filters) {
  214 |             if (!visited.contains(filter)) {
  215 |                 dfs(filter, graph, visited, result);
  216 |             }
  217 |         }
  218 |         
  219 |         // 순서(Order) 기반 추가 정렬
  220 |         result.sort(Comparator.comparingInt(PluggableFilter::getOrder));
  221 |         
  222 |         return result;
  223 |     }
  224 |     
  225 |     /**
  226 |      * 깊이 우선 탐색을 통한 위상 정렬 수행
  227 |      */
  228 |     private void dfs(PluggableFilter filter, Map<PluggableFilter, List<PluggableFilter>> graph,
  229 |                      Set<PluggableFilter> visited, List<PluggableFilter> result) {
  230 |         visited.add(filter);
  231 |         
  232 |         for (PluggableFilter dependency : graph.get(filter)) {
  233 |             if (!visited.contains(dependency)) {
  234 |                 dfs(dependency, graph, visited, result);
  235 |             }
  236 |         }
  237 |         
  238 |         result.add(filter);
  239 |     }
  240 | }
  241 |      */
  242 |     public void registerFilters(HttpSecurity http) throws Exception {
  243 |         List<PluggableFilter> sortedFilters = topologicalSort(filters);
  244 |         
  245 |         for (PluggableFilter filter : sortedFilters) {
  246 |             try {
  247 |                 if (filter.getBeforeFilter() != null) {
  248 |                     // 지정된 필터 이전에 실행
  249 |                     http.addFilterBefore(
  250 |                         new FilterWrapper(filter), 
  251 |                         (Class<? extends Filter>) filter.getBeforeFilter()
  252 |                     );
  253 |                 } else if (filter.getAfterFilter() != null) {
  254 |                     // 지정된 필터 이후에 실행
  255 |                     http.addFilterAfter(
  256 |                         new FilterWrapper(filter), 
  257 |                         (Class<? extends Filter>) filter.getAfterFilter()
  258 |                     );
  259 |                 } else {
  260 |                     // 기본 순서로 실행 (UsernamePasswordAuthenticationFilter 위치)
  261 |                     http.addFilterBefore(new FilterWrapper(filter), UsernamePasswordAuthenticationFilter.class);
  262 |                 }
  263 |             } catch (Exception e) {
  264 |                 throw new RuntimeException("Filter registration failed: " + filter.getClass().getSimpleName(), e);
  265 |             }
  266 |         }
  267 |     }
  268 | 
  269 |     private List<PluggableFilter> topologicalSort(List<PluggableFilter> filters) {
  270 | 
  271 |         // 그래프 인접 리스트 생성
  272 |         Map<Class<?>, List<Class<?>>> adjacencyList = new HashMap<>();
  273 |         
  274 |         // 각 필터의 진입 차수 저장
  275 |         Map<Class<?>, Integer> inDegree = new HashMap<>();
  276 | 
  277 |         // 필터 클래스를 필터 인스턴스에 매핑
  278 |         Map<Class<?>, PluggableFilter> filterMap = new HashMap<>();    
  279 | 
  280 | 
  281 |         // 그래프와 진입 차수 초기화
  282 |         for (PluggableFilter filter : filters) {
  283 |             Class<?> filterClass = filter.getClass();
  284 |             adjacencyList.putIfAbsent(filterClass, new ArrayList<>());
  285 |             inDegree.putIfAbsent(filterClass, 0);
  286 |             filterMap.put(filterClass, filter);
  287 |         }
  288 | 
  289 |     // before/after 관계를 기반으로 그래프 구축
  290 |     for (PluggableFilter filter : filters) {
  291 |         Class<?> filterClass = filter.getClass();
  292 |         
  293 |         if (filter.getBeforeFilter() != null) {
  294 |             // A가 B 이전에 오면, A에서 B로 간선 추가
  295 |             adjacencyList.get(filterClass).add(filter.getBeforeFilter());
  296 |             inDegree.merge(filter.getBeforeFilter(), 1, Integer::sum);
  297 |         }
  298 |         
  299 |         if (filter.getAfterFilter() != null) {
  300 |             // A가 B 이후에 오면, B에서 A로 간선 추가
  301 |             adjacencyList.putIfAbsent(filter.getAfterFilter(), new ArrayList<>());
  302 |             adjacencyList.get(filter.getAfterFilter()).add(filterClass);
  303 |             inDegree.merge(filterClass, 1, Integer::sum);
  304 |         }
  305 |     }
  306 |     
  307 |     // 위상 정렬 수행
  308 |     return performKahnsAlgorithm(adjacencyList, inDegree, filterMap);
  309 | }
  310 | 
  311 | private List<PluggableFilter> performKahnsAlgorithm(
  312 |         Map<Class<?>, List<Class<?>>> adjacencyList,
  313 |         Map<Class<?>, Integer> inDegree,
  314 |         Map<Class<?>, PluggableFilter> filterMap) {
  315 |     
  316 |     List<PluggableFilter> sortedFilters = new ArrayList<>();
  317 |     Queue<Class<?>> queue = new LinkedList<>();
  318 |     
  319 |     // 진입 차수가 0인 노드(의존성이 없는 필터)부터 시작
  320 |     for (Map.Entry<Class<?>, Integer> entry : inDegree.entrySet()) {
  321 |         if (entry.getValue() == 0) {
  322 |             queue.add(entry.getKey());
  323 |         }
  324 |     }
  325 |     
  326 |     // 위상 정렬 순서대로 노드 처리
  327 |     while (!queue.isEmpty()) {
  328 |         Class<?> current = queue.poll();
  329 |         PluggableFilter filter = filterMap.get(current);
  330 |         
  331 |         if (filter != null) {
  332 |             sortedFilters.add(filter);
  333 |         }
  334 |         
  335 |         // 각 종속 필터의 진입 차수를 감소시키고 준비됐는지 확인
  336 |         for (Class<?> dependent : adjacencyList.getOrDefault(current, Collections.emptyList())) {
  337 |             inDegree.put(dependent, inDegree.get(dependent) - 1);
  338 |             if (inDegree.get(dependent) == 0) {
  339 |                 queue.add(dependent);
  340 |             }
  341 |         }
  342 |     }
  343 |     
  344 |     // 종속성 그래프에 순환이 있는지 확인
  345 |     if (sortedFilters.size() != filterMap.size()) {
  346 |         throw new IllegalStateException("필터 간에 순환 의존성이 감지되었습니다");
  347 |     }
  348 |     
  349 |     return sortedFilters;
  350 | }
  351 | 
  352 | /**
  353 |  * 필터 어댑터 클래스
  354 |  * Spring Security Filter와 PluggableFilter 간의 호환성 제공
  355 |  */
  356 | private static class FilterWrapper extends GenericFilterBean {
  357 |     private final PluggableFilter delegate;
  358 | 
  359 |     public FilterWrapper(PluggableFilter delegate) {
  360 |         this.delegate = delegate;
  361 |     }
  362 | 
  363 |     @Override
  364 |     public void doFilter(
  365 |         ServletRequest request,
  366 |         ServletResponse response,
  367 |         FilterChain chain
  368 |     ) throws ServletException, IOException {
  369 |         delegate.doFilter(request, response, chain);
  370 |     }
  371 | }
  372 | }

#--------------------------------------------------------------------------------


# File: backend/src/main/java/com/authentication/auth/filter/AuthenticationFilter.java
#=============================================================================

    1 | package com.authentication.auth.filter;
    2 | 
    3 | import com.authentication.auth.configuration.token.JwtUtility;
    4 | import com.authentication.auth.service.RedisService;
    5 | import com.fasterxml.jackson.databind.ObjectMapper;
    6 | import jakarta.servlet.Filter;
    7 | import jakarta.servlet.FilterChain;
    8 | import jakarta.servlet.ServletException;
    9 | import jakarta.servlet.http.Cookie;
   10 | import jakarta.servlet.http.HttpServletRequest;
   11 | import jakarta.servlet.http.HttpServletResponse;
   12 | import lombok.extern.slf4j.Slf4j;
   13 | import org.springframework.security.authentication.AuthenticationManager;
   14 | import org.springframework.security.authentication.UsernamePasswordAuthenticationToken;
   15 | import org.springframework.security.config.annotation.web.builders.HttpSecurity;
   16 | import org.springframework.security.core.Authentication;
   17 | import org.springframework.security.core.AuthenticationException;
   18 | import org.springframework.security.core.context.SecurityContextHolder;
   19 | import org.springframework.security.core.userdetails.UserDetails;
   20 | import org.springframework.stereotype.Component;
   21 | 
   22 | import java.io.IOException;
   23 | import java.util.HashMap;
   24 | package com.authentication.auth.filter;
   25 | 
   26 | import com.authentication.auth.configuration.token.JwtUtility;
   27 | import com.authentication.auth.service.RedisService;
   28 | import com.fasterxml.jackson.databind.ObjectMapper;
   29 | import jakarta.annotation.PostConstruct;
   30 | import jakarta.servlet.Filter;
   31 | import jakarta.servlet.FilterChain;
   32 | import jakarta.servlet.ServletException;
   33 | import jakarta.servlet.http.Cookie;
   34 | import jakarta.servlet.http.HttpServletRequest;
   35 | import jakarta.servlet.http.HttpServletResponse;
   36 | import lombok.extern.slf4j.Slf4j;
   37 | import org.springframework.beans.factory.annotation.Autowired;
   38 | import org.springframework.http.HttpMethod;
   39 | import org.springframework.security.authentication.AuthenticationManager;
   40 | import org.springframework.security.authentication.UsernamePasswordAuthenticationToken;
   41 | import org.springframework.security.config.annotation.web.builders.HttpSecurity;
   42 | import org.springframework.security.core.Authentication;
   43 | import org.springframework.security.core.AuthenticationException;
   44 | import org.springframework.security.core.context.SecurityContextHolder;
   45 | import org.springframework.security.core.userdetails.UserDetails;
   46 | import org.springframework.stereotype.Component;
   47 | 
   48 | import java.io.IOException;
   49 | import java.util.HashMap;
   50 | import java.util.Map;
   51 | 
   52 | /**
   53 |  * @Author: choisimo
   54 |  * @Date: 2025-05-05
   55 |  * @Description: 사용자 인증 필터
   56 |  * @Details: 사용자 로그인 요청을 처리하고 JWT 토큰을 생성하는 필터의 구체적인 구현
   57 |  *          유동적인 필터 조건 지원을 위해 개선됨
   58 |  */
   59 | @Slf4j
   60 | @Component
   61 | public class AuthenticationFilter extends AbstractAuthenticationFilter {
   62 |     
   63 |     private final FilterRegistry filterRegistry;
   64 |     
   65 |     @Autowired
   66 |     public AuthenticationFilter(
   67 |             AuthenticationManager authenticationManager,
   68 |             JwtUtility jwtUtility,
   69 |             ObjectMapper objectMapper,
   70 |             RedisService redisService,
   71 |             String domain,
   72 |             String cookieDomain,
   73 |             FilterRegistry filterRegistry) {
   74 |         super(authenticationManager, jwtUtility, objectMapper, redisService, domain, cookieDomain);
   75 |         this.filterRegistry = filterRegistry;
   76 |         setFilterProcessesUrl("/api/auth/login"); // 로그인 URL 설정
   77 |     }
   78 |     
   79 |     /**
   80 |      * 필터 초기화 및 레지스트리에 등록
   81 |      */
   82 |     @PostConstruct
   83 |     public void init() {
   84 |         // 필터 레지스트리에 이 필터 등록
   85 |         filterRegistry.registerFilter(this);
   86 |         
   87 |         // 기본 필터 조건 설정 - 공개 API는 인증 필터 적용하지 않음
   88 |         PathPatternFilterCondition publicApiCondition = new PathPatternFilterCondition(
   89 |                 "공개 API 경로 제외",
   90 |                 "/api/public/**", 
   91 |                 "/api/auth/register", 
   92 |                 "/api/auth/refresh",
   93 |                 "/swagger-ui/**", 
   94 |                 "/v3/api-docs/**"
   95 |         );
   96 |         
   97 |         // 로그인 경로에는 POST 메소드만 허용하고 다른 메소드는 필터링
   98 |         PathPatternFilterCondition loginPathCondition = new PathPatternFilterCondition(
   99 |                 "로그인 경로 메소드 제한",
  100 |                 new HttpMethod[] {HttpMethod.GET, HttpMethod.PUT, HttpMethod.DELETE},
  101 |                 "/api/auth/login"
  102 |         );
  103 |         
  104 |         // 필터 레지스트리에 조건 추가
  105 |         filterRegistry.addCondition(getFilterId(), publicApiCondition);
  106 |         filterRegistry.addCondition(getFilterId(), loginPathCondition);
  107 |     }
  108 | 
  109 |     @Override
  110 |     public Authentication attemptAuthentication(HttpServletRequest request, HttpServletResponse response) 
  111 |             throws AuthenticationException {
  112 |         // 필터 적용 여부 검사
  113 |         if (shouldNotFilter(request)) {
  114 |             log.debug("인증 필터 적용되지 않음: {}", request.getRequestURI());
  115 |             return null;
  116 |         }
  117 |         
  118 |         log.info("인증 시도: {}", request.getRequestURI());
  119 |         return super.attemptAuthentication(request, response);
  120 |     }
  121 | 
  122 |     @Override
  123 |     protected void successfulAuthentication(HttpServletRequest request, HttpServletResponse response,
  124 |                                            FilterChain chain, Authentication authResult) throws IOException, ServletException {
  125 |         log.info("로그인 성공: 토큰 생성 시작");
  126 |         
  127 |         UserDetails userDetails = (UserDetails) authResult.getPrincipal();
  128 |         String username = userDetails.getUsername();
  129 |         
  130 |         // 액세스 및 리프레시 토큰 생성
  131 |         String accessToken = jwtUtility.generateAccessToken(username);
  132 |         String refreshToken = jwtUtility.generateRefreshToken(username);
  133 |         
  134 |         // 리프레시 토큰을 Redis에 저장
  135 |         redisService.setData("RT:" + username, refreshToken, jwtUtility.getRefreshTokenExpirationTime());
  136 |         
  137 |         // 토큰을 쿠키에 저장
  138 |         Cookie accessTokenCookie = new Cookie("access_token", accessToken);
  139 |         accessTokenCookie.setHttpOnly(true);
  140 |         accessTokenCookie.setPath("/");
  141 |         accessTokenCookie.setDomain(cookieDomain);
  142 |         accessTokenCookie.setSecure(true);
  143 |         
  144 |         Cookie refreshTokenCookie = new Cookie("refresh_token", refreshToken);
  145 |         refreshTokenCookie.setHttpOnly(true);
  146 |         refreshTokenCookie.setPath("/");
  147 |         refreshTokenCookie.setDomain(cookieDomain);
  148 |         refreshTokenCookie.setSecure(true);
  149 |         
  150 |         response.addCookie(accessTokenCookie);
  151 |         response.addCookie(refreshTokenCookie);
  152 |         
  153 |         // 응답 본문에도 토큰 정보 포함
  154 |         Map<String, String> tokens = new HashMap<>();
  155 |         tokens.put("access_token", accessToken);
  156 |         tokens.put("refresh_token", refreshToken);
  157 |         tokens.put("username", username);
  158 |         
  159 |         response.setContentType("application/json");
  160 |         objectMapper.writeValue(response.getOutputStream(), tokens);
  161 |         
  162 |         // SecurityContext에 인증 정보 설정
  163 |         SecurityContextHolder.getContext().setAuthentication(authResult);
  164 |         
  165 |         log.info("로그인 성공: 토큰 생성 완료 및 쿠키 설정");
  166 |     }
  167 |     
  168 |     @Override
  169 |     protected void unsuccessfulAuthentication(HttpServletRequest request, HttpServletResponse response,
  170 |                                              AuthenticationException failed) throws IOException, ServletException {
  171 |         log.error("로그인 실패: {}", failed.getMessage());
  172 |         
  173 |         SecurityContextHolder.clearContext();
  174 |         
  175 |         response.setStatus(HttpServletResponse.SC_UNAUTHORIZED);
  176 |         response.setContentType("application/json");
  177 |         
  178 |         Map<String, String> error = new HashMap<>();
  179 |         error.put("error", "인증 실패");
  180 |         error.put("message", failed.getMessage());
  181 |         
  182 |         objectMapper.writeValue(response.getOutputStream(), error);
  183 |     }
  184 |     
  185 |     /**
  186 |      * 동적 필터 조건을 통해 필터 적용 여부 결정
  187 |      */
  188 |     protected boolean shouldNotFilter(HttpServletRequest request) {
  189 |         return filterRegistry.shouldNotFilter(getFilterId(), request);
  190 |     }
  191 |     
  192 |     @Override
  193 |     public void configure(HttpSecurity http) throws Exception {
  194 |         http.addFilterAt(this, AbstractAuthenticationFilter.class);
  195 |         log.debug("인증 필터 HttpSecurity에 구성됨");
  196 |     }
  197 |     
  198 |     @Override
  199 |     public int getOrder() {
  200 |         return SecurityFilterOrder.AUTHENTICATION_FILTER.getOrder();
  201 |     }
  202 |     
  203 |     @Override
  204 |     public Class<? extends Filter> getBeforeFilter() {
  205 |         return null; // 이 필터 이전에 실행되어야 하는 필터가 없음
  206 |     }
  207 |     
  208 |     @Override
  209 |     public Class<? extends Filter> getAfterFilter() {
  210 |         return JwtVerificationFilter.class; // JWT 검증 필터 이전에 실행
  211 |     }
  212 |     
  213 |     /**
  214 |      * 필터에 새로운 조건 추가
  215 |      * @param condition 추가할 필터 조건
  216 |      */
  217 |     public void addFilterCondition(FilterCondition condition) {
  218 |         filterRegistry.addCondition(getFilterId(), condition);
  219 |     }
  220 |     
  221 |     /**
  222 |      * 필터에서 조건 제거
  223 |      * @param condition 제거할 필터 조건
  224 |      * @return 제거 성공 여부
  225 |      */
  226 |     public boolean removeFilterCondition(FilterCondition condition) {
  227 |         return filterRegistry.removeCondition(getFilterId(), condition);
  228 |     }
  229 | }
  230 |             String cookieDomain,
  231 |             ApiChecker apiChecker) {
  232 |         super(authenticationManager, jwtUtility, objectMapper, redisService, domain, cookieDomain);
  233 |         this.apiChecker = apiChecker;
  234 |         setFilterProcessesUrl("/api/auth/login"); // 로그인 URL 설정
  235 |     }
  236 |     
  237 |     @Override
  238 |     public Authentication attemptAuthentication(HttpServletRequest request, HttpServletResponse response) 
  239 |             throws AuthenticationException {
  240 |         // 부모 클래스의 인증 메소드 호출
  241 |         return super.attemptAuthentication(request, response);
  242 |     }
  243 | 
  244 |     @Override
  245 |     protected void successfulAuthentication(HttpServletRequest request, HttpServletResponse response,
  246 |                                            FilterChain chain, Authentication authResult) throws IOException, ServletException {
  247 |         log.info("로그인 성공: 토큰 생성 시작");
  248 |         
  249 |         UserDetails userDetails = (UserDetails) authResult.getPrincipal();
  250 |         String username = userDetails.getUsername();
  251 |         
  252 |         // 액세스 및 리프레시 토큰 생성
  253 |         String accessToken = jwtUtility.generateAccessToken(username);
  254 |         String refreshToken = jwtUtility.generateRefreshToken(username);
  255 |         
  256 |         // 리프레시 토큰을 Redis에 저장
  257 |         redisService.setData("RT:" + username, refreshToken, jwtUtility.getRefreshTokenExpirationTime());
  258 |         
  259 |         // 토큰을 쿠키에 저장
  260 |         Cookie accessTokenCookie = new Cookie("access_token", accessToken);
  261 |         accessTokenCookie.setHttpOnly(true);
  262 |         accessTokenCookie.setPath("/");
  263 |         accessTokenCookie.setDomain(cookieDomain);
  264 |         accessTokenCookie.setSecure(true);
  265 |         
  266 |         Cookie refreshTokenCookie = new Cookie("refresh_token", refreshToken);
  267 |         refreshTokenCookie.setHttpOnly(true);
  268 |         refreshTokenCookie.setPath("/");
  269 |         refreshTokenCookie.setDomain(cookieDomain);
  270 |         refreshTokenCookie.setSecure(true);
  271 |         
  272 |         response.addCookie(accessTokenCookie);
  273 |         response.addCookie(refreshTokenCookie);
  274 |         
  275 |         // 응답 본문에도 토큰 정보 포함
  276 |         Map<String, String> tokens = new HashMap<>();
  277 |         tokens.put("access_token", accessToken);
  278 |         tokens.put("refresh_token", refreshToken);
  279 |         
  280 |         response.setContentType("application/json");
  281 |         objectMapper.writeValue(response.getOutputStream(), tokens);
  282 |         
  283 |         // SecurityContext에 인증 정보 설정
  284 |         SecurityContextHolder.getContext().setAuthentication(authResult);
  285 |         
  286 |         log.info("로그인 성공: 토큰 생성 완료 및 쿠키 설정");
  287 |     }
  288 |     
  289 |     @Override
  290 |     protected void unsuccessfulAuthentication(HttpServletRequest request, HttpServletResponse response,
  291 |                                              AuthenticationException failed) throws IOException, ServletException {
  292 |         log.error("로그인 실패: {}", failed.getMessage());
  293 |         
  294 |         SecurityContextHolder.clearContext();
  295 |         
  296 |         response.setStatus(HttpServletResponse.SC_UNAUTHORIZED);
  297 |         response.setContentType("application/json");
  298 |         
  299 |         Map<String, String> error = new HashMap<>();
  300 |         error.put("error", "인증 실패");
  301 |         error.put("message", failed.getMessage());
  302 |         
  303 |         objectMapper.writeValue(response.getOutputStream(), error);
  304 |     }
  305 |     
  306 |     @Override
  307 |     public void configure(HttpSecurity http) throws Exception {
  308 |         http.addFilterAt(this, AbstractAuthenticationFilter.class);
  309 |     }
  310 |     
  311 |     @Override
  312 |     public int getOrder() {
  313 |         return 100; // 기본 인증 필터 순서
  314 |     }
  315 |     
  316 |     @Override
  317 |     public Class<? extends Filter> getBeforeFilter() {
  318 |         return null; // 이 필터 이전에 실행되어야 하는 필터가 없음
  319 |     }
  320 |     
  321 |     @Override
  322 |     public Class<? extends Filter> getAfterFilter() {
  323 |         return JwtVerificationFilter.class; // JWT 검증 필터 이전에 실행
  324 |     }
  325 | }
  326 |     
  327 |     /**
  328 |      * extends와 implements 복수 사용에 관한 설명:
  329 |      * 
  330 |      * 1. 다중 상속 구조:
  331 |      *    - Java에서는 단일 상속만 가능합니다(extends는 한 클래스만 가능)
  332 |      *    - 하지만 복수의 인터페이스 구현(implements)은 가능합니다
  333 |      *    - 추상 클래스 예제에서는 UsernamePasswordAuthenticationFilter를 상속하면서
  334 |      *      PluggableFilter 인터페이스를 구현하는 방식을 사용했습니다
  335 |      * 
  336 |      * 2. 장점:
  337 |      *    - 상속(extends)을 통해 기존 클래스의 기능을 재사용
  338 |      *    - 인터페이스 구현(implements)을 통해 다양한 계약을 준수
  339 |      *    - 유연한 설계 가능: 하나의 클래스가 다양한 역할 수행 가능
  340 |      * 
  341 |      * 3. 단점:
  342 |      *    - 복잡한 상속 구조는 코드 이해를 어렵게 만들 수 있음
  343 |      *    - 다이아몬드 문제 발생 가능(상속 계층이 복잡할 때)
  344 |      *    - 상위 클래스 변경 시 하위 클래스에 영향
  345 |      * 
  346 |      * 4. 구체적 구현 클래스에서는:
  347 |      *    - AbstractSecurityFilter를 상속하는 더 단순한 구조 채택
  348 |      *    - 명확한 책임과 역할 분리로 유지보수성 향상
  349 |      */

#--------------------------------------------------------------------------------


# File: backend/src/main/java/com/authentication/auth/filter/SecurityFilterOrder.java
#=============================================================================

    1 | package com.authentication.auth.filter;
    2 | 
    3 | /**
    4 |  * @Author: choisimo
    5 |  * @Date: 2025-05-05
    6 |  * @Description: 보안 필터 순서 상수
    7 |  * @Details: 필터 체인 내에서 필터의 실행 순서를 정의하는 열거형
    8 |  */
    9 | public enum SecurityFilterOrder {
   10 |     
   11 |     // 값이 낮을수록 먼저 실행됨
   12 |     REQUEST_LOGGING_FILTER(50),
   13 |     CORS_FILTER(100),
   14 |     CSRF_FILTER(200),
   15 |     AUTHENTICATION_FILTER(300),
   16 |     JWT_VERIFICATION_FILTER(400),
   17 |     AUTHORIZATION_FILTER(500),
   18 |     SESSION_MANAGEMENT_FILTER(600),
   19 |     EXCEPTION_TRANSLATION_FILTER(700);
   20 |     
   21 |     private final int order;
   22 |     
   23 |     SecurityFilterOrder(int order) {
   24 |         this.order = order;
   25 |     }
   26 |     
   27 |     public int getOrder() {
   28 |         return order;
   29 |     }
   30 | }

#--------------------------------------------------------------------------------


# File: backend/src/main/java/com/authentication/auth/filter/SnsRequestFilter.java
#=============================================================================

    1 | package com.authentication.auth.filter;
    2 | 
    3 | import jakarta.servlet.FilterChain;
    4 | import jakarta.servlet.ServletException;
    5 | import jakarta.servlet.http.HttpServletRequest;
    6 | import jakarta.servlet.http.HttpServletResponse;
    7 | import lombok.RequiredArgsConstructor;
    8 | import lombok.extern.slf4j.Slf4j;
    9 | import org.springframework.stereotype.Component;
   10 | 
   11 | import java.io.IOException;
   12 | 
   13 | /**
   14 |  * SNS 로그인 요청 처리 필터
   15 |  * 소셜 미디어 인증 요청을 처리하고 리다이렉션
   16 |  */
   17 | @Slf4j
   18 | @Component
   19 | @RequiredArgsConstructor
   20 | public class SnsRequestFilter extends AbstractSecurityFilter {
   21 | 
   22 |     private final ApiChecker apiChecker;
   23 | 
   24 |     public SnsRequestFilter(ApiChecker apiChecker) {
   25 |         super(SecurityFilterOrder.SNS_REQUEST_FILTER);
   26 |         this.apiChecker = apiChecker;
   27 |     }
   28 | 
   29 |     @Override
   30 |     protected void doFilterInternal(HttpServletRequest request, HttpServletResponse response, FilterChain chain)
   31 |             throws IOException, ServletException {
   32 |         
   33 |         String requestURI = request.getRequestURI();
   34 |         
   35 |         // SNS 인증 관련 경로 처리
   36 |         if (requestURI.startsWith("/api/auth/social/")) {
   37 |             // SNS 제공자 추출 (예: /api/auth/social/google)
   38 |             String provider = requestURI.substring("/api/auth/social/".length());
   39 |             
   40 |             log.debug("SNS 인증 요청 감지: {}", provider);
   41 |             
   42 |             // SNS 별 인증 처리 로직 구현
   43 |             // 예: 요청 파라미터 검증, 리다이렉션 URL 생성 등
   44 |             
   45 |             // 인증 코드가 포함된 경우 토큰 교환 처리
   46 |             String code = request.getParameter("code");
   47 |             if (code != null && !code.isEmpty()) {
   48 |                 log.debug("인증 코드 처리: {}", code);
   49 |                 // 인증 코드로 액세스 토큰 교환 로직 구현
   50 |             }
   51 |         }
   52 |         
   53 |         // 다음 필터로 요청 전달
   54 |         chain.doFilter(request, response);
   55 |     }
   56 | 
   57 |     @Override
   58 |     protected boolean shouldNotFilter(HttpServletRequest request) {
   59 |         String requestURI = request.getRequestURI();
   60 |         
   61 |         // SNS 인증 경로만 필터링
   62 |         if (requestURI.startsWith("/api/auth/social/")) {
   63 |             return false; // 필터 적용
   64 |         }
   65 |         
   66 |         // 다른 모든 경로는 이 필터를 건너뜀
   67 |         return true;
   68 |     }
   69 | }

#--------------------------------------------------------------------------------


# File: backend/src/main/java/com/authentication/auth/filter/AbstractSecurityFilter.java
#=============================================================================

    1 | package com.authentication.auth.filter;
    2 | 
    3 | import jakarta.servlet.Filter;
    4 | import jakarta.servlet.FilterChain;
    5 | import jakarta.servlet.ServletException;
    6 | import jakarta.servlet.ServletRequest;
    7 | import jakarta.servlet.ServletResponse;
    8 | import jakarta.servlet.http.HttpServletRequest;
    9 | import jakarta.servlet.http.HttpServletResponse;
   10 | import lombok.extern.slf4j.Slf4j;
   11 | 
   12 | import java.io.IOException;
   13 | 
   14 | /**
   15 |  * 모든 보안 필터의 기본 추상 클래스
   16 |  * 필터 실행 흐름 제어 및 공통 기능 제공
   17 |  */
   18 | @Slf4j
   19 | public abstract class AbstractSecurityFilter implements Filter {
   20 | 
   21 |     private final SecurityFilterOrder filterOrder;
   22 | 
   23 |     protected AbstractSecurityFilter(SecurityFilterOrder filterOrder) {
   24 |         this.filterOrder = filterOrder;
   25 |     }
   26 | 
   27 |     @Override
   28 |     public void doFilter(ServletRequest request, ServletResponse response, FilterChain chain)
   29 |             throws IOException, ServletException {
   30 |         
   31 |         HttpServletRequest httpRequest = (HttpServletRequest) request;
   32 |         HttpServletResponse httpResponse = (HttpServletResponse) response;
   33 |         
   34 |         // 필터 건너뛰기 여부 확인
   35 |         if (shouldNotFilter(httpRequest)) {
   36 |             chain.doFilter(request, response);
   37 |             return;
   38 |         }
   39 |         
   40 |         try {
   41 |             log.debug("필터 시작: {}", filterOrder.name());
   42 |             doFilterInternal(httpRequest, httpResponse, chain);
   43 |             log.debug("필터 종료: {}", filterOrder.name());
   44 |         } catch (Exception e) {
   45 |             log.error("필터 실행 중 오류 발생: {}", filterOrder.name(), e);
   46 |             handleFilterException(httpRequest, httpResponse, e);
   47 |         }
   48 |     }
   49 |     
   50 |     /**
   51 |      * 필터의 주요 비즈니스 로직 구현
   52 |      */
   53 |     protected abstract void doFilterInternal(HttpServletRequest request, HttpServletResponse response, 
   54 |                                            FilterChain chain) throws IOException, ServletException;
   55 |     
   56 |     package com.authentication.auth.filter;
   57 |     
   58 |     import jakarta.servlet.Filter;
   59 |     import jakarta.servlet.FilterChain;
   60 |     import jakarta.servlet.ServletException;
   61 |     import jakarta.servlet.ServletRequest;
   62 |     import jakarta.servlet.ServletResponse;
   63 |     import jakarta.servlet.http.HttpServletRequest;
   64 |     import jakarta.servlet.http.HttpServletResponse;
   65 |     import lombok.extern.slf4j.Slf4j;
   66 |     import org.springframework.web.filter.OncePerRequestFilter;
   67 |     
   68 |     import java.io.IOException;
   69 |     
   70 |     /**
   71 |      * @Author: choisimo
   72 |      * @Date: 2025-05-05
   73 |      * @Description: 추상 보안 필터
   74 |      * @Details: 모든 보안 필터의 기본 구현을 제공하는 추상 클래스
   75 |      */
   76 |     @Slf4j
   77 |     public abstract class AbstractSecurityFilter extends OncePerRequestFilter implements PluggableFilter {
   78 |     
   79 |         // 필터 실행 순서
   80 |         private final SecurityFilterOrder securityFilterOrder;
   81 |     
   82 |         /**
   83 |          * 생성자
   84 |          * @param securityFilterOrder 필터 실행 순서
   85 |          */
   86 |         protected AbstractSecurityFilter(SecurityFilterOrder securityFilterOrder) {
   87 |             this.securityFilterOrder = securityFilterOrder;
   88 |         }
   89 |     
   90 |         @Override
   91 |         public final void doFilter(ServletRequest request, ServletResponse response, FilterChain chain)
   92 |                 throws IOException, ServletException {
   93 |             doFilter((HttpServletRequest) request, (HttpServletResponse) response, chain);
   94 |         }
   95 |     
   96 |         /**
   97 |          * HTTP 요청에 대한 필터 처리
   98 |          * @param request HTTP 요청
   99 |          * @param response HTTP 응답
  100 |          * @param chain 필터 체인
  101 |          * @throws IOException IO 예외 발생 시
  102 |          * @throws ServletException 서블릿 예외 발생 시
  103 |          */
  104 |         private void doFilter(HttpServletRequest request, HttpServletResponse response, FilterChain chain)
  105 |                 throws IOException, ServletException {
  106 |             super.doFilter(request, response, chain);
  107 |         }
  108 |     
  109 |         @Override
  110 |         protected final boolean shouldNotFilter(HttpServletRequest request) throws ServletException {
  111 |             String path = request.getRequestURI();
  112 |             boolean shouldNotFilter = shouldSkipFilter(request);
  113 |             
  114 |             if (shouldNotFilter) {
  115 |                 log.trace("필터 건너뜀 ({}): {}", getFilterId(), path);
  116 |             } else {
  117 |                 log.trace("필터 적용 ({}): {}", getFilterId(), path);
  118 |             }
  119 |             
  120 |             return shouldNotFilter;
  121 |         }
  122 |         
  123 |         /**
  124 |          * 필터 적용 여부 결정
  125 |          * @param request HTTP 요청
  126 |          * @return true인 경우 필터 실행 건너뜀
  127 |          */
  128 |         protected abstract boolean shouldSkipFilter(HttpServletRequest request);
  129 |     
  130 |         @Override
  131 |         public int getOrder() {
  132 |             return securityFilterOrder.getOrder();
  133 |         }
  134 |         
  135 |         @Override
  136 |         public String getFilterId() {
  137 |             return this.getClass().getSimpleName();
  138 |         }
  139 |     }
  140 |     
  141 |     /**
  142 |      * 필터 예외 처리 메서드
  143 |      */
  144 |     protected void handleFilterException(HttpServletRequest request, HttpServletResponse response, Exception e) 
  145 |             throws IOException, ServletException {
  146 |         // 기본 구현에서는 예외를 전파
  147 |         // 필요시 하위 클래스에서 재정의
  148 |         if (e instanceof IOException) {
  149 |             throw (IOException) e;
  150 |         } else if (e instanceof ServletException) {
  151 |             throw (ServletException) e;
  152 |         } else {
  153 |             throw new ServletException("필터 처리 중 오류 발생", e);
  154 |         }
  155 |     }
  156 |     
  157 |     /**
  158 |      * 필터 순서 반환
  159 |      */
  160 |     public int getOrder() {
  161 |         return filterOrder.getOrder();
  162 |     }
  163 | }

#--------------------------------------------------------------------------------


# File: backend/src/main/java/com/authentication/auth/domain/Diary.java
#=============================================================================

    1 | package com.authentication.auth.domain;
    2 | 
    3 | import jakarta.persistence.*;
    4 | import lombok.AllArgsConstructor;
    5 | import lombok.Data;
    6 | import lombok.NoArgsConstructor;
    7 | 
    8 | import java.time.LocalDateTime;
    9 | 
   10 | @Entity
   11 | @Table(name = "Diary")
   12 | @Data
   13 | @NoArgsConstructor
   14 | @AllArgsConstructor
   15 | public class Diary {
   16 | 
   17 |     @Id
   18 |     @GeneratedValue(strategy = GenerationType.IDENTITY)
   19 |     private Long id;
   20 | 
   21 |     @ManyToOne(fetch = FetchType.LAZY)
   22 |     @JoinColumn(name = "user_id", nullable = false)
   23 |     private User user;
   24 | 
   25 |     @Column(name = "created_at")
   26 |     private LocalDateTime createdAt;
   27 | 
   28 |     @Column(name = "updated_at")
   29 |     private LocalDateTime updatedAt;
   30 | 
   31 |     private String title;
   32 | 
   33 |     @Column(nullable = false)
   34 |     private String content;
   35 | 
   36 |     @Column(name = "alternative_thought")
   37 |     private String alternativeThought;
   38 | 
   39 |     @OneToOne(mappedBy = "diary", cascade = CascadeType.ALL, orphanRemoval = true)
   40 |     private DiaryAnswer diaryAnswer;
   41 | 
   42 |     @PrePersist
   43 |     protected void onCreate() {
   44 |         createdAt = LocalDateTime.now();
   45 |         updatedAt = LocalDateTime.now();
   46 |     }
   47 | 
   48 |     @PreUpdate
   49 |     protected void onUpdate() {
   50 |         updatedAt = LocalDateTime.now();
   51 |     }
   52 | }

#--------------------------------------------------------------------------------


# File: backend/src/main/java/com/authentication/auth/domain/DiaryAnswer.java
#=============================================================================

    1 | package com.authentication.auth.domain;
    2 | 
    3 | import jakarta.persistence.*;
    4 | import lombok.AllArgsConstructor;
    5 | import lombok.Data;
    6 | import lombok.NoArgsConstructor;
    7 | 
    8 | import java.time.LocalDateTime;
    9 | 
   10 | @Entity
   11 | @Table(name = "Diary_Answer")
   12 | @Data
   13 | @NoArgsConstructor
   14 | @AllArgsConstructor
   15 | public class DiaryAnswer {
   16 | 
   17 |     @Id
   18 |     @GeneratedValue(strategy = GenerationType.IDENTITY)
   19 |     private Long id;
   20 | 
   21 |     @OneToOne(fetch = FetchType.LAZY)
   22 |     @JoinColumn(name = "diary_id", nullable = false)
   23 |     private Diary diary;
   24 | 
   25 |     @Column(name = "created_at")
   26 |     private LocalDateTime createdAt;
   27 | 
   28 |     @Column(name = "updated_at")
   29 |     private LocalDateTime updatedAt;
   30 | 
   31 |     @Column(name = "emotion_detection")
   32 |     private String emotionDetection;
   33 | 
   34 |     @Column(name = "automatic_thought")
   35 |     private String automaticThought;
   36 | 
   37 |     @Column(name = "prompt_for_change")
   38 |     private String promptForChange;
   39 | 
   40 |     @Column(name = "alternative_thought")
   41 |     private String alternativeThought;
   42 | 
   43 |     @Enumerated(EnumType.STRING)
   44 |     @Column(nullable = false)
   45 |     private EmotionStatus status = EmotionStatus.NEUTRAL;
   46 | 
   47 |     public enum EmotionStatus {
   48 |         POSITIVE, NEGATIVE, NEUTRAL
   49 |     }
   50 | }

#--------------------------------------------------------------------------------


# File: backend/src/main/java/com/authentication/auth/domain/AuthProvider.java
#=============================================================================

    1 | @Entity
    2 | @Table(name = "Auth_Provider")
    3 | @Data
    4 | @NoArgsConstructor
    5 | @AllArgsConstructor
    6 | public class AuthProvider {
    7 |     @Id
    8 |     @GeneratedValue(strategy = GenerationType.IDENTITY)
    9 |     private Integer id;
   10 |     
   11 |     @Column(name = "provider_name", nullable = false, length = 50)
   12 |     private String providerName = "SERVER";
   13 |     
   14 |     private String description;
   15 |     
   16 |     @Column(name = "is_active")
   17 |     private Boolean isActive = true;
   18 |     
   19 |     @OneToMany(mappedBy = "authProvider", cascade = CascadeType.ALL)
   20 |     private List<UserAuthentication> userAuthentications = new ArrayList<>();
   21 | }

#--------------------------------------------------------------------------------


# File: backend/src/main/java/com/authentication/auth/domain/User.java
#=============================================================================

    1 | package com.authentication.auth.domain;
    2 | 
    3 | import jakarta.persistence.*;
    4 | import lombok.AllArgsConstructor;
    5 | import lombok.Data;
    6 | import lombok.NoArgsConstructor;
    7 | import java.time.LocalDateTime;
    8 | import java.util.ArrayList;
    9 | import java.util.List;
   10 | 
   11 | @Entity
   12 | @Table(name = "Users")
   13 | @Data
   14 | @NoArgsConstructor
   15 | @AllArgsConstructor
   16 | public class User {
   17 |     @Id
   18 |     @GeneratedValue(strategy = GenerationType.IDENTITY)
   19 |     private Long id;
   20 | 
   21 |     @Column(nullable = false)
   22 |     private String password;
   23 | 
   24 |     @Column(name = "created_at")
   25 |     private LocalDateTime createdAt;
   26 | 
   27 |     @Column(name = "updated_at")
   28 |     private LocalDateTime updatedAt;
   29 | 
   30 |     @Column(name = "user_name", nullable = false, length = 30)
   31 |     private String userName;
   32 | 
   33 |     @Enumerated(EnumType.STRING)
   34 |     @Column(name = "user_role", nullable = false)
   35 |     private UserRole userRole = UserRole.USER;
   36 | 
   37 |     @Column(name = "is_premium")
   38 |     private Boolean isPremium = false;
   39 | 
   40 |     @Column(name = "last_login")
   41 |     private LocalDateTime lastLogin;
   42 | 
   43 |     @Enumerated(EnumType.STRING)
   44 |     @Column(name = "is_active", nullable = false)
   45 |     private UserStatus isActive = UserStatus.WAITING;
   46 | 
   47 |     @OneToMany(mappedBy = "user")
   48 |     private List<Diary> diaries = new ArrayList<>();
   49 | 
   50 |     @PrePersist
   51 |     protected void onCreate() {
   52 |         createdAt = LocalDateTime.now();
   53 |         updatedAt = LocalDateTime.now();
   54 |     }
   55 | 
   56 |     @PreUpdate
   57 |     protected void onUpdate() {
   58 |         updatedAt = LocalDateTime.now();
   59 |     }
   60 | 
   61 |     public enum UserRole {
   62 |         USER, ADMIN
   63 |     }
   64 | 
   65 |     /**
   66 |      * 사용자 상태를 나타내는 열거형
   67 |      * schema.sql의 enum('active','waiting','blocked','suspend','delete') 값과 일치
   68 |      */
   69 |     public enum UserStatus {
   70 |         // DB 스키마의 값과 일치시키기 위해 소문자로 정의
   71 |         // JPA에서는 UPPERCASE로 변환하므로 @Enumerated(EnumType.STRING) 사용 시 주의 필요
   72 |         ACTIVE("active"), 
   73 |         WAITING("waiting"), 
   74 |         BLOCKED("blocked"), 
   75 |         SUSPEND("suspend"), 
   76 |         DELETE("delete");
   77 |         
   78 |         private final String value;
   79 |         
   80 |         UserStatus(String value) {
   81 |             this.value = value;
   82 |         }
   83 |         
   84 |         public String getValue() {
   85 |             return value;
   86 |         }
   87 |         
   88 |         @Override
   89 |         public String toString() {
   90 |             return value;
   91 |         }
   92 |     }
   93 | }

#--------------------------------------------------------------------------------


# File: backend/src/main/java/com/authentication/auth/domain/UserAuthentication.java
#=============================================================================

    1 | @Entity
    2 | @Table(name = "User_Authentication", uniqueConstraints = {
    3 |     @UniqueConstraint(columnNames = {"auth_provider_id", "social_id"})
    4 | })
    5 | @Data
    6 | @NoArgsConstructor
    7 | @AllArgsConstructor
    8 | public class UserAuthentication {
    9 |     @EmbeddedId
   10 |     private UserAuthenticationId id;
   11 |     
   12 |     @ManyToOne(fetch = FetchType.LAZY)
   13 |     @MapsId("userId")
   14 |     @JoinColumn(name = "user_id")
   15 |     private User user;
   16 |     
   17 |     @ManyToOne(fetch = FetchType.LAZY)
   18 |     @MapsId("authProviderId")
   19 |     @JoinColumn(name = "auth_provider_id")
   20 |     private AuthProvider authProvider;
   21 |     
   22 |     @Column(name = "social_id", nullable = false)
   23 |     private String socialId;
   24 |     
   25 |     private String email;
   26 |     
   27 |     @Column(name = "created_at")
   28 |     private LocalDateTime createdAt;
   29 |     
   30 |     @Column(name = "updated_at")
   31 |     private LocalDateTime updatedAt;
   32 | }
   33 | 
   34 | @Embeddable
   35 | @Data
   36 | @NoArgsConstructor
   37 | @AllArgsConstructor
   38 | public class UserAuthenticationId implements Serializable {
   39 |     @Column(name = "user_id")
   40 |     private Long userId;
   41 |     
   42 |     @Column(name = "auth_provider_id")
   43 |     private Integer authProviderId;
   44 |     
   45 |     @Column(name = "social_id")
   46 |     private String socialId;
   47 | }

#--------------------------------------------------------------------------------


# File: backend/src/main/java/com/authentication/auth/domain/SettingsOption.java
#=============================================================================

    1 | package com.authentication.auth.domain;
    2 | 
    3 | import java.util.ArrayList;
    4 | import java.util.List;
    5 | import jakarta.persistence.*;
    6 | import lombok.AllArgsConstructor;
    7 | import lombok.Data;
    8 | import lombok.NoArgsConstructor;
    9 | 
   10 | @Entity
   11 | @Table(name = "Settings_option")
   12 | @Data
   13 | @NoArgsConstructor
   14 | @AllArgsConstructor
   15 | public class SettingsOption {
   16 |     @Id
   17 |     @GeneratedValue(strategy = GenerationType.IDENTITY)
   18 |     private Integer id;
   19 |     
   20 |     @Column(name = "setting_key", nullable = false, unique = true, length = 50)
   21 |     private String settingKey;
   22 |     
   23 |     @Column(name = "default_value", nullable = false)
   24 |     private String defaultValue;
   25 |     
   26 |     @Enumerated(EnumType.STRING)
   27 |     @Column(name = "data_type", nullable = false)
   28 |     private DataType dataType;
   29 |     
   30 |     private String description;
   31 |     
   32 |     @Column(name = "is_user_editable")
   33 |     private Boolean isUserEditable = true;
   34 |     
   35 |     @OneToMany(mappedBy = "settingsOption", cascade = CascadeType.ALL)
   36 |     private List<UserCustomSetting> userCustomSettings = new ArrayList<>();
   37 |     
   38 |     public enum DataType {
   39 |         STRING, NUMBER, BOOLEAN, JSON
   40 |     }
   41 | }

#--------------------------------------------------------------------------------


# File: backend/src/main/java/com/authentication/auth/domain/UserCustomSetting.java
#=============================================================================

    1 | package com.authentication.auth.domain;
    2 | 
    3 | @Entity
    4 | @Table(name = "User_custom_setting")
    5 | @Data
    6 | @NoArgsConstructor
    7 | @AllArgsConstructor
    8 | public class UserCustomSetting {
    9 |     @EmbeddedId
   10 |     private UserCustomSettingId id;
   11 |     
   12 |     @ManyToOne(fetch = FetchType.LAZY)
   13 |     @MapsId("userId")
   14 |     @JoinColumn(name = "user_id")
   15 |     private User user;
   16 |     
   17 |     @ManyToOne(fetch = FetchType.LAZY)
   18 |     @MapsId("settingId")
   19 |     @JoinColumn(name = "setting_id")
   20 |     private SettingsOption settingsOption;
   21 |     
   22 |     @Column(name = "override_value", nullable = false)
   23 |     private String overrideValue;
   24 |     
   25 |     @Column(name = "created_at")
   26 |     private LocalDateTime createdAt;
   27 |     
   28 |     @Column(name = "updated_at")
   29 |     private LocalDateTime updatedAt;
   30 | }
   31 | 
   32 | @Embeddable
   33 | @Data
   34 | @NoArgsConstructor
   35 | @AllArgsConstructor
   36 | public class UserCustomSettingId implements Serializable {
   37 |     @Column(name = "user_id")
   38 |     private Long userId;
   39 |     
   40 |     @Column(name = "setting_id")
   41 |     private Integer settingId;
   42 | }

#--------------------------------------------------------------------------------


# File: backend/src/main/java/com/authentication/auth/controller/usersController.java
#=============================================================================

    1 | package com.career_block.auth.controller;
    2 | 
    3 | import io.swagger.v3.oas.annotations.Operation;
    4 | import io.swagger.v3.oas.annotations.media.Content;
    5 | import io.swagger.v3.oas.annotations.responses.ApiResponse;
    6 | import io.swagger.v3.oas.annotations.responses.ApiResponses;
    7 | import io.swagger.v3.oas.annotations.tags.Tag;
    8 | import jakarta.servlet.http.Cookie;
    9 | import jakarta.servlet.http.HttpServletRequest;
   10 | import jakarta.servlet.http.HttpServletResponse;
   11 | import lombok.RequiredArgsConstructor;
   12 | import lombok.extern.slf4j.Slf4j;
   13 | import org.apache.commons.io.FilenameUtils;
   14 | import org.springframework.beans.factory.annotation.Value;
   15 | import org.springframework.http.HttpStatus;
   16 | import org.springframework.http.ResponseEntity;
   17 | import org.springframework.web.bind.annotation.*;
   18 | import org.springframework.web.multipart.MultipartFile;
   19 | 
   20 | import com.authentication.auth.DTO.token.tokenDto;
   21 | import com.authentication.auth.DTO.users.joinRequest;
   22 | import com.authentication.auth.configuration.token.jwtUtility;
   23 | import com.authentication.auth.others.constants.SecurityConstants;
   24 | import com.authentication.auth.service.redis.redisService;
   25 | import com.authentication.auth.service.smtp.emailService;
   26 | import com.authentication.auth.service.users.userService;
   27 | 
   28 | import java.io.File;
   29 | import java.io.IOException;
   30 | import java.nio.file.Files;
   31 | import java.util.*;
   32 | 
   33 | @Slf4j
   34 | @RestController
   35 | @RequiredArgsConstructor
   36 | @RequestMapping("/api")
   37 | @Tag(name = "User Management", description = "유저 관리 API")
   38 | public class usersController {
   39 | 
   40 |     @Value("${file.profile-path}")
   41 |     private String profilePath;
   42 |     @Value("${file.server}")
   43 |     private String fileServer;
   44 |     @Value("${site.domain}")
   45 |     private String domain;
   46 |     private final userService userService;
   47 |     private final emailService emailService;
   48 |     private final redisService redisService;
   49 |     private final jwtUtility jwtUtility;
   50 | 
   51 |     @Operation(summary = "회원 가입", description = "새로운 유저를 등록합니다.")
   52 |     @ApiResponses(value = {
   53 |             @ApiResponse(responseCode = "200", description = "회원 가입 성공", content = @Content(mediaType = "application/json")),
   54 |             @ApiResponse(responseCode = "500", description = "회원 가입 실패", content = @Content(mediaType = "application/json"))
   55 |     })
   56 |     @PostMapping("/public/join")
   57 |     public ResponseEntity<?> join(@RequestBody joinRequest request) throws Exception {
   58 |         if (!redisService.checkEmailCode(request.getEmail(), request.getCode()))
   59 |             return ResponseEntity.status(HttpStatus.BAD_REQUEST).body("Email validation is not accessed");
   60 |         ResponseEntity<?> save = userService.join(request);
   61 |         if (save.getStatusCode() == HttpStatus.CONFLICT)
   62 |             return ResponseEntity.status(HttpStatus.CONFLICT).body("already exist userId or nickname");
   63 |         if (save.getStatusCode() == HttpStatus.OK) {
   64 |             return ResponseEntity.status(HttpStatus.OK).body("join successfully");
   65 |         } else {
   66 |             return ResponseEntity.status(HttpStatus.INTERNAL_SERVER_ERROR).body("join save failed");
   67 |         }
   68 |     }
   69 | 
   70 |     @Operation(summary = "프로필 업로드", description = "유저 프로필 이미지를 업로드합니다.")
   71 |     @ApiResponses(value = {
   72 |             @ApiResponse(responseCode = "200", description = "프로필 업로드 성공", content = @Content(mediaType = "application/json")),
   73 |             @ApiResponse(responseCode = "400", description = "잘못된 파일 이름 또는 확장자", content = @Content(mediaType = "application/json")),
   74 |             @ApiResponse(responseCode = "500", description = "서버 오류", content = @Content(mediaType = "application/json"))
   75 |     })
   76 |     @PostMapping("/public/profileUpload")
   77 |     public ResponseEntity<?> fileUpload(@RequestParam("profile") MultipartFile[] files) {
   78 |         Map<String, String> response = new HashMap<>();
   79 |         for (MultipartFile file : files) {
   80 |             try {
   81 |                 String originName = file.getOriginalFilename();
   82 |                 if (originName == null || originName.contains("..")) {
   83 |                     log.error("invalid file name : " + originName);
   84 |                     return ResponseEntity.status(HttpStatus.BAD_REQUEST).body("invalid file name : " + originName);
   85 |                 }
   86 | 
   87 |                 String originNameOnly = FilenameUtils.getBaseName(originName);
   88 |                 String extension = FilenameUtils.getExtension(originName);
   89 |                 if (!isValidExtension(extension)) {
   90 |                     log.error("invalid file extension : " + extension);
   91 |                     return ResponseEntity.status(HttpStatus.BAD_REQUEST).body("invalid file extension : " + extension);
   92 |                 }
   93 | 
   94 |                 String fileName = UUID.randomUUID().toString() + "_" + originNameOnly + "." + extension;
   95 | 
   96 |                 File directory = new File(profilePath);
   97 |                 if (!directory.exists()) {
   98 |                     directory.mkdirs();
   99 |                 }
  100 |                 File targetFile = new File(profilePath, fileName);
  101 |                 file.transferTo(targetFile);
  102 | 
  103 |                 log.info("Saving file to {}", targetFile.getAbsolutePath());
  104 | 
  105 |                 if (!isValidFileContent(targetFile, extension)) {
  106 |                     targetFile.delete();
  107 |                     log.error("invalid file content");
  108 |                     return ResponseEntity.status(HttpStatus.BAD_REQUEST).body("invalid file content");
  109 |                 }
  110 | 
  111 |                 log.info("saving file dir to {}", targetFile.getAbsolutePath());
  112 | 
  113 |                 response.put("fileName", fileServer + "/attach/profile/" + fileName);
  114 | 
  115 |             } catch (IOException e) {
  116 |                 log.error("프로필 파일 업로드 중 오류 발생!", e);
  117 |                 return ResponseEntity.status(HttpStatus.INTERNAL_SERVER_ERROR).body("profile upload error");
  118 |             }
  119 |         }
  120 |         return ResponseEntity.status(HttpStatus.OK).body(response);
  121 |     }
  122 | 
  123 | 
  124 |     private boolean isValidExtension(String extension) {
  125 |         List<String> allowedExtensions = Arrays.asList("jpg", "jpeg", "png", "gif", "bmp", "webp", "svg", "tiff");
  126 |         return allowedExtensions.contains(extension);
  127 |     }
  128 | 
  129 |     private boolean isValidFileContent(File file, String extension) {
  130 |         try {
  131 |             String mimeType = Files.probeContentType(file.toPath());
  132 |             List<String> allowedMimeTypes = Arrays.asList(
  133 |                     "image/jpeg", "image/png", "image/gif", "image/bmp", "image/webp", "image/svg+xml", "image/tiff"
  134 |             );
  135 |             return allowedMimeTypes.contains(mimeType);
  136 |         } catch (IOException e) {
  137 |             log.error("파일 내용 검증 중 오류 발생", e);
  138 |             return false;
  139 |         }
  140 |     }
  141 | 
  142 |     @Operation(summary = "아이디 중복 체크", description = "아이디의 중복 여부를 체크합니다.")
  143 |     @ApiResponses(value = {
  144 |             @ApiResponse(responseCode = "200", description = "중복 체크 성공", content = @Content(mediaType = "application/json"))
  145 |     })
  146 |     @PostMapping("/public/check/userId/IsDuplicate")
  147 |     public boolean checkUserIdIsDuplicate(@RequestBody HashMap<String, String> user) {
  148 |         log.info("/check/userId/IsDuplicate : {}", user.get("userId"));
  149 |         return userService.checkUserIdIsDuplicate(user.get("userId"));
  150 |     }
  151 | 
  152 |     @Operation(summary = "닉네임 중복 체크", description = "닉네임의 중복 여부를 체크합니다.")
  153 |     @ApiResponses(value = {
  154 |             @ApiResponse(responseCode = "200", description = "중복 체크 성공", content = @Content(mediaType = "application/json"))
  155 |     })
  156 |     @PostMapping("/public/check/nickname/IsDuplicate")
  157 |     public boolean checkNickNameDuplicate(@RequestBody HashMap<String, String> user) {
  158 |         log.info("/check/nickname/IsDuplicate : {}", user.get("nickname"));
  159 |         return userService.checkNickNameIsDuplicate(user.get("nickname"));
  160 |     }
  161 | 
  162 |     @PostMapping("/public/clean/userTokenCookie")
  163 |     public ResponseEntity<?> cleanUserTokenCookie(HttpServletRequest request, HttpServletResponse response) {
  164 |         String cookieName = "refreshToken";
  165 |         Cookie[] cookies = request.getCookies();
  166 |         if (cookies != null) {
  167 |             for (Cookie cookie : cookies) {
  168 |                 if (cookieName.equals(cookie.getName())) {
  169 |                     cookie.setMaxAge(0);
  170 |                     cookie.setPath("/");
  171 |                     cookie.setHttpOnly(true);
  172 |                     response.addCookie(cookie);
  173 |                 }
  174 |             }
  175 |         }
  176 |         return ResponseEntity.ok().body("refreshToken deleted");
  177 |     }
  178 | 
  179 |     private void sendFrontNewCookie(HttpServletResponse response, int status, tokenDto tokendto) {
  180 |         response.setStatus(status);
  181 |         response.addHeader(SecurityConstants.TOKEN_HEADER, SecurityConstants.TOKEN_PREFIX + tokendto.getAccessToken());
  182 |         Cookie refreshTokenCookie = new Cookie("refreshToken", tokendto.getRefreshToken());
  183 |         refreshTokenCookie.setHttpOnly(true);
  184 |         refreshTokenCookie.setDomain(domain);
  185 |         refreshTokenCookie.setPath("/");
  186 |         response.addCookie(refreshTokenCookie);
  187 |     }
  188 | 
  189 |     private String getRefreshTokenFromCookie(HttpServletRequest request) {
  190 |         // cookie 배열 가지고 오기
  191 |         Cookie[] cookies = request.getCookies();
  192 | 
  193 |         if (cookies != null) {
  194 |             for (Cookie cookie : cookies) {
  195 |                 if ("refreshToken".equals(cookie.getName())) {
  196 |                     return cookie.getValue();
  197 |                 }
  198 |             }
  199 |         }
  200 |         log.error("[getRefreshTokenFromCookie] cookie 에서 refreshToken 찾기 실패");
  201 |         return null;
  202 |     }
  203 | 
  204 |     private boolean RedisMatchRToken(String userId, String RToken) {
  205 |         return redisService.findRToken(userId, "server", RToken);
  206 |     }
  207 | }

#--------------------------------------------------------------------------------


# File: backend/src/main/java/com/authentication/auth/controller/sseController.java
#=============================================================================

    1 | package com.career_block.auth.controller;
    2 | 
    3 | import io.swagger.v3.oas.annotations.Operation;
    4 | import io.swagger.v3.oas.annotations.media.Content;
    5 | import io.swagger.v3.oas.annotations.responses.ApiResponse;
    6 | import io.swagger.v3.oas.annotations.responses.ApiResponses;
    7 | import lombok.RequiredArgsConstructor;
    8 | import lombok.extern.slf4j.Slf4j;
    9 | import org.springframework.http.HttpStatus;
   10 | import org.springframework.http.MediaType;
   11 | import org.springframework.http.ResponseEntity;
   12 | import org.springframework.security.core.annotation.AuthenticationPrincipal;
   13 | import org.springframework.web.bind.annotation.*;
   14 | import org.springframework.web.servlet.mvc.method.annotation.SseEmitter;
   15 | 
   16 | import com.authentication.auth.DTO.token.principalDetails;
   17 | import com.authentication.auth.service.sse.sseService;
   18 | 
   19 | import java.util.Map;
   20 | 
   21 | @Slf4j
   22 | @RestController
   23 | @RequiredArgsConstructor
   24 | @RequestMapping("/api")
   25 | public class sseController {
   26 | 
   27 |     private final sseService sseService;
   28 | 
   29 | 
   30 |     /**
   31 |      * 클라이언트가 SSE 스트림에 구독하기 위한 엔드포인트
   32 |      * 예: GET /sse/subscribe/{userId}
   33 |      *
   34 |      * @param userId 사용자의 고유 ID
   35 |      * @return SseEmitter 객체
   36 |      */
   37 |     @Operation(summary = "SSE 구독", description = "서버에서 SSE 이벤트를 구독합니다.")
   38 |     @ApiResponses(value = {
   39 |             @ApiResponse(responseCode = "200", description = "구독 성공", content = @Content(mediaType = "application/json")),
   40 |             @ApiResponse(responseCode = "401", description = "인증 실패", content = @Content(mediaType = "application/json")),
   41 |             @ApiResponse(responseCode = "500", description = "서버 오류", content = @Content(mediaType = "application/json"))
   42 |     })
   43 |     @GetMapping(value = "/protected/sse/subscribe", produces = MediaType.TEXT_EVENT_STREAM_VALUE)
   44 |     public ResponseEntity<SseEmitter> subscribeSse(@AuthenticationPrincipal principalDetails principalDetails,
   45 |                                                    @RequestHeader(value = "Last-Event-ID", required = false, defaultValue = "") String lastEventId) {
   46 |         SseEmitter emitter = new SseEmitter(30 * 60 * 1000L);
   47 | 
   48 |         String userId = principalDetails.getUserId();
   49 |         boolean saved = sseService.saveSseEmitter(userId, emitter);
   50 |         if (!saved) {
   51 |             log.error("Failed to save SseEmitter for userId : {}", userId);
   52 |             emitter.completeWithError(new IllegalStateException("Failed to save SseEmitter for userId : " + userId));
   53 |         }
   54 | 
   55 |         // Initial Data 전송
   56 |         try {
   57 |             emitter.send(SseEmitter.event()
   58 |                     .name("INIT")
   59 |                     .data("Subscription successful"));
   60 |         } catch (Exception e) {
   61 |             log.error("Error sending initial event to userId : {}", userId, e);
   62 |             sseService.removeEmitter(userId, emitter);
   63 |             emitter.completeWithError(e);
   64 |         }
   65 | 
   66 |         return ResponseEntity.status(HttpStatus.OK).body(emitter);
   67 |     }
   68 | 
   69 | 
   70 | 
   71 |     /**
   72 |      * 더미 데이터를 특정 사용자에게 전송하는 엔드포인트
   73 |      * 예: POST /sse/dummyData/{user_id}
   74 |      *
   75 |      * @param principalDetails 인증된 사용자 정보
   76 |      * @param userId 대상 사용자의 ID
   77 |      * @param payload 전송할 데이터
   78 |      * @return ResponseEntity
   79 |      */
   80 |     @Operation(summary = "더미 데이터 전송", description = "특정 사용자에게 더미 데이터를 전송합니다.")
   81 |     @ApiResponses(value = {
   82 |             @ApiResponse(responseCode = "200", description = "데이터 전송 성공", content = @Content(mediaType = "application/json")),
   83 |             @ApiResponse(responseCode = "400", description = "잘못된 요청", content = @Content(mediaType = "application/json")),
   84 |             @ApiResponse(responseCode = "401", description = "인증 실패", content = @Content(mediaType = "application/json")),
   85 |             @ApiResponse(responseCode = "500", description = "서버 오류", content = @Content(mediaType = "application/json"))
   86 |     })
   87 |     @PostMapping("/public/dummyData/{user_id}")
   88 |     public ResponseEntity<?> sseDummyData(@AuthenticationPrincipal principalDetails principalDetails,
   89 |                                           @PathVariable("user_id") String userId,
   90 |                                           @RequestBody Map<String, String> payload){
   91 |         String message = payload.get("message");
   92 |         if (message == null || message.isEmpty()){
   93 |             return ResponseEntity.status(HttpStatus.BAD_REQUEST).body("Message is required");
   94 |         }
   95 | 
   96 |         sseService.sendEventToUser(userId, message);
   97 |         return ResponseEntity.ok().build();
   98 |     }
   99 | 
  100 | 
  101 | }

#--------------------------------------------------------------------------------


# File: backend/src/main/java/com/authentication/auth/controller/errorController.java
#=============================================================================

    1 | /*
    2 | 
    3 | package com.career_block.auth.controller;
    4 | 
    5 | import jakarta.servlet.http.HttpServlet;
    6 | import jakarta.servlet.http.HttpServletRequest;
    7 | import org.springframework.boot.web.servlet.error.ErrorController;
    8 | import org.springframework.stereotype.Controller;
    9 | import org.springframework.ui.Model;
   10 | import org.springframework.web.bind.annotation.GetMapping;
   11 | import org.springframework.web.bind.annotation.RequestMapping;
   12 | import org.springframework.web.bind.annotation.RestController;
   13 | 
   14 | 
   15 | @Controller
   16 | public class errorController implements ErrorController {
   17 | 
   18 |     @RequestMapping("/errorPage")
   19 |     public String handleError(HttpServletRequest request, Model model) {
   20 |         Object status = request.getAttribute("javax.servlet.error.status_code");
   21 | 
   22 |         if (status != null) {
   23 |             int statusCode = Integer.parseInt(status.toString());
   24 |             model.addAttribute("statusCode", statusCode);
   25 | 
   26 |             if (statusCode == 404) {
   27 |                 return "notExist";  // src/main/resources/templates/notExist.html 템플릿 반환
   28 |             } else if (statusCode == 401) {
   29 |                 return "unauthorized"; // src/main/resources/templates/unauthorized.html 템플릿 반환
   30 |             }
   31 |         }
   32 | 
   33 |         return "error"; // 다른 오류에는 기본 에러 페이지 반환 (src/main/resources/templates/error.html)
   34 | 
   35 | }
   36 | */
   37 | 

#--------------------------------------------------------------------------------


# File: backend/src/main/java/com/authentication/auth/controller/auth/oauth2Controller.java
#=============================================================================

    1 | package com.career_block.auth.controller.auth;
    2 | 
    3 | import jakarta.servlet.http.HttpServletResponse;
    4 | import lombok.RequiredArgsConstructor;
    5 | import lombok.extern.slf4j.Slf4j;
    6 | import org.springframework.http.ResponseEntity;
    7 | import org.springframework.web.bind.annotation.PostMapping;
    8 | import org.springframework.web.bind.annotation.RequestBody;
    9 | import org.springframework.web.bind.annotation.RequestMapping;
   10 | import org.springframework.web.bind.annotation.RestController;
   11 | 
   12 | import com.authentication.auth.configuration.token.jwtUtility;
   13 | import com.authentication.auth.service.oauth2.oauth2Service;
   14 | import com.authentication.auth.service.redis.redisService;
   15 | 
   16 | import java.util.Map;
   17 | import java.util.UUID;
   18 | 
   19 | @Slf4j
   20 | @RestController
   21 | @RequiredArgsConstructor
   22 | @RequestMapping("/oauth2")
   23 | public class oauth2Controller {
   24 | 
   25 |     //하핫.. 너는 서비스다...
   26 |     private final oauth2Service  oauth2Service;
   27 |     private final redisService  redisService;
   28 |     private final jwtUtility jwtUtility;
   29 | 
   30 | 
   31 |     @PostMapping("/callback/kakao")
   32 |     public ResponseEntity<?> oauth2KakaoLogin(@RequestBody Map<String, String> requestBody, HttpServletResponse response) {
   33 |         log.info("/oauth2/callback/kakao");
   34 |         return oauth2Service.handleOauth2Login(requestBody, response, "kakao");
   35 |     }
   36 |     @PostMapping("/callback/naver")
   37 |     public ResponseEntity<?> oauth2NaverLogin(@RequestBody Map<String, String> requestBody, HttpServletResponse response) {
   38 |         log.info("/oauth2/callback/naver");
   39 |         String state = UUID.randomUUID().toString();
   40 |         return oauth2Service.handleOauth2Login(requestBody, response, "naver");
   41 |     }
   42 |     @PostMapping("/callback/google")
   43 |     public ResponseEntity<?> oauth2GoogleLogin(@RequestBody Map<String, String> requestBody, HttpServletResponse response) {
   44 |         log.info("/oauth2/callback/google");
   45 |         log.info("tempCode for google from client server : {}", requestBody.get("tempCode"));
   46 |         return oauth2Service.handleOauth2Login(requestBody, response, "google");
   47 |     }
   48 | 
   49 | }

#--------------------------------------------------------------------------------


# File: backend/src/main/java/com/authentication/auth/controller/auth/tokenController.java
#=============================================================================

    1 | package com.career_block.auth.controller.auth;
    2 | 
    3 | import io.swagger.v3.oas.annotations.Operation;
    4 | import io.swagger.v3.oas.annotations.responses.ApiResponse;
    5 | import io.swagger.v3.oas.annotations.responses.ApiResponses;
    6 | import jakarta.servlet.http.HttpServletRequest;
    7 | import jakarta.servlet.http.HttpServletResponse;
    8 | import lombok.extern.slf4j.Slf4j;
    9 | import org.springframework.http.HttpStatus;
   10 | import org.springframework.http.ResponseEntity;
   11 | import org.springframework.web.bind.annotation.PostMapping;
   12 | import org.springframework.web.bind.annotation.RequestBody;
   13 | import org.springframework.web.bind.annotation.RequestMapping;
   14 | import org.springframework.web.bind.annotation.RestController;
   15 | 
   16 | import com.authentication.auth.DTO.token.tokenRefreshRequest;
   17 | import com.authentication.auth.configuration.token.jwtUtility;
   18 | import com.authentication.auth.service.redis.redisService;
   19 | import com.authentication.auth.service.token.tokenService;
   20 | 
   21 | import java.io.IOException;
   22 | 
   23 | @Slf4j
   24 | @RestController
   25 | @RequestMapping("/auth")
   26 | public class tokenController {
   27 | 
   28 |     private final jwtUtility jwtUtility;
   29 |     private final redisService redisService;
   30 |     private final tokenService  tokenService;
   31 | 
   32 |     public tokenController(jwtUtility jwtUtility, redisService redisService, tokenService tokenService){
   33 |         this.jwtUtility = jwtUtility;
   34 |         this.redisService = redisService;
   35 |         this.tokenService = tokenService;
   36 |     }
   37 | 
   38 |     @Operation(summary = "Refresh JWT Token", description = "Refreshes the expired JWT token and returns a new token if valid.")
   39 |     @ApiResponses(value = {
   40 |             @ApiResponse(responseCode = "200", description = "Token refreshed successfully, new token returned."),
   41 |             @ApiResponse(responseCode = "406", description = "Not acceptable, invalid token or no refresh token in Redis."),
   42 |             @ApiResponse(responseCode = "401", description = "Unauthorized, refresh token not found in cookies."),
   43 |     })
   44 |     @PostMapping("/api/protected/refresh")
   45 |     public ResponseEntity<?> refreshToken(HttpServletRequest httpRequest, HttpServletResponse httpResponse, @RequestBody tokenRefreshRequest request) throws IOException {
   46 | 
   47 |         if (request == null || request.getExpiredToken() == null || request.getProvider() == null) {
   48 |             return ResponseEntity.status(HttpStatus.NOT_ACCEPTABLE).build();
   49 |         }
   50 | 
   51 |         return tokenService.refreshToken(httpRequest, httpResponse, request);
   52 |     }
   53 | }
   54 | 
   55 | 

#--------------------------------------------------------------------------------


# File: backend/src/main/java/com/authentication/auth/controller/auth/AuthController.java
#=============================================================================

    1 | package com.career_block.auth.controller.auth;
    2 | 
    3 | import org.springframework.http.ResponseEntity;
    4 | import org.springframework.web.bind.annotation.GetMapping;
    5 | import org.springframework.web.bind.annotation.RestController;
    6 | 
    7 | @RestController
    8 | public class AuthController {
    9 | 
   10 |     @GetMapping("/auth_check")
   11 |     public ResponseEntity<String> authCheck() {
   12 |         return ResponseEntity.ok("Authorized");
   13 |     }
   14 | }

#--------------------------------------------------------------------------------


# File: backend/src/main/java/com/authentication/auth/controller/emailController.java
#=============================================================================

    1 | package com.career_block.auth.controller;
    2 | 
    3 | 
    4 | import io.swagger.v3.oas.annotations.Operation;
    5 | import io.swagger.v3.oas.annotations.media.Content;
    6 | import io.swagger.v3.oas.annotations.responses.ApiResponse;
    7 | import io.swagger.v3.oas.annotations.responses.ApiResponses;
    8 | import io.swagger.v3.oas.annotations.tags.Tag;
    9 | import jakarta.validation.Valid;
   10 | import lombok.RequiredArgsConstructor;
   11 | import lombok.extern.slf4j.Slf4j;
   12 | import org.springframework.http.HttpStatus;
   13 | import org.springframework.http.ResponseEntity;
   14 | import org.springframework.security.core.annotation.AuthenticationPrincipal;
   15 | import org.springframework.web.bind.annotation.*;
   16 | 
   17 | import com.authentication.auth.DTO.smtp.customEmailRequest;
   18 | import com.authentication.auth.DTO.smtp.emailCheckDto;
   19 | import com.authentication.auth.DTO.smtp.emailFindById;
   20 | import com.authentication.auth.DTO.smtp.emailRequest;
   21 | import com.authentication.auth.DTO.token.principalDetails;
   22 | import com.authentication.auth.service.redis.redisService;
   23 | import com.authentication.auth.service.smtp.emailService;
   24 | import com.authentication.auth.service.users.userService;
   25 | 
   26 | @Slf4j
   27 | @Tag(name="email 관련", description = "email")
   28 | @RestController
   29 | @RequiredArgsConstructor
   30 | @RequestMapping("/api")
   31 | public class emailController {
   32 | 
   33 |     private final emailService service;
   34 |     private final userService  userService;
   35 |     private final redisService  redisService;
   36 | 
   37 |     @Operation(summary="이메일 보내기", description = "이메일 코드 전송 관련")
   38 |     @ApiResponses(value = {
   39 |             @ApiResponse(responseCode = "200", description = "이메일 전송 성공", content = @Content(mediaType = "application/json")),
   40 |             @ApiResponse(responseCode = "500", description = "이메일 전송 실패", content = @Content(mediaType = "application/json"))
   41 |     })
   42 |     @PostMapping("/public/emailSend")
   43 |     public ResponseEntity<?> emailSend(@RequestBody @Valid emailRequest request) {
   44 |         try {
   45 |             if(service.checkIsExistEmail(request.getEmail()))
   46 |             {
   47 |                 return ResponseEntity.status(HttpStatus.BAD_REQUEST).body("user with this email already exist");
   48 |             }
   49 |             String code = service.joinEmail(request.getEmail());
   50 |             this.redisService.saveEmailCode(request.getEmail(), code);
   51 |             return ResponseEntity.status(HttpStatus.OK).body("A temporary code has been sent to your email");
   52 |         } catch (Exception e) {
   53 |             return ResponseEntity.status(HttpStatus.INTERNAL_SERVER_ERROR).body("email sent failed");
   54 |         }
   55 |     }
   56 | 
   57 | 
   58 |     @Operation(summary="커스텀 이메일 보내기", description = "커스텀 이메일 전송 관련")
   59 |     @ApiResponses(value = {
   60 |             @ApiResponse(responseCode = "200", description = "이메일 전송 성공", content = @Content(mediaType = "application/json")),
   61 |             @ApiResponse(responseCode = "500", description = "이메일 전송 실패", content = @Content(mediaType = "application/json"))
   62 |     })
   63 |     @PostMapping("/api/private/customEmailSend")
   64 |     public ResponseEntity<?> customEmailSend(@RequestBody @Valid customEmailRequest request) {
   65 |         try {
   66 |             if (request.getEmail() == null) {
   67 |                 return ResponseEntity.status(HttpStatus.BAD_REQUEST).body("email is blank");
   68 |             }
   69 |             if (request.getContent() == null){
   70 |                 return ResponseEntity.status(HttpStatus.BAD_REQUEST).body("there's no content in the request");
   71 |             }
   72 |             service.sendCustomEmail(request);
   73 |             return ResponseEntity.status(HttpStatus.OK).body("custom email send success");
   74 |         } catch (Exception e) {
   75 |             return ResponseEntity.status(HttpStatus.INTERNAL_SERVER_ERROR).body("email sent failed");
   76 |         }
   77 |     }
   78 | 
   79 | 
   80 |     @Operation(summary = "이메일 코드 확인", description = "이메일로 전송된 코드를 확인합니다")
   81 |     @ApiResponses(value = {
   82 |             @ApiResponse(responseCode = "202", description = "이메일 코드 유효", content = @Content(mediaType = "application/json")),
   83 |             @ApiResponse(responseCode = "401", description = "이메일 코드 무효", content = @Content(mediaType = "application/json"))
   84 |     })
   85 |     @PostMapping("/public/emailCheck")
   86 |     public ResponseEntity<?> emailCodeCheck(@RequestBody @Valid emailCheckDto checkdto) {
   87 |         boolean isValid = redisService.checkEmailCode(checkdto.getEmail(), checkdto.getCode());
   88 |         if (isValid) {
   89 |             return ResponseEntity.status(HttpStatus.ACCEPTED).body("email code is valid");
   90 |         } else {
   91 |             return ResponseEntity.status(HttpStatus.UNAUTHORIZED).body("email code is invalid");
   92 |         }
   93 |     }
   94 | 
   95 |     @Operation(summary = "임시 비밀번호 이메일 전송", description = "인증된 사용자에게 임시 비밀번호를 이메일로 전송합니다")
   96 |     @ApiResponses(value = {
   97 |             @ApiResponse(responseCode = "200", description = "임시 비밀번호 전송 성공", content = @Content(mediaType = "application/json")),
   98 |             @ApiResponse(responseCode = "500", description = "임시 비밀번호 전송 실패", content = @Content(mediaType = "application/json"))
   99 |     })
  100 |     @PostMapping("/protected/sendEmailPassword")
  101 |     public ResponseEntity<?> emailSendPassword(@AuthenticationPrincipal principalDetails principalDetails) {
  102 |         try {
  103 |             String userId = principalDetails.getUserId();
  104 |             String email = userService.getEmailByUserId(userId);
  105 |             String temporalPassword = service.changePwEmail(email);
  106 |             userService.UpdateUserPassword(userId, temporalPassword);
  107 |             return ResponseEntity.status(HttpStatus.OK).body("A temporary password has been sent to your email");
  108 |         } catch (Exception e) {
  109 |             return ResponseEntity.status(HttpStatus.INTERNAL_SERVER_ERROR).body("error occurred while sending an temporary password");
  110 |         }
  111 |     }
  112 | 
  113 |     @Operation(summary = "이메일로 비밀번호 찾기", description = "사용자 ID를 통해 이메일로 임시 비밀번호를 전송합니다")
  114 |     @ApiResponses(value = {
  115 |             @ApiResponse(responseCode = "200", description = "임시 비밀번호 전송 성공", content = @Content(mediaType = "application/json")),
  116 |             @ApiResponse(responseCode = "500", description = "임시 비밀번호 전송 실패", content = @Content(mediaType = "application/json"))
  117 |     })
  118 |     @GetMapping("/public/findPassWithEmail")
  119 |     public ResponseEntity<?> findPassWithEmail(@RequestBody emailFindById emailFindById) {
  120 |         try {
  121 |             String email = userService.getEmailByUserId(emailFindById.getUserId());
  122 |             String temporalPassword = service.changePwEmail(email);
  123 |             userService.UpdateUserPassword(emailFindById.getUserId(), temporalPassword);
  124 |             return ResponseEntity.status(HttpStatus.OK).body("A temporary password has been sent to your email");
  125 |         } catch (Exception e) {
  126 |             log.error("Error find Password with Email sent", e);
  127 |             return ResponseEntity.status(HttpStatus.INTERNAL_SERVER_ERROR).body("error occurred while sending an temporary password");
  128 |         }
  129 |     }
  130 | 
  131 | 
  132 | }

#--------------------------------------------------------------------------------


# File: backend/src/main/java/com/authentication/auth/AuthApplication.java
#=============================================================================

    1 | package com.authentication.auth;
    2 | 
    3 | import jakarta.annotation.PostConstruct;
    4 | import org.springframework.boot.SpringApplication;
    5 | import org.springframework.boot.autoconfigure.SpringBootApplication;
    6 | import org.springframework.data.mongodb.repository.config.EnableMongoRepositories;
    7 | 
    8 | import java.util.TimeZone;
    9 | 
   10 | @SpringBootApplication
   11 | @EnableMongoRepositories
   12 | public class AuthApplication {
   13 | 
   14 | 	public static void main(String[] args) {
   15 | 		SpringApplication.run(AuthApplication.class, args);
   16 | 	}
   17 | 
   18 | 
   19 | 	@PostConstruct
   20 | 	void set_time_zone() {
   21 | 		TimeZone.setDefault(TimeZone.getTimeZone("Asia/Seoul"));
   22 | 	}
   23 | }

#--------------------------------------------------------------------------------


# File: backend/src/main/java/com/authentication/auth/configuration/SecurityConfig.java
#=============================================================================

    1 | package com.authentication.auth.configuration;
    2 | 
    3 | import com.authentication.auth.filter.filterRegistry;
    4 | import lombok.RequiredArgsConstructor;
    5 | import lombok.extern.slf4j.Slf4j;
    6 | import org.springframework.context.annotation.Bean;
    7 | import org.springframework.context.annotation.Configuration;
    8 | import org.springframework.security.config.annotation.web.builders.HttpSecurity;
    9 | import org.springframework.security.config.annotation.web.configuration.EnableWebSecurity;
   10 | import org.springframework.security.config.http.SessionCreationPolicy;
   11 | import org.springframework.security.web.SecurityFilterChain;
   12 | 
   13 | /**
   14 |  * @Author: choisimo
   15 |  * @Date: 2025-05-05
   16 |  * @Description: Spring Security 구성 클래스
   17 |  * @Details: 보안 필터 체인 및 인증/인가 설정을 관리
   18 |  */
   19 | @Configuration
   20 | @EnableWebSecurity
   21 | @RequiredArgsConstructor
   22 | @Slf4j
   23 | public class SecurityConfig {
   24 | 
   25 |     private final filterRegistry filterRegistry;
   26 |     
   27 |     @Bean
   28 |     public SecurityFilterChain securityFilterChain(HttpSecurity http) throws Exception {
   29 |         log.info("보안 필터 체인 구성 중...");
   30 |         
   31 |         http
   32 |             .csrf().disable()
   33 |             .formLogin().disable()
   34 |             .httpBasic().disable()
   35 |             .sessionManagement().sessionCreationPolicy(SessionCreationPolicy.STATELESS)
   36 |             .and()
   37 |             .authorizeHttpRequests()
   38 |                 .requestMatchers("/auth/**", "/login", "/signup", "/public/**").permitAll()
   39 |                 .anyRequest().authenticated();
   40 |         
   41 |         // 플러그형 필터 등록
   42 |         filterRegistry.configureFilters(http);
   43 |         
   44 |         return http.build();
   45 |     }
   46 | }

#--------------------------------------------------------------------------------


# File: backend/src/main/java/com/authentication/auth/configuration/smtp/smtpConfig.java
#=============================================================================

    1 | package com.career_block.auth.configuration.smtp;
    2 | 
    3 | import org.springframework.context.annotation.Bean;
    4 | import org.springframework.context.annotation.Configuration;
    5 | import org.springframework.mail.javamail.JavaMailSender;
    6 | import org.springframework.mail.javamail.JavaMailSenderImpl;
    7 | 
    8 | import java.util.Properties;
    9 | 
   10 | @Configuration
   11 | public class smtpConfig {
   12 | 
   13 |     @Bean
   14 |     public JavaMailSender mailSender() {
   15 |         JavaMailSenderImpl mailSender = new JavaMailSenderImpl();
   16 |         mailSender.setHost("smtp.gmail.com");
   17 |         mailSender.setPort(587);
   18 |         mailSender.setUsername("careernoteproject@gmail.com");
   19 |         mailSender.setPassword("akzm ifxr ahou copf");
   20 | 
   21 |         Properties javaMailProperties = new Properties();
   22 |         javaMailProperties.put("mail.transport.protocol", "smtp");
   23 |         javaMailProperties.put("mail.smtp.auth", "true");
   24 |         javaMailProperties.put("mail.smtp.socketFactory.class", "javax.net.ssl.SSLSocketFactory");
   25 |         javaMailProperties.put("mail.smtp.starttls.enable", "true");
   26 |         javaMailProperties.put("mail.debug", "true");//디버깅 정보 출력
   27 |         javaMailProperties.put("mail.smtp.ssl.trust", "smtp.gmail.com");//smtp 서버의 ssl 인증서를 신뢰
   28 |         javaMailProperties.put("mail.smtp.ssl.protocols", "TLSv1.2");//사용할 ssl 프로토콜 버젼
   29 |         mailSender.setJavaMailProperties(javaMailProperties);
   30 |         return mailSender;
   31 |     }
   32 | }

#--------------------------------------------------------------------------------


# File: backend/src/main/java/com/authentication/auth/configuration/resource/webMvcConfig.java
#=============================================================================

    1 | package com.authentication.auth.configuration.resource;
    2 | 
    3 | import org.springframework.context.annotation.Configuration;
    4 | 
    5 | @Configuration
    6 | public class webMvcConfig {
    7 | 
    8 | 
    9 | }

#--------------------------------------------------------------------------------


# File: backend/src/main/java/com/authentication/auth/configuration/security/publicAPI.java
#=============================================================================

    1 | package com.authentication.auth.configuration.security;
    2 | 
    3 | import jakarta.servlet.http.HttpServletRequest;
    4 | import lombok.Data;
    5 | import lombok.extern.slf4j.Slf4j;
    6 | import org.springframework.context.annotation.Bean;
    7 | import org.springframework.context.annotation.Configuration;
    8 | import org.springframework.stereotype.Service;
    9 | 
   10 | import java.util.ArrayList;
   11 | import java.util.Arrays;
   12 | import java.util.List;
   13 | 
   14 | 
   15 | @Slf4j
   16 | @Data
   17 | @Service
   18 | public class publicAPI {
   19 | 
   20 |     private final List<String> apiEndPoints = Arrays.asList(
   21 |             "/login", "/public", "/api/public", "/errorPage", "/notExist", "/unauthorized", "/swagger-ui.html", "/v2/api-docs", "/swagger-resources", "/webjars", "/swagger-resources/configuration/ui", "/swagger-resources/configuration/security"
   22 |             ,"/oauth2/authorization/google", "/oauth2/authorization/google", "/oauth2/authorization/facebook", "/oauth2/authorization/github", "/oauth2/authorization/linkedin", "/oauth2/authorization/instagram", "/oauth2/authorization/twitter", "/oauth2/authorization/yahoo", "/oauth2/authorization/spotify", "/oauth2/authorization/amazon", "/oauth2/authorization/microsoft", "/oauth2/authorization/okta", "/oauth2/authorization/slack"
   23 |             ,"/oauth2/callback/google", "/oauth2/callback/google", "/oauth2/callback/facebook", "/oauth2/callback/github", "/oauth2/callback/linkedin", "/oauth2/callback/instagram", "/oauth2/callback/twitter", "/oauth2/callback/yahoo", "/oauth2/callback/spotify", "/oauth2/callback/amazon", "/oauth2/callback/microsoft", "/oauth2/callback/okta", "/oauth2/callback/slack",
   24 |             "/user/login", "/user/register", "/user/verify", "/user/forgetPassword", "/user/resetPassword", "/user/verifyResetPassword", "/user/verifyEmail", "/user/resendVerificationEmail"
   25 |     );
   26 | 
   27 |     public boolean checkRequestAPI(HttpServletRequest request){
   28 | 
   29 |     String requestURI = request.getRequestURI();
   30 |         log.info("Request URI: {}", requestURI); // log the request URI
   31 |         return (apiEndPoints.contains(requestURI));
   32 |     }
   33 | }

#--------------------------------------------------------------------------------


# File: backend/src/main/java/com/authentication/auth/configuration/security/SecurityConfig.java
#=============================================================================

    1 | package com.authentication.auth.configuration.security;
    2 | 
    3 | import com.fasterxml.jackson.databind.ObjectMapper;
    4 | import lombok.RequiredArgsConstructor;
    5 | import lombok.extern.slf4j.Slf4j;
    6 | import org.springframework.context.annotation.Bean;
    7 | import org.springframework.context.annotation.Configuration;
    8 | import org.springframework.security.authentication.AuthenticationManager;
    9 | import org.springframework.security.config.annotation.authentication.configuration.AuthenticationConfiguration;
   10 | import org.springframework.security.config.annotation.web.builders.HttpSecurity;
   11 | import org.springframework.security.config.annotation.web.configuration.EnableWebSecurity;
   12 | import org.springframework.security.config.annotation.web.configurers.AbstractHttpConfigurer;
   13 | import org.springframework.security.config.http.SessionCreationPolicy;
   14 | import org.springframework.security.crypto.bcrypt.BCryptPasswordEncoder;
   15 | import org.springframework.security.web.SecurityFilterChain;
   16 | import org.springframework.security.web.authentication.UsernamePasswordAuthenticationFilter;
   17 | import org.springframework.web.cors.CorsConfigurationSource;
   18 | 
   19 | @Slf4j
   20 | @Configuration
   21 | @EnableWebSecurity
   22 | @RequiredArgsConstructor
   23 | public class SecurityConfig {
   24 | 
   25 |     private final FilterRegistry filterRegistry; 
   26 | 
   27 |     @Bean
   28 |     public SecurityFilterChain filterChain(HttpSecurity http) throws Exception {
   29 |         // cors
   30 |         http.cors(cors -> cors.configurationSource(corsConfigurationSource));
   31 |         // 폼 로그인 비활성화
   32 |         http.formLogin(AbstractHttpConfigurer::disable);
   33 |         // Cross-Site Request Forgery 공격 방어 비활성화
   34 |         http.csrf(AbstractHttpConfigurer::disable);
   35 |         // HTTP 기본 인증 비활성화
   36 |         http.httpBasic(AbstractHttpConfigurer::disable);
   37 |         // session 기반 로그인 비활성화
   38 |         http.sessionManagement(management ->
   39 |                 management.sessionCreationPolicy(SessionCreationPolicy.STATELESS));
   40 | 
   41 |         //filter
   42 |         filterRegistry.registerFilters(http);
   43 | 
   44 |         // authorization
   45 |         http.authorizeHttpRequests((authorize) -> {
   46 |             authorize
   47 |                     .requestMatchers(PathRequest.toStaticResources().atCommonLocations()).permitAll()
   48 |                     .requestMatchers("/api/public/**").permitAll()
   49 |                     .requestMatchers(userRestrict).hasAnyAuthority("ADMIN", "USER", "COMPANY")
   50 |                     .requestMatchers(adminRestrict).hasAnyAuthority("ADMIN")
   51 |                     .requestMatchers(companyRestrict).hasAnyAuthority("COMPANY", "ADMIN")
   52 |                     .requestMatchers(oauth2Restrict).permitAll()
   53 |                     .anyRequest().permitAll();
   54 |         });
   55 | 
   56 | 
   57 | 
   58 |         http.formLogin(formLogin -> formLogin
   59 |                 .loginPage("/login").defaultSuccessUrl("/"));
   60 | 
   61 |         // 사용자 정보 서비스 및 암호화 설정
   62 |         http.userDetailsService(principalDetailService);
   63 | 
   64 |         // OAUTH 로그인 설정
   65 |         //http.oauth2Login(login -> login.loginPage("/login"));
   66 | 
   67 |         return http.build();
   68 |     }
   69 | 
   70 | 
   71 |     @Bean
   72 |     public BCryptPasswordEncoder passwordEncoder() {
   73 |         return new BCryptPasswordEncoder();
   74 |     }
   75 | 
   76 |     @Bean
   77 |     public ObjectMapper objectMapper() {
   78 |         return new ObjectMapper();
   79 |     }
   80 | 
   81 | }

#--------------------------------------------------------------------------------


# File: backend/src/main/java/com/authentication/auth/configuration/security/corsConfig.java
#=============================================================================

    1 | package com.authentication.auth.configuration.security;
    2 | 
    3 | import org.springframework.beans.factory.annotation.Value;
    4 | import org.springframework.context.annotation.Bean;
    5 | import org.springframework.context.annotation.Configuration;
    6 | import org.springframework.web.cors.CorsConfiguration;
    7 | import org.springframework.web.cors.CorsConfigurationSource;
    8 | import org.springframework.web.cors.UrlBasedCorsConfigurationSource;
    9 | 
   10 | import java.util.Arrays;
   11 | import java.util.List;
   12 | 
   13 | @Configuration
   14 | public class corsConfig {
   15 | 
   16 |     @Value("${site.domain}")
   17 |     private String siteDomain;
   18 |     @Value("${server.cookie.domain}")
   19 |     private String rootDomain;
   20 | 
   21 |     @Bean
   22 |     public CorsConfigurationSource corsConfigurationSource() {
   23 |         CorsConfiguration corsConfiguration = new CorsConfiguration();
   24 |         corsConfiguration.setAllowedOrigins(List.of(
   25 |                         "http://localhost:3000",
   26 |                         "http://127.0.0.1:3000",
   27 |                         "https://" + rootDomain,
   28 |                         "https://" + siteDomain,
   29 |                         "http://192.168.0.44",
   30 |                         "http://192.168.0.44:3000"
   31 |                 ));
   32 |         corsConfiguration.setAllowedMethods(Arrays.asList("GET", "POST", "OPTIONS", "PATCH", "DELETE", "UPDATE"));
   33 |         corsConfiguration.setAllowedHeaders(Arrays.asList("Content-Type", "Authorization", "provider"));
   34 |         corsConfiguration.setAllowCredentials(true);
   35 | 
   36 |         UrlBasedCorsConfigurationSource source = new UrlBasedCorsConfigurationSource();
   37 |         source.registerCorsConfiguration("/**", corsConfiguration);
   38 |         return source;
   39 |     }
   40 | }

#--------------------------------------------------------------------------------


# File: backend/src/main/java/com/authentication/auth/configuration/token/jwtUtility.java
#=============================================================================

    1 | package com.authentication.auth.configuration.token;
    2 | 
    3 | import com.authentication.auth.DTO.token.TokenDto;
    4 | import io.jsonwebtoken.*;
    5 | import io.jsonwebtoken.security.Keys;
    6 | import jakarta.servlet.http.Cookie;
    7 | import jakarta.servlet.http.HttpServletRequest;
    8 | import jakarta.servlet.http.HttpServletResponse;
    9 | import lombok.extern.slf4j.Slf4j;
   10 | import org.springframework.beans.factory.annotation.Value;
   11 | import org.springframework.context.annotation.Bean;
   12 | import org.springframework.security.authentication.UsernamePasswordAuthenticationToken;
   13 | import org.springframework.security.core.GrantedAuthority;
   14 | import org.springframework.security.core.userdetails.UserDetails;
   15 | import org.springframework.stereotype.Component;
   16 | import org.springframework.transaction.annotation.Transactional;
   17 | import org.springframework.web.client.RestTemplate;
   18 | 
   19 | import java.io.IOException;
   20 | import java.io.PrintWriter;
   21 | import java.security.Key;
   22 | import java.time.Instant;
   23 | import java.util.*;
   24 | 
   25 | @Slf4j
   26 | @Component
   27 | public class jwtUtility {
   28 | 
   29 |     
   30 | 
   31 | 
   32 |     public jwtUtility(
   33 |             @Value("${jwt.secret-key}") String secretKey,
   34 |             @Value("${jwt.secret-key2}") String secretKey2,
   35 |             @Value("${ACCESS_TOKEN_VALIDITY}") Long ACCESS_TOKEN_VALIDITY,
   36 |             @Value("${REFRESH_TOKEN_VALIDITY}") Long REFRESH_TOKEN_VALIDITY){
   37 |         this.key = Keys.hmacShaKeyFor(secretKey.getBytes());
   38 |         this.key2 = Keys.hmacShaKeyFor(secretKey2.getBytes());
   39 |         this.ACCESS_TOKEN_VALIDITY = ACCESS_TOKEN_VALIDITY;
   40 |         this.REFRESH_TOKEN_VALIDITY = REFRESH_TOKEN_VALIDITY;
   41 |     }
   42 | 
   43 | 
   44 |     public TokenDto buildToken(String userId, String nickname, Collection<? extends GrantedAuthority> role) {
   45 |         Claims claims = createClaims(userId, nickname, role);
   46 | 
   47 |         // 토큰 만료 시간 설정
   48 |         Instant now = Instant.now();
   49 |         Instant validity = now.plusSeconds(ACCESS_TOKEN_VALIDITY);
   50 |         Instant validity2 = now.plusSeconds(REFRESH_TOKEN_VALIDITY);
   51 | 
   52 |         // 액세스 토큰 생성
   53 |         String accessToken = buildToken(claims, now, validity, key, SecurityConstants.TOKEN_TYPE);
   54 |         // 리프레시 토큰 생성
   55 |         String refreshToken = buildToken(Jwts.claims(), now, validity2, key2, SecurityConstants.TOKEN_TYPE2);
   56 | 
   57 |         return TokenDto.builder()
   58 | 
   59 |         return tokenDto.builder()
   60 |                 .refreshToken(refreshToken)
   61 |                 .accessToken(accessToken)
   62 |                 .build();
   63 |     }
   64 | /* <<<<<<<<<<  2f21aafa-d159-41a6-892b-76ef4b9b83f8  >>>>>>>>>>> */
   65 | 
   66 |     // 클레임 생성 유틸리티 메서드
   67 |     private Claims createClaims(String userId, String nickname, Collection<? extends GrantedAuthority> role) {
   68 |         Claims claims = Jwts.claims();
   69 |         claims.put("userId", userId);
   70 |         claims.put("nickname", nickname);
   71 |         claims.put("role", role);
   72 |         return claims;
   73 |     }
   74 | 
   75 |     // 토큰 생성 유틸리티 메서드
   76 |     private String buildToken(Claims claims, Instant issuedAt, Instant expiry, Key signingKey, String type) {
   77 |         return Jwts.builder()
   78 |                 .setClaims(claims)
   79 |                 .setIssuedAt(Date.from(issuedAt))
   80 |                 .setExpiration(Date.from(expiry))
   81 |                 .signWith(signingKey, SignatureAlgorithm.HS512)
   82 |                 .claim("type", type)
   83 |                 .compact();
   84 |     }
   85 | 
   86 |     public UsernamePasswordAuthenticationToken getAuthentication(String JWT){
   87 |         try {
   88 |             Jws<Claims> parsedToken = Jwts.parserBuilder()
   89 |                     .setSigningKey(key)
   90 |                     .build()
   91 |                     .parseClaimsJws(JWT);
   92 | 
   93 |             log.info("parsedToken : " + parsedToken);
   94 |             users user = new users();
   95 | 
   96 |             List<LinkedHashMap<String, String>> roleList =
   97 |                     (List<LinkedHashMap<String, String>>) parsedToken.getBody().get("role");
   98 | 
   99 |             Role role = Role .valueOf(roleList.get(0).get("authority"));
  100 |             log.info("role : {}", role.toString());
  101 |             user = user.builder()
  102 |                     .userId((String) parsedToken.getBody().get("userId"))
  103 |                     .role(role)
  104 |                     .build();
  105 | 
  106 |             UserDetails userDetails = new principalDetails(user);
  107 | 
  108 | 
  109 |             log.info(userDetails.getUsername());
  110 |             log.info(userDetails.getAuthorities().toString());
  111 | 
  112 |             Collection<? extends GrantedAuthority> authorities = userDetails.getAuthorities();
  113 |             return new UsernamePasswordAuthenticationToken(userDetails, null, authorities);
  114 |         } catch (Exception e){
  115 |             log.error("authentication 과정에서 Exception 발생! " + e.getMessage());
  116 |             return null;
  117 |         }
  118 |     }
  119 | 
  120 |     public boolean validateJWT(String JWT) {
  121 |         try {
  122 |             Jws<Claims> parsedToken = Jwts.parserBuilder()
  123 |                     .setSigningKey(key)
  124 |                     .build()
  125 |                     .parseClaimsJws(JWT);
  126 | 
  127 |             log.info("JWT 유효성 검증 통과 - 만료일: {}", parsedToken.getBody().getExpiration());
  128 |             return !parsedToken.getBody().getExpiration().before(new Date());
  129 |         } catch (ExpiredJwtException e) {
  130 |             log.error("JWT 만료 - {}", e.getMessage());
  131 |             return false;
  132 |         } catch (UnsupportedJwtException e) {
  133 |             log.error("지원되지 않는 JWT - {}", e.getMessage());
  134 |             return false;
  135 |         } catch (MalformedJwtException e) {
  136 |             log.error("잘못된 형식의 JWT - {}", e.getMessage());
  137 |             return false;
  138 |         } catch (JwtException e) {
  139 |             log.error("JWT 예외 발생 - {}", e.getMessage());
  140 |             return false;
  141 |         } catch (Exception e) {
  142 |             log.error("JWT 처리 중 일반 예외 발생 - {}", e.getMessage());
  143 |             return false;
  144 |         }
  145 | 
  146 |     }
  147 | 
  148 |     public boolean validateRefreshJWT(String refreshJWT) {
  149 |         try{
  150 |             Jws<Claims> parsedRefreshToken = Jwts.parserBuilder()
  151 |                     .setSigningKey(key2)
  152 |                     .build()
  153 |                     .parseClaimsJws(refreshJWT);
  154 |             return !parsedRefreshToken.getBody().getExpiration().before(new Date());
  155 |         } catch(ExpiredJwtException e){
  156 |             log.error("refresh token expired");
  157 |             return false;
  158 |         } catch (JwtException e){
  159 |             log.error("refresh token tampered");
  160 |             return false;
  161 |         } catch(NullPointerException e){
  162 |             log.error("refresh token is null");
  163 |             return false;
  164 |         } catch (Exception e){
  165 |             log.error("refresh token error");
  166 |             return false;
  167 |         }
  168 |     }
  169 | 
  170 | 
  171 | 
  172 |     public Map<String, Object> getClaimsFromAccessToken(String JWT) {
  173 |         try {
  174 |             Jws<Claims> parsedToken = Jwts.parserBuilder()
  175 |                     .setSigningKey(key)
  176 |                     .build()
  177 |                     .parseClaimsJws(JWT);
  178 | 
  179 |             Claims claims = parsedToken.getBody();
  180 | 
  181 |             Map<String, Object> claimMap = new HashMap<>();
  182 |             claimMap.put("userId", claims.get("userId"));
  183 |             claimMap.put("nickname", claims.get("nickname"));
  184 |             claimMap.put("role", claims.get("role"));
  185 |             return claimMap;
  186 |         } catch (ExpiredJwtException e) {
  187 |             log.error("| jwt utils | expired Token!");
  188 |             Map<String, Object> claimMap = new HashMap<>();
  189 |             claimMap.put("userId", e.getClaims().get("userId"));
  190 |             claimMap.put("nickname", e.getClaims().get("nickname"));
  191 |             claimMap.put("role", e.getClaims().get("role"));
  192 |             return claimMap;
  193 |         } catch (JwtException e) {
  194 |             throw new RuntimeException("token error");
  195 |         }
  196 |     }
  197 | 
  198 | 
  199 |     // 기존 토큰을 기반으로 새로운 토큰을 발급하는 메서드
  200 |     public String refreshToken(String expiredToken) {
  201 |         Claims claims; Instant now = Instant.now();Instant newExpiry = now.plusSeconds(ACCESS_TOKEN_VALIDITY);
  202 |         try {
  203 |             claims = extractClaims(expiredToken);
  204 |         } catch (ExpiredJwtException e) {
  205 |             claims = e.getClaims();
  206 |         } catch (JwtException e) {
  207 |             throw new RuntimeException("token error");
  208 |         }
  209 |         return buildToken(claims, now, newExpiry, key, SecurityConstants.TOKEN_TYPE);
  210 |     }
  211 | 
  212 | 
  213 |     public String getUserIdFromToken(String token) {
  214 |         if (token == null) {
  215 |             throw new IllegalArgumentException("Token is null");
  216 |         }
  217 | 
  218 |         Claims getClaims = this.extractClaims(token);
  219 |         return getClaims.get("userId", String.class);  // userId를 String으로 반환
  220 |     }
  221 | 
  222 | 
  223 |     // access 토큰에서 Claims 를 추출하는 유틸리티 메서드
  224 |     public Claims extractClaims(String token) {
  225 |         return Jwts.parserBuilder()
  226 |                 .setSigningKey(key)
  227 |                 .build()
  228 |                 .parseClaimsJws(token)
  229 |                 .getBody();
  230 |     }
  231 | 
  232 |     public String checkSnsCookie(HttpServletRequest request, HttpServletResponse response) throws IOException {
  233 |         String providerHeader = request.getHeader("provider"); // SNS 정보 제공자 추가하기
  234 |         Cookie[] cookies = request.getCookies();
  235 |         String RToken = null;
  236 |         if (cookies != null) {
  237 |             for (Cookie cookie : cookies) {
  238 |                 if (cookie.getName().equals(providerHeader + "_refreshToken")) {
  239 |                     RToken = cookie.getValue();
  240 |                     break;
  241 |                 }
  242 |             }
  243 |         }
  244 |         if (RToken == null) {
  245 |             sendResponseStatus(response, HttpServletResponse.SC_UNAUTHORIZED, "there's no refreshToken");
  246 |         }
  247 |         return RToken;
  248 |     }
  249 | 
  250 |     private void sendResponseStatus(HttpServletResponse response, int status, String message)
  251 |             throws IOException{
  252 |         response.setStatus(status);
  253 |         PrintWriter writer = response.getWriter();
  254 |         response.setContentType("application/json");
  255 |         response.setCharacterEncoding("UTF-8");
  256 |         writer.print("{\"message\":\"" + message + "\"}");
  257 |         writer.flush();
  258 |     }
  259 | 
  260 | 
  261 |     @Transactional
  262 |     public String checkCookie(HttpServletRequest request, HttpServletResponse response, String provider) throws IOException {
  263 |         Cookie[] cookies = request.getCookies();
  264 |         String RToken = null;
  265 | 
  266 |         if (cookies == null) {
  267 |             sendResponseStatus(response, HttpServletResponse.SC_UNAUTHORIZED, "there's no cookies");
  268 |             return null;
  269 |         }
  270 | 
  271 |         if (!"server".equals(provider)) {
  272 |             for (Cookie cookie : cookies) {
  273 |                 if (cookie.getName().equals(provider + "_refreshToken")) {
  274 |                     RToken = cookie.getValue();
  275 |                     break;
  276 |                 }
  277 |             }
  278 |         } else {
  279 |             for (Cookie cookie : cookies) {
  280 |                 if (cookie.getName().equals("refreshToken")) {
  281 |                     RToken = cookie.getValue();
  282 |                     break;
  283 |                 }
  284 |             }
  285 |         }
  286 | 
  287 |         if (RToken == null) {
  288 |             sendResponseStatus(response, HttpServletResponse.SC_UNAUTHORIZED, "there's no refreshToken");
  289 |         }
  290 | 
  291 |         return RToken;
  292 |     }
  293 | 
  294 | 
  295 |     @Bean
  296 |     public RestTemplate restTemplate() {
  297 |         return new RestTemplate();
  298 |     }
  299 | 
  300 | }

#--------------------------------------------------------------------------------


# File: backend/src/main/java/com/authentication/auth/configuration/redis/redisConfig.java
#=============================================================================

    1 | package com.authentication.auth.configuration.redis;
    2 | 
    3 | import org.springframework.beans.factory.annotation.Value;
    4 | import org.springframework.context.annotation.Bean;
    5 | import org.springframework.context.annotation.Configuration;
    6 | import org.springframework.data.redis.connection.RedisConnectionFactory;
    7 | import org.springframework.data.redis.connection.RedisStandaloneConfiguration;
    8 | import org.springframework.data.redis.connection.lettuce.LettuceConnectionFactory;
    9 | import org.springframework.data.redis.core.RedisTemplate;
   10 | import org.springframework.data.redis.serializer.StringRedisSerializer;
   11 | 
   12 | @Configuration
   13 | public class redisConfig {
   14 | 
   15 |     @Value("${spring.data.redis.host}")
   16 |     private String host;
   17 | 
   18 |     @Value("${spring.data.redis.port}")
   19 |     private int port;
   20 | 
   21 |     @Value("${spring.data.redis.password}")
   22 |     private String password;
   23 | 
   24 | 
   25 |     @Bean
   26 |     public RedisConnectionFactory redisConnectionFactory() {
   27 |         RedisStandaloneConfiguration redisStandaloneConfiguration = new RedisStandaloneConfiguration();
   28 |         redisStandaloneConfiguration.setHostName(host);
   29 |         redisStandaloneConfiguration.setPort(port);
   30 |         redisStandaloneConfiguration.setPassword(password);
   31 |         return new LettuceConnectionFactory(redisStandaloneConfiguration);
   32 |     }
   33 | 
   34 | 
   35 |     @Bean
   36 |     public RedisTemplate<?, ?> redisTemplate() {
   37 |         RedisTemplate<?, ?> redisTemplate = new RedisTemplate<>();
   38 |         redisTemplate.setKeySerializer(new StringRedisSerializer());
   39 |         redisTemplate.setValueSerializer(new StringRedisSerializer());
   40 |         redisTemplate.setConnectionFactory(redisConnectionFactory());
   41 |         return redisTemplate;
   42 |     }
   43 | }

#--------------------------------------------------------------------------------


# File: backend/src/main/java/com/authentication/auth/repository/usersRepository.java
#=============================================================================

    1 | package com.career_block.auth.repository;
    2 | 
    3 | import com.authentication.auth.domain.User;
    4 | import com.authentication.auth.domain.users;
    5 | 
    6 | import org.springframework.data.jpa.repository.JpaRepository;
    7 | import org.springframework.data.jpa.repository.Modifying;
    8 | import org.springframework.data.jpa.repository.Query;
    9 | import org.springframework.transaction.annotation.Transactional;
   10 | 
   11 | import java.util.Optional;
   12 | 
   13 | public interface usersRepository extends JpaRepository<users, Long> {
   14 | 
   15 |     User findByUserId(String userId);
   16 |     boolean existsByEmail(String email);
   17 |     boolean existsByUserIdOrNickname(String userId, String nickname);
   18 |     boolean existsByNickname(String nickname);
   19 | 
   20 |     boolean existsByUserId(String userId);
   21 | 
   22 |     @Modifying
   23 |     @Transactional
   24 |     @Query("UPDATE users u SET u.userPw = :password WHERE u.userId = :userId")
   25 |     int updatePassword(String userId, String password);
   26 | 
   27 |     Optional<User> findByProviderAndProviderId(String provider, String providerId);
   28 | }

#--------------------------------------------------------------------------------


# File: backend/src/main/java/com/authentication/auth/repository/AuthProviderRepository.java
#=============================================================================


#--------------------------------------------------------------------------------


# File: backend/src/main/java/com/authentication/auth/service/sse/sseService.java
#=============================================================================

    1 | package com.career_block.auth.service.sse;
    2 | 
    3 | import lombok.extern.slf4j.Slf4j;
    4 | import org.springframework.security.core.parameters.P;
    5 | import org.springframework.stereotype.Service;
    6 | import org.springframework.web.servlet.mvc.method.annotation.SseEmitter;
    7 | 
    8 | import java.io.IOException;
    9 | import java.util.List;
   10 | import java.util.concurrent.ConcurrentHashMap;
   11 | import java.util.concurrent.CopyOnWriteArrayList;
   12 | 
   13 | @Slf4j
   14 | @Service
   15 | public class sseService {
   16 | 
   17 |     // 사용자 ID를 키로, SseEmitter 목록을 값으로 저장
   18 |     private final ConcurrentHashMap<String, List<SseEmitter>> emittersMap = new ConcurrentHashMap<>();
   19 | 
   20 | 
   21 |     // SseEmitter 저장
   22 |     public boolean saveSseEmitter(String userId, SseEmitter emitter) {
   23 |         if (userId == null || userId.isEmpty() || emitter == null) {
   24 |             log.error("userId or emitter is null");
   25 |             return false;
   26 |         }
   27 | 
   28 |         emittersMap.computeIfAbsent(userId, k -> new CopyOnWriteArrayList<>()).add(emitter);
   29 | 
   30 |         // 연결 종료 시 제거
   31 |         emitter.onCompletion(() -> removeEmitter(userId, emitter));
   32 |         emitter.onTimeout(() -> removeEmitter(userId, emitter));
   33 |         emitter.onError((e) -> removeEmitter(userId, emitter));
   34 | 
   35 |         log.info("SseEmitter saved for userId: {}", userId);
   36 |         return true;
   37 |     }
   38 | 
   39 | 
   40 |     // SseEmitter 제거
   41 |     public void removeEmitter(String userId, SseEmitter emitter){
   42 |         List<SseEmitter> emitters = emittersMap.get(userId);
   43 |         if (emitters != null) {
   44 |             emitters.remove(emitter);
   45 |             if (emitters.isEmpty()) {
   46 |                 emittersMap.remove(userId);
   47 |             }
   48 |         }
   49 |     }
   50 | 
   51 | 
   52 |     // 특정 사용자에게 이벤트 전송
   53 |     public void sendEventToUser(String userId, Object data) {
   54 |         List<SseEmitter> emitters = emittersMap.get(userId);
   55 |         if (emitters != null) {
   56 |             emitters.forEach(emitter -> {
   57 |                 try {
   58 |                     emitter.send(SseEmitter.event().name("message").data(data));
   59 |                 } catch (IOException e) {
   60 |                     log.error("Error sending event to userId: {}", userId, e);
   61 |                     removeEmitter(userId, emitter);
   62 |                 }
   63 |             });
   64 |         }
   65 |     }
   66 | 
   67 | 
   68 |     // 모든 사용자에게 이벤트 전송
   69 |     public void sendEventToAll(Object data) {
   70 |         emittersMap.forEach((userId, emitters) -> {
   71 |             sendEventToUser(userId, data);
   72 |         });
   73 |     }
   74 | 
   75 | 
   76 | }

#--------------------------------------------------------------------------------


# File: backend/src/main/java/com/authentication/auth/service/users/userService.java
#=============================================================================

    1 | package com.career_block.auth.service.users;
    2 | 
    3 | import lombok.RequiredArgsConstructor;
    4 | import lombok.extern.slf4j.Slf4j;
    5 | import org.springframework.http.HttpStatus;
    6 | import org.springframework.http.ResponseEntity;
    7 | import org.springframework.security.crypto.bcrypt.BCryptPasswordEncoder;
    8 | import org.springframework.stereotype.Service;
    9 | import org.springframework.transaction.annotation.Transactional;
   10 | 
   11 | import com.authentication.auth.DTO.users.joinRequest;
   12 | import com.authentication.auth.domain.Role;
   13 | import com.authentication.auth.domain.users;
   14 | import com.authentication.auth.repository.usersRepository;
   15 | 
   16 | @Slf4j
   17 | @Service
   18 | @RequiredArgsConstructor
   19 | public class userService {
   20 | 
   21 |     private final usersRepository usersRepository;
   22 |     private final BCryptPasswordEncoder passwordEncoder;
   23 | 
   24 |     @Transactional
   25 |     public ResponseEntity<?> join(joinRequest request){
   26 |         if (usersRepository.existsByUserIdOrNickname(request.getUserId(), request.getNickname())) {
   27 |             log.error("이미 존재하는 아이디 혹은 닉네임 입니다.");
   28 |             return ResponseEntity.status(HttpStatus.CONFLICT).build();
   29 |         }
   30 | 
   31 |         try {
   32 |             joinRequest joinRequestBuilder = joinRequest.builder()
   33 |                     .userId(request.getUserId())
   34 |                     .userPw(passwordEncoder.encode(request.getUserPw()))
   35 |                     .userName(request.getUserName())
   36 |                     .nickname(request.getNickname())
   37 |                     .phone(request.getPhone())
   38 |                     .email(request.getEmail())
   39 |                     .role(Role.USER)
   40 |                     .birthDate(request.getBirthDate())
   41 |                     .gender(request.getGender())
   42 |                     .isPrivate(request.isPrivate())
   43 |                     .profile(request.getProfile() != null ? request.getProfile() : "대충 이미지")
   44 |                     .build();
   45 |             users joinUser = joinRequestBuilder.toEntity();
   46 |             usersRepository.save(joinUser);
   47 |             return ResponseEntity.status(HttpStatus.OK).build();
   48 |         } catch (Exception e) {
   49 |             log.error("회원 가입 실패", e);
   50 |             return ResponseEntity.status(HttpStatus.INTERNAL_SERVER_ERROR).build();
   51 |         }
   52 |     }
   53 | 
   54 | 
   55 |     @Transactional
   56 |     public String getEmailByUserId(String userId){
   57 |         try{
   58 |             users user = usersRepository.findByUserId(userId);
   59 |             return user.getEmail();
   60 |         } catch (Exception e){
   61 |             log.error("이메일 찾기 실패", e);
   62 |             return null;
   63 |         }
   64 |     }
   65 | 
   66 | 
   67 |     @Transactional
   68 |     public void UpdateUserPassword(String userId, String temporalPassword) {
   69 |         try {
   70 |             int updateCount = usersRepository.updatePassword(userId, passwordEncoder.encode(temporalPassword));
   71 |             if (updateCount == 0) throw new Exception("비밀번호 변경 실패! 사용자를 찾을 수 없음");
   72 |         } catch (Exception e) {
   73 |             log.error("비밀번호 변경 실패", e);
   74 |         }
   75 |     }
   76 | 
   77 | 
   78 | 
   79 |     @Transactional
   80 |     public boolean checkUserIdIsDuplicate(String userId) {
   81 |         return usersRepository.existsByUserId(userId);
   82 |     }
   83 | 
   84 |     @Transactional
   85 |     public boolean checkNickNameIsDuplicate(String nickname) {
   86 |         return usersRepository.existsByNickname(nickname);
   87 |     }
   88 | 
   89 | 
   90 | 
   91 | }

#--------------------------------------------------------------------------------


# File: backend/src/main/java/com/authentication/auth/service/oauth2/snsTokenValidator.java
#=============================================================================

    1 | package com.career_block.auth.service.oauth2;
    2 | 
    3 | import lombok.extern.slf4j.Slf4j;
    4 | import org.springframework.beans.factory.annotation.Value;
    5 | import org.springframework.http.*;
    6 | import org.springframework.stereotype.Service;
    7 | import org.springframework.util.LinkedMultiValueMap;
    8 | import org.springframework.util.MultiValueMap;
    9 | import org.springframework.web.client.RestTemplate;
   10 | 
   11 | import java.util.HashMap;
   12 | import java.util.Map;
   13 | 
   14 | @Slf4j
   15 | @Service
   16 | public class snsTokenValidator {
   17 | 
   18 | 
   19 |     @Value("${kakao.token.validate.url}")
   20 |     private String kakaoValidateURL;
   21 | 
   22 |     @Value("${naver.token.validate.url}")
   23 |     private String naverValidateURL;
   24 | 
   25 |     @Value("${google.token.validate.url}")
   26 |     private String googleValidateURL;
   27 | 
   28 |     @Value("${spring.security.oauth2.client.registration.kakao.client-id}")
   29 |     private String kakaoClientId;
   30 | 
   31 |     @Value("${spring.security.oauth2.client.registration.kakao.client-secret}")
   32 |     private String kakaoClientSecret;
   33 | 
   34 |     @Value("${spring.security.oauth2.client.registration.kakao.redirect-uri}")
   35 |     private String kakaoRedirectUri;
   36 | 
   37 |     @Value("${spring.security.oauth2.client.registration.naver.client-id}")
   38 |     private String naverClientId;
   39 | 
   40 |     @Value("${spring.security.oauth2.client.registration.naver.client-secret}")
   41 |     private String naverClientSecret;
   42 | 
   43 |     @Value("${spring.security.oauth2.client.registration.naver.redirect-uri}")
   44 |     private String naverRedirectUri;
   45 | 
   46 |     @Value("${spring.security.oauth2.client.registration.google.client-id}")
   47 |     private String googleClientId;
   48 | 
   49 |     @Value("${spring.security.oauth2.client.registration.google.client-secret}")
   50 |     private String googleClientSecret;
   51 | 
   52 |     @Value("${spring.security.oauth2.client.registration.google.redirect-uri}")
   53 |     private String googleRedirectUri;
   54 | 
   55 |     @Value("${site.domain}")
   56 |     private String domain;
   57 | 
   58 |     private final RestTemplate restTemplate;
   59 | 
   60 |     public snsTokenValidator(RestTemplate restTemplate) {
   61 |         this.restTemplate = restTemplate;
   62 |     }
   63 | 
   64 | 
   65 |     public boolean validateToken(String token, String provider) {
   66 |         log.info("provider : [{}] token validation start", provider);
   67 |         return switch (provider) {
   68 |             case "kakao" -> kakaoValidateToken(token);
   69 |             case "naver" -> naverValidateToken(token);
   70 |             case "google" -> googleValidateToken(token);
   71 |             default -> false;
   72 |         };
   73 |     }
   74 | 
   75 |     public Map<String, String> getNewTokenByRefreshToken(String refreshToken, String provider) {
   76 |         String url = null;
   77 |         MultiValueMap<String, String> params = new LinkedMultiValueMap<>();
   78 |         RestTemplate restTemplate = new RestTemplate();
   79 |         HttpHeaders headers = new HttpHeaders();
   80 |         headers.add("Content-Type", "application/x-www-form-urlencoded");
   81 | 
   82 |         switch (provider) {
   83 |             case "kakao":
   84 |                 url = "https://kauth.kakao.com/oauth/token";
   85 |                 params.add("grant_type", "refresh_token");
   86 |                 params.add("client_id", kakaoClientId);
   87 |                 params.add("refresh_token", refreshToken);
   88 |                 params.add("client_secret", kakaoClientSecret);
   89 |                 break;
   90 |             case "naver":
   91 |                 url = "https://nid.naver.com/oauth2.0/token";
   92 |                 params.add("grant_type", "refresh_token");
   93 |                 params.add("client_id", naverClientId);
   94 |                 params.add("refresh_token", refreshToken);
   95 |                 params.add("client_secret", naverClientSecret);
   96 |                 break;
   97 |             case "google":
   98 |                 url = "https://oauth2.googleapis.com/token";
   99 |                 params.add("grant_type", "refresh_token");
  100 |                 params.add("client_id", googleClientId);
  101 |                 params.add("refresh_token", refreshToken);
  102 |                 params.add("client_secret", googleClientSecret);
  103 |                 break;
  104 |             default:
  105 |                 throw new IllegalArgumentException("Unsupported provider: " + provider);
  106 |         }
  107 | 
  108 |         HttpEntity<MultiValueMap<String, String>> entity = new HttpEntity<>(params, headers);
  109 |         ResponseEntity<Map> response = restTemplate.exchange(url, HttpMethod.POST, entity, Map.class);
  110 | 
  111 |         if (response.getStatusCode() == HttpStatus.OK && response.getBody() != null) {
  112 |             Map<String, String> tokens = new HashMap<>();
  113 |             tokens.put("access_token", response.getBody().get("access_token").toString());
  114 |             if (response.getBody().containsKey("refresh_token")) {
  115 |                 tokens.put("refresh_token", response.getBody().get("refresh_token").toString());
  116 |             }
  117 |             return tokens;
  118 |         } else {
  119 |             throw new RuntimeException("Failed to get sns tokens for provider: " + provider);
  120 |         }
  121 |     }
  122 | 
  123 | 
  124 | 
  125 |     private boolean kakaoValidateToken(String token) {
  126 |         String url = kakaoValidateURL;
  127 |         HttpHeaders headers = new HttpHeaders();
  128 |         headers.set("Authorization", "Bearer " + token);
  129 |         HttpEntity<String> entity = new HttpEntity<>(headers);
  130 |         try {
  131 |             ResponseEntity<String> response = restTemplate.exchange(url, HttpMethod.GET, entity, String.class);
  132 |             return response.getStatusCode().is2xxSuccessful();
  133 |         } catch (Exception e) {
  134 |             log.error("카카오 토큰 검증 중 에러 발생", e);
  135 |             return false;
  136 |         }
  137 |     }
  138 | 
  139 |     private boolean naverValidateToken(String token) {
  140 |         String url = naverValidateURL;
  141 |         HttpHeaders headers = new HttpHeaders();
  142 |         headers.set("Authorization", "Bearer " + token);
  143 |         HttpEntity<String> entity = new HttpEntity<>(headers);
  144 |         try {
  145 |             ResponseEntity<String> response = restTemplate.exchange(url, HttpMethod.GET, entity, String.class);
  146 |             return response.getStatusCode().is2xxSuccessful();
  147 |         } catch (Exception e) {
  148 |             log.error("네이버 토큰 검증 중 에러 발생", e);
  149 |             return false;
  150 |         }
  151 |     }
  152 | 
  153 |     private boolean googleValidateToken(String token) {
  154 |         String url = googleValidateURL + "?id_token=" + token;
  155 |         try {
  156 |             ResponseEntity<String> response = restTemplate.getForEntity(url, String.class);
  157 |             return response.getStatusCode().is2xxSuccessful();
  158 |         } catch (Exception e) {
  159 |             log.error("구글 토큰 검증 중 에러 발생", e);
  160 |             return false;
  161 |         }
  162 |     }
  163 | }

#--------------------------------------------------------------------------------


# File: backend/src/main/java/com/authentication/auth/service/oauth2/oauth2Service.java
#=============================================================================

    1 | package com.career_block.auth.service.oauth2;
    2 | 
    3 | import jakarta.servlet.http.Cookie;
    4 | import jakarta.servlet.http.HttpServletResponse;
    5 | import lombok.RequiredArgsConstructor;
    6 | import lombok.extern.slf4j.Slf4j;
    7 | import org.springframework.beans.factory.annotation.Value;
    8 | import org.springframework.http.*;
    9 | import org.springframework.security.core.authority.SimpleGrantedAuthority;
   10 | import org.springframework.stereotype.Service;
   11 | import org.springframework.transaction.annotation.Transactional;
   12 | import org.springframework.util.LinkedMultiValueMap;
   13 | import org.springframework.util.MultiValueMap;
   14 | import org.springframework.web.client.HttpClientErrorException;
   15 | import org.springframework.web.client.RestTemplate;
   16 | 
   17 | import com.authentication.auth.DTO.token.tokenDto;
   18 | import com.authentication.auth.configuration.token.jwtUtility;
   19 | import com.authentication.auth.domain.Role;
   20 | import com.authentication.auth.domain.users;
   21 | import com.authentication.auth.others.nickNameGenerator;
   22 | import com.authentication.auth.others.constants.SecurityConstants;
   23 | import com.authentication.auth.repository.usersRepository;
   24 | import com.authentication.auth.service.redis.redisService;
   25 | 
   26 | import java.net.URLDecoder;
   27 | import java.nio.charset.StandardCharsets;
   28 | import java.security.SecureRandom;
   29 | import java.text.ParseException;
   30 | import java.text.SimpleDateFormat;
   31 | import java.util.*;
   32 | 
   33 | 
   34 | @Slf4j
   35 | @Service
   36 | @RequiredArgsConstructor
   37 | public class oauth2Service {
   38 | 
   39 |     @Value("${spring.security.oauth2.client.registration.kakao.client-id}")
   40 |     private String kakaoClientId;
   41 | 
   42 |     @Value("${spring.security.oauth2.client.registration.kakao.client-secret}")
   43 |     private String kakaoClientSecret;
   44 | 
   45 |     @Value("${spring.security.oauth2.client.registration.kakao.redirect-uri}")
   46 |     private String kakaoRedirectUri;
   47 | 
   48 |     @Value("${spring.security.oauth2.client.registration.naver.client-id}")
   49 |     private String naverClientId;
   50 | 
   51 |     @Value("${spring.security.oauth2.client.registration.naver.client-secret}")
   52 |     private String naverClientSecret;
   53 | 
   54 |     @Value("${spring.security.oauth2.client.registration.naver.redirect-uri}")
   55 |     private String naverRedirectUri;
   56 | 
   57 |     @Value("${spring.security.oauth2.client.registration.google.client-id}")
   58 |     private String googleClientId;
   59 | 
   60 |     @Value("${spring.security.oauth2.client.registration.google.client-secret}")
   61 |     private String googleClientSecret;
   62 | 
   63 |     @Value("${spring.security.oauth2.client.registration.google.redirect-uri}")
   64 |     private String googleRedirectUri;
   65 | 
   66 |     @Value("${site.domain}")
   67 |     private String domain;
   68 | 
   69 |     private final usersRepository usersRepository;
   70 |     private final redisService redisService;
   71 |     private final jwtUtility jwtUtility;
   72 |     private final nickNameGenerator nickNameGenerator;
   73 | 
   74 | 
   75 |     public Map<String, String> getKakaoTokens(String tempCode) {
   76 |         log.info("current : getKakaoTokens");
   77 | 
   78 |         String url = "https://kauth.kakao.com/oauth/token";
   79 | 
   80 |         RestTemplate restTemplate = new RestTemplate();
   81 | 
   82 |         HttpHeaders headers = new HttpHeaders();
   83 |         headers.add("Content-Type", "application/x-www-form-urlencoded");
   84 | 
   85 |         MultiValueMap<String, String> params = new LinkedMultiValueMap<>();
   86 |         params.add("grant_type", "authorization_code");
   87 |         params.add("client_id", kakaoClientId);
   88 |         params.add("redirect_uri", kakaoRedirectUri);
   89 |         params.add("code", tempCode);
   90 |         params.add("client_secret", kakaoClientSecret);
   91 | 
   92 |         HttpEntity<MultiValueMap<String, String>> entity = new HttpEntity<>(params, headers);
   93 | 
   94 |         try {
   95 |             ResponseEntity<Map> response = restTemplate.exchange(url, HttpMethod.POST, entity, Map.class);
   96 | 
   97 |             if (response.getBody() != null && response.getBody().containsKey("access_token") && response.getBody().containsKey("refresh_token")) {
   98 |                 return Map.of(
   99 |                         "access_token", response.getBody().get("access_token").toString(),
  100 |                         "refresh_token", response.getBody().get("refresh_token").toString()
  101 |                 );
  102 |             } else {
  103 |                 throw new RuntimeException("액세스 토큰을 가져오지 못했습니다.");
  104 |             }
  105 |         } catch (Exception e) {
  106 |             log.error("Error while requesting tokens: ", e);
  107 |             throw e;
  108 |         }
  109 |     }
  110 | 
  111 |     public Map<String, Object> getKakaoUserProfile(String accessToken) {
  112 |         log.info("current : getKakaoUserProfile");
  113 | 
  114 |         String url = "https://kapi.kakao.com/v2/user/me";
  115 | 
  116 |         RestTemplate restTemplate = new RestTemplate();
  117 | 
  118 |         HttpHeaders headers = new HttpHeaders();
  119 |         headers.add("Authorization", "Bearer " + accessToken);
  120 | 
  121 |         log.info("Requesting user profile with accessToken: {}", accessToken);
  122 | 
  123 |         HttpEntity<Void> entity = new HttpEntity<>(headers);
  124 | 
  125 |         try {
  126 |             ResponseEntity<Map> response = restTemplate.exchange(url, HttpMethod.GET, entity, Map.class);
  127 | 
  128 |             if (response.getBody() != null) {
  129 |                 return response.getBody();
  130 |             } else {
  131 |                 throw new RuntimeException("사용자 프로필을 가져오지 못했습니다.");
  132 |             }
  133 |         } catch (Exception e) {
  134 |             log.error("Error while requesting user profile: ", e);
  135 |             throw e;
  136 |         }
  137 |     }
  138 | 
  139 |     public Map<String, String> getNaverTokens(String tempCode, String state) {
  140 |         log.info("current : getNaverTokens");
  141 | 
  142 |         String url = "https://nid.naver.com/oauth2.0/token";
  143 | 
  144 |         RestTemplate restTemplate = new RestTemplate();
  145 | 
  146 |         HttpHeaders headers = new HttpHeaders();
  147 |         headers.add("Content-Type", "application/x-www-form-urlencoded");
  148 | 
  149 |         MultiValueMap<String, String> params = new LinkedMultiValueMap<>();
  150 |         params.add("grant_type", "authorization_code");
  151 |         params.add("client_id", naverClientId);
  152 |         params.add("redirect_uri", naverRedirectUri);
  153 |         params.add("code", tempCode);
  154 |         params.add("client_secret", naverClientSecret);
  155 |         params.add("state", state);
  156 | 
  157 |         log.info("Requesting tokens with params: {}", params);
  158 | 
  159 |         HttpEntity<MultiValueMap<String, String>> entity = new HttpEntity<>(params, headers);
  160 | 
  161 |         try {
  162 |             ResponseEntity<Map> response = restTemplate.exchange(url, HttpMethod.POST, entity, Map.class);
  163 | 
  164 |             log.info("Response from Naver: {}", response);
  165 | 
  166 |             if (response.getStatusCode() == HttpStatus.OK) {
  167 |                 Map<String, Object> responseBody = response.getBody();
  168 |                 log.info("responseBody info : {}", responseBody.toString());
  169 | 
  170 |                 if (responseBody != null && responseBody.containsKey("access_token") && responseBody.containsKey("refresh_token")) {
  171 |                     log.info("Received tokens: {}", responseBody);
  172 |                     return Map.of(
  173 |                             "access_token", responseBody.get("access_token").toString(),
  174 |                             "refresh_token", responseBody.get("refresh_token").toString()
  175 |                     );
  176 |                 } else {
  177 |                     log.error("Response body is missing required tokens: {}", responseBody);
  178 |                     throw new RuntimeException("액세스 토큰을 가져오지 못했습니다.");
  179 |                 }
  180 |             } else {
  181 |                 log.error("Failed to get tokens, status code: {}, response: {}", response.getStatusCode(), response.getBody());
  182 |                 throw new RuntimeException("액세스 토큰을 가져오지 못했습니다.");
  183 |             }
  184 |         } catch (Exception e) {
  185 |             log.error("Error while requesting tokens: ", e);
  186 |             throw e;
  187 |         }
  188 |     }
  189 | 
  190 | 
  191 |     public Map<String, Object> getNaverUserProfile(String accessToken) {
  192 |         log.info("current : getNaverUserProfile");
  193 | 
  194 |         String url = "https://openapi.naver.com/v1/nid/me";
  195 | 
  196 |         RestTemplate restTemplate = new RestTemplate();
  197 | 
  198 |         HttpHeaders headers = new HttpHeaders();
  199 |         headers.add("Authorization", "Bearer " + accessToken);
  200 | 
  201 |         log.info("Requesting user profile with accessToken: {}", accessToken);
  202 | 
  203 |         HttpEntity<Void> entity = new HttpEntity<>(headers);
  204 | 
  205 |         try {
  206 |             ResponseEntity<Map> response = restTemplate.exchange(url, HttpMethod.GET, entity, Map.class);
  207 | 
  208 |             if (response.getBody() != null) {
  209 |                 return response.getBody();
  210 |             } else {
  211 |                 throw new RuntimeException("사용자 프로필을 가져오지 못했습니다.");
  212 |             }
  213 |         } catch (Exception e) {
  214 |             log.error("Error while requesting user profile: ", e);
  215 |             throw e;
  216 |         }
  217 |     }
  218 | 
  219 |     public Map<String, String> getGoogleTokens(String tempCode) {
  220 |         log.info("current : getGoogleTokens");
  221 | 
  222 |         String url = "https://oauth2.googleapis.com/token";
  223 | 
  224 |         RestTemplate restTemplate = new RestTemplate();
  225 | 
  226 |         HttpHeaders headers = new HttpHeaders();
  227 |         headers.add("Content-Type", "application/x-www-form-urlencoded");
  228 | 
  229 |         String decode =URLDecoder.decode(tempCode, StandardCharsets.UTF_8);
  230 | 
  231 |         MultiValueMap<String, String> params = new LinkedMultiValueMap<>();
  232 |         params.add("grant_type", "authorization_code");
  233 |         params.add("client_id", googleClientId);
  234 |         params.add("redirect_uri", googleRedirectUri);
  235 |         params.add("code", decode);
  236 |         params.add("client_secret", googleClientSecret);
  237 |         params.add("access_type", "offline");
  238 |         params.add("prompt", "consent");
  239 | 
  240 |         log.info("Requesting tokens with params: {}", params);
  241 | 
  242 |         HttpEntity<MultiValueMap<String, String>> entity = new HttpEntity<>(params, headers);
  243 | 
  244 |         try {
  245 |             ResponseEntity<Map> response = restTemplate.exchange(url, HttpMethod.POST, entity, Map.class);
  246 | 
  247 |             if (response.getBody() != null && response.getBody().containsKey("access_token") && response.getBody().containsKey("refresh_token")) {
  248 |                 log.info("Received tokens: {}", response.getBody());
  249 |                 return Map.of(
  250 |                         "access_token", response.getBody().get("access_token").toString(),
  251 |                         "refresh_token", response.getBody().get("refresh_token").toString()
  252 |                 );
  253 |             } else {
  254 |                 log.info("response.getBody() :  {}", response.getBody());
  255 |                 throw new RuntimeException("액세스 토큰을 가져오지 못했습니다.");
  256 |             }
  257 | 
  258 |         } catch (HttpClientErrorException e) {
  259 |             if (e.getStatusCode() == HttpStatus.BAD_REQUEST) {
  260 |                 log.error("Oauth 2.0 compliance error: {}", e.getResponseBodyAsString());
  261 |             } else {
  262 |                 log.error("Error while requesting tokens : ", e);
  263 |             }
  264 |             throw e;
  265 |         }
  266 |     }
  267 | 
  268 |     public Map<String, Object> getGoogleUserProfile(String accessToken) {
  269 |         log.info("current : getGoogleUserProfile");
  270 | 
  271 |         String url = "https://www.googleapis.com/oauth2/v3/userinfo";
  272 | 
  273 |         RestTemplate restTemplate = new RestTemplate();
  274 | 
  275 |         HttpHeaders headers = new HttpHeaders();
  276 |         headers.add("Authorization", "Bearer " + accessToken);
  277 | 
  278 |         log.info("Requesting user profile with accessToken: {}", accessToken);
  279 | 
  280 |         HttpEntity<Void> entity = new HttpEntity<>(headers);
  281 | 
  282 |         try {
  283 |             ResponseEntity<Map> response = restTemplate.exchange(url, HttpMethod.GET, entity, Map.class);
  284 | 
  285 |             if (response.getBody() != null) {
  286 |                 return response.getBody();
  287 |             } else {
  288 |                 throw new RuntimeException("사용자 프로필을 가져오지 못했습니다.");
  289 |             }
  290 |         } catch (Exception e) {
  291 |             log.error("Error while requesting user profile: ", e);
  292 |             throw e;
  293 |         }
  294 |     }
  295 | 
  296 |     @Transactional
  297 |     public users saveOrUpdateOauth2User(String provider, String oauthId, Map<String, Object> userProfile) {
  298 |         Optional<users> optionalUser = usersRepository.findByProviderAndProviderId(provider, oauthId);
  299 |         users user;
  300 |         if (optionalUser.isPresent()) {
  301 |             user = optionalUser.get();
  302 |             log.info("user found for {}", optionalUser.get().getUserId());
  303 |             updateUserDetails(user, userProfile, provider);
  304 |         } else {
  305 |             log.info("user not found, creating new user");
  306 |             user = createUser(provider, userProfile);
  307 |         }
  308 |         return usersRepository.save(user);
  309 |     }
  310 | 
  311 | 
  312 |     private void updateUserDetails(users user, Map<String, Object> userProfile, String provider) {
  313 |         log.info("updateUserDetails 호출");
  314 | 
  315 |         String newName = null;
  316 |         String newNickname = null;
  317 |         String newProfileImage = null;
  318 |         String newGender = null;
  319 |         String newPhone = null;
  320 |         String newBirthDate = null;
  321 |         String newEmail = null;
  322 | 
  323 |         String defaultString = "";
  324 |         String defaultGender = "N/A";
  325 |         String defaultPhone = "000-0000-0000";
  326 | 
  327 |         switch (provider) {
  328 |             case "kakao":
  329 |                 Map<String, Object> properties = (Map<String, Object>) userProfile.get("properties");
  330 |                 newNickname = (String) properties.get("nickname");
  331 |                 newProfileImage = (String) properties.get("profile_image");
  332 |                 Map<String, Object> kakaoAccount = (Map<String, Object>) userProfile.get("kakao_account");
  333 |                 newEmail = (String) kakaoAccount.get("email");
  334 |                 break;
  335 |             case "naver":
  336 |                 Map<String, Object> response = (Map<String, Object>) userProfile.get("response");
  337 |                 newName = (String) response.get("name");
  338 |                 newNickname = (String) response.get("nickname");
  339 |                 newProfileImage = (String) response.get("profile_image");
  340 |                 newEmail = (String) response.get("email");
  341 |                 newGender = (String) response.get("gender");
  342 |                 newPhone = (String) response.get("mobile_e164");
  343 |                 newBirthDate = (String) response.get("birthday");
  344 |                 break;
  345 |             case "google":
  346 |                 newName = (String) userProfile.get("name");
  347 |                 newProfileImage = (String) userProfile.get("picture");
  348 |                 newEmail = (String) userProfile.get("email");
  349 |                 newGender = defaultGender;
  350 |                 newPhone = defaultPhone;
  351 |                 newBirthDate = defaultString;
  352 |                 break;
  353 |         }
  354 | 
  355 |         if (newName != null && !newName.equals(user.getUserName())) {
  356 |             user.setUserName(newName);
  357 |         }
  358 | 
  359 |         if (newNickname != null && !newNickname.equals(user.getNickname())) {
  360 |             user.setNickname(newNickname);
  361 |         }
  362 | 
  363 |         if (newProfileImage != null && !newProfileImage.equals(user.getProfile())) {
  364 |             user.setProfile(newProfileImage);
  365 |         }
  366 | 
  367 |         if (newGender != null && !newGender.equals(user.getGender())) {
  368 |             user.setGender(newGender);
  369 |         }
  370 | 
  371 |         if (newPhone != null && !newPhone.equals(user.getPhone())) {
  372 |             user.setPhone(newPhone);
  373 |         }
  374 | 
  375 |         if (newBirthDate != null && !newBirthDate.equals(user.getBirthDate())) {
  376 |             user.setBirthDate(parseBirthday(newBirthDate));
  377 |         }
  378 | 
  379 |         if (newEmail != null && !newEmail.equals(user.getEmail())) {
  380 |             user.setEmail(newEmail);
  381 |         }
  382 |     }
  383 | 
  384 |     private users createUser(String provider, Map<String, Object> userProfile) {
  385 | 
  386 |         log.info("createUser 호출");
  387 | 
  388 |         String randomPassword = generateRandomString(13);
  389 |         String randomUserId = generateRandomString(13);
  390 | 
  391 |         String name = null;
  392 |         String nickname = null;
  393 |         String profileImage = null;
  394 |         String email = null;
  395 |         String providerId = null;
  396 |         String gender = null;
  397 |         String phone = null;
  398 |         String birthDate = null;
  399 | 
  400 |         String defaultString = "";
  401 |         String defaultGender = "N/A"; // Example default gender
  402 |         String defaultPhone = "000-0000-0000"; // Example default phone number
  403 | 
  404 | 
  405 |         log.info("provider [{}] 의 userProfile : {}", provider, userProfile);
  406 | 
  407 |         switch (provider) {
  408 |             case "kakao":
  409 |                 Map<String, Object> properties = (Map<String, Object>) userProfile.get("properties");
  410 |                 log.info("createUser [kakao] properties : {}", properties);
  411 |                 providerId = String.valueOf(userProfile.get("id"));
  412 |                 nickname = (String) properties.get("nickname");
  413 |                 profileImage = (String) properties.get("profile_image");
  414 |                 Map<String, Object> kakaoAccount = (Map<String, Object>) userProfile.get("kakao_account");
  415 |                 email = (String) kakaoAccount.get("email");
  416 |                 break;
  417 |             case "naver":
  418 |                 Map<String, Object> response = (Map<String, Object>) userProfile.get("response");
  419 |                 log.info("createUser [naver] response : {}", response);
  420 |                 providerId = (String) response.get("id");
  421 |                 name = (String) response.get("name");
  422 |                 nickname = (String) response.get("nickname");
  423 |                 profileImage = (String) response.get("profile_image");
  424 |                 email = (String) response.get("email");
  425 |                 gender = (String) response.get("gender");
  426 |                 phone = (String) response.get("mobile_e164");
  427 |                 birthDate = (String) response.get("birthday");
  428 |                 break;
  429 |             case "google":
  430 |                 log.info("createUser [google] userProfile : {}", userProfile);
  431 |                 providerId = (String) userProfile.get("sub"); // Google uses "sub" for user ID
  432 |                 name = (String) userProfile.get("name");
  433 |                 profileImage = (String) userProfile.get("picture");
  434 |                 email = (String) userProfile.get("email");
  435 |                 gender = defaultGender; // Google does not provide gender directly
  436 |                 phone = defaultPhone; // Google does not provide phone directly
  437 |                 birthDate = defaultString; // Google does not provide birthdate directly
  438 |                 break;
  439 |         }
  440 | 
  441 |         return users.builder()
  442 |                 .userId(randomUserId)
  443 |                 .userPw(randomPassword)
  444 |                 .userName(name != null ? name : defaultString)
  445 |                 .nickname(nickname != null ? nickname : defaultString)
  446 |                 .email(email != null ? email : defaultString)
  447 |                 .profile(profileImage != null ? profileImage : defaultString)
  448 |                 .gender(gender != null ? gender : defaultGender)
  449 |                 .phone(phone != null ? phone : defaultPhone)
  450 |                 .birthDate(birthDate != null ? parseBirthday(birthDate) : null)
  451 |                 .provider(provider)
  452 |                 .providerId(providerId != null ? providerId : "")
  453 |                 .role(Role.USER)
  454 |                 .build();
  455 |     }
  456 | 
  457 |     @Transactional
  458 |     public ResponseEntity<?> handleOauth2Login(Map<String, String> requestBody, HttpServletResponse response, String provider) {
  459 |         log.info("current : handleOauth2Login{}", provider);
  460 | 
  461 |         String tempCode = requestBody.get("tempCode");
  462 | 
  463 |         if (tempCode == null) {
  464 |             log.error("there is no tempCode needed for {} login", provider);
  465 |             return ResponseEntity.status(HttpStatus.BAD_REQUEST).body("there is no tempCode needed for " + provider + " login");
  466 |         }
  467 | 
  468 |         try {
  469 |             Map<String, String> tokens;
  470 |             Map<String, Object> userProfile;
  471 | 
  472 |             switch (provider) {
  473 |                 case "kakao":
  474 |                     tokens = getKakaoTokens(tempCode);
  475 |                     userProfile = getKakaoUserProfile(tokens.get("access_token"));
  476 |                     break;
  477 |                 case "naver":
  478 |                     String state = requestBody.get("state");
  479 |                     if (state == null) {
  480 |                         log.error("there is no state needed for naver login");
  481 |                         return ResponseEntity.status(HttpStatus.BAD_REQUEST).body("there is no state for naver login");
  482 |                     }
  483 |                     tokens = getNaverTokens(tempCode, state);
  484 |                     userProfile = getNaverUserProfile(tokens.get("access_token"));
  485 |                     log.info("Naver user profile: {}", userProfile); // Log the entire user profile
  486 |                     break;
  487 |                 case "google":
  488 |                     tokens = getGoogleTokens(tempCode);
  489 |                     userProfile = getGoogleUserProfile(tokens.get("access_token"));
  490 |                     break;
  491 |                 default:
  492 |                     throw new IllegalArgumentException("Unsupported provider: " + provider);
  493 |             }
  494 | 
  495 |             String snsAccessToken = tokens.get("access_token");
  496 |             String refreshToken = tokens.get("refresh_token");
  497 | 
  498 |             if (snsAccessToken == null || refreshToken == null) {
  499 |                 log.error("access token or refresh token does not exist");
  500 |                 return ResponseEntity.status(HttpStatus.NO_CONTENT).body("access token or refresh token does not exist");
  501 |             }
  502 | 
  503 |             if (userProfile == null) {
  504 |                 log.error("userProfile does not exist");
  505 |                 return ResponseEntity.status(HttpStatus.NOT_FOUND).body("user info does not exist");
  506 |             }
  507 | 
  508 |             // extract userId based on provider
  509 |             String oauthId = switch (provider) {
  510 |                 case "naver" -> ((Map<String, Object>) userProfile.get("response")).get("id").toString();
  511 |                 case "kakao" -> userProfile.get("id").toString();
  512 |                 case "google" -> userProfile.get("sub").toString();
  513 |                 default -> throw new IllegalArgumentException("Unsupported provider: " + provider);
  514 |             };
  515 | 
  516 |             if (oauthId == null) {
  517 |                 log.error("id를 파싱하는데 문제가 생긴 것 같습니다 ㅠㅠ");
  518 |             }
  519 | 
  520 |             // Redis에 refresh token 저장
  521 |             redisService.saveRToken(oauthId, provider, refreshToken);
  522 | 
  523 |             // Oauth2 사용자 확인 후 저장 또는 업데이트 하기
  524 |             users user = saveOrUpdateOauth2User(provider, oauthId, userProfile);
  525 | 
  526 |             // 서버 자체 access_token 생성
  527 |             tokenDto accessToken = jwtUtility.buildToken(user.getUserId(), user.getNickname(), Collections.singletonList(new SimpleGrantedAuthority(user.getRole().name())));
  528 | 
  529 |             loginResponse(response, accessToken.getAccessToken(), refreshToken, provider);
  530 | 
  531 |             //return ResponseEntity.ok(userProfile);
  532 |             return ResponseEntity.ok(Map.of(
  533 |                     "access_token", accessToken.getAccessToken(),
  534 |                     "userProfile", userProfile
  535 |             ));
  536 | 
  537 |         } catch (HttpClientErrorException e){
  538 |             if (e.getStatusCode() == HttpStatus.BAD_REQUEST && e.getResponseBodyAsString().contains("invalid_grant")) {
  539 |                 log.error("{} 로그인 실패 - 재 사용된 인증 코드 입니다. ", provider);
  540 |                 return ResponseEntity.status(HttpStatus.BAD_REQUEST).body("재사용된 인증 코드입니다.");
  541 |             }
  542 |             log.error("{} 로그인 실패!", provider, e);
  543 |             return ResponseEntity.status(HttpStatus.INTERNAL_SERVER_ERROR).body(provider + "로그인 실패!");
  544 |         } catch (Exception e) {
  545 |             log.error("{} 로그인 실패! ", provider, e);
  546 |             return ResponseEntity.status(HttpStatus.INTERNAL_SERVER_ERROR).body(provider + " 로그인 실패!");
  547 |         }
  548 |     }
  549 | 
  550 | 
  551 |     private void loginResponse(HttpServletResponse response, String accessToken, String refreshToken, String provider) {
  552 |         Cookie newCookie = new Cookie(provider + "_refreshToken", refreshToken);
  553 |         newCookie.setHttpOnly(true);
  554 |         newCookie.setDomain(domain);
  555 |         newCookie.setPath("/");
  556 |         response.addCookie(newCookie);
  557 | 
  558 |         response.addHeader(SecurityConstants.TOKEN_HEADER, SecurityConstants.TOKEN_PREFIX + accessToken);
  559 |     }
  560 | 
  561 | 
  562 |     private Date parseBirthday(String birthday) {
  563 |         if (birthday != null && birthday.length() == 5) {
  564 |             try {
  565 |                 SimpleDateFormat sdf = new SimpleDateFormat("MM-dd");
  566 |                 Date date = sdf.parse(birthday);
  567 |                 return date;
  568 |             } catch (ParseException e) {
  569 |                 log.error("Error parsing birthday: ", e);
  570 |             }
  571 |         }
  572 |         return null; // Implement proper parsing if different format
  573 |     }
  574 | 
  575 | 
  576 |     private String generateRandomString(int length) {
  577 |         final String characters = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789";
  578 |         Random random = new SecureRandom();
  579 |         StringBuilder sb = new StringBuilder(length);
  580 | 
  581 |         for (int i = 0; i < length; i++) {
  582 |             sb.append(characters.charAt(random.nextInt(characters.length())));
  583 |         }
  584 | 
  585 |         return sb.toString();
  586 |     }
  587 | }

#--------------------------------------------------------------------------------


# File: backend/src/main/java/com/authentication/auth/service/smtp/emailService.java
#=============================================================================

    1 | package com.career_block.auth.service.smtp;
    2 | 
    3 | import lombok.RequiredArgsConstructor;
    4 | import lombok.extern.slf4j.Slf4j;
    5 | import org.springframework.beans.factory.annotation.Value;
    6 | import org.springframework.mail.javamail.JavaMailSender;
    7 | import org.springframework.mail.javamail.MimeMessageHelper;
    8 | import org.springframework.stereotype.Service;
    9 | import org.springframework.transaction.annotation.Transactional;
   10 | 
   11 | import com.authentication.auth.DTO.smtp.customEmailRequest;
   12 | import com.authentication.auth.DTO.smtp.customEmailToAllRequest;
   13 | import com.authentication.auth.repository.usersRepository;
   14 | 
   15 | import javax.mail.MessagingException;
   16 | import javax.mail.internet.MimeMessage;
   17 | import java.util.UUID;
   18 | 
   19 | @Slf4j
   20 | @Service
   21 | @RequiredArgsConstructor
   22 | public class emailService {
   23 | 
   24 |     @Value("${server.email.sender}")
   25 |     private String sender_email;
   26 |     private final usersRepository usersRepository;
   27 |     private final JavaMailSender mailSender;
   28 | 
   29 |     private String randomNum() {
   30 |         String rand = UUID.randomUUID().toString().replace("-", "");
   31 |         String result = "";
   32 |         for (int i = 0; i < 8; i++){
   33 |             result += rand.charAt(i);
   34 |         }
   35 |         return result;
   36 |     }
   37 | 
   38 | 
   39 |     public String joinEmail(String email){
   40 |         String rand = randomNum();
   41 |         String from_email = sender_email;
   42 |         String to_email = email;
   43 |         String title = "회원 가입 인증 이메일 입니다.";
   44 | 
   45 |         // HTML 이메일 컨텐츠
   46 |         String content =
   47 |                 "<div style=\"font-family: Arial, sans-serif; max-width: 600px; margin: 0 auto; padding: 30px; border: 1px solid #e0e0e0; border-radius: 8px; background-color: #ffffff; box-shadow: 0 4px 8px rgba(0, 0, 0, 0.05);\">\n" +
   48 |                         "    <h2 style=\"color: #4c5baf; text-align: center; margin-bottom: 20px;\">\uD83C\uDF89 Career Block 에 오신 것을 환영합니다!</h2>\n" +
   49 |                         "\n" +
   50 |                         "    <p style=\"font-size: 16px; color: #333333; line-height: 1.6; margin-bottom: 20px;\">\n" +
   51 |                         "        가입해주셔서 진심으로 감사합니다! 아래의 이메일 인증 코드를 사용하여 가입을 완료해주세요.\n" +
   52 |                         "    </p>\n" +
   53 |                         "\n" +
   54 |                         "    <div style=\"text-align: center; margin: 30px 0;\">\n" +
   55 |                         "        <span style=\"display: inline-block; font-size: 28px; font-weight: bold; color: #4c5baf; padding: 15px 30px; border: 2px dashed #4c5baf; border-radius: 5px; background-color: #f0f4ff;\">\n" +
   56 |                         "            " + rand + "\n" +
   57 |                         "        </span>\n" +
   58 |                         "    </div>\n" +
   59 |                         "\n" +
   60 |                         "    <p style=\"font-size: 16px; color: #333333; line-height: 1.6;\">\n" +
   61 |                         "        위 코드를 인증 페이지에 입력하여 가입을 완료해주세요. 이 코드의 유효 시간은 30분 입니다.\n" +
   62 |                         "    </p>\n" +
   63 |                         "\n" +
   64 |                         "    <p style=\"font-size: 14px; color: #666666; line-height: 1.6; margin-top: 30px;\">\n" +
   65 |                         "        만약 Career Block 가입을 시도하지 않았다면, 이 메시지를 무시해 주세요.\n" +
   66 |                         "    </p>\n" +
   67 |                         "\n" +
   68 |                         "    <hr style=\"border-top: 1px solid #e0e0e0; margin-top: 40px; margin-bottom: 20px;\">\n" +
   69 |                         "\n" +
   70 |                         "    <p style=\"text-align: center; font-size: 12px; color: #999999;\">\n" +
   71 |                         "        © 2024 Career Block. All rights reserved.\n" +
   72 |                         "    </p>\n" +
   73 |                         "</div>\n";
   74 | 
   75 |         mailSend(from_email, to_email, title, content);
   76 |         return rand;
   77 |     }
   78 | 
   79 | 
   80 |     public String changePwEmail(String email){
   81 |         String rand = randomNum();
   82 |         String from_email = sender_email;
   83 |         String to_email = email;
   84 |         String title = "비밀번호 변경 이메일입니다.";
   85 |         String content =
   86 |                 "<!DOCTYPE html>" +
   87 |                         "<html>" +
   88 |                         "    <head>" +
   89 |                         "        <meta charset='UTF-8'>" +
   90 |                         "        <title>비밀번호 변경 안내</title>" +
   91 |                         "        <style>" +
   92 |                         "            body { font-family: Arial, sans-serif; margin: 0; padding: 20px; background-color: #f6f6f6; }" +
   93 |                         "            .container { background-color: #ffffff; padding: 40px; border-radius: 10px; box-shadow: 0 2px 4px rgba(0, 0, 0, 0.1); }" +
   94 |                         "            h1 { color: #333333; }" +
   95 |                         "            p { color: #666666; }" +
   96 |                         "            .button { display: inline-block; padding: 10px 20px; color: #ffffff; background-color: #007bff; text-decoration: none; border-radius: 5px; }" +
   97 |                         "        </style>" +
   98 |                         "    </head>" +
   99 |                         "    <body>" +
  100 |                         "        <div class='container'>" +
  101 |                         "            <h1>비밀번호 변경 안내</h1>" +
  102 |                         "            <p>비밀번호를 잊어버리셨군요!</p>" +
  103 |                         "            <p>아래의 임시 비밀번호를 사용하여 비밀번호를 변경하세요:</p>" +
  104 |                         "            <h2>" + rand + "</h2>" +
  105 |                         "            <p><a href='gcp.nodove.com' class='button'>비밀번호 변경하기</a></p>" +
  106 |                         "        </div>" +
  107 |                         "    </body>" +
  108 |                         "</html>";
  109 |         mailSend(from_email, to_email, title, content);
  110 |         return rand;
  111 |     }
  112 | 
  113 | 
  114 | 
  115 | 
  116 |     public void mailSend(String from_email, String to_email, String title, String content) {
  117 |         MimeMessage message = mailSender.createMimeMessage();
  118 |         try {
  119 |             MimeMessageHelper helper = new MimeMessageHelper(message, true, "utf-8");
  120 |             helper.setFrom(from_email);
  121 |             helper.setTo(to_email);
  122 |             helper.setSubject(title);
  123 |             helper.setText(content, true);
  124 |             mailSender.send(message);
  125 | 
  126 |         } catch(MessagingException e){
  127 |             log.error("messagingException", e);
  128 |         }
  129 |     }
  130 | 
  131 |     @Transactional
  132 |     public void sendCustomEmail(customEmailRequest request) {
  133 |         try {
  134 |             String from_email = sender_email;
  135 |             String to_email = request.getEmail();
  136 |             String title = request.getTitle();
  137 |             String content = request.getContent();
  138 |             mailSend(from_email, to_email, title, content);
  139 |         } catch (Exception e) {
  140 |             log.error("message send Exception : ", e);
  141 |         }
  142 |     }
  143 | 
  144 |     @Transactional
  145 |     public void sendCustomEmailToAll(customEmailToAllRequest request) {
  146 | 
  147 |     }
  148 | 
  149 |     public boolean checkIsExistEmail(String userEmail){
  150 |         return usersRepository.existsByEmail(userEmail);
  151 |     }
  152 | 
  153 | }

#--------------------------------------------------------------------------------


# File: backend/src/main/java/com/authentication/auth/service/security/principalDetailService.java
#=============================================================================

    1 | package com.career_block.auth.service.security;
    2 | 
    3 | import lombok.RequiredArgsConstructor;
    4 | import lombok.extern.slf4j.Slf4j;
    5 | import org.springframework.security.core.userdetails.UserDetails;
    6 | import org.springframework.security.core.userdetails.UserDetailsService;
    7 | import org.springframework.security.core.userdetails.UsernameNotFoundException;
    8 | import org.springframework.stereotype.Service;
    9 | 
   10 | import com.authentication.auth.DTO.token.principalDetails;
   11 | import com.authentication.auth.domain.users;
   12 | import com.authentication.auth.repository.usersRepository;
   13 | 
   14 | @Slf4j
   15 | @Service
   16 | @RequiredArgsConstructor
   17 | public class principalDetailService implements UserDetailsService {
   18 | 
   19 |     private final usersRepository repository;
   20 | 
   21 |     @Override
   22 |     public UserDetails loadUserByUsername(String username) throws UsernameNotFoundException {
   23 |         users user = repository.findByUserId(username);
   24 |         return new principalDetails(user);
   25 |     }
   26 | }

#--------------------------------------------------------------------------------


# File: backend/src/main/java/com/authentication/auth/service/token/tokenService.java
#=============================================================================

    1 | package com.career_block.auth.service.token;
    2 | 
    3 | import jakarta.servlet.http.HttpServletRequest;
    4 | import jakarta.servlet.http.HttpServletResponse;
    5 | import lombok.RequiredArgsConstructor;
    6 | import lombok.extern.slf4j.Slf4j;
    7 | import org.springframework.http.HttpStatus;
    8 | import org.springframework.http.ResponseEntity;
    9 | import org.springframework.stereotype.Service;
   10 | import org.springframework.transaction.annotation.Transactional;
   11 | 
   12 | import com.authentication.auth.DTO.token.tokenRefreshRequest;
   13 | import com.authentication.auth.configuration.token.jwtUtility;
   14 | import com.authentication.auth.service.redis.redisService;
   15 | 
   16 | import java.io.IOException;
   17 | 
   18 | @Slf4j
   19 | @Service
   20 | @RequiredArgsConstructor
   21 | public class tokenService {
   22 | 
   23 | 
   24 |     private final jwtUtility jwtUtility;
   25 |     private final redisService redisService;
   26 | 
   27 |     @Transactional
   28 |     public ResponseEntity<?> refreshToken(HttpServletRequest httpRequest, HttpServletResponse httpResponse, tokenRefreshRequest request) throws IOException {
   29 | 
   30 |         String expiredToken = request.getExpiredToken();
   31 |         String provider = request.getProvider();
   32 | 
   33 |         if (jwtUtility.validateJWT(expiredToken)) {
   34 |             // token 갱신
   35 |             String newToken = jwtUtility.refreshToken(expiredToken);
   36 | 
   37 |             // Redis에 갱신된 토큰 저장
   38 |             String userId = jwtUtility.getUserIdFromToken(newToken);
   39 | 
   40 |             String RToken = jwtUtility.checkCookie(httpRequest, httpResponse, provider);
   41 |             if(!redisService.isRTokenExist(userId, provider, RToken)){
   42 |                 return ResponseEntity.status(HttpStatus.NOT_ACCEPTABLE).body("There is no refresh token in REDIS");
   43 |             }
   44 | 
   45 |             return ResponseEntity.status(HttpStatus.OK).body(newToken);
   46 |         } else {
   47 |             return ResponseEntity.status(HttpStatus.NOT_ACCEPTABLE).body("not a valid token");
   48 |         }
   49 |     }
   50 | }

#--------------------------------------------------------------------------------


# File: backend/src/main/java/com/authentication/auth/service/redis/redisService.java
#=============================================================================

    1 | package com.career_block.auth.service.redis;
    2 | 
    3 | import lombok.RequiredArgsConstructor;
    4 | import lombok.extern.slf4j.Slf4j;
    5 | import org.springframework.beans.factory.annotation.Value;
    6 | import org.springframework.data.redis.core.RedisTemplate;
    7 | import org.springframework.stereotype.Component;
    8 | import org.springframework.transaction.annotation.Transactional;
    9 | import org.springframework.web.servlet.mvc.method.annotation.SseEmitter;
   10 | 
   11 | import java.util.Collections;
   12 | import java.util.List;
   13 | import java.util.Objects;
   14 | import java.util.Set;
   15 | import java.util.concurrent.TimeUnit;
   16 | 
   17 | @Slf4j
   18 | @RequiredArgsConstructor
   19 | @Component
   20 | public class redisService {
   21 | 
   22 |     @Value("${REFRESH_TOKEN_VALIDITY}")
   23 |     private long refreshExpire;
   24 | 
   25 |     @Value("${ACCESS_TOKEN_VALIDITY}")
   26 |     private long accessExpire;
   27 | 
   28 |     private final RedisTemplate<String, String> redisTemplate;
   29 | 
   30 | 
   31 |     private String RefreshTokenToRedisKey(String userId, String provider, String RToken) {
   32 |         if (userId == null || provider == null || RToken == null ||
   33 |                 userId.isEmpty() || provider.isEmpty() || RToken.isEmpty()) {
   34 |             throw new RuntimeException("error while convert Refresh Token into REDIS_KEY..");
   35 |         }
   36 |         return provider + "_RToken_" + userId;
   37 |     }
   38 | 
   39 |     private String AccessTokenToRedisKey(String RToken) {
   40 |         if (RToken == null || RToken.isEmpty()){
   41 |             throw new RuntimeException("error while convert access Token into REDIS_KEY..");
   42 |         }
   43 |         return "_accessToken_" + RToken.substring(10);
   44 |     }
   45 | 
   46 |     @Transactional
   47 |     public boolean saveRToken(String userId, String provider, String RToken) {
   48 |         String REDIS_KEY = RefreshTokenToRedisKey(userId, provider, RToken);
   49 |         try {
   50 |             redisTemplate.opsForValue().set(REDIS_KEY, RToken, refreshExpire, TimeUnit.SECONDS);
   51 |             log.info("Redis RToken save success for provider: {}", provider);
   52 |             return true;
   53 |         } catch (Exception e) {
   54 |             log.error("Redis has failed to save Refresh Token for provider {} and for userId {}", provider, userId, e);
   55 |             return false;
   56 |         }
   57 |     }
   58 | 
   59 |     @Transactional
   60 |     public boolean saveAccessToken(String RToken, String accessToken, String userId) {
   61 |         String REDIS_KEY = AccessTokenToRedisKey(RToken);
   62 |         try {
   63 |             redisTemplate.opsForValue().set(REDIS_KEY, accessToken, accessExpire, TimeUnit.SECONDS);
   64 |             return true;
   65 |         } catch (Exception e) {
   66 |             log.error("Redis has failed to save Access Token for userId {}", userId);
   67 |             return false;
   68 |         }
   69 |     }
   70 | 
   71 |     @Transactional
   72 |     public String getAccessToken(String RToken) {
   73 |         String REDIS_KEY = AccessTokenToRedisKey(RToken);
   74 |         try {
   75 |             String accessToken = redisTemplate.opsForValue().get(REDIS_KEY);
   76 | 
   77 |             if (accessToken == null) {
   78 |                 log.warn("No access Token INFO");
   79 |                 return null;
   80 |             }
   81 | 
   82 |             return accessToken;
   83 |         } catch (Exception e) {
   84 |             log.error("Failed to get AccessToken INFO from REDIS");
   85 |             return null;
   86 |         }
   87 |     }
   88 | 
   89 |     @Transactional
   90 |     public boolean isRTokenExist(String userId, String provider, String RToken) {
   91 |         String REDIS_KEY = RefreshTokenToRedisKey(userId, provider, RToken);
   92 |         try {
   93 |             Boolean exists = redisTemplate.hasKey(REDIS_KEY);
   94 |             return exists != null && exists;
   95 |         } catch (Exception e) {
   96 |             log.error("REDIS key searching failed for provider: {}", provider, e);
   97 |             return false;
   98 |         }
   99 |     }
  100 | 
  101 | 
  102 |     @Transactional
  103 |     public boolean deleteRToken(String userId, String provider, String RToken) {
  104 |         String REDIS_KEY = RefreshTokenToRedisKey(userId, provider, RToken);
  105 |         try {
  106 |             Boolean removed = redisTemplate.delete(REDIS_KEY);
  107 |             return removed != null && removed;
  108 |         } catch (Exception e) {
  109 |             log.error("Failed to delete RToken for provider: {}", provider, e);
  110 |             return false;
  111 |         }
  112 |     }
  113 | 
  114 | 
  115 |     @Transactional
  116 |     public List<String> getAllRTokens(String userId, String provider) {
  117 |         String pattern = provider + "_RToken_" + userId + "_";
  118 |         Set<String> keys = redisTemplate.keys(pattern);
  119 |         if (keys == null || keys.isEmpty()){
  120 |             return Collections.emptyList();
  121 |         }
  122 |         return redisTemplate.opsForValue().multiGet(keys);
  123 |     }
  124 | 
  125 | 
  126 |     @Transactional
  127 |     public boolean changeRToken(String userId, String provider, String RToken, String newRToken) {
  128 |         try {
  129 |             deleteRToken(userId, provider, RToken);
  130 |             saveRToken(userId, provider, newRToken);
  131 |             log.info("{}'s RToken has been changed for provider: {}", userId, provider);
  132 |             return true;
  133 |         } catch (Exception e) {
  134 |             log.error("Failed to change RToken for provider: {}", provider, e);
  135 |             return false;
  136 |         }
  137 |     }
  138 | 
  139 | 
  140 |     @Transactional
  141 |     public boolean saveEmailCode(String email, String code) {
  142 |         if (email == null || email.isEmpty() || code == null || code.isEmpty()){
  143 |             log.error("essential parameter or parameters is null");
  144 |             return false;
  145 |         }
  146 |         try {
  147 |             redisTemplate.opsForValue().set(email, code, 1800, TimeUnit.SECONDS);
  148 |             return true;
  149 |         } catch (Exception e) {
  150 |             log.error("Failed to save email code for email: {}", email);
  151 |             return false;
  152 |         }
  153 |     }
  154 | 
  155 | 
  156 |     @Transactional(readOnly = true)
  157 |     public boolean checkEmailCode(String email, String code) {
  158 |         if (email == null || email.isEmpty() || code == null || code.isEmpty()){
  159 |             log.error("essential parameter or parameters is null");
  160 |             return false;
  161 |         }
  162 |         try {
  163 |             return (Objects.equals(code, redisTemplate.opsForValue().get(email)));
  164 |         } catch (Exception e) {
  165 |             log.error("Failed to check Email Code for email : {}", email);
  166 |             return false;
  167 |         }
  168 |     }
  169 | 
  170 |     @Transactional
  171 |     public boolean findRToken(String userId, String provider, String RToken) {
  172 |         try {
  173 |             String key = RefreshTokenToRedisKey(userId, provider, RToken);
  174 |             return Boolean.TRUE.equals(redisTemplate.opsForSet().isMember(key, RToken));
  175 |         } catch (Exception e) {
  176 |             log.error("redis key search failed", e);
  177 |             return false;
  178 |         }
  179 |     }
  180 | 
  181 | 
  182 | }

#--------------------------------------------------------------------------------


# File: backend/build.gradle
#=============================================================================

    1 | plugins {
    2 | 	id 'java'
    3 | 	id 'org.springframework.boot' version '3.2.4'
    4 | 	id 'io.spring.dependency-management' version '1.1.4'
    5 | }
    6 | 
    7 | group = 'com.authentication'
    8 | version = '0.0.1-SNAPSHOT'
    9 | 
   10 | java {
   11 | 	toolchain {
   12 | 		languageVersion = JavaLanguageVersion.of(21)
   13 | 	}
   14 | }
   15 | 
   16 | configurations {
   17 | 	compileOnly {
   18 | 		extendsFrom annotationProcessor
   19 | 	}
   20 | }
   21 | 
   22 | repositories {
   23 | 	mavenCentral()
   24 | }
   25 | 
   26 | dependencies {
   27 | 	implementation 'org.springframework.boot:spring-boot-starter-data-jpa'
   28 | 	implementation 'org.springframework.boot:spring-boot-starter-security'
   29 | 	implementation 'org.springframework.boot:spring-boot-starter-web'
   30 | 	implementation 'org.apache.commons:commons-lang3:3.12.0'
   31 | 	implementation 'org.springframework.boot:spring-boot-starter-data-redis'
   32 | 	implementation group: 'commons-io', name: 'commons-io', version: '2.15.1'
   33 | 	implementation 'org.springframework.boot:spring-boot-starter-validation'
   34 | 	implementation 'javax.mail:mail:1.4.7'
   35 | 	implementation 'org.springframework:spring-context-support:5.3.9'
   36 | 	implementation 'org.springdoc:springdoc-openapi-starter-webmvc-ui:2.2.0'
   37 | 	compileOnly group: 'io.jsonwebtoken', name: 'jjwt-api', version: '0.11.2'
   38 | 	runtimeOnly group: 'io.jsonwebtoken', name: 'jjwt-impl', version: '0.11.2'
   39 | 	runtimeOnly group: 'io.jsonwebtoken', name: 'jjwt-jackson', version: '0.11.2'
   40 | 	compileOnly 'org.projectlombok:lombok'
   41 | 	runtimeOnly 'org.mariadb.jdbc:mariadb-java-client'
   42 | 	annotationProcessor 'org.projectlombok:lombok'
   43 | 	testImplementation 'org.springframework.boot:spring-boot-starter-test'
   44 | 	testImplementation 'org.springframework.security:spring-security-test'
   45 | 	implementation 'com.github.ulisesbocchio:jasypt-spring-boot-starter:3.0.5'
   46 | 	implementation 'org.springframework.boot:spring-boot-starter-oauth2-client:3.3.0'
   47 | 	implementation 'org.apache.commons:commons-text:1.3'
   48 | 	implementation 'org.springframework.boot:spring-boot-starter-data-elasticsearch'
   49 | 	implementation 'org.springframework.boot:spring-boot-starter-data-mongodb'
   50 | 	implementation 'com.corundumstudio.socketio:netty-socketio:2.0.3'
   51 | }
   52 | 
   53 | tasks.named('test') {
   54 | 	useJUnitPlatform()
   55 | }

#--------------------------------------------------------------------------------


# File: .gitignore
#=============================================================================

    1 | HELP.md
    2 | .gradle
    3 | build/
    4 | !gradle/wrapper/gradle-wrapper.jar
    5 | !**/src/main/**/build/
    6 | !**/src/test/**/build/
    7 | 
    8 | ### STS ###
    9 | .apt_generated
   10 | .classpath
   11 | .factorypath
   12 | .project
   13 | .settings
   14 | .springBeans
   15 | .sts4-cache
   16 | bin/
   17 | !**/src/main/**/bin/
   18 | !**/src/test/**/bin/
   19 | 
   20 | ### IntelliJ IDEA ###
   21 | .idea
   22 | *.iws
   23 | *.iml
   24 | *.ipr
   25 | out/
   26 | !**/src/main/**/out/
   27 | !**/src/test/**/out/
   28 | 
   29 | ### NetBeans ###
   30 | /nbproject/private/
   31 | /nbbuild/
   32 | /dist/
   33 | /nbdist/
   34 | /.nb-gradle/
   35 | 
   36 | ### VS Code ###
   37 | .vscode/

#--------------------------------------------------------------------------------


# File: file_concat/main.go
#=============================================================================

    1 | package main
    2 | 
    3 | import (
    4 | 	"bufio"
    5 | 	"flag"
    6 | 	"fmt"
    7 | 	"io"
    8 | 	"os"
    9 | 	"path/filepath"
   10 | 	"strings"
   11 | )
   12 | 
   13 | func main() {
   14 | 	// 명령줄 플래그 정의
   15 | 	var (
   16 | 		startDir   = flag.String("d", ".", "검색 시작 디렉토리 지정 (기본값: 현재 디렉토리)")
   17 | 		outputFile = flag.String("o", "merged_source_files.txt", "출력 파일 지정 (기본값: merged_source_files.txt)")
   18 | 		helpFlag   = flag.Bool("h", false, "도움말 표시")
   19 | 	)
   20 | 
   21 | 	// 긴 형식의 플래그 별칭 추가
   22 | 	flag.StringVar(startDir, "directory", ".", "검색 시작 디렉토리 지정 (기본값: 현재 디렉토리)")
   23 | 	flag.StringVar(outputFile, "output", "merged_source_files.txt", "출력 파일 지정 (기본값: merged_source_files.txt)")
   24 | 	flag.BoolVar(helpFlag, "help", false, "도움말 표시")
   25 | 
   26 | 	// 사용법 메시지 설정
   27 | 	flag.Usage = func() {
   28 | 		fmt.Fprintf(os.Stderr, "사용법: %s [옵션]\n", os.Args[0])
   29 | 		fmt.Fprintln(os.Stderr, "옵션:")
   30 | 		fmt.Fprintln(os.Stderr, "  -d, --directory DIR  검색 시작 디렉토리 지정 (기본값: 현재 디렉토리)")
   31 | 		fmt.Fprintln(os.Stderr, "  -o, --output FILE    출력 파일 지정 (기본값: merged_source_files.txt)")
   32 | 		fmt.Fprintln(os.Stderr, "  -h, --help           도움말 표시")
   33 | 	}
   34 | 
   35 | 	// 플래그 파싱
   36 | 	flag.Parse()
   37 | 
   38 | 	// 도움말 표시
   39 | 	if *helpFlag {
   40 | 		flag.Usage()
   41 | 		os.Exit(0)
   42 | 	}
   43 | 
   44 | 	// 시작 디렉토리 유효성 검사
   45 | 	dirInfo, err := os.Stat(*startDir)
   46 | 	if err != nil || !dirInfo.IsDir() {
   47 | 		fmt.Fprintf(os.Stderr, "오류: 디렉토리 '%s'가 존재하지 않습니다.\n", *startDir)
   48 | 		os.Exit(1)
   49 | 	}
   50 | 
   51 | 	// 출력 파일 생성
   52 | 	outFile, err := os.Create(*outputFile)
   53 | 	if err != nil {
   54 | 		fmt.Fprintf(os.Stderr, "오류: 출력 파일 '%s'을 생성할 수 없습니다: %v\n", *outputFile, err)
   55 | 		os.Exit(1)
   56 | 	}
   57 | 	defer outFile.Close()
   58 | 
   59 | 	// 버퍼 라이터 생성 (성능 향상)
   60 | 	writer := bufio.NewWriter(outFile)
   61 | 	defer writer.Flush()
   62 | 
   63 | 	fmt.Printf("디렉토리 '%s'에서 .h 및 .cpp 파일을 검색하여 '%s'에 병합합니다...\n", *startDir, *outputFile)
   64 | 
   65 | 	// 파일 카운터 초기화
   66 | 	fileCount := 0
   67 | 
   68 | 	// 디렉토리 탐색 및 파일 처리
   69 | 	err = filepath.Walk(*startDir, func(path string, info os.FileInfo, err error) error {
   70 | 		if err != nil {
   71 | 			fmt.Fprintf(os.Stderr, "디렉토리 탐색 중 오류 발생: %v\n", err)
   72 | 			return err
   73 | 		}
   74 | 
   75 | 		// 파일이며 확장자가 .h 또는 .cpp인 경우에만 처리
   76 | 		if !info.IsDir() && (strings.HasSuffix(path, ".h") || strings.HasSuffix(path, ".cpp")) {
   77 | 			fileCount++
   78 | 
   79 | 			// 진행 상황 표시
   80 | 			fmt.Printf("처리 중: %s\n", path)
   81 | 
   82 | 			// 파일 구분자 추가
   83 | 			fmt.Fprintf(writer, "\n\n===== %s =====\n\n", path)
   84 | 
   85 | 			// 파일 내용을 결과 파일에 추가
   86 | 			if err := appendFileContent(path, writer); err != nil {
   87 | 				fmt.Fprintf(os.Stderr, "파일 '%s' 처리 중 오류 발생: %v\n", path, err)
   88 | 				// 오류가 있더라도 계속 진행
   89 | 			}
   90 | 		}
   91 | 		return nil
   92 | 	})
   93 | 
   94 | 	if err != nil {
   95 | 		fmt.Fprintf(os.Stderr, "파일 탐색 중 오류 발생: %v\n", err)
   96 | 		os.Exit(1)
   97 | 	}
   98 | 
   99 | 	fmt.Printf("완료: %d개의 파일이 '%s'에 병합되었습니다.\n", fileCount, *outputFile)
  100 | }
  101 | 
  102 | // appendFileContent 함수는 소스 파일의 내용을 writer에 추가합니다.
  103 | func appendFileContent(filepath string, writer *bufio.Writer) error {
  104 | 	srcFile, err := os.Open(filepath)
  105 | 	if err != nil {
  106 | 		return fmt.Errorf("파일 열기 오류: %w", err)
  107 | 	}
  108 | 	defer srcFile.Close()
  109 | 
  110 | 	// 버퍼 리더 생성 (성능 향상)
  111 | 	reader := bufio.NewReader(srcFile)
  112 | 
  113 | 	// 파일 내용을 결과 파일에 복사
  114 | 	_, err = io.Copy(writer, reader)
  115 | 	if err != nil {
  116 | 		return fmt.Errorf("파일 복사 오류: %w", err)
  117 | 	}
  118 | 
  119 | 	return nil
  120 | }

#--------------------------------------------------------------------------------

[0;32mIncluded content from 103 essential file(s).[0m

========================================
End of Report
========================================
