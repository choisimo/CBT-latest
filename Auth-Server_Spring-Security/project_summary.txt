========================================
Project Summary Report
========================================
Project Path: /workspace/Auth-Server_Spring-Security
Generated: Sun May 18 08:07:42 PM KST 2025

Exclusion Patterns Applied: .git .idea .vscode

========================================
Project Directory Structure
========================================
[01;34m/workspace/Auth-Server_Spring-Security[0m
|-- [01;34mauth-server-refactoring[0m
|   `-- [01;34msrc[0m
|       `-- [01;34mmain[0m
|           `-- [01;34mjava[0m
|               `-- [01;34mcom[0m
|                   `-- [01;34mauthentication[0m
|                       `-- [01;34mauth[0m
|                           |-- [01;34mconfiguration[0m
|                           |   |-- SecurityConfig.java
|                           |   `-- [01;34mtoken[0m
|                           |       `-- JwtUtility.java
|                           |-- [01;34mconstants[0m
|                           |   |-- ErrorType.java
|                           |   |-- FilterOrder.java
|                           |   `-- SecurityConstants.java
|                           |-- [01;34mdomain[0m
|                           |   |-- AuthProvider.java
|                           |   |-- UserAuthentication.java
|                           |   `-- User.java
|                           |-- [01;34mdto[0m
|                           |   |-- [01;34memail[0m
|                           |   |   |-- CustomEmailRequest.java
|                           |   |   |-- EmailCheckRequest.java
|                           |   |   `-- EmailRequest.java
|                           |   |-- [01;34mresponse[0m
|                           |   |   `-- ApiResponse.java
|                           |   |-- [01;34mtoken[0m
|                           |   |   |-- TokenDto.java
|                           |   |   `-- TokenRefreshRequest.java
|                           |   `-- [01;34musers[0m
|                           |       |-- JoinRequest.java
|                           |       |-- LoginRequest.java
|                           |       `-- UserProfileResponse.java
|                           |-- [01;34mfilter[0m
|                           |   |-- AbstractSecurityFilter.java
|                           |   |-- AuthenticationFilter.java
|                           |   |-- AuthorizationFilter.java
|                           |   |-- FilterCondition.java
|                           |   |-- FilterRegistry.java
|                           |   |-- JwtVerificationFilter.java
|                           |   |-- PathPatternFilterCondition.java
|                           |   |-- PluggableFilter.java
|                           |   `-- SecurityFilterOrder.java
|                           `-- [01;34mservice[0m
|                               `-- [01;34mredis[0m
|                                   `-- RedisService.java
|-- [01;34mbackend[0m
|   |-- [01;34mbin[0m
|   |   |-- [01;34mdefault[0m
|   |   |-- [01;34mgenerated-sources[0m
|   |   |   `-- [01;34mannotations[0m
|   |   |-- [01;34mgenerated-test-sources[0m
|   |   |   `-- [01;34mannotations[0m
|   |   |-- [01;34mmain[0m
|   |   |   |-- [01;32mapplication-database.properties[0m
|   |   |   |-- [01;32mapplication-oauth-google.properties[0m
|   |   |   |-- [01;32mapplication-oauth-kakao.properties[0m
|   |   |   |-- [01;32mapplication-oauth-naver.properties[0m
|   |   |   |-- [01;32mapplication.properties[0m
|   |   |   |-- [01;34mcom[0m
|   |   |   |   `-- [01;34mauthentication[0m
|   |   |   |       `-- [01;34mauth[0m
|   |   |   |           |-- AuthApplication.class
|   |   |   |           |-- [01;34mconfig[0m
|   |   |   |           |   `-- SecurityFilterConfig.class
|   |   |   |           |-- [01;34mconfiguration[0m
|   |   |   |           |   |-- [01;34mredis[0m
|   |   |   |           |   |   `-- redisConfig.class
|   |   |   |           |   |-- [01;34mresource[0m
|   |   |   |           |   |   `-- webMvcConfig.class
|   |   |   |           |   |-- [01;34msecurity[0m
|   |   |   |           |   |   |-- corsConfig.class
|   |   |   |           |   |   |-- publicAPI.class
|   |   |   |           |   |   `-- SecurityConfig.class
|   |   |   |           |   |-- SecurityConfig.class
|   |   |   |           |   |-- [01;34msmtp[0m
|   |   |   |           |   |   `-- smtpConfig.class
|   |   |   |           |   `-- [01;34mtoken[0m
|   |   |   |           |       `-- jwtUtility.class
|   |   |   |           |-- [01;34mcontroller[0m
|   |   |   |           |   |-- [01;34mauth[0m
|   |   |   |           |   |   |-- AuthController.class
|   |   |   |           |   |   |-- oauth2Controller.class
|   |   |   |           |   |   `-- tokenController.class
|   |   |   |           |   |-- emailController.class
|   |   |   |           |   |-- sseController.class
|   |   |   |           |   `-- usersController.class
|   |   |   |           |-- [01;34mdocument[0m
|   |   |   |           |   `-- [01;32mDev-Schedule.md[0m
|   |   |   |           |-- [01;34mdomain[0m
|   |   |   |           |   |-- AuthProvider.class
|   |   |   |           |   |-- DiaryAnswer$EmotionStatus.class
|   |   |   |           |   |-- DiaryAnswer.class
|   |   |   |           |   |-- Diary.class
|   |   |   |           |   |-- SettingsOption$DataType.class
|   |   |   |           |   |-- SettingsOption.class
|   |   |   |           |   |-- User$UserRole.class
|   |   |   |           |   |-- User$UserStatus.class
|   |   |   |           |   |-- UserAuthentication.class
|   |   |   |           |   |-- UserAuthenticationId.class
|   |   |   |           |   |-- User.class
|   |   |   |           |   |-- UserCustomSetting.class
|   |   |   |           |   `-- UserCustomSettingId.class
|   |   |   |           |-- [01;34mDTO[0m
|   |   |   |           |   |-- [01;34msmtp[0m
|   |   |   |           |   |   |-- customEmailRequest.class
|   |   |   |           |   |   |-- customEmailToAllRequest.class
|   |   |   |           |   |   |-- emailCheckDto.class
|   |   |   |           |   |   |-- emailFindById.class
|   |   |   |           |   |   `-- emailRequest.class
|   |   |   |           |   |-- [01;34mtoken[0m
|   |   |   |           |   |   |-- principalDetails.class
|   |   |   |           |   |   |-- TokenDto.class
|   |   |   |           |   |   `-- tokenRefreshRequest.class
|   |   |   |           |   `-- [01;34musers[0m
|   |   |   |           |       |-- JoinRequest.class
|   |   |   |           |       |-- LoginRequest.class
|   |   |   |           |       |-- userStat$userStatBuilder.class
|   |   |   |           |       `-- userStat.class
|   |   |   |           |-- [01;34mfilter[0m
|   |   |   |           |   |-- AbstractAuthenticationFilter.class
|   |   |   |           |   |-- AbstractSecurityFilter.class
|   |   |   |           |   |-- ApiChecker.class
|   |   |   |           |   |-- AuthenticationFilter.class
|   |   |   |           |   |-- authorizationFilter.class
|   |   |   |           |   |-- AuthorizationFilter.class
|   |   |   |           |   |-- FilterCondition.class
|   |   |   |           |   |-- filterRegistry$FilterWrapper.class
|   |   |   |           |   |-- filterRegistry.class
|   |   |   |           |   |-- FilterRegistry.class
|   |   |   |           |   |-- JwtVerificationFilter.class
|   |   |   |           |   |-- PathPatternFilterCondition.class
|   |   |   |           |   |-- PluggableFilter.class
|   |   |   |           |   |-- [01;32mREADME.md[0m
|   |   |   |           |   |-- RoleBasedAccessFilter.class
|   |   |   |           |   |-- SecurityFilterOrder.class
|   |   |   |           |   |-- snsRequestFilter.class
|   |   |   |           |   `-- SnsRequestFilter.class
|   |   |   |           |-- [01;34mothers[0m
|   |   |   |           |   `-- [01;34mconstants[0m
|   |   |   |           |       `-- SecurityConstants.class
|   |   |   |           |-- [01;34mrepository[0m
|   |   |   |           |   `-- usersRepository.class
|   |   |   |           `-- [01;34mservice[0m
|   |   |   |               |-- [01;34moauth2[0m
|   |   |   |               |   |-- oauth2Service.class
|   |   |   |               |   `-- snsTokenValidator.class
|   |   |   |               |-- [01;34mredis[0m
|   |   |   |               |   `-- redisService.class
|   |   |   |               |-- [01;34msecurity[0m
|   |   |   |               |   `-- principalDetailService.class
|   |   |   |               |-- [01;34msmtp[0m
|   |   |   |               |   `-- emailService.class
|   |   |   |               |-- [01;34msse[0m
|   |   |   |               |   `-- sseService.class
|   |   |   |               |-- [01;34mtoken[0m
|   |   |   |               |   `-- tokenService.class
|   |   |   |               `-- [01;34musers[0m
|   |   |   |                   `-- userService.class
|   |   |   |-- [01;32mlog4j2.xml[0m
|   |   |   |-- [01;32mschema.sql[0m
|   |   |   `-- [01;34mtemplates[0m
|   |   |       |-- [01;32merror.html[0m
|   |   |       |-- [01;32mnotExist.html[0m
|   |   |       `-- [01;32munauthorized.html[0m
|   |   `-- [01;34mtest[0m
|   |       |-- [01;34mcom[0m
|   |       |   `-- [01;34mauthentication[0m
|   |       |       `-- [01;34mauth[0m
|   |       |           |-- AuthApplicationTests.class
|   |       |           |-- [01;34mdomain[0m
|   |       |           |   `-- EntitySqlValidationTest.class
|   |       |           |-- [01;34mtoken[0m
|   |       |           |   `-- JwtUtilityTest.class
|   |       |           |-- [01;34mutility[0m
|   |       |           |   `-- SqlSchemaLoader.class
|   |       |           `-- [01;34mvalidator[0m
|   |       |               |-- EntitySqlValidator$ValidationResult.class
|   |       |               |-- EntitySqlValidator$ValidationStatus.class
|   |       |               |-- EntitySqlValidator.class
|   |       |               `-- EntityValidationOutput.class
|   |       `-- [01;32mtest-schema.sql[0m
|   |-- [01;34mbuild[0m
|   |   |-- [01;34mclasses[0m
|   |   |   `-- [01;34mjava[0m
|   |   |       |-- [01;34mmain[0m
|   |   |       `-- [01;34mtest[0m
|   |   |-- [01;34mgenerated[0m
|   |   |   `-- [01;34msources[0m
|   |   |       |-- [01;34mannotationProcessor[0m
|   |   |       |   `-- [01;34mjava[0m
|   |   |       |       `-- [01;34mmain[0m
|   |   |       `-- [01;34mheaders[0m
|   |   |           `-- [01;34mjava[0m
|   |   |               `-- [01;34mmain[0m
|   |   |-- [01;34mresources[0m
|   |   |   |-- [01;34mmain[0m
|   |   |   `-- [01;34mtest[0m
|   |   `-- [01;34mtmp[0m
|   |       `-- [01;34mcompileJava[0m
|   |-- [01;32mbuild.gradle[0m
|   |-- [01;34m.gradle[0m
|   |   |-- [01;34m8.10.1[0m
|   |   |   |-- [01;34mchecksums[0m
|   |   |   |   |-- [01;32mchecksums.lock[0m
|   |   |   |   |-- [01;32mmd5-checksums.bin[0m
|   |   |   |   `-- [01;32msha1-checksums.bin[0m
|   |   |   |-- [01;34mdependencies-accessors[0m
|   |   |   |   `-- [01;32mgc.properties[0m
|   |   |   |-- [01;34mexecutionHistory[0m
|   |   |   |   |-- [01;32mexecutionHistory.bin[0m
|   |   |   |   `-- [01;32mexecutionHistory.lock[0m
|   |   |   |-- [01;34mexpanded[0m
|   |   |   |-- [01;34mfileChanges[0m
|   |   |   |   `-- [01;32mlast-build.bin[0m
|   |   |   |-- [01;34mfileHashes[0m
|   |   |   |   |-- [01;32mfileHashes.bin[0m
|   |   |   |   |-- [01;32mfileHashes.lock[0m
|   |   |   |   `-- [01;32mresourceHashesCache.bin[0m
|   |   |   |-- [01;32mgc.properties[0m
|   |   |   `-- [01;34mvcsMetadata[0m
|   |   |-- [01;34mbuildOutputCleanup[0m
|   |   |   |-- [01;32mbuildOutputCleanup.lock[0m
|   |   |   |-- [01;32mcache.properties[0m
|   |   |   `-- [01;32moutputFiles.bin[0m
|   |   |-- [01;32mfile-system.probe[0m
|   |   `-- [01;34mvcs-1[0m
|   |       `-- [01;32mgc.properties[0m
|   |-- [01;34mgradle[0m
|   |   `-- [01;34mwrapper[0m
|   |       |-- [01;32mgradle-wrapper.jar[0m
|   |       `-- [01;32mgradle-wrapper.properties[0m
|   |-- [01;32mgradlew[0m
|   |-- [01;32mgradlew.bat[0m
|   |-- [01;32msettings.gradle[0m
|   `-- [01;34msrc[0m
|       |-- [01;34mmain[0m
|       |   |-- [01;34mjava[0m
|       |   |   `-- [01;34mcom[0m
|       |   |       `-- [01;34mauthentication[0m
|       |   |           `-- [01;34mauth[0m
|       |   |               |-- [01;32mAuthApplication.java[0m
|       |   |               |-- [01;34mconfig[0m
|       |   |               |   `-- [01;32mSecurityFilterConfig.java[0m
|       |   |               |-- [01;34mconfiguration[0m
|       |   |               |   |-- [01;34mredis[0m
|       |   |               |   |   `-- [01;32mredisConfig.java[0m
|       |   |               |   |-- [01;34mresource[0m
|       |   |               |   |   `-- [01;32mwebMvcConfig.java[0m
|       |   |               |   |-- [01;34msecurity[0m
|       |   |               |   |   |-- [01;32mcorsConfig.java[0m
|       |   |               |   |   |-- [01;32mpublicAPI.java[0m
|       |   |               |   |   `-- [01;32mSecurityConfig.java[0m
|       |   |               |   |-- [01;32mSecurityConfig.java[0m
|       |   |               |   |-- [01;34msmtp[0m
|       |   |               |   |   `-- [01;32msmtpConfig.java[0m
|       |   |               |   `-- [01;34mtoken[0m
|       |   |               |       |-- JwtProperties.record
|       |   |               |       `-- [01;32mjwtUtility.java[0m
|       |   |               |-- [01;34mcontroller[0m
|       |   |               |   |-- [01;34mauth[0m
|       |   |               |   |   |-- [01;32mAuthController.java[0m
|       |   |               |   |   |-- [01;32moauth2Controller.java[0m
|       |   |               |   |   `-- [01;32mtokenController.java[0m
|       |   |               |   |-- [01;32memailController.java[0m
|       |   |               |   |-- [01;32merrorController.java[0m
|       |   |               |   |-- [01;32msseController.java[0m
|       |   |               |   `-- [01;32musersController.java[0m
|       |   |               |-- [01;34mdocument[0m
|       |   |               |   `-- [01;32mDev-Schedule.md[0m
|       |   |               |-- [01;34mdomain[0m
|       |   |               |   |-- [01;32mAuthProvider.java[0m
|       |   |               |   |-- [01;32mDiaryAnswer.java[0m
|       |   |               |   |-- [01;32mDiary.java[0m
|       |   |               |   |-- [01;32mSettingsOption.java[0m
|       |   |               |   |-- [01;32mUserAuthentication.java[0m
|       |   |               |   |-- [01;32mUserCustomSetting.java[0m
|       |   |               |   `-- [01;32mUser.java[0m
|       |   |               |-- [01;34mDTO[0m
|       |   |               |   |-- [01;34msmtp[0m
|       |   |               |   |   |-- [01;32mcustomEmailRequest.java[0m
|       |   |               |   |   |-- [01;32mcustomEmailToAllRequest.java[0m
|       |   |               |   |   |-- [01;32memailCheckDto.java[0m
|       |   |               |   |   |-- [01;32memailFindById.java[0m
|       |   |               |   |   `-- [01;32memailRequest.java[0m
|       |   |               |   |-- [01;34mtoken[0m
|       |   |               |   |   |-- [01;32mprincipalDetails.java[0m
|       |   |               |   |   |-- [01;32mTokenDto.java[0m
|       |   |               |   |   `-- [01;32mtokenRefreshRequest.java[0m
|       |   |               |   `-- [01;34musers[0m
|       |   |               |       |-- [01;32mJoinRequest.java[0m
|       |   |               |       |-- [01;32mloginRequest.java[0m
|       |   |               |       `-- [01;32muserStat.java[0m
|       |   |               |-- [01;34mfilter[0m
|       |   |               |   |-- [01;32mAbstractAuthenticationFilter.java[0m
|       |   |               |   |-- [01;32mAbstractSecurityFilter.java[0m
|       |   |               |   |-- [01;32mApiChecker.java[0m
|       |   |               |   |-- [01;32mauthenticationFilter.java[0m
|       |   |               |   |-- [01;32mAuthenticationFilter.java[0m
|       |   |               |   |-- [01;32mauthorizationFilter.java[0m
|       |   |               |   |-- [01;32mAuthorizationFilter.java[0m
|       |   |               |   |-- [01;32mFilterCondition.java[0m
|       |   |               |   |-- [01;32mfilterRegistry.java[0m
|       |   |               |   |-- [01;32mFilterRegistry.java[0m
|       |   |               |   |-- [01;32mJwtVerificationFilter.java[0m
|       |   |               |   |-- [01;32mPathPatternFilterCondition.java[0m
|       |   |               |   |-- [01;32mPluggableFilter.java[0m
|       |   |               |   |-- [01;32mREADME.md[0m
|       |   |               |   |-- [01;32mRoleBasedAccessFilter.java[0m
|       |   |               |   |-- [01;32msecurityFilterOrder.java[0m
|       |   |               |   |-- [01;32mSecurityFilterOrder.java[0m
|       |   |               |   |-- [01;32msnsRequestFilter.java[0m
|       |   |               |   `-- [01;32mSnsRequestFilter.java[0m
|       |   |               |-- [01;34mothers[0m
|       |   |               |   `-- [01;34mconstants[0m
|       |   |               |       `-- [01;32mSecurityConstants.java[0m
|       |   |               |-- [01;34mrepository[0m
|       |   |               |   |-- [01;32mAuthProviderRepository.java[0m
|       |   |               |   `-- [01;32musersRepository.java[0m
|       |   |               `-- [01;34mservice[0m
|       |   |                   |-- [01;34moauth2[0m
|       |   |                   |   |-- [01;32moauth2Service.java[0m
|       |   |                   |   `-- [01;32msnsTokenValidator.java[0m
|       |   |                   |-- [01;34mredis[0m
|       |   |                   |   `-- [01;32mredisService.java[0m
|       |   |                   |-- [01;34msecurity[0m
|       |   |                   |   `-- [01;32mprincipalDetailService.java[0m
|       |   |                   |-- [01;34msmtp[0m
|       |   |                   |   `-- [01;32memailService.java[0m
|       |   |                   |-- [01;34msse[0m
|       |   |                   |   `-- [01;32msseService.java[0m
|       |   |                   |-- [01;34mtoken[0m
|       |   |                   |   `-- [01;32mtokenService.java[0m
|       |   |                   `-- [01;34musers[0m
|       |   |                       `-- [01;32muserService.java[0m
|       |   `-- [01;34mresources[0m
|       |       |-- [01;32mapplication-database.properties[0m
|       |       |-- [01;32mapplication-oauth-google.properties[0m
|       |       |-- [01;32mapplication-oauth-kakao.properties[0m
|       |       |-- [01;32mapplication-oauth-naver.properties[0m
|       |       |-- [01;32mapplication.properties[0m
|       |       |-- [01;32mlog4j2.xml[0m
|       |       |-- [01;32mschema.sql[0m
|       |       `-- [01;34mtemplates[0m
|       |           |-- [01;32merror.html[0m
|       |           |-- [01;32mnotExist.html[0m
|       |           `-- [01;32munauthorized.html[0m
|       `-- [01;34mtest[0m
|           |-- [01;34mjava[0m
|           |   `-- [01;34mcom[0m
|           |       `-- [01;34mauthentication[0m
|           |           `-- [01;34mauth[0m
|           |               |-- [01;32mAuthApplicationTests.java[0m
|           |               |-- [01;34mdomain[0m
|           |               |   `-- [01;32mEntitySqlValidationTest.java[0m
|           |               |-- [01;34mtoken[0m
|           |               |   `-- [01;32mJwtUtilityTest.java[0m
|           |               |-- [01;34mutility[0m
|           |               |   `-- [01;32mSqlSchemaLoader.java[0m
|           |               `-- [01;34mvalidator[0m
|           |                   |-- [01;32mEntitySqlValidator.java[0m
|           |                   `-- [01;32mEntityValidationOutput.java[0m
|           `-- [01;34mresources[0m
|               `-- [01;32mtest-schema.sql[0m
|-- [01;34mconcat[0m
|   |-- backend.txt
|   `-- frontend.txt
|-- [01;32mconcat.sh[0m
|-- [01;34mfile_concat[0m
|   |-- [01;32mgo1.22.0.linux-amd64.tar.gz[0m
|   |-- [01;32mgo.mod[0m
|   |-- [01;32mmain.go[0m
|   `-- [01;32mmerged_source_files.txt[0m
|-- find_stderr.log
|-- [01;34m.github[0m
|   `-- [01;34mworkflows[0m
|       `-- [01;32mdeploy.yml[0m
|-- [01;32m.gitignore[0m
|-- [01;32mproject-summary.sh[0m
|-- project_summary.txt
`-- [01;32mREADME.md[0m

147 directories, 235 files

========================================
Essential Files Content
========================================

[0;34mProcessing essential files matching patterns: README.md readme.md README.rst README.txt package.json composer.json pom.xml build.gradle requirements.txt Pipfile Gemfile Dockerfile docker-compose.yml docker-compose.yaml Makefile Jenkinsfile .gitlab-ci.yml .travis.yml *.config.js *.config.ts *.config.mjs *.config.cjs webpack.config.* vite.config.* rollup.config.* tsconfig.json jsconfig.json next.config.* manage.py app.py main.py server.js index.js main.go .env.example .env.sample settings.py config.py src*/*.js src*/*.ts src*/*.jsx src*/*.tsx src*/*.py src*/*.java src*/*.go src*/*.rb src*/*.php app*/*.js app*/*.ts app*/*.jsx app*/*.tsx app*/*.py components*/*.js components*/*.jsx components*/*.ts components*/*.tsx pages*/*.js pages*/*.jsx pages*/*.ts pages*/*.tsx lib*/*.js lib*/*.ts lib*/*.py api*/*.ts api*/*.js api*/*.py routes*/*.js routes*/*.ts routes*/*.py controllers*/*.js controllers*/*.ts controllers*/*.py models*/*.js models*/*.ts models*/*.py types*/*.d.ts css*/*.css scss*/*.scss sass*/*.sass app*/globals.css tailwind.config.* postcss.config.* .gitignore .dockerignore components.json next-env.d.ts[0m

# File: auth-server-refactoring/src/main/java/com/authentication/auth/constants/ErrorType.java
#=============================================================================

    1 | package com.authentication.auth.constants;
    2 | 
    3 | import org.springframework.http.HttpStatus;
    4 | 
    5 | /**
    6 |  * ì˜¤ë¥˜ ìœ í˜•ì„ ì •ì˜í•˜ëŠ” ì—´ê±°í˜•
    7 |  */
    8 | public enum ErrorType {
    9 |     AUTHENTICATION_FAILED("ì¸ì¦ ì‹¤íŒ¨", "ì‚¬ìš©ì ì¸ì¦ì— ì‹¤íŒ¨í–ˆìŠµë‹ˆë‹¤", HttpStatus.UNAUTHORIZED),
   10 |     INVALID_TOKEN("ìœ íš¨í•˜ì§€ ì•Šì€ í† í°", "ì œê³µëœ í† í°ì´ ìœ íš¨í•˜ì§€ ì•ŠìŠµë‹ˆë‹¤", HttpStatus.UNAUTHORIZED),
   11 |     TOKEN_EXPIRED("í† í° ë§Œë£Œ", "í† í°ì´ ë§Œë£Œë˜ì—ˆìŠµë‹ˆë‹¤", HttpStatus.UNAUTHORIZED),
   12 |     ACCESS_DENIED("ì ‘ê·¼ ê±°ë¶€", "í•´ë‹¹ ë¦¬ì†ŒìŠ¤ì— ì ‘ê·¼í•  ê¶Œí•œì´ ì—†ìŠµë‹ˆë‹¤", HttpStatus.FORBIDDEN),
   13 |     INVALID_REQUEST("ì˜ëª»ëœ ìš”ì²­", "ìš”ì²­ í˜•ì‹ì´ ì˜¬ë°”ë¥´ì§€ ì•ŠìŠµë‹ˆë‹¤", HttpStatus.BAD_REQUEST),
   14 |     RESOURCE_NOT_FOUND("ë¦¬ì†ŒìŠ¤ ì—†ìŒ", "ìš”ì²­í•œ ë¦¬ì†ŒìŠ¤ë¥¼ ì°¾ì„ ìˆ˜ ì—†ìŠµë‹ˆë‹¤", HttpStatus.NOT_FOUND),
   15 |     SERVER_ERROR("ì„œë²„ ì˜¤ë¥˜", "ì„œë²„ ë‚´ë¶€ ì˜¤ë¥˜ê°€ ë°œìƒí–ˆìŠµë‹ˆë‹¤", HttpStatus.INTERNAL_SERVER_ERROR);
   16 |     
   17 |     private final String title;
   18 |     private final String message;
   19 |     private final HttpStatus status;
   20 |     
   21 |     ErrorType(String title, String message, HttpStatus status) {
   22 |         this.title = title;
   23 |         this.message = message;
   24 |         this.status = status;
   25 |     }
   26 |     
   27 |     public String getTitle() {
   28 |         return title;
   29 |     }
   30 |     
   31 |     public String getMessage() {
   32 |         return message;
   33 |     }
   34 |     
   35 |     public HttpStatus getStatus() {
   36 |         return status;
   37 |     }
   38 |     
   39 |     public int getStatusCode() {
   40 |         return status.value();
   41 |     }
   42 | }

#--------------------------------------------------------------------------------


# File: auth-server-refactoring/src/main/java/com/authentication/auth/constants/SecurityConstants.java
#=============================================================================

    1 | package com.authentication.auth.constants;
    2 | 
    3 | import java.util.Arrays;
    4 | import java.util.List;
    5 | 
    6 | /**
    7 |  * ë³´ì•ˆ ê´€ë ¨ ìƒìˆ˜ë¥¼ ì •ì˜í•˜ëŠ” ì—´ê±°í˜• í´ë˜ìŠ¤
    8 |  * í•˜ë“œì½”ë”© ë°©ì§€ ë° ì¤‘ì•™í™”ëœ ìƒìˆ˜ ê´€ë¦¬
    9 |  */
   10 | public enum SecurityConstants {
   11 |     // í† í° ê´€ë ¨ ìƒìˆ˜
   12 |     TOKEN_TYPE("JWT"),
   13 |     TOKEN_HEADER("Authorization"),
   14 |     TOKEN_PREFIX("Bearer "),
   15 |     REFRESH_TOKEN_TYPE("refreshJWT"),
   16 |     
   17 |     // ì¿ í‚¤ ê´€ë ¨ ìƒìˆ˜
   18 |     COOKIE_REFRESH_TOKEN("refreshToken"),
   19 |     COOKIE_ACCESS_TOKEN("access_token"),
   20 |     COOKIE_PATH("/"),
   21 |     
   22 |     // URL íŒ¨í„´ ê´€ë ¨ ìƒìˆ˜
   23 |     PUBLIC_API_PATH("/api/public/**"),
   24 |     AUTH_API_PATH("/api/auth/**"),
   25 |     LOGIN_PATH("/api/auth/login"),
   26 |     REGISTER_PATH("/api/auth/register"),
   27 |     REFRESH_PATH("/api/auth/refresh"),
   28 |     ADMIN_API_PATH("/api/admin/**"),
   29 |     SWAGGER_UI_PATH("/swagger-ui/**"),
   30 |     API_DOCS_PATH("/v3/api-docs/**"),
   31 |     
   32 |     // ì œê³µì ê´€ë ¨ ìƒìˆ˜
   33 |     DEFAULT_PROVIDER("server"),
   34 |     
   35 |     // ì˜¤ë¥˜ ë©”ì‹œì§€
   36 |     ERROR_INVALID_TOKEN("ìœ íš¨í•˜ì§€ ì•Šì€ í† í°ì…ë‹ˆë‹¤"),
   37 |     ERROR_TOKEN_EXPIRED("í† í°ì´ ë§Œë£Œë˜ì—ˆìŠµë‹ˆë‹¤"),
   38 |     ERROR_NO_REFRESH_TOKEN("ë¦¬í”„ë ˆì‹œ í† í°ì´ ì—†ìŠµë‹ˆë‹¤"),
   39 |     ERROR_NO_COOKIES("ì¿ í‚¤ê°€ ì—†ìŠµë‹ˆë‹¤"),
   40 |     ERROR_ADMIN_REQUIRED("ê´€ë¦¬ì ê¶Œí•œì´ í•„ìš”í•©ë‹ˆë‹¤"),
   41 |     ERROR_AUTHENTICATION_FAILED("ì¸ì¦ì— ì‹¤íŒ¨í–ˆìŠµë‹ˆë‹¤");
   42 |     
   43 |     private final String value;
   44 |     
   45 |     SecurityConstants(String value) {
   46 |         this.value = value;
   47 |     }
   48 |     
   49 |     public String getValue() {
   50 |         return value;
   51 |     }
   52 |     
   53 |     /**
   54 |      * ê³µê°œ API ê²½ë¡œ ëª©ë¡ ë°˜í™˜
   55 |      * @return ê³µê°œ API ê²½ë¡œ ëª©ë¡
   56 |      */
   57 |     public static List<String> getPublicPaths() {
   58 |         return Arrays.asList(
   59 |             PUBLIC_API_PATH.getValue(),
   60 |             LOGIN_PATH.getValue(),
   61 |             REGISTER_PATH.getValue(),
   62 |             REFRESH_PATH.getValue(),
   63 |             SWAGGER_UI_PATH.getValue(),
   64 |             API_DOCS_PATH.getValue()
   65 |         );
   66 |     }
   67 |     
   68 |     /**
   69 |      * ê´€ë¦¬ì ì „ìš© API ê²½ë¡œ ëª©ë¡ ë°˜í™˜
   70 |      * @return ê´€ë¦¬ì ì „ìš© API ê²½ë¡œ ëª©ë¡
   71 |      */
   72 |     public static List<String> getAdminPaths() {
   73 |         return Arrays.asList(
   74 |             ADMIN_API_PATH.getValue()
   75 |         );
   76 |     }
   77 | }

#--------------------------------------------------------------------------------


# File: auth-server-refactoring/src/main/java/com/authentication/auth/constants/FilterOrder.java
#=============================================================================

    1 | package com.authentication.auth.constants;
    2 | 
    3 | /**
    4 |  * í•„í„° ì‹¤í–‰ ìˆœì„œë¥¼ ì •ì˜í•˜ëŠ” ì—´ê±°í˜•
    5 |  * ê°’ì´ ë‚®ì„ìˆ˜ë¡ ë¨¼ì € ì‹¤í–‰ë¨
    6 |  */
    7 | public enum FilterOrder {
    8 |     REQUEST_LOGGING(50),
    9 |     CORS(100),
   10 |     CSRF(200),
   11 |     AUTHENTICATION(300),
   12 |     JWT_VERIFICATION(400),
   13 |     AUTHORIZATION(500),
   14 |     SESSION_MANAGEMENT(600),
   15 |     EXCEPTION_TRANSLATION(700),
   16 |     SNS_REQUEST(800);
   17 |     
   18 |     private final int order;
   19 |     
   20 |     FilterOrder(int order) {
   21 |         this.order = order;
   22 |     }
   23 |     
   24 |     public int getOrder() {
   25 |         return order;
   26 |     }
   27 | }

#--------------------------------------------------------------------------------


# File: auth-server-refactoring/src/main/java/com/authentication/auth/filter/PathPatternFilterCondition.java
#=============================================================================

    1 | package com.authentication.auth.filter;
    2 | 
    3 | import jakarta.servlet.http.HttpServletRequest;
    4 | import org.springframework.http.HttpMethod;
    5 | import org.springframework.util.AntPathMatcher;
    6 | 
    7 | import java.util.Arrays;
    8 | import java.util.HashSet;
    9 | import java.util.Set;
   10 | 
   11 | /**
   12 |  * ê²½ë¡œ íŒ¨í„´ ê¸°ë°˜ í•„í„° ì¡°ê±´
   13 |  * URL íŒ¨í„´ê³¼ HTTP ë©”ì†Œë“œ ê¸°ë°˜ìœ¼ë¡œ í•„í„° ì ìš© ì—¬ë¶€ë¥¼ ê²°ì •
   14 |  */
   15 | public record PathPatternFilterCondition(
   16 |     String description,
   17 |     Set<String> patterns,
   18 |     Set<HttpMethod> methods
   19 | ) implements FilterCondition {
   20 |     
   21 |     private static final AntPathMatcher PATH_MATCHER = new AntPathMatcher();
   22 |     
   23 |     /**
   24 |      * ê²½ë¡œ íŒ¨í„´ë§Œ ì§€ì •í•˜ëŠ” ìƒì„±ì
   25 |      * @param description ì¡°ê±´ ì„¤ëª…
   26 |      * @param patterns í¬í•¨í•  URL íŒ¨í„´ (Ant-style)
   27 |      */
   28 |     public PathPatternFilterCondition(String description, String... patterns) {
   29 |         this(description, new HashSet<>(Arrays.asList(patterns)), new HashSet<>());
   30 |     }
   31 |     
   32 |     /**
   33 |      * ê²½ë¡œ íŒ¨í„´ê³¼ HTTP ë©”ì†Œë“œë¥¼ ì§€ì •í•˜ëŠ” ìƒì„±ì
   34 |      * @param description ì¡°ê±´ ì„¤ëª…
   35 |      * @param methods í¬í•¨í•  HTTP ë©”ì†Œë“œ
   36 |      * @param patterns í¬í•¨í•  URL íŒ¨í„´ (Ant-style)
   37 |      */
   38 |     public PathPatternFilterCondition(String description, HttpMethod[] methods, String... patterns) {
   39 |         this(description, new HashSet<>(Arrays.asList(patterns)), new HashSet<>(Arrays.asList(methods)));
   40 |     }
   41 |     
   42 |     /**
   43 |      * íŒ¨í„´ ì¶”ê°€
   44 |      * @param pattern ì¶”ê°€í•  íŒ¨í„´
   45 |      * @return ìƒˆ ì¡°ê±´ ê°ì²´
   46 |      */
   47 |     public PathPatternFilterCondition withPattern(String pattern) {
   48 |         Set<String> newPatterns = new HashSet<>(this.patterns);
   49 |         newPatterns.add(pattern);
   50 |         return new PathPatternFilterCondition(this.description, newPatterns, this.methods);
   51 |     }
   52 |     
   53 |     /**
   54 |      * HTTP ë©”ì†Œë“œ ì¶”ê°€
   55 |      * @param method ì¶”ê°€í•  HTTP ë©”ì†Œë“œ
   56 |      * @return ìƒˆ ì¡°ê±´ ê°ì²´
   57 |      */
   58 |     public PathPatternFilterCondition withMethod(HttpMethod method) {
   59 |         Set<HttpMethod> newMethods = new HashSet<>(this.methods);
   60 |         newMethods.add(method);
   61 |         return new PathPatternFilterCondition(this.description, this.patterns, newMethods);
   62 |     }
   63 | 
   64 |     @Override
   65 |     public boolean shouldNotFilter(HttpServletRequest request) {
   66 |         String requestPath = request.getRequestURI();
   67 |         
   68 |         // ì–´ëŠ í•˜ë‚˜ì˜ íŒ¨í„´ì´ë¼ë„ ë§ìœ¼ë©´ í•„í„° ì œì™¸
   69 |         boolean matchesPattern = patterns.stream()
   70 |                 .anyMatch(pattern -> PATH_MATCHER.match(pattern, requestPath));
   71 |         
   72 |         // HTTP ë©”ì†Œë“œ ì œí•œì´ ì—†ê±°ë‚˜, ìš”ì²­ ë©”ì†Œë“œê°€ ì§€ì •ëœ ë©”ì†Œë“œ ì¤‘ í•˜ë‚˜ì™€ ì¼ì¹˜í•˜ë©´ í•„í„° ì œì™¸
   73 |         boolean matchesMethod = methods.isEmpty() || 
   74 |                                methods.contains(HttpMethod.valueOf(request.getMethod()));
   75 |         
   76 |         return matchesPattern && matchesMethod;
   77 |     }
   78 | 
   79 |     @Override
   80 |     public String getDescription() {
   81 |         return description;
   82 |     }
   83 | }

#--------------------------------------------------------------------------------


# File: auth-server-refactoring/src/main/java/com/authentication/auth/filter/FilterCondition.java
#=============================================================================

    1 | package com.authentication.auth.filter;
    2 | 
    3 | import jakarta.servlet.http.HttpServletRequest;
    4 | 
    5 | /**
    6 |  * í•„í„° ì¡°ê±´ ì¸í„°í˜ì´ìŠ¤
    7 |  * í•„í„° ì ìš© ì¡°ê±´ì„ ì •ì˜í•˜ëŠ” ì¸í„°í˜ì´ìŠ¤
    8 |  */
    9 | public interface FilterCondition {
   10 |     
   11 |     /**
   12 |      * ìš”ì²­ì— í•„í„°ë¥¼ ì ìš©í• ì§€ ì—¬ë¶€ë¥¼ ê²°ì •
   13 |      * @param request HTTP ìš”ì²­
   14 |      * @return trueì´ë©´ í•„í„°ë¥¼ ì ìš©í•˜ì§€ ì•ŠìŒ, falseì´ë©´ í•„í„° ì ìš©
   15 |      */
   16 |     boolean shouldNotFilter(HttpServletRequest request);
   17 |     
   18 |     /**
   19 |      * ì¡°ê±´ì— ì„¤ëª…ì„ ì œê³µ
   20 |      * @return ì¡°ê±´ ì„¤ëª…
   21 |      */
   22 |     String getDescription();
   23 | }

#--------------------------------------------------------------------------------


# File: auth-server-refactoring/src/main/java/com/authentication/auth/filter/JwtVerificationFilter.java
#=============================================================================

    1 | package com.authentication.auth.filter;
    2 | 
    3 | import com.authentication.auth.constants.ErrorType;
    4 | import com.authentication.auth.constants.FilterOrder;
    5 | import com.authentication.auth.constants.SecurityConstants;
    6 | import com.authentication.auth.configuration.token.JwtUtility;
    7 | import com.authentication.auth.dto.response.ApiResponse;
    8 | import com.fasterxml.jackson.databind.ObjectMapper;
    9 | import jakarta.annotation.PostConstruct;
   10 | import jakarta.servlet.Filter;
   11 | import jakarta.servlet.FilterChain;
   12 | import jakarta.servlet.ServletException;
   13 | import jakarta.servlet.http.HttpServletRequest;
   14 | import jakarta.servlet.http.HttpServletResponse;
   15 | import lombok.extern.slf4j.Slf4j;
   16 | import org.springframework.beans.factory.annotation.Autowired;
   17 | import org.springframework.http.MediaType;
   18 | import org.springframework.security.authentication.UsernamePasswordAuthenticationToken;
   19 | import org.springframework.security.core.authority.SimpleGrantedAuthority;
   20 | import org.springframework.security.core.context.SecurityContextHolder;
   21 | import org.springframework.stereotype.Component;
   22 | 
   23 | import java.io.IOException;
   24 | import java.util.Set;
   25 | import java.util.stream.Collectors;
   26 | 
   27 | /**
   28 |  * JWT í† í° ê²€ì¦ í•„í„°
   29 |  * ìš”ì²­ì— í¬í•¨ëœ JWT í† í°ì„ ê²€ì¦í•˜ê³  ì‚¬ìš©ì ì¸ì¦ ì •ë³´ë¥¼ ì„¤ì •
   30 |  */
   31 | @Slf4j
   32 | @Component
   33 | public class JwtVerificationFilter extends AbstractSecurityFilter {
   34 | 
   35 |     private final JwtUtility jwtUtility;
   36 |     private final ObjectMapper objectMapper;
   37 |     private final FilterRegistry filterRegistry;
   38 | 
   39 |     @Autowired
   40 |     public JwtVerificationFilter(
   41 |             JwtUtility jwtUtility,
   42 |             ObjectMapper objectMapper,
   43 |             FilterRegistry filterRegistry) {
   44 |         super(FilterOrder.JWT_VERIFICATION);
   45 |         this.jwtUtility = jwtUtility;
   46 |         this.objectMapper = objectMapper;
   47 |         this.filterRegistry = filterRegistry;
   48 |     }
   49 | 
   50 |     /**
   51 |      * í•„í„° ì´ˆê¸°í™” ë° ë ˆì§€ìŠ¤íŠ¸ë¦¬ì— ë“±ë¡
   52 |      */
   53 |     @PostConstruct
   54 |     public void init() {
   55 |         // í•„í„° ë ˆì§€ìŠ¤íŠ¸ë¦¬ì— ì´ í•„í„° ë“±ë¡
   56 |         filterRegistry.registerFilter(this);
   57 | 
   58 |         // ê¸°ë³¸ í•„í„° ì¡°ê±´ ì„¤ì • - ê³µê°œ APIëŠ” JWT ê²€ì¦ í•„í„° ì ìš©í•˜ì§€ ì•ŠìŒ
   59 |         PathPatternFilterCondition publicApiCondition = new PathPatternFilterCondition(
   60 |                 "JWT ê²€ì¦ ë¶ˆí•„ìš” ê²½ë¡œ",
   61 |                 SecurityConstants.getPublicPaths().toArray(new String[0])
   62 |         );
   63 | 
   64 |         // í•„í„° ë ˆì§€ìŠ¤íŠ¸ë¦¬ì— ì¡°ê±´ ì¶”ê°€
   65 |         filterRegistry.addCondition(getFilterId(), publicApiCondition);
   66 |     }
   67 | 
   68 |     @Override
   69 |     protected void doFilterInternal(HttpServletRequest request, HttpServletResponse response, FilterChain chain)
   70 |             throws IOException, ServletException {
   71 |         
   72 |         String path = request.getRequestURI();
   73 |         log.debug("JWT ê²€ì¦ í•„í„° ì‹¤í–‰: {}", path);
   74 |         
   75 |         try {
   76 |             String token = extractToken(request);
   77 |             
   78 |             if (token != null) {
   79 |                 if (jwtUtility.validateToken(token)) {
   80 |                     String username = jwtUtility.getUsernameFromToken(token);
   81 |                     Set<String> roles = jwtUtility.getRolesFromToken(token);
   82 |                     
   83 |                     // ê¶Œí•œ ì„¤ì •
   84 |                     Set<SimpleGrantedAuthority> authorities = roles.stream()
   85 |                             .map(SimpleGrantedAuthority::new)
   86 |                             .collect(Collectors.toSet());
   87 |                     
   88 |                     UsernamePasswordAuthenticationToken authToken = 
   89 |                             new UsernamePasswordAuthenticationToken(username, null, authorities);
   90 |                     
   91 |                     SecurityContextHolder.getContext().setAuthentication(authToken);
   92 |                     log.debug("JWT í† í° ê²€ì¦ ì„±ê³µ: {}", username);
   93 |                 } else {
   94 |                     log.warn("ìœ íš¨í•˜ì§€ ì•Šì€ JWT í† í°");
   95 |                     sendErrorResponse(response, ErrorType.INVALID_TOKEN);
   96 |                     return;
   97 |                 }
   98 |             } else {
   99 |                 log.debug("JWT í† í°ì´ ì—†ìŒ");
  100 |             }
  101 |             
  102 |             chain.doFilter(request, response);
  103 |         } catch (Exception e) {
  104 |             log.error("JWT ê²€ì¦ ì¤‘ ì˜¤ë¥˜ ë°œìƒ: {}", e.getMessage());
  105 |             SecurityContextHolder.clearContext();
  106 |             sendErrorResponse(response, ErrorType.AUTHENTICATION_FAILED);
  107 |         }
  108 |     }
  109 | 
  110 |     /**
  111 |      * ìš”ì²­ì—ì„œ JWT í† í° ì¶”ì¶œ
  112 |      */
  113 |     private String extractToken(HttpServletRequest request) {
  114 |         String authHeader = request.getHeader(SecurityConstants.TOKEN_HEADER.getValue());
  115 |         
  116 |         if (authHeader != null && authHeader.startsWith(SecurityConstants.TOKEN_PREFIX.getValue())) {
  117 |             return authHeader.substring(SecurityConstants.TOKEN_PREFIX.getValue().length());
  118 |         }
  119 |         
  120 |         return null;
  121 |     }
  122 | 
  123 |     /**
  124 |      * ì˜¤ë¥˜ ì‘ë‹µ ì „ì†¡
  125 |      */
  126 |     private void sendErrorResponse(HttpServletResponse response, ErrorType errorType) throws IOException {
  127 |         response.setStatus(errorType.getStatusCode());
  128 |         response.setContentType(MediaType.APPLICATION_JSON_VALUE);
  129 |         
  130 |         objectMapper.writeValue(response.getOutputStream(), 
  131 |                                ApiResponse.error(errorType));
  132 |     }
  133 | 
  134 |     @Override
  135 |     protected boolean shouldSkipFilter(HttpServletRequest request) {
  136 |         return filterRegistry.shouldNotFilter(getFilterId(), request);
  137 |     }
  138 | 
  139 |     @Override
  140 |     public void configure(HttpSecurity http) throws Exception {
  141 |         http.addFilterAfter(this, AuthenticationFilter.class);
  142 |         log.debug("JWT ê²€ì¦ í•„í„° HttpSecurityì— êµ¬ì„±ë¨");
  143 |     }
  144 | 
  145 |     @Override
  146 |     public Class<? extends Filter> getBeforeFilter() {
  147 |         return AuthenticationFilter.class;
  148 |     }
  149 | 
  150 |     @Override
  151 |     public Class<? extends Filter> getAfterFilter() {
  152 |         return AuthorizationFilter.class;
  153 |     }
  154 | }

#--------------------------------------------------------------------------------


# File: auth-server-refactoring/src/main/java/com/authentication/auth/filter/PluggableFilter.java
#=============================================================================

    1 | package com.authentication.auth.filter;
    2 | 
    3 | import jakarta.servlet.Filter;
    4 | import org.springframework.security.config.annotation.web.builders.HttpSecurity;
    5 | 
    6 | /**
    7 |  * í”ŒëŸ¬ê·¸í˜• í•„í„° ì¸í„°í˜ì´ìŠ¤
    8 |  * ë™ì ìœ¼ë¡œ ì¶”ê°€/ì œê±° ê°€ëŠ¥í•œ í•„í„°ë¥¼ ìœ„í•œ ì¸í„°í˜ì´ìŠ¤
    9 |  */
   10 | public interface PluggableFilter extends Filter {
   11 |     
   12 |     /**
   13 |      * HttpSecurityì— ì´ í•„í„°ë¥¼ êµ¬ì„±
   14 |      * @param http HttpSecurity ê°ì²´
   15 |      * @throws Exception êµ¬ì„± ì¤‘ ì˜ˆì™¸ ë°œìƒ ì‹œ
   16 |      */
   17 |     void configure(HttpSecurity http) throws Exception;
   18 |     
   19 |     /**
   20 |      * í•„í„°ì˜ ì‹¤í–‰ ìˆœì„œ ë°˜í™˜
   21 |      * ë‚®ì€ ê°’ì´ ë†’ì€ ìš°ì„ ìˆœìœ„ë¥¼ ì˜ë¯¸í•¨
   22 |      * @return í•„í„° ì‹¤í–‰ ìˆœì„œ
   23 |      */
   24 |     int getOrder();
   25 |     
   26 |     /**
   27 |      * ì´ í•„í„° ì´ì „ì— ì‹¤í–‰ë˜ì–´ì•¼ í•˜ëŠ” í•„í„° í´ë˜ìŠ¤ ë°˜í™˜
   28 |      * @return ì´ì „ í•„í„° í´ë˜ìŠ¤, ì—†ìœ¼ë©´ null
   29 |      */
   30 |     Class<? extends Filter> getBeforeFilter();
   31 |     
   32 |     /**
   33 |      * ì´ í•„í„° ì´í›„ì— ì‹¤í–‰ë˜ì–´ì•¼ í•˜ëŠ” í•„í„° í´ë˜ìŠ¤ ë°˜í™˜
   34 |      * @return ì´í›„ í•„í„° í´ë˜ìŠ¤, ì—†ìœ¼ë©´ null
   35 |      */
   36 |     Class<? extends Filter> getAfterFilter();
   37 |     
   38 |     /**
   39 |      * í•„í„° ID ë°˜í™˜ (ê¸°ë³¸ êµ¬í˜„ì€ í´ë˜ìŠ¤ëª…)
   40 |      * @return í•„í„° ID
   41 |      */
   42 |     default String getFilterId() {
   43 |         return this.getClass().getSimpleName();
   44 |     }
   45 | }

#--------------------------------------------------------------------------------


# File: auth-server-refactoring/src/main/java/com/authentication/auth/filter/FilterRegistry.java
#=============================================================================

    1 | package com.authentication.auth.filter;
    2 | 
    3 | import lombok.extern.slf4j.Slf4j;
    4 | import org.springframework.security.config.annotation.web.builders.HttpSecurity;
    5 | import org.springframework.stereotype.Component;
    6 | 
    7 | import java.util.*;
    8 | import java.util.concurrent.ConcurrentHashMap;
    9 | import java.util.concurrent.CopyOnWriteArrayList;
   10 | 
   11 | /**
   12 |  * í•„í„° ë ˆì§€ìŠ¤íŠ¸ë¦¬
   13 |  * í”ŒëŸ¬ê·¸ì¸ ë°©ì‹ì˜ í•„í„°ë¥¼ ë“±ë¡í•˜ê³  ê´€ë¦¬í•˜ëŠ” ì¤‘ì•™ ì»´í¬ë„ŒíŠ¸
   14 |  */
   15 | @Slf4j
   16 | @Component
   17 | public class FilterRegistry {
   18 | 
   19 |     // í•„í„° ì¸ìŠ¤í„´ìŠ¤ ì €ì¥ ë§µ (í•„í„° ID -> í•„í„° ì¸ìŠ¤í„´ìŠ¤)
   20 |     private final Map<String, PluggableFilter> filterMap = new ConcurrentHashMap<>();
   21 |     
   22 |     // í•„í„° ìš°ì„ ìˆœìœ„ ìˆœì„œëŒ€ë¡œ ì €ì¥ëœ ë¦¬ìŠ¤íŠ¸
   23 |     private final List<PluggableFilter> orderedFilters = new CopyOnWriteArrayList<>();
   24 |     
   25 |     // í•„í„° ì¡°ê±´ ì €ì¥ ë§µ (í•„í„° ID -> í•„í„° ì¡°ê±´ ë¦¬ìŠ¤íŠ¸)
   26 |     private final Map<String, List<FilterCondition>> filterConditions = new ConcurrentHashMap<>();
   27 | 
   28 |     /**
   29 |      * í•„í„° ë“±ë¡
   30 |      * @param filter ë“±ë¡í•  í•„í„°
   31 |      */
   32 |     public void registerFilter(PluggableFilter filter) {
   33 |         String filterId = filter.getFilterId();
   34 |         filterMap.put(filterId, filter);
   35 |         
   36 |         // ìš°ì„ ìˆœìœ„ì— ë”°ë¼ ì •ë ¬ëœ ìœ„ì¹˜ì— í•„í„° ì‚½ì…
   37 |         insertFilterInOrder(filter);
   38 |         
   39 |         log.info("í•„í„° ë“±ë¡ ì™„ë£Œ: {}, ìš°ì„ ìˆœìœ„: {}", filterId, filter.getOrder());
   40 |     }
   41 | 
   42 |     /**
   43 |      * í•„í„°ì— ì¡°ê±´ ì¶”ê°€
   44 |      * @param filterId í•„í„° ID
   45 |      * @param condition í•„í„° ì¡°ê±´
   46 |      */
   47 |     public void addCondition(String filterId, FilterCondition condition) {
   48 |         filterConditions.computeIfAbsent(filterId, k -> new CopyOnWriteArrayList<>())
   49 |                         .add(condition);
   50 |         log.info("í•„í„° '{}' ì— ì¡°ê±´ ì¶”ê°€: {}", filterId, condition.getDescription());
   51 |     }
   52 | 
   53 |     /**
   54 |      * í•„í„°ì— ì¡°ê±´ ì œê±°
   55 |      * @param filterId í•„í„° ID
   56 |      * @param condition ì œê±°í•  ì¡°ê±´
   57 |      * @return ì œê±° ì„±ê³µ ì—¬ë¶€
   58 |      */
   59 |     public boolean removeCondition(String filterId, FilterCondition condition) {
   60 |         List<FilterCondition> conditions = filterConditions.get(filterId);
   61 |         if (conditions != null) {
   62 |             boolean result = conditions.remove(condition);
   63 |             if (result) {
   64 |                 log.info("í•„í„° '{}' ì—ì„œ ì¡°ê±´ ì œê±°: {}", filterId, condition.getDescription());
   65 |             }
   66 |             return result;
   67 |         }
   68 |         return false;
   69 |     }
   70 | 
   71 |     /**
   72 |      * íŠ¹ì • ìš”ì²­ì— ëŒ€í•´ í•„í„°ë¥¼ ì ìš©í•´ì•¼ í•˜ëŠ”ì§€ í™•ì¸
   73 |      * @param filterId í•„í„° ID
   74 |      * @param request HTTP ìš”ì²­
   75 |      * @return trueë©´ í•„í„°ë¥¼ ì ìš©í•˜ì§€ ì•ŠìŒ, falseë©´ í•„í„° ì ìš©
   76 |      */
   77 |     public boolean shouldNotFilter(String filterId, jakarta.servlet.http.HttpServletRequest request) {
   78 |         List<FilterCondition> conditions = filterConditions.get(filterId);
   79 |         if (conditions == null || conditions.isEmpty()) {
   80 |             return false; // ì¡°ê±´ì´ ì—†ìœ¼ë©´ í•­ìƒ í•„í„° ì ìš©
   81 |         }
   82 |         
   83 |         // ì–´ëŠ í•˜ë‚˜ì˜ ì¡°ê±´ì´ë¼ë„ trueë¥¼ ë°˜í™˜í•˜ë©´ í•„í„°ë¥¼ ì ìš©í•˜ì§€ ì•ŠìŒ (OR ì¡°ê±´)
   84 |         return conditions.stream().anyMatch(condition -> condition.shouldNotFilter(request));
   85 |     }
   86 | 
   87 |     /**
   88 |      * ìš°ì„ ìˆœìœ„ì— ë”°ë¼ ì •ë ¬ëœ ìœ„ì¹˜ì— í•„í„° ì‚½ì…
   89 |      * @param filter ì‚½ì…í•  í•„í„°
   90 |      */
   91 |     private void insertFilterInOrder(PluggableFilter filter) {
   92 |         // ê¸°ì¡´ í•„í„°ê°€ ìˆìœ¼ë©´ ì œê±°
   93 |         orderedFilters.remove(filter);
   94 |         
   95 |         // ìƒˆ í•„í„°ì˜ ìˆœì„œ
   96 |         int newFilterOrder = filter.getOrder();
   97 |         
   98 |         int insertIndex = 0;
   99 |         while (insertIndex < orderedFilters.size() && 
  100 |                orderedFilters.get(insertIndex).getOrder() <= newFilterOrder) {
  101 |             insertIndex++;
  102 |         }
  103 |         
  104 |         orderedFilters.add(insertIndex, filter);
  105 |     }
  106 | 
  107 |     /**
  108 |      * ë“±ë¡ëœ ëª¨ë“  í•„í„°ë¥¼ SecurityConfigì— ë“±ë¡
  109 |      * @param http HttpSecurity ê°ì²´
  110 |      * @throws Exception ì„¤ì • ì¤‘ ì˜ˆì™¸ ë°œìƒ ì‹œ
  111 |      */
  112 |     public void configureFilters(HttpSecurity http) throws Exception {
  113 |         for (PluggableFilter filter : orderedFilters) {
  114 |             filter.configure(http);
  115 |             log.debug("í•„í„° êµ¬ì„± ì ìš©: {}", filter.getFilterId());
  116 |         }
  117 |         log.info("ì´ {}ê°œì˜ í•„í„°ê°€ SecurityConfigì— ë“±ë¡ë¨", orderedFilters.size());
  118 |     }
  119 | 
  120 |     /**
  121 |      * ë“±ë¡ëœ ëª¨ë“  í•„í„° ëª©ë¡ ë°˜í™˜
  122 |      * @return í•„í„° ëª©ë¡
  123 |      */
  124 |     public List<PluggableFilter> getRegisteredFilters() {
  125 |         return Collections.unmodifiableList(orderedFilters);
  126 |     }
  127 |     
  128 |     /**
  129 |      * íŠ¹ì • í•„í„° ì¡°íšŒ
  130 |      * @param filterId í•„í„° ID
  131 |      * @return ì°¾ì€ í•„í„°, ì—†ìœ¼ë©´ null
  132 |      */
  133 |     public PluggableFilter getFilter(String filterId) {
  134 |         return filterMap.get(filterId);
  135 |     }
  136 | }

#--------------------------------------------------------------------------------


# File: auth-server-refactoring/src/main/java/com/authentication/auth/filter/AuthorizationFilter.java
#=============================================================================

    1 | package com.authentication.auth.filter;
    2 | 
    3 | import com.authentication.auth.constants.ErrorType;
    4 | import com.authentication.auth.constants.FilterOrder;
    5 | import com.authentication.auth.constants.SecurityConstants;
    6 | import com.authentication.auth.dto.response.ApiResponse;
    7 | import com.fasterxml.jackson.databind.ObjectMapper;
    8 | import jakarta.annotation.PostConstruct;
    9 | import jakarta.servlet.Filter;
   10 | import jakarta.servlet.FilterChain;
   11 | import jakarta.servlet.ServletException;
   12 | import jakarta.servlet.http.HttpServletRequest;
   13 | import jakarta.servlet.http.HttpServletResponse;
   14 | import lombok.extern.slf4j.Slf4j;
   15 | import org.springframework.beans.factory.annotation.Autowired;
   16 | import org.springframework.http.MediaType;
   17 | import org.springframework.security.core.Authentication;
   18 | import org.springframework.security.core.context.SecurityContextHolder;
   19 | import org.springframework.stereotype.Component;
   20 | 
   21 | import java.io.IOException;
   22 | import java.util.Set;
   23 | 
   24 | /**
   25 |  * ê¶Œí•œ ë¶€ì—¬ í•„í„°
   26 |  * JWT í† í°ì˜ ìœ íš¨ì„±ì„ ê²€ì¦í•˜ê³  ì‚¬ìš©ì ê¶Œí•œì„ ê²€ì‚¬í•˜ëŠ” í•„í„°
   27 |  */
   28 | @Slf4j
   29 | @Component
   30 | public class AuthorizationFilter extends AbstractSecurityFilter {
   31 | 
   32 |     private final ObjectMapper objectMapper;
   33 |     private final FilterRegistry filterRegistry;
   34 |     private final Set<String> adminRoles = Set.of("ROLE_ADMIN", "ADMIN");
   35 | 
   36 |     @Autowired
   37 |     public AuthorizationFilter(
   38 |             ObjectMapper objectMapper,
   39 |             FilterRegistry filterRegistry) {
   40 |         super(FilterOrder.AUTHORIZATION);
   41 |         this.objectMapper = objectMapper;
   42 |         this.filterRegistry = filterRegistry;
   43 |     }
   44 | 
   45 |     /**
   46 |      * í•„í„° ì´ˆê¸°í™” ë° ë ˆì§€ìŠ¤íŠ¸ë¦¬ì— ë“±ë¡
   47 |      */
   48 |     @PostConstruct
   49 |     public void init() {
   50 |         // í•„í„° ë ˆì§€ìŠ¤íŠ¸ë¦¬ì— ì´ í•„í„° ë“±ë¡
   51 |         filterRegistry.registerFilter(this);
   52 | 
   53 |         // ê¸°ë³¸ í•„í„° ì¡°ê±´ ì„¤ì • - ê³µê°œ APIëŠ” ê¶Œí•œ í•„í„° ì ìš©í•˜ì§€ ì•ŠìŒ
   54 |         PathPatternFilterCondition publicApiCondition = new PathPatternFilterCondition(
   55 |                 "ê¶Œí•œ í™•ì¸ ë¶ˆí•„ìš” ê²½ë¡œ",
   56 |                 SecurityConstants.getPublicPaths().toArray(new String[0])
   57 |         );
   58 | 
   59 |         // í•„í„° ë ˆì§€ìŠ¤íŠ¸ë¦¬ì— ì¡°ê±´ ì¶”ê°€
   60 |         filterRegistry.addCondition(getFilterId(), publicApiCondition);
   61 |     }
   62 | 
   63 |     @Override
   64 |     protected void doFilterInternal(HttpServletRequest request, HttpServletResponse response, FilterChain chain)
   65 |             throws IOException, ServletException {
   66 |         
   67 |         String path = request.getRequestURI();
   68 |         log.debug("ê¶Œí•œ ë¶€ì—¬ í•„í„° ì‹¤í–‰: {}", path);
   69 |         
   70 |         try {
   71 |             // í† í°ì—ì„œ ì¸ì¦ ì •ë³´ ì¶”ì¶œ
   72 |             Authentication authentication = SecurityContextHolder.getContext().getAuthentication();
   73 |             
   74 |             if (authentication != null && authentication.isAuthenticated()) {
   75 |                 // ê´€ë¦¬ì ì „ìš© API ì ‘ê·¼ ì œí•œ
   76 |                 if (path.startsWith(SecurityConstants.ADMIN_API_PATH.getValue()) && !hasAdminRole(authentication)) {
   77 |                     sendErrorResponse(response, ErrorType.ACCESS_DENIED);
   78 |                     return;
   79 |                 }
   80 |                 
   81 |                 log.debug("ì‚¬ìš©ì '{}' ê¶Œí•œ í™•ì¸ ì„±ê³µ", authentication.getName());
   82 |             }
   83 |             
   84 |             chain.doFilter(request, response);
   85 |         } catch (Exception e) {
   86 |             log.error("ê¶Œí•œ ë¶€ì—¬ í•„í„° ì‹¤í–‰ ì¤‘ ì˜¤ë¥˜ ë°œìƒ: {}", e.getMessage());
   87 |             sendErrorResponse(response, ErrorType.AUTHENTICATION_FAILED);
   88 |         }
   89 |     }
   90 | 
   91 |     /**
   92 |      * ì‚¬ìš©ìê°€ ê´€ë¦¬ì ê¶Œí•œì„ ê°€ì§€ê³  ìˆëŠ”ì§€ í™•ì¸
   93 |      */
   94 |     private boolean hasAdminRole(Authentication authentication) {
   95 |         return authentication.getAuthorities().stream()
   96 |                 .anyMatch(authority -> adminRoles.contains(authority.getAuthority()));
   97 |     }
   98 | 
   99 |     /**
  100 |      * ì˜¤ë¥˜ ì‘ë‹µ ì „ì†¡
  101 |      */
  102 |     private void sendErrorResponse(HttpServletResponse response, ErrorType errorType) throws IOException {
  103 |         response.setStatus(errorType.getStatusCode());
  104 |         response.setContentType(MediaType.APPLICATION_JSON_VALUE);
  105 |         
  106 |         objectMapper.writeValue(response.getOutputStream(), 
  107 |                                ApiResponse.error(errorType));
  108 |     }
  109 | 
  110 |     @Override
  111 |     protected boolean shouldSkipFilter(HttpServletRequest request) {
  112 |         return filterRegistry.shouldNotFilter(getFilterId(), request);
  113 |     }
  114 | 
  115 |     @Override
  116 |     public void configure(HttpSecurity http) throws Exception {
  117 |         http.addFilterAfter(this, JwtVerificationFilter.class);
  118 |         log.debug("ê¶Œí•œ ë¶€ì—¬ í•„í„° HttpSecurityì— êµ¬ì„±ë¨");
  119 |     }
  120 | 
  121 |     @Override
  122 |     public Class<? extends Filter> getBeforeFilter() {
  123 |         return JwtVerificationFilter.class;
  124 |     }
  125 | 
  126 |     @Override
  127 |     public Class<? extends Filter> getAfterFilter() {
  128 |         return null;
  129 |     }
  130 | }

#--------------------------------------------------------------------------------


# File: auth-server-refactoring/src/main/java/com/authentication/auth/filter/AuthenticationFilter.java
#=============================================================================

    1 | package com.authentication.auth.filter;
    2 | 
    3 | import com.authentication.auth.constants.ErrorType;
    4 | import com.authentication.auth.constants.FilterOrder;
    5 | import com.authentication.auth.constants.SecurityConstants;
    6 | import com.authentication.auth.configuration.token.JwtUtility;
    7 | import com.authentication.auth.dto.response.ApiResponse;
    8 | import com.authentication.auth.dto.token.TokenDto;
    9 | import com.authentication.auth.service.redis.RedisService;
   10 | import com.fasterxml.jackson.databind.ObjectMapper;
   11 | import jakarta.annotation.PostConstruct;
   12 | import jakarta.servlet.Filter;
   13 | import jakarta.servlet.FilterChain;
   14 | import jakarta.servlet.ServletException;
   15 | import jakarta.servlet.http.Cookie;
   16 | import jakarta.servlet.http.HttpServletRequest;
   17 | import jakarta.servlet.http.HttpServletResponse;
   18 | import lombok.extern.slf4j.Slf4j;
   19 | import org.springframework.beans.factory.annotation.Autowired;
   20 | import org.springframework.beans.factory.annotation.Value;
   21 | import org.springframework.http.HttpMethod;
   22 | import org.springframework.http.MediaType;
   23 | import org.springframework.security.authentication.AuthenticationManager;
   24 | import org.springframework.security.authentication.UsernamePasswordAuthenticationToken;
   25 | import org.springframework.security.core.Authentication;
   26 | import org.springframework.security.core.AuthenticationException;
   27 | import org.springframework.security.core.context.SecurityContextHolder;
   28 | import org.springframework.security.web.authentication.UsernamePasswordAuthenticationFilter;
   29 | import org.springframework.stereotype.Component;
   30 | 
   31 | import java.io.IOException;
   32 | import java.util.HashMap;
   33 | import java.util.Map;
   34 | 
   35 | /**
   36 |  * ì‚¬ìš©ì ì¸ì¦ í•„í„°
   37 |  * ì‚¬ìš©ì ë¡œê·¸ì¸ ìš”ì²­ì„ ì²˜ë¦¬í•˜ê³  JWT í† í°ì„ ìƒì„±í•˜ëŠ” í•„í„°
   38 |  */
   39 | @Slf4j
   40 | @Component
   41 | public class AuthenticationFilter extends UsernamePasswordAuthenticationFilter implements PluggableFilter {
   42 |     
   43 |     private final AuthenticationManager authenticationManager;
   44 |     private final JwtUtility jwtUtility;
   45 |     private final ObjectMapper objectMapper;
   46 |     private final RedisService redisService;
   47 |     private final String domain;
   48 |     private final String cookieDomain;
   49 |     private final FilterRegistry filterRegistry;
   50 |     
   51 |     @Autowired
   52 |     public AuthenticationFilter(
   53 |             AuthenticationManager authenticationManager,
   54 |             JwtUtility jwtUtility,
   55 |             ObjectMapper objectMapper,
   56 |             RedisService redisService,
   57 |             @Value("${site.domain}") String domain,
   58 |             @Value("${server.cookie.domain}") String cookieDomain,
   59 |             FilterRegistry filterRegistry) {
   60 |         this.authenticationManager = authenticationManager;
   61 |         this.jwtUtility = jwtUtility;
   62 |         this.objectMapper = objectMapper;
   63 |         this.redisService = redisService;
   64 |         this.domain = domain;
   65 |         this.cookieDomain = cookieDomain;
   66 |         this.filterRegistry = filterRegistry;
   67 |         setFilterProcessesUrl(SecurityConstants.LOGIN_PATH.getValue());
   68 |         setAuthenticationManager(authenticationManager);
   69 |     }
   70 |     
   71 |     /**
   72 |      * í•„í„° ì´ˆê¸°í™” ë° ë ˆì§€ìŠ¤íŠ¸ë¦¬ì— ë“±ë¡
   73 |      */
   74 |     @PostConstruct
   75 |     public void init() {
   76 |         // í•„í„° ë ˆì§€ìŠ¤íŠ¸ë¦¬ì— ì´ í•„í„° ë“±ë¡
   77 |         filterRegistry.registerFilter(this);
   78 |         
   79 |         // ê¸°ë³¸ í•„í„° ì¡°ê±´ ì„¤ì • - ê³µê°œ APIëŠ” ì¸ì¦ í•„í„° ì ìš©í•˜ì§€ ì•ŠìŒ
   80 |         PathPatternFilterCondition publicApiCondition = new PathPatternFilterCondition(
   81 |                 "ê³µê°œ API ê²½ë¡œ ì œì™¸",
   82 |                 SecurityConstants.getPublicPaths().toArray(new String[0])
   83 |         );
   84 |         
   85 |         // ë¡œê·¸ì¸ ê²½ë¡œì—ëŠ” POST ë©”ì†Œë“œë§Œ í—ˆìš©í•˜ê³  ë‹¤ë¥¸ ë©”ì†Œë“œëŠ” í•„í„°ë§
   86 |         PathPatternFilterCondition loginPathCondition = new PathPatternFilterCondition(
   87 |                 "ë¡œê·¸ì¸ ê²½ë¡œ ë©”ì†Œë“œ ì œí•œ",
   88 |                 new HttpMethod[] {HttpMethod.GET, HttpMethod.PUT, HttpMethod.DELETE},
   89 |                 SecurityConstants.LOGIN_PATH.getValue()
   90 |         );
   91 |         
   92 |         // í•„í„° ë ˆì§€ìŠ¤íŠ¸ë¦¬ì— ì¡°ê±´ ì¶”ê°€
   93 |         filterRegistry.addCondition(getFilterId(), publicApiCondition);
   94 |         filterRegistry.addCondition(getFilterId(), loginPathCondition);
   95 |     }
   96 | 
   97 |     @Override
   98 |     public Authentication attemptAuthentication(HttpServletRequest request, HttpServletResponse response) 
   99 |             throws AuthenticationException {
  100 |         log.info("ì¸ì¦ ì‹œë„: {}", request.getRequestURI());
  101 |         
  102 |         try {
  103 |             // ìš”ì²­ ë°”ë””ì—ì„œ ì‚¬ìš©ì ìê²© ì¦ëª… ì¶”ì¶œ
  104 |             Map<String, String> credentials = objectMapper.readValue(request.getInputStream(), Map.class);
  105 |             String username = credentials.get("username");
  106 |             String password = credentials.get("password");
  107 |             
  108 |             log.debug("ì‚¬ìš©ì ì¸ì¦ ì‹œë„: {}", username);
  109 |             
  110 |             // ì¸ì¦ í† í° ìƒì„± ë° ì¸ì¦ ì‹œë„
  111 |             UsernamePasswordAuthenticationToken authToken = 
  112 |                 new UsernamePasswordAuthenticationToken(username, password);
  113 |                 
  114 |             return authenticationManager.authenticate(authToken);
  115 |         } catch (IOException e) {
  116 |             log.error("ì¸ì¦ ìš”ì²­ ì²˜ë¦¬ ì¤‘ ì˜¤ë¥˜ ë°œìƒ: {}", e.getMessage());
  117 |             throw new AuthenticationException(ErrorType.AUTHENTICATION_FAILED.getMessage()) {};
  118 |         }
  119 |     }
  120 | 
  121 |     @Override
  122 |     protected void successfulAuthentication(HttpServletRequest request, HttpServletResponse response,
  123 |                                            FilterChain chain, Authentication authResult) 
  124 |                                            throws IOException, ServletException {
  125 |         log.info("ì¸ì¦ ì„±ê³µ: í† í° ìƒì„± ì‹œì‘");
  126 |         
  127 |         // ì‚¬ìš©ì ì •ë³´ ì¶”ì¶œ
  128 |         String username = authResult.getName();
  129 |         
  130 |         // í† í° ìƒì„±
  131 |         TokenDto tokenDto = jwtUtility.createTokenDto(username, authResult.getAuthorities());
  132 |         
  133 |         // ë¦¬í”„ë ˆì‹œ í† í°ì„ Redisì— ì €ì¥
  134 |         redisService.saveRToken(username, SecurityConstants.DEFAULT_PROVIDER.getValue(), tokenDto.refreshToken());
  135 |         redisService.saveAccessToken(tokenDto.refreshToken(), tokenDto.accessToken(), username);
  136 |         
  137 |         // í† í°ì„ ì¿ í‚¤ì— ì €ì¥
  138 |         Cookie refreshTokenCookie = new Cookie(SecurityConstants.COOKIE_REFRESH_TOKEN.getValue(), tokenDto.refreshToken());
  139 |         refreshTokenCookie.setHttpOnly(true);
  140 |         refreshTokenCookie.setPath(SecurityConstants.COOKIE_PATH.getValue());
  141 |         refreshTokenCookie.setDomain(cookieDomain);
  142 |         refreshTokenCookie.setSecure(true);
  143 |         
  144 |         response.addCookie(refreshTokenCookie);
  145 |         response.addHeader(SecurityConstants.TOKEN_HEADER.getValue(), 
  146 |                           SecurityConstants.TOKEN_PREFIX.getValue() + tokenDto.accessToken());
  147 |         
  148 |         // ì‘ë‹µ ë³¸ë¬¸ì—ë„ í† í° ì •ë³´ í¬í•¨
  149 |         Map<String, String> tokens = new HashMap<>();
  150 |         tokens.put("access_token", tokenDto.accessToken());
  151 |         
  152 |         response.setContentType(MediaType.APPLICATION_JSON_VALUE);
  153 |         objectMapper.writeValue(response.getOutputStream(), 
  154 |                                ApiResponse.success(tokens, "ë¡œê·¸ì¸ ì„±ê³µ"));
  155 |         
  156 |         // SecurityContextì— ì¸ì¦ ì •ë³´ ì„¤ì •
  157 |         SecurityContextHolder.getContext().setAuthentication(authResult);
  158 |         
  159 |         log.info("ì¸ì¦ ì„±ê³µ: í† í° ìƒì„± ì™„ë£Œ ë° ì¿ í‚¤ ì„¤ì •");
  160 |     }
  161 |     
  162 |     @Override
  163 |     protected void unsuccessfulAuthentication(HttpServletRequest request, HttpServletResponse response,
  164 |                                              AuthenticationException failed) throws IOException, ServletException {
  165 |         log.error("ì¸ì¦ ì‹¤íŒ¨: {}", failed.getMessage());
  166 |         
  167 |         SecurityContextHolder.clearContext();
  168 |         
  169 |         response.setStatus(ErrorType.AUTHENTICATION_FAILED.getStatusCode());
  170 |         response.setContentType(MediaType.APPLICATION_JSON_VALUE);
  171 |         
  172 |         objectMapper.writeValue(response.getOutputStream(), 
  173 |                                ApiResponse.error(ErrorType.AUTHENTICATION_FAILED));
  174 |     }
  175 |     
  176 |     @Override
  177 |     public void configure(HttpSecurity http) throws Exception {
  178 |         http.addFilterAt(this, UsernamePasswordAuthenticationFilter.class);
  179 |         log.debug("ì¸ì¦ í•„í„° HttpSecurityì— êµ¬ì„±ë¨");
  180 |     }
  181 |     
  182 |     @Override
  183 |     public int getOrder() {
  184 |         return FilterOrder.AUTHENTICATION.getOrder();
  185 |     }
  186 |     
  187 |     @Override
  188 |     public Class<? extends Filter> getBeforeFilter() {
  189 |         return null; // ì´ í•„í„° ì´ì „ì— ì‹¤í–‰ë˜ì–´ì•¼ í•˜ëŠ” í•„í„°ê°€ ì—†ìŒ
  190 |     }
  191 |     
  192 |     @Override
  193 |     public Class<? extends Filter> getAfterFilter() {
  194 |         return JwtVerificationFilter.class; // JWT ê²€ì¦ í•„í„° ì´ì „ì— ì‹¤í–‰
  195 |     }
  196 |     
  197 |     @Override
  198 |     public String getFilterId() {
  199 |         return this.getClass().getSimpleName();
  200 |     }
  201 | }

#--------------------------------------------------------------------------------


# File: auth-server-refactoring/src/main/java/com/authentication/auth/filter/SecurityFilterOrder.java
#=============================================================================

    1 | package com.authentication.auth.filter;
    2 | 
    3 | /**
    4 |  * ë³´ì•ˆ í•„í„° ìˆœì„œ ìƒìˆ˜
    5 |  * í•„í„° ì²´ì¸ ë‚´ì—ì„œ í•„í„°ì˜ ì‹¤í–‰ ìˆœì„œë¥¼ ì •ì˜í•˜ëŠ” ì—´ê±°í˜•
    6 |  */
    7 | public enum SecurityFilterOrder {
    8 |     
    9 |     // ê°’ì´ ë‚®ì„ìˆ˜ë¡ ë¨¼ì € ì‹¤í–‰ë¨
   10 |     REQUEST_LOGGING_FILTER(50),
   11 |     CORS_FILTER(100),
   12 |     CSRF_FILTER(200),
   13 |     AUTHENTICATION_FILTER(300),
   14 |     JWT_VERIFICATION_FILTER(400),
   15 |     AUTHORIZATION_FILTER(500),
   16 |     SESSION_MANAGEMENT_FILTER(600),
   17 |     EXCEPTION_TRANSLATION_FILTER(700);
   18 |     
   19 |     private final int order;
   20 |     
   21 |     SecurityFilterOrder(int order) {
   22 |         this.order = order;
   23 |     }
   24 |     
   25 |     public int getOrder() {
   26 |         return order;
   27 |     }
   28 | }

#--------------------------------------------------------------------------------


# File: auth-server-refactoring/src/main/java/com/authentication/auth/filter/AbstractSecurityFilter.java
#=============================================================================

    1 | package com.authentication.auth.filter;
    2 | 
    3 | import jakarta.servlet.FilterChain;
    4 | import jakarta.servlet.ServletException;
    5 | import jakarta.servlet.http.HttpServletRequest;
    6 | import jakarta.servlet.http.HttpServletResponse;
    7 | import lombok.extern.slf4j.Slf4j;
    8 | import org.springframework.web.filter.OncePerRequestFilter;
    9 | 
   10 | import java.io.IOException;
   11 | 
   12 | /**
   13 |  * ëª¨ë“  ë³´ì•ˆ í•„í„°ì˜ ê¸°ë³¸ ì¶”ìƒ í´ë˜ìŠ¤
   14 |  * í•„í„° ì‹¤í–‰ íë¦„ ì œì–´ ë° ê³µí†µ ê¸°ëŠ¥ ì œê³µ
   15 |  */
   16 | @Slf4j
   17 | public abstract class AbstractSecurityFilter extends OncePerRequestFilter implements PluggableFilter {
   18 | 
   19 |     // í•„í„° ì‹¤í–‰ ìˆœì„œ
   20 |     private final SecurityFilterOrder securityFilterOrder;
   21 | 
   22 |     /**
   23 |      * ìƒì„±ì
   24 |      * @param securityFilterOrder í•„í„° ì‹¤í–‰ ìˆœì„œ
   25 |      */
   26 |     protected AbstractSecurityFilter(SecurityFilterOrder securityFilterOrder) {
   27 |         this.securityFilterOrder = securityFilterOrder;
   28 |     }
   29 | 
   30 |     @Override
   31 |     protected final void doFilterInternal(HttpServletRequest request, HttpServletResponse response, FilterChain chain)
   32 |             throws ServletException, IOException {
   33 |         
   34 |         String path = request.getRequestURI();
   35 |         log.debug("í•„í„° ì‹œì‘: {} - {}", securityFilterOrder.name(), path);
   36 |         
   37 |         try {
   38 |             doFilterInternal(request, response, chain);
   39 |             log.debug("í•„í„° ì¢…ë£Œ: {} - {}", securityFilterOrder.name(), path);
   40 |         } catch (Exception e) {
   41 |             log.error("í•„í„° ì‹¤í–‰ ì¤‘ ì˜¤ë¥˜ ë°œìƒ: {} - {}", securityFilterOrder.name(), e.getMessage(), e);
   42 |             handleFilterException(request, response, e);
   43 |         }
   44 |     }
   45 |     
   46 |     /**
   47 |      * í•„í„°ì˜ ì£¼ìš” ë¹„ì¦ˆë‹ˆìŠ¤ ë¡œì§ êµ¬í˜„
   48 |      */
   49 |     protected abstract void doFilterInternal(HttpServletRequest request, HttpServletResponse response, 
   50 |                                            FilterChain chain) throws IOException, ServletException;
   51 |     
   52 |     /**
   53 |      * í•„í„° ì˜ˆì™¸ ì²˜ë¦¬ ë©”ì„œë“œ
   54 |      */
   55 |     protected void handleFilterException(HttpServletRequest request, HttpServletResponse response, Exception e) 
   56 |             throws IOException, ServletException {
   57 |         // ê¸°ë³¸ êµ¬í˜„ì—ì„œëŠ” ì˜ˆì™¸ë¥¼ ì „íŒŒ
   58 |         // í•„ìš”ì‹œ í•˜ìœ„ í´ë˜ìŠ¤ì—ì„œ ì¬ì •ì˜
   59 |         if (e instanceof IOException) {
   60 |             throw (IOException) e;
   61 |         } else if (e instanceof ServletException) {
   62 |             throw (ServletException) e;
   63 |         } else {
   64 |             throw new ServletException("í•„í„° ì²˜ë¦¬ ì¤‘ ì˜¤ë¥˜ ë°œìƒ", e);
   65 |         }
   66 |     }
   67 |     
   68 |     @Override
   69 |     public int getOrder() {
   70 |         return securityFilterOrder.getOrder();
   71 |     }
   72 |     
   73 |     /**
   74 |      * í•„í„° ì ìš© ì—¬ë¶€ ê²°ì • ë©”ì„œë“œ
   75 |      * @param request HTTP ìš”ì²­
   76 |      * @return í•„í„° ì ìš© ì—¬ë¶€
   77 |      */
   78 |     protected abstract boolean shouldSkipFilter(HttpServletRequest request);
   79 | }

#--------------------------------------------------------------------------------


# File: auth-server-refactoring/src/main/java/com/authentication/auth/domain/AuthProvider.java
#=============================================================================

    1 | package com.authentication.auth.domain;
    2 | 
    3 | import jakarta.persistence.*;
    4 | import lombok.AllArgsConstructor;
    5 | import lombok.Builder;
    6 | import lombok.Data;
    7 | import lombok.NoArgsConstructor;
    8 | 
    9 | import java.util.ArrayList;
   10 | import java.util.List;
   11 | 
   12 | @Entity
   13 | @Table(name = "Auth_Provider")
   14 | @Data
   15 | @NoArgsConstructor
   16 | @AllArgsConstructor
   17 | @Builder
   18 | public class AuthProvider {
   19 |     @Id
   20 |     @GeneratedValue(strategy = GenerationType.IDENTITY)
   21 |     private Integer id;
   22 |     
   23 |     @Column(name = "provider_name", nullable = false, length = 50)
   24 |     private String providerName;
   25 |     
   26 |     private String description;
   27 |     
   28 |     @Column(name = "is_active")
   29 |     private Boolean isActive = true;
   30 |     
   31 |     @OneToMany(mappedBy = "authProvider", cascade = CascadeType.ALL)
   32 |     private List<UserAuthentication> userAuthentications = new ArrayList<>();
   33 |     
   34 |     /**
   35 |      * ì¸ì¦ ì œê³µì ìœ í˜•ì„ ë‚˜íƒ€ë‚´ëŠ” ì—´ê±°í˜•
   36 |      */
   37 |     public enum ProviderType {
   38 |         SERVER("server", "ë‚´ë¶€ ì„œë²„ ì¸ì¦"),
   39 |         GOOGLE("google", "êµ¬ê¸€ OAuth2"),
   40 |         KAKAO("kakao", "ì¹´ì¹´ì˜¤ OAuth2"),
   41 |         NAVER("naver", "ë„¤ì´ë²„ OAuth2"),
   42 |         FACEBOOK("facebook", "í˜ì´ìŠ¤ë¶ OAuth2"),
   43 |         GITHUB("github", "ê¹ƒí—ˆë¸Œ OAuth2");
   44 |         
   45 |         private final String code;
   46 |         private final String description;
   47 |         
   48 |         ProviderType(String code, String description) {
   49 |             this.code = code;
   50 |             this.description = description;
   51 |         }
   52 |         
   53 |         public String getCode() {
   54 |             return code;
   55 |         }
   56 |         
   57 |         public String getDescription() {
   58 |             return description;
   59 |         }
   60 |         
   61 |         public static ProviderType fromCode(String code) {
   62 |             for (ProviderType type : values()) {
   63 |                 if (type.code.equals(code)) {
   64 |                     return type;
   65 |                 }
   66 |             }
   67 |             return SERVER; // ê¸°ë³¸ê°’
   68 |         }
   69 |     }
   70 | }

#--------------------------------------------------------------------------------


# File: auth-server-refactoring/src/main/java/com/authentication/auth/domain/User.java
#=============================================================================

    1 | package com.authentication.auth.domain;
    2 | 
    3 | import jakarta.persistence.*;
    4 | import lombok.AllArgsConstructor;
    5 | import lombok.Builder;
    6 | import lombok.Data;
    7 | import lombok.NoArgsConstructor;
    8 | import java.time.LocalDateTime;
    9 | import java.util.ArrayList;
   10 | import java.util.List;
   11 | 
   12 | @Entity
   13 | @Table(name = "Users")
   14 | @Data
   15 | @NoArgsConstructor
   16 | @AllArgsConstructor
   17 | @Builder
   18 | public class User {
   19 |     @Id
   20 |     @GeneratedValue(strategy = GenerationType.IDENTITY)
   21 |     private Long id;
   22 | 
   23 |     @Column(nullable = false)
   24 |     private String password;
   25 | 
   26 |     @Column(name = "created_at")
   27 |     private LocalDateTime createdAt;
   28 | 
   29 |     @Column(name = "updated_at")
   30 |     private LocalDateTime updatedAt;
   31 | 
   32 |     @Column(name = "user_name", nullable = false, length = 30)
   33 |     private String userName;
   34 | 
   35 |     @Enumerated(EnumType.STRING)
   36 |     @Column(name = "user_role", nullable = false)
   37 |     private UserRole userRole = UserRole.USER;
   38 | 
   39 |     @Column(name = "is_premium")
   40 |     private Boolean isPremium = false;
   41 | 
   42 |     @Column(name = "last_login")
   43 |     private LocalDateTime lastLogin;
   44 | 
   45 |     @Enumerated(EnumType.STRING)
   46 |     @Column(name = "is_active", nullable = false)
   47 |     private UserStatus isActive = UserStatus.WAITING;
   48 | 
   49 |     @OneToMany(mappedBy = "user")
   50 |     private List<Diary> diaries = new ArrayList<>();
   51 | 
   52 |     @OneToMany(mappedBy = "user", cascade = CascadeType.ALL, orphanRemoval = true)
   53 |     private List<UserAuthentication> authentications = new ArrayList<>();
   54 | 
   55 |     @OneToMany(mappedBy = "user", cascade = CascadeType.ALL, orphanRemoval = true)
   56 |     private List<UserCustomSetting> customSettings = new ArrayList<>();
   57 | 
   58 |     @PrePersist
   59 |     protected void onCreate() {
   60 |         createdAt = LocalDateTime.now();
   61 |         updatedAt = LocalDateTime.now();
   62 |     }
   63 | 
   64 |     @PreUpdate
   65 |     protected void onUpdate() {
   66 |         updatedAt = LocalDateTime.now();
   67 |     }
   68 | 
   69 |     /**
   70 |      * ì‚¬ìš©ì ì—­í• ì„ ë‚˜íƒ€ë‚´ëŠ” ì—´ê±°í˜•
   71 |      */
   72 |     public enum UserRole {
   73 |         USER("ì¼ë°˜ ì‚¬ìš©ì"),
   74 |         ADMIN("ê´€ë¦¬ì");
   75 |         
   76 |         private final String description;
   77 |         
   78 |         UserRole(String description) {
   79 |             this.description = description;
   80 |         }
   81 |         
   82 |         public String getDescription() {
   83 |             return description;
   84 |         }
   85 |     }
   86 | 
   87 |     /**
   88 |      * ì‚¬ìš©ì ìƒíƒœë¥¼ ë‚˜íƒ€ë‚´ëŠ” ì—´ê±°í˜•
   89 |      */
   90 |     public enum UserStatus {
   91 |         ACTIVE("active", "í™œì„±í™”ëœ ê³„ì •"),
   92 |         WAITING("waiting", "ì´ë©”ì¼ ì¸ì¦ ëŒ€ê¸° ì¤‘"),
   93 |         BLOCKED("blocked", "ì°¨ë‹¨ëœ ê³„ì •"),
   94 |         SUSPEND("suspend", "ì¼ì‹œ ì •ì§€ëœ ê³„ì •"),
   95 |         DELETE("delete", "ì‚­ì œëœ ê³„ì •");
   96 |         
   97 |         private final String value;
   98 |         private final String description;
   99 |         
  100 |         UserStatus(String value, String description) {
  101 |             this.value = value;
  102 |             this.description = description;
  103 |         }
  104 |         
  105 |         public String getValue() {
  106 |             return value;
  107 |         }
  108 |         
  109 |         public String getDescription() {
  110 |             return description;
  111 |         }
  112 |         
  113 |         @Override
  114 |         public String toString() {
  115 |             return value;
  116 |         }
  117 |     }
  118 | }

#--------------------------------------------------------------------------------


# File: auth-server-refactoring/src/main/java/com/authentication/auth/domain/UserAuthentication.java
#=============================================================================

    1 | package com.authentication.auth.domain;
    2 | 
    3 | import jakarta.persistence.*;
    4 | import lombok.AllArgsConstructor;
    5 | import lombok.Builder;
    6 | import lombok.Data;
    7 | import lombok.NoArgsConstructor;
    8 | 
    9 | import java.io.Serializable;
   10 | import java.time.LocalDateTime;
   11 | 
   12 | @Entity
   13 | @Table(name = "User_Authentication", uniqueConstraints = {
   14 |     @UniqueConstraint(columnNames = {"auth_provider_id", "social_id"})
   15 | })
   16 | @Data
   17 | @NoArgsConstructor
   18 | @AllArgsConstructor
   19 | @Builder
   20 | public class UserAuthentication {
   21 |     @EmbeddedId
   22 |     private UserAuthenticationId id;
   23 |     
   24 |     @ManyToOne(fetch = FetchType.LAZY)
   25 |     @MapsId("userId")
   26 |     @JoinColumn(name = "user_id")
   27 |     private User user;
   28 |     
   29 |     @ManyToOne(fetch = FetchType.LAZY)
   30 |     @MapsId("authProviderId")
   31 |     @JoinColumn(name = "auth_provider_id")
   32 |     private AuthProvider authProvider;
   33 |     
   34 |     @Column(name = "social_id", nullable = false)
   35 |     private String socialId;
   36 |     
   37 |     private String email;
   38 |     
   39 |     @Column(name = "created_at")
   40 |     private LocalDateTime createdAt;
   41 |     
   42 |     @Column(name = "updated_at")
   43 |     private LocalDateTime updatedAt;
   44 |     
   45 |     @PrePersist
   46 |     protected void onCreate() {
   47 |         createdAt = LocalDateTime.now();
   48 |         updatedAt = LocalDateTime.now();
   49 |     }
   50 | 
   51 |     @PreUpdate
   52 |     protected void onUpdate() {
   53 |         updatedAt = LocalDateTime.now();
   54 |     }
   55 | }
   56 | 
   57 | @Embeddable
   58 | @Data
   59 | @NoArgsConstructor
   60 | @AllArgsConstructor
   61 | class UserAuthenticationId implements Serializable {
   62 |     @Column(name = "user_id")
   63 |     private Long userId;
   64 |     
   65 |     @Column(name = "auth_provider_id")
   66 |     private Integer authProviderId;
   67 | }

#--------------------------------------------------------------------------------


# File: auth-server-refactoring/src/main/java/com/authentication/auth/dto/response/ApiResponse.java
#=============================================================================

    1 | package com.authentication.auth.dto.response;
    2 | 
    3 | import com.authentication.auth.constants.ErrorType;
    4 | import org.springframework.http.HttpStatus;
    5 | import org.springframework.http.ResponseEntity;
    6 | 
    7 | import java.time.LocalDateTime;
    8 | import java.util.HashMap;
    9 | import java.util.Map;
   10 | 
   11 | /**
   12 |  * API ì‘ë‹µ í˜•ì‹ì„ í‘œì¤€í™”í•˜ëŠ” ë ˆì½”ë“œ
   13 |  * @param status ìƒíƒœ (success/error)
   14 |  * @param message ë©”ì‹œì§€
   15 |  * @param data ì‘ë‹µ ë°ì´í„°
   16 |  * @param timestamp íƒ€ì„ìŠ¤íƒ¬í”„
   17 |  */
   18 | public record ApiResponse<T>(
   19 |     String status,
   20 |     String message,
   21 |     T data,
   22 |     LocalDateTime timestamp
   23 | ) {
   24 |     /**
   25 |      * ì„±ê³µ ì‘ë‹µ ìƒì„±
   26 |      * @param data ì‘ë‹µ ë°ì´í„°
   27 |      * @param message ë©”ì‹œì§€
   28 |      * @return API ì‘ë‹µ
   29 |      */
   30 |     public static <T> ApiResponse<T> success(T data, String message) {
   31 |         return new ApiResponse<>("success", message, data, LocalDateTime.now());
   32 |     }
   33 |     
   34 |     /**
   35 |      * ì„±ê³µ ì‘ë‹µ ìƒì„± (ê¸°ë³¸ ë©”ì‹œì§€)
   36 |      * @param data ì‘ë‹µ ë°ì´í„°
   37 |      * @return API ì‘ë‹µ
   38 |      */
   39 |     public static <T> ApiResponse<T> success(T data) {
   40 |         return success(data, "ìš”ì²­ì´ ì„±ê³µì ìœ¼ë¡œ ì²˜ë¦¬ë˜ì—ˆìŠµë‹ˆë‹¤");
   41 |     }
   42 |     
   43 |     /**
   44 |      * ì˜¤ë¥˜ ì‘ë‹µ ìƒì„±
   45 |      * @param errorType ì˜¤ë¥˜ ìœ í˜•
   46 |      * @param details ì¶”ê°€ ì„¸ë¶€ ì •ë³´
   47 |      * @return API ì‘ë‹µ
   48 |      */
   49 |     public static ApiResponse<Map<String, Object>> error(ErrorType errorType, Map<String, Object> details) {
   50 |         Map<String, Object> errorData = new HashMap<>();
   51 |         errorData.put("code", errorType.name());
   52 |         errorData.put("title", errorType.getTitle());
   53 |         if (details != null) {
   54 |             errorData.put("details", details);
   55 |         }
   56 |         
   57 |         return new ApiResponse<>("error", errorType.getMessage(), errorData, LocalDateTime.now());
   58 |     }
   59 |     
   60 |     /**
   61 |      * ì˜¤ë¥˜ ì‘ë‹µ ìƒì„± (ì„¸ë¶€ ì •ë³´ ì—†ìŒ)
   62 |      * @param errorType ì˜¤ë¥˜ ìœ í˜•
   63 |      * @return API ì‘ë‹µ
   64 |      */
   65 |     public static ApiResponse<Map<String, Object>> error(ErrorType errorType) {
   66 |         return error(errorType, null);
   67 |     }
   68 |     
   69 |     /**
   70 |      * ResponseEntityë¡œ ë³€í™˜
   71 |      * @param httpStatus HTTP ìƒíƒœ
   72 |      * @return ResponseEntity
   73 |      */
   74 |     public ResponseEntity<ApiResponse<T>> toResponseEntity(HttpStatus httpStatus) {
   75 |         return ResponseEntity.status(httpStatus).body(this);
   76 |     }
   77 |     
   78 |     /**
   79 |      * ì„±ê³µ ì‘ë‹µì„ ResponseEntityë¡œ ë³€í™˜ (HTTP 200)
   80 |      * @return ResponseEntity
   81 |      */
   82 |     public ResponseEntity<ApiResponse<T>> toSuccessResponseEntity() {
   83 |         return toResponseEntity(HttpStatus.OK);
   84 |     }
   85 |     
   86 |     /**
   87 |      * ì˜¤ë¥˜ ì‘ë‹µì„ ResponseEntityë¡œ ë³€í™˜
   88 |      * @param errorType ì˜¤ë¥˜ ìœ í˜•
   89 |      * @return ResponseEntity
   90 |      */
   91 |     public static ResponseEntity<ApiResponse<Map<String, Object>>> toErrorResponseEntity(ErrorType errorType) {
   92 |         return error(errorType).toResponseEntity(errorType.getStatus());
   93 |     }
   94 | }

#--------------------------------------------------------------------------------


# File: auth-server-refactoring/src/main/java/com/authentication/auth/dto/users/UserProfileResponse.java
#=============================================================================

    1 | package com.authentication.auth.dto.users;
    2 | 
    3 | import com.authentication.auth.domain.User;
    4 | import com.fasterxml.jackson.annotation.JsonProperty;
    5 | 
    6 | import java.time.LocalDateTime;
    7 | import java.util.Date;
    8 | 
    9 | /**
   10 |  * ì‚¬ìš©ì í”„ë¡œí•„ ì‘ë‹µ ì •ë³´ë¥¼ ë‹´ëŠ” ë¶ˆë³€ ë ˆì½”ë“œ
   11 |  */
   12 | public record UserProfileResponse(
   13 |     String userId,
   14 |     String userName,
   15 |     String nickname,
   16 |     String email,
   17 |     String phone,
   18 |     String role,
   19 |     Date birthDate,
   20 |     String gender,
   21 |     @JsonProperty("isPrivate") boolean isPrivate,
   22 |     String profile,
   23 |     LocalDateTime createdAt,
   24 |     LocalDateTime lastLogin
   25 | ) {
   26 |     /**
   27 |      * ì‚¬ìš©ì ì—”í‹°í‹°ì—ì„œ ì‘ë‹µ ê°ì²´ ìƒì„±
   28 |      */
   29 |     public static UserProfileResponse fromEntity(User user) {
   30 |         return new UserProfileResponse(
   31 |             user.getId().toString(),
   32 |             user.getUserName(),
   33 |             user.getUserName(), // nickname í•„ë“œê°€ ì—†ì–´ì„œ userNameìœ¼ë¡œ ëŒ€ì²´
   34 |             "", // email í•„ë“œê°€ ì—†ì–´ì„œ ë¹ˆ ë¬¸ìì—´ë¡œ ëŒ€ì²´
   35 |             "", // phone í•„ë“œê°€ ì—†ì–´ì„œ ë¹ˆ ë¬¸ìì—´ë¡œ ëŒ€ì²´
   36 |             user.getUserRole().name(),
   37 |             null, // birthDate í•„ë“œê°€ ì—†ì–´ì„œ nullë¡œ ëŒ€ì²´
   38 |             "", // gender í•„ë“œê°€ ì—†ì–´ì„œ ë¹ˆ ë¬¸ìì—´ë¡œ ëŒ€ì²´
   39 |             false, // isPrivate í•„ë“œê°€ ì—†ì–´ì„œ falseë¡œ ëŒ€ì²´
   40 |             "", // profile í•„ë“œê°€ ì—†ì–´ì„œ ë¹ˆ ë¬¸ìì—´ë¡œ ëŒ€ì²´
   41 |             user.getCreatedAt(),
   42 |             user.getLastLogin()
   43 |         );
   44 |     }
   45 | }

#--------------------------------------------------------------------------------


# File: auth-server-refactoring/src/main/java/com/authentication/auth/dto/users/LoginRequest.java
#=============================================================================

    1 | package com.authentication.auth.dto.users;
    2 | 
    3 | import jakarta.validation.constraints.NotBlank;
    4 | 
    5 | /**
    6 |  * ë¡œê·¸ì¸ ìš”ì²­ ì •ë³´ë¥¼ ë‹´ëŠ” ë¶ˆë³€ ë ˆì½”ë“œ
    7 |  */
    8 | public record LoginRequest(
    9 |     @NotBlank(message = "ì‚¬ìš©ì IDëŠ” í•„ìˆ˜ì…ë‹ˆë‹¤")
   10 |     String userId,
   11 |     
   12 |     @NotBlank(message = "ë¹„ë°€ë²ˆí˜¸ëŠ” í•„ìˆ˜ì…ë‹ˆë‹¤")
   13 |     String password
   14 | ) {
   15 |     /**
   16 |      * ìœ íš¨ì„± ê²€ì‚¬
   17 |      */
   18 |     public boolean isValid() {
   19 |         return userId != null && !userId.isBlank() &&
   20 |                password != null && !password.isBlank();
   21 |     }
   22 | }

#--------------------------------------------------------------------------------


# File: auth-server-refactoring/src/main/java/com/authentication/auth/dto/users/JoinRequest.java
#=============================================================================

    1 | package com.authentication.auth.dto.users;
    2 | 
    3 | import com.authentication.auth.domain.User;
    4 | import com.fasterxml.jackson.annotation.JsonProperty;
    5 | import jakarta.validation.constraints.Email;
    6 | import jakarta.validation.constraints.NotBlank;
    7 | import jakarta.validation.constraints.Pattern;
    8 | import jakarta.validation.constraints.Size;
    9 | 
   10 | import java.util.Date;
   11 | 
   12 | /**
   13 |  * íšŒì› ê°€ì… ìš”ì²­ ì •ë³´ë¥¼ ë‹´ëŠ” ë¶ˆë³€ ë ˆì½”ë“œ
   14 |  */
   15 | public record JoinRequest(
   16 |     @NotBlank(message = "ì‚¬ìš©ì IDëŠ” í•„ìˆ˜ì…ë‹ˆë‹¤") 
   17 |     @Size(min = 4, max = 20, message = "ì‚¬ìš©ì IDëŠ” 4~20ì ì‚¬ì´ì—¬ì•¼ í•©ë‹ˆë‹¤")
   18 |     String userId,
   19 |     
   20 |     @NotBlank(message = "ë¹„ë°€ë²ˆí˜¸ëŠ” í•„ìˆ˜ì…ë‹ˆë‹¤")
   21 |     @Size(min = 8, message = "ë¹„ë°€ë²ˆí˜¸ëŠ” ìµœì†Œ 8ì ì´ìƒì´ì–´ì•¼ í•©ë‹ˆë‹¤")
   22 |     String userPw,
   23 |     
   24 |     @NotBlank(message = "ì´ë¦„ì€ í•„ìˆ˜ì…ë‹ˆë‹¤")
   25 |     String userName,
   26 |     
   27 |     @NotBlank(message = "ë‹‰ë„¤ì„ì€ í•„ìˆ˜ì…ë‹ˆë‹¤")
   28 |     @Size(min = 2, max = 20, message = "ë‹‰ë„¤ì„ì€ 2~20ì ì‚¬ì´ì—¬ì•¼ í•©ë‹ˆë‹¤")
   29 |     String nickname,
   30 |     
   31 |     @NotBlank(message = "ì „í™”ë²ˆí˜¸ëŠ” í•„ìˆ˜ì…ë‹ˆë‹¤")
   32 |     @Pattern(regexp = "^\\d{3}-\\d{3,4}-\\d{4}$", message = "ì „í™”ë²ˆí˜¸ í˜•ì‹ì´ ì˜¬ë°”ë¥´ì§€ ì•ŠìŠµë‹ˆë‹¤")
   33 |     String phone,
   34 |     
   35 |     @Email(message = "ì´ë©”ì¼ í˜•ì‹ì´ ì˜¬ë°”ë¥´ì§€ ì•ŠìŠµë‹ˆë‹¤")
   36 |     String email,
   37 |     
   38 |     User.UserRole role,
   39 |     
   40 |     Date birthDate,
   41 |     
   42 |     @NotBlank(message = "ì„±ë³„ì€ í•„ìˆ˜ì…ë‹ˆë‹¤")
   43 |     String gender,
   44 |     
   45 |     @JsonProperty("isPrivate") 
   46 |     boolean isPrivate,
   47 |     
   48 |     String profile,
   49 |     
   50 |     @NotBlank(message = "ì¸ì¦ ì½”ë“œëŠ” í•„ìˆ˜ì…ë‹ˆë‹¤")
   51 |     String code
   52 | ) {
   53 |     /**
   54 |      * ê¸°ë³¸ í”„ë¡œí•„ ì´ë¯¸ì§€ë¥¼ ì‚¬ìš©í•˜ëŠ” íŒ©í† ë¦¬ ë©”ì„œë“œ
   55 |      */
   56 |     public static JoinRequest of(
   57 |             String userId, String userPw, String userName, String nickname, 
   58 |             String phone, String email, User.UserRole role, Date birthDate, 
   59 |             String gender, boolean isPrivate, String code) {
   60 |         return new JoinRequest(
   61 |                 userId, userPw, userName, nickname, phone, email, role, 
   62 |                 birthDate, gender, isPrivate, "https://zrr.kr/iPHf", code);
   63 |     }
   64 | 
   65 |     /**
   66 |      * ì‚¬ìš©ì ì—”í‹°í‹°ë¡œ ë³€í™˜
   67 |      */
   68 |     public User toEntity(String encodedPassword) {
   69 |         return User.builder()
   70 |                 .password(encodedPassword)
   71 |                 .userName(this.userName)
   72 |                 .userRole(this.role != null ? this.role : User.UserRole.USER)
   73 |                 .isPremium(false)
   74 |                 .isActive(User.UserStatus.WAITING)
   75 |                 .build();
   76 |     }
   77 |     
   78 |     /**
   79 |      * ìœ íš¨ì„± ê²€ì‚¬
   80 |      */
   81 |     public boolean isValid() {
   82 |         return userId != null && !userId.isBlank() &&
   83 |                userPw != null && !userPw.isBlank() &&
   84 |                userName != null && !userName.isBlank() &&
   85 |                nickname != null && !nickname.isBlank() &&
   86 |                phone != null && !phone.isBlank() &&
   87 |                code != null && !code.isBlank();
   88 |     }
   89 | }

#--------------------------------------------------------------------------------


# File: auth-server-refactoring/src/main/java/com/authentication/auth/dto/email/EmailRequest.java
#=============================================================================

    1 | package com.authentication.auth.dto.email;
    2 | 
    3 | import jakarta.validation.constraints.Email;
    4 | import jakarta.validation.constraints.NotBlank;
    5 | 
    6 | /**
    7 |  * ì´ë©”ì¼ ìš”ì²­ ì •ë³´ë¥¼ ë‹´ëŠ” ë¶ˆë³€ ë ˆì½”ë“œ
    8 |  */
    9 | public record EmailRequest(
   10 |     @NotBlank(message = "ì´ë©”ì¼ì€ í•„ìˆ˜ì…ë‹ˆë‹¤")
   11 |     @Email(message = "ì´ë©”ì¼ í˜•ì‹ì´ ì˜¬ë°”ë¥´ì§€ ì•ŠìŠµë‹ˆë‹¤")
   12 |     String email
   13 | ) {
   14 |     /**
   15 |      * ìœ íš¨ì„± ê²€ì‚¬
   16 |      */
   17 |     public boolean isValid() {
   18 |         return email != null && !email.isBlank();
   19 |     }
   20 | }

#--------------------------------------------------------------------------------


# File: auth-server-refactoring/src/main/java/com/authentication/auth/dto/email/EmailCheckRequest.java
#=============================================================================

    1 | package com.authentication.auth.dto.email;
    2 | 
    3 | import jakarta.validation.constraints.Email;
    4 | import jakarta.validation.constraints.NotBlank;
    5 | 
    6 | /**
    7 |  * ì´ë©”ì¼ ì¸ì¦ ì½”ë“œ í™•ì¸ ìš”ì²­ ì •ë³´ë¥¼ ë‹´ëŠ” ë¶ˆë³€ ë ˆì½”ë“œ
    8 |  */
    9 | public record EmailCheckRequest(
   10 |     @NotBlank(message = "ì´ë©”ì¼ì€ í•„ìˆ˜ì…ë‹ˆë‹¤")
   11 |     @Email(message = "ì´ë©”ì¼ í˜•ì‹ì´ ì˜¬ë°”ë¥´ì§€ ì•ŠìŠµë‹ˆë‹¤")
   12 |     String email,
   13 |     
   14 |     @NotBlank(message = "ì¸ì¦ ì½”ë“œëŠ” í•„ìˆ˜ì…ë‹ˆë‹¤")
   15 |     String code
   16 | ) {
   17 |     /**
   18 |      * ìœ íš¨ì„± ê²€ì‚¬
   19 |      */
   20 |     public boolean isValid() {
   21 |         return email != null && !email.isBlank() &&
   22 |                code != null && !code.isBlank();
   23 |     }
   24 | }

#--------------------------------------------------------------------------------


# File: auth-server-refactoring/src/main/java/com/authentication/auth/dto/email/CustomEmailRequest.java
#=============================================================================

    1 | package com.authentication.auth.dto.email;
    2 | 
    3 | import jakarta.validation.constraints.Email;
    4 | import jakarta.validation.constraints.NotBlank;
    5 | 
    6 | /**
    7 |  * ì»¤ìŠ¤í…€ ì´ë©”ì¼ ìš”ì²­ ì •ë³´ë¥¼ ë‹´ëŠ” ë¶ˆë³€ ë ˆì½”ë“œ
    8 |  */
    9 | public record CustomEmailRequest(
   10 |     @NotBlank(message = "ì´ë©”ì¼ì€ í•„ìˆ˜ì…ë‹ˆë‹¤")
   11 |     @Email(message = "ì´ë©”ì¼ í˜•ì‹ì´ ì˜¬ë°”ë¥´ì§€ ì•ŠìŠµë‹ˆë‹¤")
   12 |     String email,
   13 |     
   14 |     @NotBlank(message = "ì œëª©ì€ í•„ìˆ˜ì…ë‹ˆë‹¤")
   15 |     String title,
   16 |     
   17 |     @NotBlank(message = "ë‚´ìš©ì€ í•„ìˆ˜ì…ë‹ˆë‹¤")
   18 |     String content
   19 | ) {
   20 |     /**
   21 |      * ìœ íš¨ì„± ê²€ì‚¬
   22 |      */
   23 |     public boolean isValid() {
   24 |         return email != null && !email.isBlank() &&
   25 |                title != null && !title.isBlank() &&
   26 |                content != null && !content.isBlank();
   27 |     }
   28 | }

#--------------------------------------------------------------------------------


# File: auth-server-refactoring/src/main/java/com/authentication/auth/dto/token/TokenDto.java
#=============================================================================

    1 | package com.authentication.auth.dto.token;
    2 | 
    3 | /**
    4 |  * í† í° ì •ë³´ë¥¼ ë‹´ëŠ” ë¶ˆë³€ ë ˆì½”ë“œ
    5 |  * @param accessToken ì•¡ì„¸ìŠ¤ í† í°
    6 |  * @param refreshToken ë¦¬í”„ë ˆì‹œ í† í°
    7 |  * @param expiresIn ì•¡ì„¸ìŠ¤ í† í° ë§Œë£Œ ì‹œê°„(ì´ˆ)
    8 |  * @param tokenType í† í° íƒ€ì…
    9 |  */
   10 | public record TokenDto(
   11 |     String accessToken,
   12 |     String refreshToken,
   13 |     long expiresIn,
   14 |     String tokenType
   15 | ) {
   16 |     /**
   17 |      * ê¸°ë³¸ í† í° ìƒì„± íŒ©í† ë¦¬ ë©”ì„œë“œ
   18 |      */
   19 |     public static TokenDto of(String accessToken, String refreshToken, long expiresIn) {
   20 |         return new TokenDto(accessToken, refreshToken, expiresIn, "Bearer");
   21 |     }
   22 |     
   23 |     /**
   24 |      * ì•¡ì„¸ìŠ¤ í† í°ë§Œ í¬í•¨í•˜ëŠ” DTO ìƒì„±
   25 |      */
   26 |     public static TokenDto accessTokenOnly(String accessToken, long expiresIn) {
   27 |         return new TokenDto(accessToken, null, expiresIn, "Bearer");
   28 |     }
   29 | }

#--------------------------------------------------------------------------------


# File: auth-server-refactoring/src/main/java/com/authentication/auth/dto/token/TokenRefreshRequest.java
#=============================================================================

    1 | package com.authentication.auth.dto.token;
    2 | 
    3 | /**
    4 |  * í† í° ê°±ì‹  ìš”ì²­ ì •ë³´ë¥¼ ë‹´ëŠ” ë¶ˆë³€ ë ˆì½”ë“œ
    5 |  * @param expiredToken ë§Œë£Œëœ í† í°
    6 |  * @param provider ì¸ì¦ ì œê³µì
    7 |  */
    8 | public record TokenRefreshRequest(
    9 |     String expiredToken,
   10 |     String provider
   11 | ) {
   12 |     /**
   13 |      * ìœ íš¨ì„± ê²€ì‚¬
   14 |      * @return ìœ íš¨ ì—¬ë¶€
   15 |      */
   16 |     public boolean isValid() {
   17 |         return expiredToken != null && !expiredToken.isBlank() && 
   18 |                provider != null && !provider.isBlank();
   19 |     }
   20 | }

#--------------------------------------------------------------------------------


# File: auth-server-refactoring/src/main/java/com/authentication/auth/configuration/SecurityConfig.java
#=============================================================================

    1 | package com.authentication.auth.configuration;
    2 | 
    3 | import com.authentication.auth.filter.FilterRegistry;
    4 | import lombok.RequiredArgsConstructor;
    5 | import lombok.extern.slf4j.Slf4j;
    6 | import org.springframework.context.annotation.Bean;
    7 | import org.springframework.context.annotation.Configuration;
    8 | import org.springframework.security.config.annotation.web.builders.HttpSecurity;
    9 | import org.springframework.security.config.annotation.web.configuration.EnableWebSecurity;
   10 | import org.springframework.security.config.http.SessionCreationPolicy;
   11 | import org.springframework.security.crypto.bcrypt.BCryptPasswordEncoder;
   12 | import org.springframework.security.web.SecurityFilterChain;
   13 | 
   14 | /**
   15 |  * Spring Security êµ¬ì„± í´ë˜ìŠ¤
   16 |  * ë³´ì•ˆ í•„í„° ì²´ì¸ ë° ì¸ì¦/ì¸ê°€ ì„¤ì •ì„ ê´€ë¦¬
   17 |  */
   18 | @Configuration
   19 | @EnableWebSecurity
   20 | @RequiredArgsConstructor
   21 | @Slf4j
   22 | public class SecurityConfig {
   23 | 
   24 |     private final FilterRegistry filterRegistry;
   25 |     
   26 |     @Bean
   27 |     public SecurityFilterChain securityFilterChain(HttpSecurity http) throws Exception {
   28 |         log.info("ë³´ì•ˆ í•„í„° ì²´ì¸ êµ¬ì„± ì¤‘...");
   29 |         
   30 |         http
   31 |             .csrf(csrf -> csrf.disable())
   32 |             .formLogin(form -> form.disable())
   33 |             .httpBasic(basic -> basic.disable())
   34 |             .sessionManagement(session -> session.sessionCreationPolicy(SessionCreationPolicy.STATELESS))
   35 |             .authorizeHttpRequests(auth -> auth
   36 |                 .requestMatchers("/auth/**", "/login", "/signup", "/public/**").permitAll()
   37 |                 .anyRequest().authenticated()
   38 |             );
   39 |         
   40 |         // í”ŒëŸ¬ê·¸í˜• í•„í„° ë“±ë¡
   41 |         filterRegistry.configureFilters(http);
   42 |         
   43 |         return http.build();
   44 |     }
   45 |     
   46 |     @Bean
   47 |     public BCryptPasswordEncoder passwordEncoder() {
   48 |         return new BCryptPasswordEncoder();
   49 |     }
   50 | }

#--------------------------------------------------------------------------------


# File: auth-server-refactoring/src/main/java/com/authentication/auth/configuration/token/JwtUtility.java
#=============================================================================

    1 | package com.authentication.auth.configuration.token;
    2 | 
    3 | import com.authentication.auth.constants.ErrorType;
    4 | import com.authentication.auth.constants.SecurityConstants;
    5 | import com.authentication.auth.dto.token.TokenDto;
    6 | import io.jsonwebtoken.*;
    7 | import io.jsonwebtoken.security.Keys;
    8 | import jakarta.servlet.http.Cookie;
    9 | import jakarta.servlet.http.HttpServletRequest;
   10 | import jakarta.servlet.http.HttpServletResponse;
   11 | import lombok.extern.slf4j.Slf4j;
   12 | import org.springframework.beans.factory.annotation.Value;
   13 | import org.springframework.security.authentication.UsernamePasswordAuthenticationToken;
   14 | import org.springframework.security.core.Authentication;
   15 | import org.springframework.security.core.GrantedAuthority;
   16 | import org.springframework.security.core.authority.SimpleGrantedAuthority;
   17 | import org.springframework.security.core.userdetails.User;
   18 | import org.springframework.security.core.userdetails.UserDetails;
   19 | import org.springframework.stereotype.Component;
   20 | 
   21 | import java.io.IOException;
   22 | import java.io.PrintWriter;
   23 | import java.security.Key;
   24 | import java.time.Instant;
   25 | import java.util.*;
   26 | import java.util.stream.Collectors;
   27 | 
   28 | @Slf4j
   29 | @Component
   30 | public class JwtUtility {
   31 | 
   32 |     private final String domain;
   33 |     private final String cookieDomain;
   34 |     private final Key accessTokenKey;
   35 |     private final Key refreshTokenKey;
   36 |     private final long accessTokenValidity;
   37 |     private final long refreshTokenValidity;
   38 | 
   39 |     public JwtUtility(
   40 |             @Value("${site.domain}") String domain,
   41 |             @Value("${server.cookie.domain}") String cookieDomain,
   42 |             @Value("${jwt.secret-key}") String accessTokenSecret,
   43 |             @Value("${jwt.secret-key2}") String refreshTokenSecret,
   44 |             @Value("${ACCESS_TOKEN_VALIDITY}") Long accessTokenValidity,
   45 |             @Value("${REFRESH_TOKEN_VALIDITY}") Long refreshTokenValidity) {
   46 |         this.domain = domain;
   47 |         this.cookieDomain = cookieDomain;
   48 |         this.accessTokenKey = Keys.hmacShaKeyFor(accessTokenSecret.getBytes());
   49 |         this.refreshTokenKey = Keys.hmacShaKeyFor(refreshTokenSecret.getBytes());
   50 |         this.accessTokenValidity = accessTokenValidity;
   51 |         this.refreshTokenValidity = refreshTokenValidity;
   52 |     }
   53 | 
   54 |     /**
   55 |      * í† í° DTO ìƒì„±
   56 |      * @param username ì‚¬ìš©ì ì´ë¦„
   57 |      * @param authorities ê¶Œí•œ ëª©ë¡
   58 |      * @return í† í° DTO
   59 |      */
   60 |     public TokenDto createTokenDto(String username, Collection<? extends GrantedAuthority> authorities) {
   61 |         String accessToken = generateAccessToken(username, authorities);
   62 |         String refreshToken = generateRefreshToken(username);
   63 |         
   64 |         return TokenDto.of(accessToken, refreshToken, accessTokenValidity);
   65 |     }
   66 | 
   67 |     /**
   68 |      * ì•¡ì„¸ìŠ¤ í† í° ìƒì„±
   69 |      * @param username ì‚¬ìš©ì ì´ë¦„
   70 |      * @param authorities ê¶Œí•œ ëª©ë¡
   71 |      * @return ìƒì„±ëœ ì•¡ì„¸ìŠ¤ í† í°
   72 |      */
   73 |     public String generateAccessToken(String username, Collection<? extends GrantedAuthority> authorities) {
   74 |         Instant now = Instant.now();
   75 |         Instant expiry = now.plusSeconds(accessTokenValidity);
   76 |         
   77 |         Claims claims = Jwts.claims();
   78 |         claims.setSubject(username);
   79 |         claims.put("authorities", authorities.stream()
   80 |                 .map(GrantedAuthority::getAuthority)
   81 |                 .collect(Collectors.toList()));
   82 |         
   83 |         return Jwts.builder()
   84 |                 .setClaims(claims)
   85 |                 .setIssuedAt(Date.from(now))
   86 |                 .setExpiration(Date.from(expiry))
   87 |                 .signWith(accessTokenKey, SignatureAlgorithm.HS512)
   88 |                 .compact();
   89 |     }
   90 | 
   91 |     /**
   92 |      * ë¦¬í”„ë ˆì‹œ í† í° ìƒì„±
   93 |      * @param username ì‚¬ìš©ì ì´ë¦„
   94 |      * @return ìƒì„±ëœ ë¦¬í”„ë ˆì‹œ í† í°
   95 |      */
   96 |     public String generateRefreshToken(String username) {
   97 |         Instant now = Instant.now();
   98 |         Instant expiry = now.plusSeconds(refreshTokenValidity);
   99 |         
  100 |         Claims claims = Jwts.claims();
  101 |         claims.setSubject(username);
  102 |         claims.setId(UUID.randomUUID().toString());
  103 |         
  104 |         return Jwts.builder()
  105 |                 .setClaims(claims)
  106 |                 .setIssuedAt(Date.from(now))
  107 |                 .setExpiration(Date.from(expiry))
  108 |                 .signWith(refreshTokenKey, SignatureAlgorithm.HS512)
  109 |                 .compact();
  110 |     }
  111 | 
  112 |     /**
  113 |      * í† í° ìœ íš¨ì„± ê²€ì¦
  114 |      * @param token ê²€ì¦í•  í† í°
  115 |      * @return ìœ íš¨ ì—¬ë¶€
  116 |      */
  117 |     public boolean validateToken(String token) {
  118 |         try {
  119 |             Jws<Claims> claims = Jwts.parserBuilder()
  120 |                     .setSigningKey(accessTokenKey)
  121 |                     .build()
  122 |                     .parseClaimsJws(token);
  123 |             
  124 |             return !claims.getBody().getExpiration().before(new Date());
  125 |         } catch (ExpiredJwtException e) {
  126 |             log.error("JWT ë§Œë£Œ: {}", e.getMessage());
  127 |             return false;
  128 |         } catch (JwtException e) {
  129 |             log.error("JWT ì˜ˆì™¸: {}", e.getMessage());
  130 |             return false;
  131 |         } catch (Exception e) {
  132 |             log.error("JWT ì²˜ë¦¬ ì¤‘ ì¼ë°˜ ì˜ˆì™¸: {}", e.getMessage());
  133 |             return false;
  134 |         }
  135 |     }
  136 | 
  137 |     /**
  138 |      * ë¦¬í”„ë ˆì‹œ í† í° ìœ íš¨ì„± ê²€ì¦
  139 |      * @param refreshToken ê²€ì¦í•  ë¦¬í”„ë ˆì‹œ í† í°
  140 |      * @return ìœ íš¨ ì—¬ë¶€
  141 |      */
  142 |     public boolean validateRefreshToken(String refreshToken) {
  143 |         try {
  144 |             Jws<Claims> claims = Jwts.parserBuilder()
  145 |                     .setSigningKey(refreshTokenKey)
  146 |                     .build()
  147 |                     .parseClaimsJws(refreshToken);
  148 |             
  149 |             return !claims.getBody().getExpiration().before(new Date());
  150 |         } catch (JwtException | NullPointerException e) {
  151 |             log.error("ë¦¬í”„ë ˆì‹œ í† í° ê²€ì¦ ì‹¤íŒ¨: {}", e.getMessage());
  152 |             return false;
  153 |         }
  154 |     }
  155 | 
  156 |     /**
  157 |      * í† í°ì—ì„œ ì‚¬ìš©ì ì´ë¦„ ì¶”ì¶œ
  158 |      * @param token JWT í† í°
  159 |      * @return ì‚¬ìš©ì ì´ë¦„
  160 |      */
  161 |     public String getUsernameFromToken(String token) {
  162 |         Claims claims = Jwts.parserBuilder()
  163 |                 .setSigningKey(accessTokenKey)
  164 |                 .build()
  165 |                 .parseClaimsJws(token)
  166 |                 .getBody();
  167 |         
  168 |         return claims.getSubject();
  169 |     }
  170 | 
  171 |     /**
  172 |      * í† í°ì—ì„œ ê¶Œí•œ ëª©ë¡ ì¶”ì¶œ
  173 |      * @param token JWT í† í°
  174 |      * @return ê¶Œí•œ ëª©ë¡
  175 |      */
  176 |     @SuppressWarnings("unchecked")
  177 |     public Set<String> getRolesFromToken(String token) {
  178 |         Claims claims = Jwts.parserBuilder()
  179 |                 .setSigningKey(accessTokenKey)
  180 |                 .build()
  181 |                 .parseClaimsJws(token)
  182 |                 .getBody();
  183 |         
  184 |         List<String> authorities = claims.get("authorities", List.class);
  185 |         return authorities != null ? new HashSet<>(authorities) : Collections.emptySet();
  186 |     }
  187 | 
  188 |     /**
  189 |      * í† í°ì—ì„œ í´ë ˆì„ ì¶”ì¶œ
  190 |      * @param token JWT í† í°
  191 |      * @return í´ë ˆì„
  192 |      */
  193 |     public Claims getClaims(String token) {
  194 |         return Jwts.parserBuilder()
  195 |                 .setSigningKey(accessTokenKey)
  196 |                 .build()
  197 |                 .parseClaimsJws(token)
  198 |                 .getBody();
  199 |     }
  200 | 
  201 |     /**
  202 |      * ì¸ì¦ ê°ì²´ ìƒì„±
  203 |      * @param token JWT í† í°
  204 |      * @return ì¸ì¦ ê°ì²´
  205 |      */
  206 |     public Authentication getAuthentication(String token) {
  207 |         Claims claims = getClaims(token);
  208 |         
  209 |         @SuppressWarnings("unchecked")
  210 |         List<String> authorities = claims.get("authorities", List.class);
  211 |         
  212 |         List<SimpleGrantedAuthority> grantedAuthorities = authorities.stream()
  213 |                 .map(SimpleGrantedAuthority::new)
  214 |                 .collect(Collectors.toList());
  215 |         
  216 |         UserDetails principal = new User(claims.getSubject(), "", grantedAuthorities);
  217 |         
  218 |         return new UsernamePasswordAuthenticationToken(principal, token, grantedAuthorities);
  219 |     }
  220 | 
  221 |     /**
  222 |      * ì¿ í‚¤ì—ì„œ ë¦¬í”„ë ˆì‹œ í† í° í™•ì¸
  223 |      * @param request HTTP ìš”ì²­
  224 |      * @param response HTTP ì‘ë‹µ
  225 |      * @param provider ì œê³µì
  226 |      * @return ë¦¬í”„ë ˆì‹œ í† í°
  227 |      */
  228 |     public String checkCookie(HttpServletRequest request, HttpServletResponse response, String provider) throws IOException {
  229 |         Cookie[] cookies = request.getCookies();
  230 |         String refreshToken = null;
  231 | 
  232 |         if (cookies == null) {
  233 |             sendErrorResponse(response, ErrorType.AUTHENTICATION_FAILED);
  234 |             return null;
  235 |         }
  236 | 
  237 |         String cookieName = SecurityConstants.DEFAULT_PROVIDER.getValue().equals(provider) 
  238 |                 ? SecurityConstants.COOKIE_REFRESH_TOKEN.getValue()
  239 |                 : provider + "_" + SecurityConstants.COOKIE_REFRESH_TOKEN.getValue();
  240 | 
  241 |         for (Cookie cookie : cookies) {
  242 |             if (cookie.getName().equals(cookieName)) {
  243 |                 refreshToken = cookie.getValue();
  244 |                 break;
  245 |             }
  246 |         }
  247 | 
  248 |         if (refreshToken == null) {
  249 |             sendErrorResponse(response, ErrorType.AUTHENTICATION_FAILED);
  250 |         }
  251 | 
  252 |         return refreshToken;
  253 |     }
  254 | 
  255 |     /**
  256 |      * SNS ì¿ í‚¤ í™•ì¸
  257 |      * @param request HTTP ìš”ì²­
  258 |      * @param response HTTP ì‘ë‹µ
  259 |      * @return ë¦¬í”„ë ˆì‹œ í† í°
  260 |      */
  261 |     public String checkSnsCookie(HttpServletRequest request, HttpServletResponse response) throws IOException {
  262 |         String providerHeader = request.getHeader("provider");
  263 |         Cookie[] cookies = request.getCookies();
  264 |         String refreshToken = null;
  265 |         
  266 |         if (cookies != null) {
  267 |             for (Cookie cookie : cookies) {
  268 |                 if (cookie.getName().equals(providerHeader + "_" + SecurityConstants.COOKIE_REFRESH_TOKEN.getValue())) {
  269 |                     refreshToken = cookie.getValue();
  270 |                     break;
  271 |                 }
  272 |             }
  273 |         }
  274 |         
  275 |         if (refreshToken == null) {
  276 |             sendErrorResponse(response, ErrorType.AUTHENTICATION_FAILED);
  277 |         }
  278 |         
  279 |         return refreshToken;
  280 |     }
  281 | 
  282 |     /**
  283 |      * ì˜¤ë¥˜ ì‘ë‹µ ì „ì†¡
  284 |      * @param response HTTP ì‘ë‹µ
  285 |      * @param errorType ì˜¤ë¥˜ ìœ í˜•
  286 |      */
  287 |     private void sendErrorResponse(HttpServletResponse response, ErrorType errorType)
  288 |             throws IOException {
  289 |         response.setStatus(errorType.getStatusCode());
  290 |         PrintWriter writer = response.getWriter();
  291 |         response.setContentType("application/json");
  292 |         response.setCharacterEncoding("UTF-8");
  293 |         writer.print("{\"error\":\"" + errorType.getTitle() + "\",\"message\":\"" + errorType.getMessage() + "\"}");
  294 |         writer.flush();
  295 |     }
  296 | 
  297 |     /**
  298 |      * ì•¡ì„¸ìŠ¤ í† í° ë§Œë£Œ ì‹œê°„ ë°˜í™˜
  299 |      * @return ë§Œë£Œ ì‹œê°„ (ì´ˆ)
  300 |      */
  301 |     public long getAccessTokenExpiration() {
  302 |         return accessTokenValidity * 1000; // ë°€ë¦¬ì´ˆë¡œ ë³€í™˜
  303 |     }
  304 | 
  305 |     /**
  306 |      * ë¦¬í”„ë ˆì‹œ í† í° ë§Œë£Œ ì‹œê°„ ë°˜í™˜
  307 |      * @return ë§Œë£Œ ì‹œê°„ (ì´ˆ)
  308 |      */
  309 |     public long getRefreshTokenExpiration() {
  310 |         return refreshTokenValidity * 1000; // ë°€ë¦¬ì´ˆë¡œ ë³€í™˜
  311 |     }
  312 | }

#--------------------------------------------------------------------------------


# File: auth-server-refactoring/src/main/java/com/authentication/auth/service/redis/RedisService.java
#=============================================================================

    1 | package com.authentication.auth.service.redis;
    2 | 
    3 | import com.authentication.auth.constants.SecurityConstants;
    4 | import lombok.RequiredArgsConstructor;
    5 | import lombok.extern.slf4j.Slf4j;
    6 | import org.springframework.beans.factory.annotation.Value;
    7 | import org.springframework.data.redis.core.RedisTemplate;
    8 | import org.springframework.stereotype.Component;
    9 | import org.springframework.transaction.annotation.Transactional;
   10 | 
   11 | import java.util.concurrent.TimeUnit;
   12 | 
   13 | /**
   14 |  * Redis ì„œë¹„ìŠ¤
   15 |  * í† í° ë° ì¸ì¦ ê´€ë ¨ ë°ì´í„°ë¥¼ Redisì— ì €ì¥í•˜ê³  ê´€ë¦¬
   16 |  */
   17 | @Slf4j
   18 | @RequiredArgsConstructor
   19 | @Component
   20 | public class RedisService {
   21 | 
   22 |     private static final String TOKEN_PREFIX = "TOKEN:";
   23 |     private static final String REFRESH_TOKEN_PREFIX = "REFRESH:";
   24 |     private static final String ACCESS_TOKEN_PREFIX = "ACCESS:";
   25 |     private static final String EMAIL_CODE_PREFIX = "EMAIL_CODE:";
   26 |     
   27 |     @Value("${REFRESH_TOKEN_VALIDITY}")
   28 |     private long refreshExpire;
   29 | 
   30 |     @Value("${ACCESS_TOKEN_VALIDITY}")
   31 |     private long accessExpire;
   32 | 
   33 |     private final RedisTemplate<String, String> redisTemplate;
   34 | 
   35 |     /**
   36 |      * ë¦¬í”„ë ˆì‹œ í† í°ì„ Redis í‚¤ë¡œ ë³€í™˜
   37 |      * @param userId ì‚¬ìš©ì ID
   38 |      * @param provider ì œê³µì
   39 |      * @return Redis í‚¤
   40 |      */
   41 |     private String refreshTokenToRedisKey(String userId, String provider) {
   42 |         if (userId == null || provider == null || 
   43 |                 userId.isEmpty() || provider.isEmpty()) {
   44 |             throw new IllegalArgumentException("Redis í‚¤ ìƒì„±ì— í•„ìš”í•œ íŒŒë¼ë¯¸í„°ê°€ ëˆ„ë½ë˜ì—ˆìŠµë‹ˆë‹¤");
   45 |         }
   46 |         return REFRESH_TOKEN_PREFIX + provider + ":" + userId;
   47 |     }
   48 | 
   49 |     /**
   50 |      * ì•¡ì„¸ìŠ¤ í† í°ì„ Redis í‚¤ë¡œ ë³€í™˜
   51 |      * @param refreshToken ë¦¬í”„ë ˆì‹œ í† í°
   52 |      * @return Redis í‚¤
   53 |      */
   54 |     private String accessTokenToRedisKey(String refreshToken) {
   55 |         if (refreshToken == null || refreshToken.isEmpty()){
   56 |             throw new IllegalArgumentException("Redis í‚¤ ìƒì„±ì— í•„ìš”í•œ ë¦¬í”„ë ˆì‹œ í† í°ì´ ëˆ„ë½ë˜ì—ˆìŠµë‹ˆë‹¤");
   57 |         }
   58 |         return ACCESS_TOKEN_PREFIX + refreshToken.substring(0, Math.min(refreshToken.length(), 20));
   59 |     }
   60 | 
   61 |     /**
   62 |      * ì´ë©”ì¼ ì½”ë“œë¥¼ Redis í‚¤ë¡œ ë³€í™˜
   63 |      * @param email ì´ë©”ì¼
   64 |      * @return Redis í‚¤
   65 |      */
   66 |     private String emailCodeToRedisKey(String email) {
   67 |         if (email == null || email.isEmpty()) {
   68 |             throw new IllegalArgumentException("Redis í‚¤ ìƒì„±ì— í•„ìš”í•œ ì´ë©”ì¼ì´ ëˆ„ë½ë˜ì—ˆìŠµë‹ˆë‹¤");
   69 |         }
   70 |         return EMAIL_CODE_PREFIX + email;
   71 |     }
   72 | 
   73 |     /**
   74 |      * ë¦¬í”„ë ˆì‹œ í† í° ì €ì¥
   75 |      * @param userId ì‚¬ìš©ì ID
   76 |      * @param provider ì œê³µì
   77 |      * @param refreshToken ë¦¬í”„ë ˆì‹œ í† í°
   78 |      * @return ì €ì¥ ì„±ê³µ ì—¬ë¶€
   79 |      */
   80 |     @Transactional
   81 |     public boolean saveRToken(String userId, String provider, String refreshToken) {
   82 |         String redisKey = refreshTokenToRedisKey(userId, provider);
   83 |         try {
   84 |             redisTemplate.opsForValue().set(redisKey, refreshToken, refreshExpire, TimeUnit.SECONDS);
   85 |             log.info("Redisì— ë¦¬í”„ë ˆì‹œ í† í° ì €ì¥ ì„±ê³µ: ì œê³µì={}, ì‚¬ìš©ì={}", provider, userId);
   86 |             return true;
   87 |         } catch (Exception e) {
   88 |             log.error("Redisì— ë¦¬í”„ë ˆì‹œ í† í° ì €ì¥ ì‹¤íŒ¨: ì œê³µì={}, ì‚¬ìš©ì={}", provider, userId, e);
   89 |             return false;
   90 |         }
   91 |     }
   92 | 
   93 |     /**
   94 |      * ì•¡ì„¸ìŠ¤ í† í° ì €ì¥
   95 |      * @param refreshToken ë¦¬í”„ë ˆì‹œ í† í°
   96 |      * @param accessToken ì•¡ì„¸ìŠ¤ í† í°
   97 |      * @param userId ì‚¬ìš©ì ID
   98 |      * @return ì €ì¥ ì„±ê³µ ì—¬ë¶€
   99 |      */
  100 |     @Transactional
  101 |     public boolean saveAccessToken(String refreshToken, String accessToken, String userId) {
  102 |         String redisKey = accessTokenToRedisKey(refreshToken);
  103 |         try {
  104 |             redisTemplate.opsForValue().set(redisKey, accessToken, accessExpire, TimeUnit.SECONDS);
  105 |             log.info("Redisì— ì•¡ì„¸ìŠ¤ í† í° ì €ì¥ ì„±ê³µ: ì‚¬ìš©ì={}", userId);
  106 |             return true;
  107 |         } catch (Exception e) {
  108 |             log.error("Redisì— ì•¡ì„¸ìŠ¤ í† í° ì €ì¥ ì‹¤íŒ¨: ì‚¬ìš©ì={}", userId, e);
  109 |             return false;
  110 |         }
  111 |     }
  112 | 
  113 |     /**
  114 |      * ì•¡ì„¸ìŠ¤ í† í° ì¡°íšŒ
  115 |      * @param refreshToken ë¦¬í”„ë ˆì‹œ í† í°
  116 |      * @return ì•¡ì„¸ìŠ¤ í† í°
  117 |      */
  118 |     @Transactional(readOnly = true)
  119 |     public String getAccessToken(String refreshToken) {
  120 |         String redisKey = accessTokenToRedisKey(refreshToken);
  121 |         try {
  122 |             String accessToken = redisTemplate.opsForValue().get(redisKey);
  123 | 
  124 |             if (accessToken == null) {
  125 |                 log.warn("Redisì—ì„œ ì•¡ì„¸ìŠ¤ í† í°ì„ ì°¾ì„ ìˆ˜ ì—†ìŠµë‹ˆë‹¤");
  126 |                 return null;
  127 |             }
  128 | 
  129 |             return accessToken;
  130 |         } catch (Exception e) {
  131 |             log.error("Redisì—ì„œ ì•¡ì„¸ìŠ¤ í† í° ì¡°íšŒ ì‹¤íŒ¨", e);
  132 |             return null;
  133 |         }
  134 |     }
  135 | 
  136 |     /**
  137 |      * ë¦¬í”„ë ˆì‹œ í† í° ì¡´ì¬ ì—¬ë¶€ í™•ì¸
  138 |      * @param userId ì‚¬ìš©ì ID
  139 |      * @param provider ì œê³µì
  140 |      * @param refreshToken ë¦¬í”„ë ˆì‹œ í† í°
  141 |      * @return ì¡´ì¬ ì—¬ë¶€
  142 |      */
  143 |     @Transactional(readOnly = true)
  144 |     public boolean isRTokenExist(String userId, String provider, String refreshToken) {
  145 |         String redisKey = refreshTokenToRedisKey(userId, provider);
  146 |         try {
  147 |             String storedToken = redisTemplate.opsForValue().get(redisKey);
  148 |             return storedToken != null && storedToken.equals(refreshToken);
  149 |         } catch (Exception e) {
  150 |             log.error("Redisì—ì„œ ë¦¬í”„ë ˆì‹œ í† í° í™•ì¸ ì‹¤íŒ¨: ì œê³µì={}", provider, e);
  151 |             return false;
  152 |         }
  153 |     }
  154 | 
  155 |     /**
  156 |      * ë¦¬í”„ë ˆì‹œ í† í° ì‚­ì œ
  157 |      * @param userId ì‚¬ìš©ì ID
  158 |      * @param provider ì œê³µì
  159 |      * @return ì‚­ì œ ì„±ê³µ ì—¬ë¶€
  160 |      */
  161 |     @Transactional
  162 |     public boolean deleteRToken(String userId, String provider) {
  163 |         String redisKey = refreshTokenToRedisKey(userId, provider);
  164 |         try {
  165 |             Boolean removed = redisTemplate.delete(redisKey);
  166 |             if (removed != null && removed) {
  167 |                 log.info("Redisì—ì„œ ë¦¬í”„ë ˆì‹œ í† í° ì‚­ì œ ì„±ê³µ: ì œê³µì={}, ì‚¬ìš©ì={}", provider, userId);
  168 |             }
  169 |             return removed != null && removed;
  170 |         } catch (Exception e) {
  171 |             log.error("Redisì—ì„œ ë¦¬í”„ë ˆì‹œ í† í° ì‚­ì œ ì‹¤íŒ¨: ì œê³µì={}", provider, e);
  172 |             return false;
  173 |         }
  174 |     }
  175 | 
  176 |     /**
  177 |      * ë¦¬í”„ë ˆì‹œ í† í° ë³€ê²½
  178 |      * @param userId ì‚¬ìš©ì ID
  179 |      * @param provider ì œê³µì
  180 |      * @param oldRefreshToken ê¸°ì¡´ ë¦¬í”„ë ˆì‹œ í† í°
  181 |      * @param newRefreshToken ìƒˆ ë¦¬í”„ë ˆì‹œ í† í°
  182 |      * @return ë³€ê²½ ì„±ê³µ ì—¬ë¶€
  183 |      */
  184 |     @Transactional
  185 |     public boolean changeRToken(String userId, String provider, String oldRefreshToken, String newRefreshToken) {
  186 |         try {
  187 |             // ê¸°ì¡´ í† í°ì´ ìœ íš¨í•œì§€ í™•ì¸
  188 |             if (!isRTokenExist(userId, provider, oldRefreshToken)) {
  189 |                 log.warn("ê¸°ì¡´ ë¦¬í”„ë ˆì‹œ í† í°ì´ ìœ íš¨í•˜ì§€ ì•ŠìŠµë‹ˆë‹¤: ì œê³µì={}, ì‚¬ìš©ì={}", provider, userId);
  190 |                 return false;
  191 |             }
  192 |             
  193 |             // ê¸°ì¡´ í† í° ì‚­ì œ í›„ ìƒˆ í† í° ì €ì¥
  194 |             deleteRToken(userId, provider);
  195 |             saveRToken(userId, provider, newRefreshToken);
  196 |             
  197 |             log.info("ë¦¬í”„ë ˆì‹œ í† í° ë³€ê²½ ì„±ê³µ: ì œê³µì={}, ì‚¬ìš©ì={}", provider, userId);
  198 |             return true;
  199 |         } catch (Exception e) {
  200 |             log.error("ë¦¬í”„ë ˆì‹œ í† í° ë³€ê²½ ì‹¤íŒ¨: ì œê³µì={}", provider, e);
  201 |             return false;
  202 |         }
  203 |     }
  204 | 
  205 |     /**
  206 |      * ì´ë©”ì¼ ì¸ì¦ ì½”ë“œ ì €ì¥
  207 |      * @param email ì´ë©”ì¼
  208 |      * @param code ì¸ì¦ ì½”ë“œ
  209 |      * @return ì €ì¥ ì„±ê³µ ì—¬ë¶€
  210 |      */
  211 |     @Transactional
  212 |     public boolean saveEmailCode(String email, String code) {
  213 |         if (email == null || email.isEmpty() || code == null || code.isEmpty()){
  214 |             log.error("ì´ë©”ì¼ ë˜ëŠ” ì¸ì¦ ì½”ë“œê°€ ëˆ„ë½ë˜ì—ˆìŠµë‹ˆë‹¤");
  215 |             return false;
  216 |         }
  217 |         try {
  218 |             String redisKey = emailCodeToRedisKey(email);
  219 |             redisTemplate.opsForValue().set(redisKey, code, 1800, TimeUnit.SECONDS); // 30ë¶„ ìœ íš¨
  220 |             log.info("ì´ë©”ì¼ ì¸ì¦ ì½”ë“œ ì €ì¥ ì„±ê³µ: ì´ë©”ì¼={}", email);
  221 |             return true;
  222 |         } catch (Exception e) {
  223 |             log.error("ì´ë©”ì¼ ì¸ì¦ ì½”ë“œ ì €ì¥ ì‹¤íŒ¨: ì´ë©”ì¼={}", email, e);
  224 |             return false;
  225 |         }
  226 |     }
  227 | 
  228 |     /**
  229 |      * ì´ë©”ì¼ ì¸ì¦ ì½”ë“œ í™•ì¸
  230 |      * @param email ì´ë©”ì¼
  231 |      * @param code ì¸ì¦ ì½”ë“œ
  232 |      * @return ì¼ì¹˜ ì—¬ë¶€
  233 |      */
  234 |     @Transactional(readOnly = true)
  235 |     public boolean checkEmailCode(String email, String code) {
  236 |         if (email == null || email.isEmpty() || code == null || code.isEmpty()){
  237 |             log.error("ì´ë©”ì¼ ë˜ëŠ” ì¸ì¦ ì½”ë“œê°€ ëˆ„ë½ë˜ì—ˆìŠµë‹ˆë‹¤");
  238 |             return false;
  239 |         }
  240 |         try {
  241 |             String redisKey = emailCodeToRedisKey(email);
  242 |             String storedCode = redisTemplate.opsForValue().get(redisKey);
  243 |             return code.equals(storedCode);
  244 |         } catch (Exception e) {
  245 |             log.error("ì´ë©”ì¼ ì¸ì¦ ì½”ë“œ í™•ì¸ ì‹¤íŒ¨: ì´ë©”ì¼={}", email, e);
  246 |             return false;
  247 |         }
  248 |     }
  249 | 
  250 |     /**
  251 |      * ë¦¬í”„ë ˆì‹œ í† í° ì°¾ê¸°
  252 |      * @param userId ì‚¬ìš©ì ID
  253 |      * @param provider ì œê³µì
  254 |      * @param refreshToken ë¦¬í”„ë ˆì‹œ í† í°
  255 |      * @return ì¡´ì¬ ì—¬ë¶€
  256 |      */
  257 |     @Transactional(readOnly = true)
  258 |     public boolean findRToken(String userId, String provider, String refreshToken) {
  259 |         return isRTokenExist(userId, provider, refreshToken);
  260 |     }
  261 | }

#--------------------------------------------------------------------------------


# File: README.md
#=============================================================================

    1 | # Refactoring (2025-04-18) : ì‹œì‘

#--------------------------------------------------------------------------------


# File: backend/bin/main/com/authentication/auth/filter/README.md
#=============================================================================

    1 | # ì¸ì¦(Authentication) ë° ì¸ê°€(Authorization) í•„í„° ì‹œìŠ¤í…œ
    2 | 
    3 | ## ê°œìš”
    4 | ì´ ì‹œìŠ¤í…œì€ Jakarta EEì™€ Spring Securityë¥¼ ê¸°ë°˜ìœ¼ë¡œ í•˜ë©°, í”ŒëŸ¬ê·¸í˜• í•„í„° ì•„í‚¤í…ì²˜ë¥¼ ì‚¬ìš©í•˜ì—¬ ì¸ì¦ ë° ì¸ê°€ ë¡œì§ì„ ë¶„ë¦¬í•˜ê³  í™•ì¥ ê°€ëŠ¥í•˜ê²Œ êµ¬í˜„í•©ë‹ˆë‹¤.
    5 | 
    6 | ## í”ŒëŸ¬ê·¸í˜• í•„í„° ì•„í‚¤í…ì²˜
    7 | 
    8 | ### êµ¬ì¡°ì  íŠ¹ì§•
    9 | - `PluggableFilter` ì¸í„°í˜ì´ìŠ¤: ëª¨ë“  í•„í„°ì˜ ê¸°ë³¸ ì¸í„°í˜ì´ìŠ¤ë¡œ, í•„í„° ìˆœì„œì™€ ì˜ì¡´ì„±ì„ ì •ì˜
   10 | - `filterRegistry`: í•„í„° ë“±ë¡ ë° ìˆœì„œ ê´€ë¦¬ë¥¼ ìœ„í•œ í´ë˜ìŠ¤
   11 | - ìœ„ìƒ ì •ë ¬(Topological Sort): í•„í„° ê°„ ì˜ì¡´ì„±ì„ ê³ ë ¤í•œ ì‹¤í–‰ ìˆœì„œ ê²°ì •
   12 | 
   13 | ### ì£¼ìš” ì¸ì¦/ì¸ê°€ í•„í„°
   14 | 
   15 | #### 1. ì¸ì¦(Authentication) í•„í„°
   16 | - **AuthenticationFilter**: ì‚¬ìš©ì ë¡œê·¸ì¸ ë° ìê²© ì¦ëª… ê²€ì¦ ë‹´ë‹¹
   17 | - **JwtVerificationFilter**: JWT í† í° ìœ íš¨ì„± ê²€ì¦ ë‹´ë‹¹
   18 | - **SnsRequestFilter**: ì†Œì…œ ë¡œê·¸ì¸ ìš”ì²­ ì²˜ë¦¬ ë‹´ë‹¹
   19 | 
   20 | #### 2. ì¸ê°€(Authorization) í•„í„°
   21 | - **AuthorizationFilter**: ì‚¬ìš©ì ê¶Œí•œ í™•ì¸ ë° ì ‘ê·¼ ì œì–´ ë‹´ë‹¹
   22 | - **RoleBasedAccessFilter**: ì—­í•  ê¸°ë°˜ ë¦¬ì†ŒìŠ¤ ì ‘ê·¼ ì œì–´ ë‹´ë‹¹
   23 | 
   24 | ## í•„í„° ì ìš© íë¦„
   25 | 1. ìš”ì²­ ì ‘ìˆ˜
   26 | 2. ì¸ì¦(Authentication) í•„í„°ë¥¼ í†µí•œ ì‚¬ìš©ì ì‹ ì› í™•ì¸
   27 |    - JWT í† í° ê²€ì¦ ë˜ëŠ” ì†Œì…œ ë¡œê·¸ì¸ ì¸ì¦
   28 |    - ì¸ì¦ ì„±ê³µ ì‹œ `SecurityContext`ì— ì¸ì¦ ì •ë³´ ì„¤ì •
   29 | 3. ì¸ê°€(Authorization) í•„í„°ë¥¼ í†µí•œ ê¶Œí•œ í™•ì¸
   30 |    - ì‚¬ìš©ì ì—­í•  ë° ê¶Œí•œ í™•ì¸
   31 |    - ì ‘ê·¼ ê°€ëŠ¥í•œ ë¦¬ì†ŒìŠ¤ì¸ì§€ ê²€ì¦
   32 | 4. ì ì ˆí•œ ê¶Œí•œì´ ìˆëŠ” ê²½ìš° ìš”ì²­ ì²˜ë¦¬, ì—†ëŠ” ê²½ìš° ì ‘ê·¼ ê±°ë¶€
   33 | 
   34 | ## í•„í„° ë“±ë¡ ë°©ë²•
   35 | 
   36 | í•„í„°ë¥¼ ë“±ë¡í•˜ë ¤ë©´ ë‹¤ìŒ ë‹¨ê³„ë¥¼ ë”°ë¥´ì„¸ìš”:
   37 | 
   38 | 1. `PluggableFilter` ì¸í„°í˜ì´ìŠ¤ë¥¼ êµ¬í˜„í•œ í•„í„° í´ë˜ìŠ¤ ì‘ì„±
   39 | 2. í•„í„°ì˜ ìš°ì„ ìˆœìœ„(`getOrder()`) ë° ì˜ì¡´ ê´€ê³„(`getBeforeFilter()`, `getAfterFilter()`) ì •ì˜
   40 | 3. Spring Beanìœ¼ë¡œ ë“±ë¡í•˜ì—¬ ìë™ìœ¼ë¡œ `filterRegistry`ì— ë“±ë¡ë˜ë„ë¡ í•¨
   41 | 
   42 | ## í™•ì¥ ë° ì»¤ìŠ¤í„°ë§ˆì´ì§•
   43 | 
   44 | ìƒˆë¡œìš´ ì¸ì¦/ì¸ê°€ ë°©ì‹ì„ ì¶”ê°€í•˜ë ¤ë©´:
   45 | 
   46 | 1. `PluggableFilter` ì¸í„°í˜ì´ìŠ¤ë¥¼ êµ¬í˜„í•œ ìƒˆ í•„í„° í´ë˜ìŠ¤ ìƒì„±
   47 | 2. ì ì ˆí•œ ì‹¤í–‰ ìˆœì„œì™€ ì˜ì¡´ì„± ì •ì˜
   48 | 3. Spring Beanìœ¼ë¡œ ë“±ë¡
   49 | 
   50 | ## ì£¼ì˜ì‚¬í•­
   51 | - í•„í„° ê°„ ìˆœí™˜ ì˜ì¡´ì„±ì´ ì—†ë„ë¡ ì£¼ì˜í•´ì•¼ í•¨
   52 | - ì„±ëŠ¥ì„ ìœ„í•´ ë¶ˆí•„ìš”í•œ í•„í„° ì¤‘ë³µ ì ìš© ë°©ì§€
   53 | - ë³´ì•ˆì— ë¯¼ê°í•œ ê²½ë¡œëŠ” í•­ìƒ ì ì ˆí•œ ì¸ì¦/ì¸ê°€ í•„í„°ë¥¼ í†µê³¼í•˜ë„ë¡ ì„¤ì •

#--------------------------------------------------------------------------------


# File: backend/src/test/java/com/authentication/auth/validator/EntityValidationOutput.java
#=============================================================================

    1 | package com.authentication.auth.validator;
    2 | 
    3 | import java.util.List;
    4 | 
    5 | public class EntityValidationOutput {
    6 |     
    7 |     /**
    8 |      * ê²€ì¦ ê²°ê³¼ë¥¼ í…Œì´ë¸” í˜•ì‹ìœ¼ë¡œ í‘œì‹œ
    9 |      */
   10 |     public static void displayResults(List<EntitySqlValidator.ValidationResult> results) {
   11 |         // í…Œì´ë¸” í—¤ë”
   12 |         System.out.println("+------------------------+------------------------+-----------+------------------------------------+");
   13 |         System.out.println("| í•„ë“œ                    | í˜„ì¬ ê°’                | ìƒíƒœ      | ë©”ì‹œì§€                               |");
   14 |         System.out.println("+------------------------+------------------------+-----------+------------------------------------+");
   15 |         
   16 |         // ê° ê²°ê³¼ í–‰ ì¶œë ¥
   17 |         for (EntitySqlValidator.ValidationResult result : results) {
   18 |             System.out.printf("| %-22s | %-22s | %-9s | %-34s |\n", 
   19 |                     truncate(result.getFieldName(), 22),
   20 |                     truncate(result.getCurrentValue(), 22), 
   21 |                     result.getStatus().getSymbol(),
   22 |                     truncate(result.getMessage(), 34));
   23 |         }
   24 |         
   25 |         // í…Œì´ë¸” í‘¸í„°
   26 |         System.out.println("+------------------------+------------------------+-----------+------------------------------------+");
   27 |         
   28 |         // ìš”ì•½ í†µê³„
   29 |         long errorCount = results.stream()
   30 |                 .filter(r -> r.getStatus() == EntitySqlValidator.ValidationStatus.ERROR)
   31 |                 .count();
   32 |         long warningCount = results.stream()
   33 |                 .filter(r -> r.getStatus() == EntitySqlValidator.ValidationStatus.WARNING)
   34 |                 .count();
   35 |         
   36 |         System.out.println("\nìš”ì•½: " + 
   37 |                 errorCount + " ì˜¤ë¥˜, " + 
   38 |                 warningCount + " ê²½ê³ , " + 
   39 |                 (results.size() - errorCount - warningCount) + " ìœ íš¨í•œ ê²€ì‚¬");
   40 |     }
   41 |     
   42 |     private static String truncate(String value, int maxLength) {
   43 |         if (value == null) {
   44 |             return "";
   45 |         }
   46 |         return value.length() <= maxLength ? value : value.substring(0, maxLength - 3) + "...";
   47 |     }
   48 | }

#--------------------------------------------------------------------------------


# File: backend/src/test/java/com/authentication/auth/validator/EntitySqlValidator.java
#=============================================================================

    1 | package com.authentication.auth.validator;
    2 | 
    3 | import java.lang.reflect.Field;
    4 | import java.util.ArrayList;
    5 | import java.util.HashMap;
    6 | import java.util.List;
    7 | import java.util.Map;
    8 | 
    9 | import net.sf.jsqlparser.parser.CCJSqlParserUtil;
   10 | import net.sf.jsqlparser.statement.create.table.ColumnDefinition;
   11 | import net.sf.jsqlparser.statement.create.table.CreateTable;
   12 | 
   13 | /**
   14 |  * JPA ì—”í‹°í‹°ì™€ SQL ìƒì„± êµ¬ë¬¸ì„ ë¹„êµ ê²€ì¦í•˜ëŠ” ê²€ì¦ê¸°
   15 |  */
   16 | public class EntitySqlValidator {
   17 | 
   18 |     public enum ValidationStatus {
   19 |         VALID("âœ…"),
   20 |         WARNING("âš ï¸"),
   21 |         ERROR("âŒ");
   22 | 
   23 |         private final String symbol;
   24 | 
   25 |         ValidationStatus(String symbol) {
   26 |             this.symbol = symbol;
   27 |         }
   28 | 
   29 |         public String getSymbol() {
   30 |             return symbol;
   31 |         }
   32 |     }
   33 | 
   34 |     /**
   35 |      * í•„ë“œ ê²€ì¦ ê²°ê³¼
   36 |      */
   37 |     public static class ValidationResult {
   38 |         private String fieldName;
   39 |         private String currentValue;
   40 |         private ValidationStatus status;
   41 |         private String message;
   42 | 
   43 |         public ValidationResult(String fieldName, String currentValue, ValidationStatus status, String message) {
   44 |             this.fieldName = fieldName;
   45 |             this.currentValue = currentValue;
   46 |             this.status = status;
   47 |             this.message = message;
   48 |         }
   49 | 
   50 |         // Getters
   51 |         public String getFieldName() { return fieldName; }
   52 |         public String getCurrentValue() { return currentValue; }
   53 |         public ValidationStatus getStatus() { return status; }
   54 |         public String getMessage() { return message; }
   55 |     }
   56 | 
   57 |     /**
   58 |      * JPA ì—”í‹°í‹°ì™€ SQL ìƒì„± êµ¬ë¬¸ ê²€ì¦
   59 |      */
   60 |     public static List<ValidationResult> validate(Class<?> entityClass, String sqlStatement) {
   61 |         List<ValidationResult> results = new ArrayList<>();
   62 | 
   63 |         try {
   64 |             // SQL íŒŒì‹±
   65 |             Statement statement = CCJSqlParserUtil.parse(sqlStatement);
   66 |             if (!(statement instanceof CreateTable)) {
   67 |                 results.add(new ValidationResult("SQL", sqlStatement, ValidationStatus.ERROR,
   68 |                             "ìœ íš¨í•œ CREATE TABLE êµ¬ë¬¸ì´ ì•„ë‹™ë‹ˆë‹¤"));
   69 |                 return results;
   70 |             }
   71 | 
   72 |             CreateTable createTable = (CreateTable) statement;
   73 | 
   74 |             // í…Œì´ë¸” ì´ë¦„ ê²€ì¦
   75 |             validateTableName(entityClass, createTable, results);
   76 | 
   77 |             // SQLì—ì„œ ì»¬ëŸ¼ ì¶”ì¶œ
   78 |             Map<String, ColumnDefinition> sqlColumns = extractSqlColumns(createTable);
   79 | 
   80 |             // ì—”í‹°í‹° í•„ë“œ ê²€ì¦
   81 |             validateEntityFields(entityClass, sqlColumns, results);
   82 | 
   83 |             // SQLì— ìˆëŠ” ì»¬ëŸ¼ ì¤‘ ì—”í‹°í‹°ì— ì—†ëŠ” ì»¬ëŸ¼ í™•ì¸
   84 |             validateSqlColumns(entityClass, sqlColumns, results);
   85 | 
   86 |             // ê¸°ë³¸ í‚¤ ê²€ì¦
   87 |             validatePrimaryKey(entityClass, createTable, results);
   88 | 
   89 |         } catch (JSQLParserException e) {
   90 |             results.add(new ValidationResult("SQL íŒŒì‹± ì˜¤ë¥˜", e.getMessage(),
   91 |                        ValidationStatus.ERROR, "SQL êµ¬ë¬¸ íŒŒì‹±ì— ì‹¤íŒ¨í–ˆìŠµë‹ˆë‹¤"));
   92 |         }
   93 | 
   94 |         return results;
   95 |     }
   96 | 
   97 |     private static Map<String, ColumnDefinition> extractSqlColumns(CreateTable createTable) {
   98 |         Map<String, ColumnDefinition> columns = new HashMap<>();
   99 | 
  100 |         if (createTable.getColumnDefinitions() != null) {
  101 |             for (ColumnDefinition colDef : createTable.getColumnDefinitions()) {
  102 |                 columns.put(colDef.getColumnName().replaceAll("[`\"]", ""), colDef);
  103 |             }
  104 |         }
  105 | 
  106 |         return columns;
  107 |     }
  108 | 
  109 |     private static void validateTableName(Class<?> entityClass, CreateTable createTable,
  110 |                                        List<ValidationResult> results) {
  111 |         javax.persistence.Table tableAnnotation = entityClass.getAnnotation(javax.persistence.Table.class);
  112 |         String entityTableName = tableAnnotation != null && !tableAnnotation.name().isEmpty() ?
  113 |                 tableAnnotation.name() : entityClass.getSimpleName();
  114 | 
  115 |         String sqlTableName = createTable.getTable().getName().replaceAll("[`\"]", "");
  116 | 
  117 |         if (entityTableName.equals(sqlTableName)) {
  118 |             results.add(new ValidationResult("í…Œì´ë¸” ì´ë¦„", entityTableName, ValidationStatus.VALID,
  119 |                        "í…Œì´ë¸” ì´ë¦„ì´ ì¼ì¹˜í•©ë‹ˆë‹¤"));
  120 |         } else {
  121 |             results.add(new ValidationResult("í…Œì´ë¸” ì´ë¦„", entityTableName, ValidationStatus.ERROR,
  122 |                        "ì—”í‹°í‹° í…Œì´ë¸” ì´ë¦„ì´ SQL í…Œì´ë¸” ì´ë¦„ê³¼ ì¼ì¹˜í•˜ì§€ ì•ŠìŠµë‹ˆë‹¤: " + sqlTableName));
  123 |         }
  124 |     }
  125 | 
  126 |     // ì—”í‹°í‹° í•„ë“œ ê²€ì¦
  127 |     private static void validateEntityFields(Class<?> entityClass, Map<String, ColumnDefinition> sqlColumns,
  128 |                                          List<ValidationResult> results) {
  129 |         for (Field field : getAllFields(entityClass)) {
  130 |             // ì •ì , ì„ì‹œ ë° ê´€ê³„ í•„ë“œ ê±´ë„ˆë›°ê¸°
  131 |             if (java.lang.reflect.Modifier.isStatic(field.getModifiers()) ||
  132 |                 field.isAnnotationPresent(Transient.class) ||
  133 |                 isRelationshipField(field)) {
  134 |                 continue;
  135 |             }
  136 | 
  137 |             // ì—”í‹°í‹°ì—ì„œ ì»¬ëŸ¼ ì´ë¦„ ê°€ì ¸ì˜¤ê¸°
  138 |             String columnName = getColumnName(field);
  139 | 
  140 |             // SQLì— ì»¬ëŸ¼ì´ ì¡´ì¬í•˜ëŠ”ì§€ í™•ì¸
  141 |             if (!sqlColumns.containsKey(columnName)) {
  142 |                 results.add(new ValidationResult(field.getName(), "ì»¬ëŸ¼: " + columnName,
  143 |                           ValidationStatus.ERROR, "SQL ì •ì˜ì—ì„œ ì»¬ëŸ¼ì„ ì°¾ì„ ìˆ˜ ì—†ìŠµë‹ˆë‹¤"));
  144 |                 continue;
  145 |             }
  146 | 
  147 |             ColumnDefinition sqlColumn = sqlColumns.get(columnName);
  148 | 
  149 |             // ë°ì´í„° íƒ€ì… ê²€ì¦
  150 |             validateColumnType(field, sqlColumn, results);
  151 | 
  152 |             // null í—ˆìš© ì œì•½ ì¡°ê±´ ê²€ì¦
  153 |             validateNullable(field, sqlColumn, results);
  154 | 
  155 |             // ë¬¸ìì—´ ê¸¸ì´ ê²€ì¦
  156 |             validateLength(field, sqlColumn, results);
  157 | 
  158 |             // ê¸°ë³¸ê°’ ê²€ì¦
  159 |             validateDefaultValue(field, sqlColumn, results);
  160 |         }
  161 |     }
  162 | 
  163 |         private static void validateColumnType(Field field, ColumnDefinition sqlColumn,
  164 |                                        List<ValidationResult> results) {
  165 |         String javaType = field.getType().getSimpleName();
  166 |         String sqlType = sqlColumn.getColDataType().getDataType().toUpperCase();
  167 | 
  168 |         if (isTypeCompatible(field.getType(), sqlType)) {
  169 |             results.add(new ValidationResult(field.getName(), "íƒ€ì…: " + javaType,
  170 |                       ValidationStatus.VALID, "SQL íƒ€ì…ê³¼ í˜¸í™˜ë©ë‹ˆë‹¤: " + sqlType));
  171 |         } else {
  172 |             results.add(new ValidationResult(field.getName(), "íƒ€ì…: " + javaType,
  173 |                       ValidationStatus.WARNING, "SQL íƒ€ì…ê³¼ í˜¸í™˜ë˜ì§€ ì•Šì„ ìˆ˜ ìˆìŠµë‹ˆë‹¤: " + sqlType));
  174 |         }
  175 |     }
  176 | 
  177 |     private static void validateNullable(Field field, ColumnDefinition sqlColumn,
  178 |                                      List<ValidationResult> results) {
  179 |         Column columnAnnotation = field.getAnnotation(Column.class);
  180 |         boolean entityNullable = columnAnnotation == null || columnAnnotation.nullable();
  181 | 
  182 |         // @Idê°€ ìˆëŠ” í•„ë“œëŠ” nullì´ ë  ìˆ˜ ì—†ìŒ
  183 |         if (field.isAnnotationPresent(Id.class)) {
  184 |             entityNullable = false;
  185 |         }
  186 | 
  187 |         boolean sqlNullable = !hasNotNullConstraint(sqlColumn);
  188 | 
  189 |         if (entityNullable == sqlNullable) {
  190 |             results.add(new ValidationResult(field.getName(), "Null í—ˆìš©: " + entityNullable,
  191 |                       ValidationStatus.VALID, "Null í—ˆìš© ì—¬ë¶€ê°€ SQL ì •ì˜ì™€ ì¼ì¹˜í•©ë‹ˆë‹¤"));
  192 |         } else {
  193 |             results.add(new ValidationResult(field.getName(), "Null í—ˆìš©: " + entityNullable,
  194 |                       ValidationStatus.ERROR, "Null í—ˆìš© ì—¬ë¶€ê°€ SQL ì •ì˜ì™€ ì¼ì¹˜í•˜ì§€ ì•ŠìŠµë‹ˆë‹¤ (SQL: " + sqlNullable + ")"));
  195 |         }
  196 |     }
  197 | 
  198 |     private static void validateLength(Field field, ColumnDefinition sqlColumn,
  199 |                                    List<ValidationResult> results) {
  200 |         if (String.class.isAssignableFrom(field.getType())) {
  201 |             Column columnAnnotation = field.getAnnotation(Column.class);
  202 |             if (columnAnnotation != null && columnAnnotation.length() > 0) {
  203 |                 int entityLength = columnAnnotation.length();
  204 |                 Integer sqlLength = getColumnLength(sqlColumn);
  205 | 
  206 |                 if (sqlLength == null) {
  207 |                     results.add(new ValidationResult(field.getName(), "ê¸¸ì´: " + entityLength,
  208 |                               ValidationStatus.WARNING, "ì—”í‹°í‹°ëŠ” ê¸¸ì´ë¥¼ ì§€ì •í•˜ì§€ë§Œ SQL ì»¬ëŸ¼ì€ ê¸¸ì´ë¥¼ ì§€ì •í•˜ì§€ ì•ŠìŠµë‹ˆë‹¤"));
  209 |                 } else if (entityLength == sqlLength) {
  210 |                     results.add(new ValidationResult(field.getName(), "ê¸¸ì´: " + entityLength,
  211 |                               ValidationStatus.VALID, "ê¸¸ì´ê°€ SQL ì •ì˜ì™€ ì¼ì¹˜í•©ë‹ˆë‹¤"));
  212 |                 } else {
  213 |                     results.add(new ValidationResult(field.getName(), "ê¸¸ì´: " + entityLength,
  214 |                               ValidationStatus.ERROR, "ê¸¸ì´ê°€ SQL ì •ì˜ì™€ ì¼ì¹˜í•˜ì§€ ì•ŠìŠµë‹ˆë‹¤ (SQL: " + sqlLength + ")"));
  215 |                 }
  216 |             }
  217 |         }
  218 |     }
  219 | 
  220 | 
  221 |     private static boolean isTypeCompatible(Class<?> javaType, String sqlType) {
  222 |         sqlType = sqlType.toUpperCase();
  223 | 
  224 |         if (String.class.isAssignableFrom(javaType)) {
  225 |             return sqlType.contains("VARCHAR") || sqlType.contains("TEXT") || sqlType.contains("CHAR");
  226 |         } else if (Integer.class.isAssignableFrom(javaType) || int.class.isAssignableFrom(javaType)) {
  227 |             return sqlType.contains("INT");
  228 |         } else if (Long.class.isAssignableFrom(javaType) || long.class.isAssignableFrom(javaType)) {
  229 |             return sqlType.contains("BIGINT") || sqlType.contains("INT");
  230 |         } else if (Boolean.class.isAssignableFrom(javaType) || boolean.class.isAssignableFrom(javaType)) {
  231 |             return sqlType.contains("BOOLEAN") || sqlType.contains("BIT") || sqlType.contains("TINYINT");
  232 |         } else if (Double.class.isAssignableFrom(javaType) || double.class.isAssignableFrom(javaType)) {
  233 |             return sqlType.contains("DOUBLE") || sqlType.contains("DECIMAL");
  234 |         } else if (Float.class.isAssignableFrom(javaType) || float.class.isAssignableFrom(javaType)) {
  235 |             return sqlType.contains("FLOAT") || sqlType.contains("DECIMAL");
  236 |         } else if (java.util.Date.class.isAssignableFrom(javaType)) {
  237 |             return sqlType.contains("DATE") || sqlType.contains("TIMESTAMP");
  238 |         }
  239 | 
  240 |         return false;
  241 |     }
  242 | 
  243 |     private static boolean hasNotNullConstraint(ColumnDefinition columnDef) {
  244 |         if (columnDef.getColumnSpecStrings() != null) {
  245 |             String specs = String.join(" ", columnDef.getColumnSpecStrings()).toUpperCase();
  246 |             return specs.contains("NOT NULL");
  247 |         }
  248 |         return false;
  249 |     }
  250 | 
  251 |     private static Integer getColumnLength(ColumnDefinition columnDef) {
  252 |         if (columnDef.getColDataType().getArgumentsStringList() != null &&
  253 |             !columnDef.getColDataType().getArgumentsStringList().isEmpty()) {
  254 |             try {
  255 |                 return Integer.parseInt(columnDef.getColDataType().getArgumentsStringList().get(0));
  256 |             } catch (NumberFormatException e) {
  257 |                 return null;
  258 |             }
  259 |         }
  260 |         return null;
  261 |     }
  262 | }

#--------------------------------------------------------------------------------


# File: backend/src/test/java/com/authentication/auth/domain/EntitySqlValidationTest.java
#=============================================================================

    1 | package com.authentication.auth.domain;
    2 | 
    3 | import static org.junit.jupiter.api.Assertions.*;
    4 | 
    5 | import java.util.List;
    6 | 
    7 | import org.junit.jupiter.api.DisplayName;
    8 | import org.junit.jupiter.api.Test;
    9 | import org.springframework.boot.test.context.SpringBootTest;
   10 | 
   11 | import com.authentication.auth.utility.SqlSchemaLoader;
   12 | import com.authentication.auth.validator.EntitySqlValidator;
   13 | import com.authentication.auth.validator.EntityValidationOutput;
   14 | 
   15 | @SpringBootTest
   16 | public class EntitySqlValidationTest {
   17 | 
   18 |     @Test
   19 |     @DisplayName("AuthProvider ì—”í‹°í‹°ì™€ SQL ì •ì˜ê°€ ì¼ì¹˜í•˜ëŠ”ì§€ ê²€ì¦")
   20 |     public void testAuthProviderEntityAgainstSql() {
   21 |         // SQL ìƒì„± êµ¬ë¬¸
   22 |         String sqlStatement = SqlSchemaLoader.loadSqlFromApi("AuthProvider");
   23 |         
   24 |         // ì—”í‹°í‹°ì™€ SQL ê²€ì¦
   25 |         List<EntitySqlValidator.ValidationResult> results = 
   26 |                 EntitySqlValidator.validate(AuthProvider.class, sqlStatement);
   27 |         
   28 |         // ê²°ê³¼ í‘œì‹œ
   29 |         EntityValidationDisplayService.displayResults(results);
   30 |         
   31 |         // ì˜¤ë¥˜ê°€ ì—†ëŠ”ì§€ í™•ì¸
   32 |         long errorCount = results.stream()
   33 |                 .filter(r -> r.getStatus() == EntitySqlValidator.ValidationStatus.ERROR)
   34 |                 .count();
   35 |         
   36 |         assertEquals(0, errorCount, "ì—”í‹°í‹°ëŠ” SQLì— ëŒ€í•´ ê²€ì¦ ì˜¤ë¥˜ê°€ ì—†ì–´ì•¼ í•©ë‹ˆë‹¤");
   37 |         
   38 |         // íŠ¹ì • ê²€ì‚¬ í™•ì¸
   39 |         assertTrue(results.stream()
   40 |                 .anyMatch(r -> r.getFieldName().equals("í…Œì´ë¸” ì´ë¦„") && 
   41 |                          r.getStatus() == EntitySqlValidator.ValidationStatus.VALID),
   42 |                 "í…Œì´ë¸” ì´ë¦„ì´ ì„±ê³µì ìœ¼ë¡œ ê²€ì¦ë˜ì–´ì•¼ í•©ë‹ˆë‹¤");
   43 |         
   44 |         assertTrue(results.stream()
   45 |                 .anyMatch(r -> r.getFieldName().equals("providerName") && 
   46 |                          r.getStatus() == EntitySqlValidator.ValidationStatus.VALID),
   47 |                 "providerName í•„ë“œê°€ ì„±ê³µì ìœ¼ë¡œ ê²€ì¦ë˜ì–´ì•¼ í•©ë‹ˆë‹¤");
   48 |     }
   49 | }

#--------------------------------------------------------------------------------


# File: backend/src/test/java/com/authentication/auth/AuthApplicationTests.java
#=============================================================================

    1 | package com.authentication.auth;
    2 | 
    3 | import org.junit.jupiter.api.Test;
    4 | import org.springframework.boot.test.context.SpringBootTest;
    5 | 
    6 | @SpringBootTest
    7 | class AuthApplicationTests {
    8 | 
    9 | 	@Test
   10 | 	void contextLoads() {
   11 | 	}
   12 | 
   13 | }

#--------------------------------------------------------------------------------


# File: backend/src/test/java/com/authentication/auth/utility/SqlSchemaLoader.java
#=============================================================================

    1 | package com.authentication.auth.utility;
    2 | 
    3 | import org.springframework.core.io.ClassPathResource;
    4 | import org.springframework.util.FileCopyUtils;
    5 | 
    6 | import java.io.IOException;
    7 | import java.io.InputStreamReader;
    8 | import java.io.Reader;
    9 | import java.nio.charset.StandardCharsets;
   10 | 
   11 | public class SqlSchemaLoader {
   12 | 
   13 |     /**
   14 |      * ClassPathReource ì—ì„œ SQL íŒŒì¼ì„ ì½ì–´ì˜´
   15 |      */
   16 |     public static String loadSqlFromClasspath(String path) throws IOException {
   17 |         ClassPathResource resource = new ClassPathResource(path);
   18 |         try (Reader reader = new InputStreamReader(resource.getInputStream(), StandardCharsets.UTF_8)) {
   19 |             return FileCopyUtils.copyToString(reader);
   20 |         }
   21 |     }
   22 |     
   23 |     /**
   24 |      * APIì—ì„œ SQL ìŠ¤í‚¤ë§ˆë¥¼ ê°€ì ¸ì˜´ (Mock êµ¬í˜„)
   25 |      */
   26 |     public static String loadSqlFromApi(String entityName) {
   27 |         // ì‹¤ì œ êµ¬í˜„ì—ì„œëŠ” API í˜¸ì¶œ ì½”ë“œë¡œ ëŒ€ì²´
   28 |         if ("AuthProvider".equals(entityName)) {
   29 |             return "CREATE TABLE Auth_Provider (\n" +
   30 |                    "    id INT AUTO_INCREMENT,\n" +
   31 |                    "    provider_name VARCHAR(50) NOT NULL DEFAULT 'SERVER',\n" +
   32 |                    "    description VARCHAR(255),\n" +
   33 |                    "    is_active BOOLEAN DEFAULT TRUE,\n" +
   34 |                    "    PRIMARY KEY (id)\n" +
   35 |                    ");";
   36 |         }
   37 |         return "";
   38 |     }
   39 | }

#--------------------------------------------------------------------------------


# File: backend/src/test/java/com/authentication/auth/token/JwtUtilityTest.java
#=============================================================================

    1 | package com.authentication.auth.token;
    2 | 
    3 | import org.junit.jupiter.api.Test;
    4 | import org.springframework.security.core.authority.SimpleGrantedAuthority;
    5 | 
    6 | import com.authentication.auth.DTO.token.tokenDto;
    7 | import com.authentication.auth.configuration.token.jwtUtility;
    8 | 
    9 | import java.util.Collections;
   10 | 
   11 | public class JwtUtilityTest {
   12 | 
   13 |     @Test
   14 |     void testShortLivedAccessToken() throws InterruptedException {
   15 |         // ë§Œë£Œ ì‹œê°„ 10ì´ˆë¡œ ì„¤ì •
   16 |         jwtUtility jwtUtility = new jwtUtility(
   17 |                 "eyJraWQiOiJlZjdlY2JkMy0xODcyLTRkMGUtYjYyZC03NzJkZjU2ZDcyMjEiLCJhbGciOiJSUzUxMiJ9.ew0KICAic3ViIjogIjExMzI0M2ZkaDRzZGZoMCIsDQogICJuYW1lIjogImFzZGFzZGcxMjROYXQ0MzUzNGgiLA0KICAiaWF0IjogMTUxNjEyNDVmZ2g5MDIyZXINCn0.cvsTbjRw-DWUQcrgacNmpBFzSYO8rjEvY6oMlTFcicizb1VFVVgGPf1wOJHwkc09rxzmExD7wC2q9WG_VVQ05lqzTUUJ_OVUxiJ2KNHPL3ysvpCQH5i70zCoqkCNqTu_-WHF09HXV_VEZNsGBSHQokOGqdZr8cdpSVeo2Y2u2Bx_LKf7j6XbW0xL_QJeV1c1GZt6El1lbC01tptfLYc43KGhW7fpktxbyuPito3QCx7oYgi4IESABpDWGNAVTidt1v-TE-cEhoo8D5sv6zlAR49M-8ITj8BoRJdTqb-v85d2K-jJaG10bjRQxN16LphaD5vFNb7LvcyJdre15HTYJw",  // 32ë°”ì´íŠ¸ ì´ìƒì˜ ë¬¸ìì—´
   18 |                 "eyJlZjdlY2JkMy0xODcyLTRkMGUtYjYQ1MTYtODU0My0zYjM3ZWNhYzViM2EiLCJhbGciOiJSUzUxMiJ9.ew0KICAic3ViIjogIjExMzI0M2ZkZ2pnZmpkZmgwIiwNCiAgIm5hbWUiOiAiYTEyM3NkNDU3OTg5amhtZGdmaGpqNE5hdDQzNTM0aCIsDQogICJpYXQiOiAxNTE2MTI0NWZnamRnaHlqa2R5Z2ZnaGc5MGRmZ2gyMmVyDQp9.f0XpFz2rJ97kW4-jEodL5jQ79Tre5tY3sScViI6b9m3grk5nZm8EQd1wmu6u55ckageOvVLqg1SaWpqKTgIL6Dknv6Bh4K-kOEuHl5S6WzxNSyIk4B-dYu4n644ZVuhF54UeFoRfRjQ1kB2RfqXi_ekwtc4Q2ff-KU15EtEV_AN4R_gerSzC7VAwqj9BN4G1rbHTvSLsozcsGi4r1aSihXpaq4nrkad48TpLVSbkGWovdaVuR4aY9RARHDPvm5x1WG8bjaDMu7PB5at2LAayvd3yXRF9Xjr5MypX9AUg6Ne0VodeppFwah-PRjob8-5hb3l1yqTU8Ht6ml-dVO7UVw",      // 32ë°”ì´íŠ¸ ì´ìƒì˜ ë¬¸ìì—´
   19 |                 10L,  // ACCESS_TOKEN_VALIDITY (10ì´ˆ)
   20 |                 3600L // REFRESH_TOKEN_VALIDITY (1ì‹œê°„)
   21 |         );
   22 | 
   23 |         // ìœ ì € ì •ë³´ ì„¤ì •
   24 |         String userId = "admin";
   25 |         String nickname = "ê´€ë¦¬ì";
   26 |         SimpleGrantedAuthority role = new SimpleGrantedAuthority("ROLE_USER");
   27 | 
   28 |         // í† í° ìƒì„±
   29 |         tokenDto token = jwtUtility.buildToken(userId, nickname, Collections.singletonList(role));
   30 | 
   31 |         System.out.println("Generated Access Token: " + token.getAccessToken());
   32 |         System.out.println("Generated Refresh Token: " + token.getRefreshToken());
   33 | 
   34 |         // ìƒì„±ëœ í† í°ì„ ë°”ë¡œ ê²€ì¦ (ìœ íš¨í•´ì•¼ í•¨)
   35 |         boolean isValid = jwtUtility.validateJWT(token.getAccessToken());
   36 |         System.out.println("Access Token is valid: " + isValid);
   37 | 
   38 |         // 10ì´ˆ ëŒ€ê¸° í›„ í† í° ë§Œë£Œ ì—¬ë¶€ ê²€ì¦
   39 |         System.out.println("Waiting for 10 seconds...");
   40 |         Thread.sleep(10000);
   41 | 
   42 |         // ë§Œë£Œëœ í† í°ì„ ê²€ì¦ (ìœ íš¨í•˜ì§€ ì•Šì•„ì•¼ í•¨)
   43 |         isValid = jwtUtility.validateJWT(token.getAccessToken());
   44 |         System.out.println("Access Token is valid after 10 seconds: " + isValid);
   45 |     }
   46 | }

#--------------------------------------------------------------------------------


# File: backend/src/main/java/com/authentication/auth/others/constants/SecurityConstants.java
#=============================================================================

    1 | package com.authentication.auth.others.constants;
    2 | 
    3 | import java.util.HashMap;
    4 | import java.util.Map;
    5 | import java.util.Optional;
    6 | 
    7 | /**
    8 |  * ë³´ì•ˆ ê´€ë ¨ ìƒìˆ˜ë¥¼ ì •ì˜í•˜ëŠ” Enum í´ë˜ìŠ¤
    9 |  * JWT í† í°, ì¸ì¦, ì¸ê°€ ê´€ë ¨ ìƒìˆ˜ ì •ì˜
   10 |  */
   11 | public enum SecurityConstants {
   12 | 
   13 |     TOKEN_TYPE("TOKEN_TYPE", "JWT"),
   14 |     TOKEN_HEADER("TOKEN_HEADER", "Authorization"),
   15 |     TOKEN_PREFIX("TOKEN_PREFIX", "Bearer "),
   16 |     TOKEN_TYPE_REFRESH("TOKEN_TYPE_REFRESH", "refreshJWT"),
   17 |     
   18 |     ACCESS_TOKEN_EXPIRATION("ACCESS_TOKEN_EXPIRATION", "1800"), // 30ë¶„(ì´ˆ ë‹¨ìœ„)
   19 |     REFRESH_TOKEN_EXPIRATION("REFRESH_TOKEN_EXPIRATION", "2592000"), // 30ì¼(ì´ˆ ë‹¨ìœ„)
   20 |     COOKIE_NAME("COOKIE_NAME", "refresh_token"),
   21 |     COOKIE_SECURE("COOKIE_SECURE", "true"),
   22 |     COOKIE_HTTP_ONLY("COOKIE_HTTP_ONLY", "true"),
   23 |     COOKIE_PATH("COOKIE_PATH", "/"),
   24 |     COOKIE_DOMAIN("COOKIE_DOMAIN", ""),
   25 |     REMEMBER_ME_KEY("REMEMBER_ME_KEY", "rememberMeKey"),
   26 |     REMEMBER_ME_VALIDITY("REMEMBER_ME_VALIDITY", "1209600"), // 14ì¼(ì´ˆ ë‹¨ìœ„)
   27 |     CORS_ALLOWED_ORIGINS("CORS_ALLOWED_ORIGINS", "*"),
   28 |     CORS_ALLOWED_METHODS("CORS_ALLOWED_METHODS", "GET,POST,PUT,DELETE,OPTIONS"),
   29 |     CSRF_HEADER_NAME("CSRF_HEADER_NAME", "X-CSRF-TOKEN"),
   30 |     CSRF_PARAMETER_NAME("CSRF_PARAMETER_NAME", "_csrf"),
   31 |     LOGIN_URL("LOGIN_URL", "/api/auth/login"),
   32 |     LOGOUT_URL("LOGOUT_URL", "/api/auth/logout"),
   33 |     SIGNUP_URL("SIGNUP_URL", "/api/auth/signup"),
   34 |     AUTH_WHITE_LIST("AUTH_WHITE_LIST", "/api/auth/**,/public/**,/api/v1/health,/swagger-ui/**,/v3/api-docs/**");
   35 |     
   36 |     private final String key;
   37 |     private final String value;
   38 |     
   39 |     // ê°’ íƒìƒ‰ì„ ìœ„í•œ ë§¤í•‘
   40 |     private static final Map<String, SecurityConstants> BY_KEY = new HashMap<>();
   41 |     private static final Map<String, SecurityConstants> BY_VALUE = new HashMap<>();
   42 |     
   43 |     // ì •ì  ì´ˆê¸°í™” ë¸”ë¡ìœ¼ë¡œ ë§¤í•‘ ì´ˆê¸°í™”
   44 |     static {
   45 |         for (SecurityConstants constant : values()) {
   46 |             BY_KEY.put(constant.getKey(), constant);
   47 |             BY_VALUE.put(constant.getValue(), constant);
   48 |         }
   49 |     }
   50 |     
   51 |     /**
   52 |      * SecurityConstants ìƒì„±ì
   53 |      * @param key ìƒìˆ˜ í‚¤
   54 |      * @param value ìƒìˆ˜ ê°’
   55 |      */
   56 |     SecurityConstants(String key, String value) {
   57 |         if (key == null || key.isEmpty() || value == null || value.isEmpty()) {
   58 |             throw new IllegalArgumentException("í‚¤ì™€ ê°’ì€ nullì´ê±°ë‚˜ ë¹ˆ ë¬¸ìì—´ì¼ ìˆ˜ ì—†ìŠµë‹ˆë‹¤.");
   59 |         }
   60 |         this.key = key;
   61 |         this.value = value;
   62 |     }
   63 |     
   64 |     /**
   65 |      * ìƒìˆ˜ í‚¤ë¥¼ ë°˜í™˜í•©ë‹ˆë‹¤.
   66 |      * @return ìƒìˆ˜ í‚¤
   67 |      */
   68 |     public String getKey() {
   69 |         return key;
   70 |     }
   71 |     
   72 |     /**
   73 |      * ìƒìˆ˜ ê°’ì„ ë°˜í™˜í•©ë‹ˆë‹¤.
   74 |      * @return ìƒìˆ˜ ê°’
   75 |      */
   76 |     public String getValue() {
   77 |         return value;
   78 |     }
   79 |     
   80 |     /**
   81 |      * ìƒìˆ˜ ê°’ì„ ì •ìˆ˜ë¡œ ë°˜í™˜í•©ë‹ˆë‹¤.
   82 |      * @return ì •ìˆ˜ë¡œ ë³€í™˜ëœ ìƒìˆ˜ ê°’
   83 |      * @throws NumberFormatException ìƒìˆ˜ ê°’ì´ ì •ìˆ˜ë¡œ ë³€í™˜ë  ìˆ˜ ì—†ëŠ” ê²½ìš°
   84 |      */
   85 |     public int getIntValue() {
   86 |         return Integer.parseInt(value);
   87 |     }
   88 |     
   89 |     /**
   90 |      * ìƒìˆ˜ ê°’ì„ longìœ¼ë¡œ ë°˜í™˜í•©ë‹ˆë‹¤.
   91 |      * @return longìœ¼ë¡œ ë³€í™˜ëœ ìƒìˆ˜ ê°’
   92 |      * @throws NumberFormatException ìƒìˆ˜ ê°’ì´ longìœ¼ë¡œ ë³€í™˜ë  ìˆ˜ ì—†ëŠ” ê²½ìš°
   93 |      */
   94 |     public long getLongValue() {
   95 |         return Long.parseLong(value);
   96 |     }
   97 |     
   98 |     /**
   99 |      * ìƒìˆ˜ ê°’ì„ booleanìœ¼ë¡œ ë°˜í™˜í•©ë‹ˆë‹¤.
  100 |      * @return booleanìœ¼ë¡œ ë³€í™˜ëœ ìƒìˆ˜ ê°’
  101 |      */
  102 |     public boolean getBooleanValue() {
  103 |         return Boolean.parseBoolean(value);
  104 |     }
  105 |     
  106 |     /**
  107 |      * í‚¤ë¡œ SecurityConstantsë¥¼ ì°¾ìŠµë‹ˆë‹¤.
  108 |      * @param key ì°¾ìœ¼ë ¤ëŠ” ìƒìˆ˜ì˜ í‚¤
  109 |      * @return í•´ë‹¹ í‚¤ì— ë§¤í•‘ëœ SecurityConstants ë˜ëŠ” null
  110 |      */
  111 |     public static SecurityConstants fromKey(String key) {
  112 |         return BY_KEY.get(key);
  113 |     }
  114 |     
  115 |     /**
  116 |      * ê°’ìœ¼ë¡œ SecurityConstantsë¥¼ ì°¾ìŠµë‹ˆë‹¤.
  117 |      * @param value ì°¾ìœ¼ë ¤ëŠ” ìƒìˆ˜ì˜ ê°’
  118 |      * @return í•´ë‹¹ ê°’ì„ ê°€ì§„ SecurityConstants ë˜ëŠ” null
  119 |      */
  120 |     public static SecurityConstants fromValue(String value) {
  121 |         return BY_VALUE.get(value);
  122 |     }
  123 |     
  124 |     /**
  125 |      * í‚¤ë¡œ SecurityConstantsë¥¼ ì•ˆì „í•˜ê²Œ ì°¾ìŠµë‹ˆë‹¤.
  126 |      * @param key ì°¾ìœ¼ë ¤ëŠ” ìƒìˆ˜ì˜ í‚¤
  127 |      * @return í•´ë‹¹ í‚¤ì— ë§¤í•‘ëœ SecurityConstantsë¥¼ ë‹´ê³  ìˆëŠ” Optional
  128 |      */
  129 |     public static Optional<SecurityConstants> getByKey(String key) {
  130 |         return Optional.ofNullable(fromKey(key));
  131 |     }
  132 |     
  133 |     /**
  134 |      * ê°’ìœ¼ë¡œ SecurityConstantsë¥¼ ì•ˆì „í•˜ê²Œ ì°¾ìŠµë‹ˆë‹¤.
  135 |      * @param value ì°¾ìœ¼ë ¤ëŠ” ìƒìˆ˜ì˜ ê°’
  136 |      * @return í•´ë‹¹ ê°’ì„ ê°€ì§„ SecurityConstantsë¥¼ ë‹´ê³  ìˆëŠ” Optional
  137 |      */
  138 |     public static Optional<SecurityConstants> getByValue(String value) {
  139 |         return Optional.ofNullable(fromValue(value));
  140 |     }
  141 |     
  142 |     /**
  143 |      * Enum ìƒìˆ˜ë¥¼ ë¬¸ìì—´ë¡œ ë°˜í™˜í•©ë‹ˆë‹¤.
  144 |      * @return í‚¤ì™€ ê°’ì„ í¬í•¨í•œ ë¬¸ìì—´ í‘œí˜„
  145 |      */
  146 |     @Override
  147 |     public String toString() {
  148 |         return String.format("%s[key=%s, value=%s]", name(), key, value);
  149 |     }
  150 |     
  151 |     /**
  152 |      * ëª¨ë“  SecurityConstantsë¥¼ ë¬¸ìì—´ë¡œ ì¶œë ¥í•©ë‹ˆë‹¤.
  153 |      * ë””ë²„ê¹… ìš©ë„ë¡œ ìœ ìš©í•©ë‹ˆë‹¤.
  154 |      * @return ëª¨ë“  ë³´ì•ˆ ìƒìˆ˜ì— ëŒ€í•œ ë¬¸ìì—´ í‘œí˜„
  155 |      */
  156 |     public static String printAll() {
  157 |         StringBuilder sb = new StringBuilder("SecurityConstants:\n");
  158 |         for (SecurityConstants constant : values()) {
  159 |             sb.append(constant.toString()).append("\n");
  160 |         }
  161 |         return sb.toString();
  162 |     }
  163 | }
  164 |     }
  165 | }

#--------------------------------------------------------------------------------


# File: backend/src/main/java/com/authentication/auth/config/SecurityFilterConfig.java
#=============================================================================

    1 | package com.authentication.auth.config;
    2 | 
    3 | import com.authentication.auth.filter.AuthenticationFilter;
    4 | import com.authentication.auth.filter.AuthorizationFilter;
    5 | import com.authentication.auth.filter.SnsRequestFilter;
    6 | import lombok.RequiredArgsConstructor;
    7 | import org.springframework.boot.web.servlet.FilterRegistrationBean;
    8 | import org.springframework.context.annotation.Bean;
    9 | import org.springframework.context.annotation.Configuration;
   10 | 
   11 | /**
   12 |  * ë³´ì•ˆ í•„í„° ì„¤ì • í´ë˜ìŠ¤
   13 |  * í•„í„°ì˜ ë“±ë¡ ë° ìˆœì„œ ì„¤ì •ì„ ë‹´ë‹¹
   14 |  */
   15 | @Configuration
   16 | @RequiredArgsConstructor
   17 | public class SecurityFilterConfig {
   18 | 
   19 |     private final AuthenticationFilter authenticationFilter;
   20 |     private final AuthorizationFilter authorizationFilter;
   21 |     private final SnsRequestFilter snsRequestFilter;
   22 | 
   23 |     /**
   24 |      * ì¸ì¦ í•„í„° ë“±ë¡
   25 |      */
   26 |     @Bean
   27 |     public FilterRegistrationBean<AuthenticationFilter> authenticationFilterRegistration() {
   28 |         FilterRegistrationBean<AuthenticationFilter> registrationBean = new FilterRegistrationBean<>();
   29 |         registrationBean.setFilter(authenticationFilter);
   30 |         registrationBean.addUrlPatterns("/*");
   31 |         registrationBean.setOrder(authenticationFilter.getOrder());
   32 |         registrationBean.setName("authenticationFilter");
   33 |         return registrationBean;
   34 |     }
   35 | 
   36 |     /**
   37 |      * ê¶Œí•œ í•„í„° ë“±ë¡
   38 |      */
   39 |     @Bean
   40 |     public FilterRegistrationBean<AuthorizationFilter> authorizationFilterRegistration() {
   41 |         FilterRegistrationBean<AuthorizationFilter> registrationBean = new FilterRegistrationBean<>();
   42 |         registrationBean.setFilter(authorizationFilter);
   43 |         registrationBean.addUrlPatterns("/*");
   44 |         registrationBean.setOrder(authorizationFilter.getOrder());
   45 |         registrationBean.setName("authorizationFilter");
   46 |         return registrationBean;
   47 |     }
   48 | 
   49 |     /**
   50 |      * SNS ìš”ì²­ í•„í„° ë“±ë¡
   51 |      */
   52 |     @Bean
   53 |     public FilterRegistrationBean<SnsRequestFilter> snsRequestFilterRegistration() {
   54 |         FilterRegistrationBean<SnsRequestFilter> registrationBean = new FilterRegistrationBean<>();
   55 |         registrationBean.setFilter(snsRequestFilter);
   56 |         registrationBean.addUrlPatterns("/*");
   57 |         registrationBean.setOrder(snsRequestFilter.getOrder());
   58 |         registrationBean.setName("snsRequestFilter");
   59 |         return registrationBean;
   60 |     }
   61 | }

#--------------------------------------------------------------------------------


# File: backend/src/main/java/com/authentication/auth/DTO/users/loginRequest.java
#=============================================================================

    1 | package com.authentication.auth.DTO.users;
    2 | 
    3 | import lombok.Data;
    4 | 
    5 | public record LoginRequest(String userId, String password) {}

#--------------------------------------------------------------------------------


# File: backend/src/main/java/com/authentication/auth/DTO/users/userStat.java
#=============================================================================

    1 | package com.career_block.auth.DTO.users;
    2 | 
    3 | import jakarta.validation.constraints.NotBlank;
    4 | import lombok.Builder;
    5 | import lombok.Data;
    6 | 
    7 | import java.time.LocalDateTime;
    8 | import java.util.Date;
    9 | import java.util.List;
   10 | 
   11 | import com.authentication.auth.domain.Role;
   12 | 
   13 | @Data
   14 | @Builder
   15 | public class userStat {
   16 |     @NotBlank
   17 |     private String userId;
   18 |     @NotBlank
   19 |     private String nickname;
   20 |     private Role role;
   21 |     private Date birthDate;
   22 |     //private String gender;
   23 |     private boolean isPrivate;
   24 |     private String profile;
   25 |     private List<String> hashtags;
   26 |     private List<String> certifications;
   27 |     private List<String> groups;
   28 |     private LocalDateTime userActivites;
   29 | }

#--------------------------------------------------------------------------------


# File: backend/src/main/java/com/authentication/auth/DTO/users/JoinRequest.java
#=============================================================================

    1 | package com.authentication.auth.DTO.users;
    2 | 
    3 | import com.authentication.auth.domain.User;
    4 | import com.fasterxml.jackson.annotation.JsonProperty;
    5 | import jakarta.validation.constraints.NotBlank;
    6 | 
    7 | import java.util.Date;
    8 | 
    9 | /**
   10 |  * @author: nodove
   11 |  * ê¸°ì¡´ class -> record ìœ¼ë¡œ ë³€ê²½ 
   12 |  * record ë§¤ê°œë³€ìˆ˜ì— ì§ì ‘ @NotBlank ì¶”ê°€
   13 |  * 
   14 |  * */
   15 | public record JoinRequest(
   16 |     @NotBlank String userId,
   17 |     @NotBlank String userPw,
   18 |     @NotBlank String userName,
   19 |     @NotBlank String nickname,
   20 |     @NotBlank String phone,
   21 |     String email,
   22 |     User.UserRole role,
   23 |     Date birthDate,
   24 |     @NotBlank String gender,
   25 |     @JsonProperty("isPrivate") boolean isPrivate,
   26 |     String profile,
   27 |     String code
   28 | ) {
   29 |     // default í”„ë¡œí•„ ì´ë¯¸ì§€ë¥¼ ìœ„í•œ ì •ì  íŒ©í† ë¦¬ ë©”ì„œë“œ -> ë¶ˆí•„ìš”í•œ ê°ì²´ ìƒì„± ë°©ì§€(ìƒì„±ì í™œìš©, immutable) ëª©ì 
   30 |     public static JoinRequest of(String userId, String userPw, String userName, String nickname, 
   31 |                               String phone, String email, User.UserRole role, Date birthDate, 
   32 |                               String gender, boolean isPrivate, String code) {
   33 |         return new JoinRequest(userId, userPw, userName, nickname, phone, email, role, 
   34 |                             birthDate, gender, isPrivate, "https://zrr.kr/iPHf", code);
   35 |     }
   36 | 
   37 |     // ì‚¬ìš©ì ì—”í‹°í‹°ë¡œ ë³€í™˜í•˜ëŠ” ë©”ì„œë“œ
   38 |     public User toEntity() {
   39 |         return User.builder()
   40 |                 .userId(this.userId)
   41 |                 .userPw(this.userPw)
   42 |                 .userName(this.userName)
   43 |                 .nickname(this.nickname)
   44 |                 .phone(this.phone)
   45 |                 .email(this.email)
   46 |                 .role(this.role)
   47 |                 .birthDate(this.birthDate)
   48 |                 .gender(this.gender)
   49 |                 .isPrivate(this.isPrivate)
   50 |                 .profile(this.profile)
   51 |                 .build();
   52 |     }
   53 | }

#--------------------------------------------------------------------------------


# File: backend/src/main/java/com/authentication/auth/DTO/smtp/emailCheckDto.java
#=============================================================================

    1 | package com.career_block.auth.DTO.smtp;
    2 | 
    3 | import jakarta.validation.constraints.Email;
    4 | import jakarta.validation.constraints.NotBlank;
    5 | import lombok.Getter;
    6 | 
    7 | @Getter
    8 | public class emailCheckDto {
    9 |     @Email
   10 |     @NotBlank
   11 |     private String email;
   12 |     @NotBlank
   13 |     private String code;
   14 | }

#--------------------------------------------------------------------------------


# File: backend/src/main/java/com/authentication/auth/DTO/smtp/emailFindById.java
#=============================================================================

    1 | package com.career_block.auth.DTO.smtp;
    2 | 
    3 | import jakarta.validation.constraints.NotBlank;
    4 | import lombok.Data;
    5 | 
    6 | @Data
    7 | public class emailFindById {
    8 |     @NotBlank
    9 |     private String userId;
   10 | }

#--------------------------------------------------------------------------------


# File: backend/src/main/java/com/authentication/auth/DTO/smtp/customEmailRequest.java
#=============================================================================

    1 | package com.career_block.auth.DTO.smtp;
    2 | 
    3 | import lombok.Data;
    4 | 
    5 | @Data
    6 | public class customEmailRequest {
    7 |     private String email;
    8 |     private String content;
    9 |     private String title;
   10 | }

#--------------------------------------------------------------------------------


# File: backend/src/main/java/com/authentication/auth/DTO/smtp/emailRequest.java
#=============================================================================

    1 | package com.career_block.auth.DTO.smtp;
    2 | 
    3 | import jakarta.validation.constraints.Email;
    4 | import jakarta.validation.constraints.NotBlank;
    5 | import lombok.Data;
    6 | 
    7 | @Data
    8 | public class emailRequest {
    9 |     @Email
   10 |     @NotBlank
   11 |     private String email;
   12 | }

#--------------------------------------------------------------------------------


# File: backend/src/main/java/com/authentication/auth/DTO/smtp/customEmailToAllRequest.java
#=============================================================================

    1 | package com.career_block.auth.DTO.smtp;
    2 | 
    3 | import lombok.Data;
    4 | 
    5 | @Data
    6 | public class customEmailToAllRequest {
    7 |     private String title;
    8 |     private String content;
    9 | }

#--------------------------------------------------------------------------------


# File: backend/src/main/java/com/authentication/auth/DTO/token/TokenDto.java
#=============================================================================

    1 | package com.authentication.auth.DTO.token;
    2 | 
    3 | 
    4 | /**
    5 |  * @Author : choisimo
    6 |  * @Date : 2025.05.08
    7 |  * @Description : Token Data Transfer Object
    8 |  * @Detail : accessToken, refreshToken
    9 |  * @Refactor : change class type to record type
   10 |  * */
   11 | 
   12 | public record TokenDto(String accessToken, String refreshToken) {}
   13 | 
   14 | // same as
   15 | /**
   16 |  * class TokenDto {
   17 |  *     String accessToken;
   18 |  *     String refreshToken;
   19 |  *
   20 |  *     public TokenDto(String accessToken, String refreshToken) {
   21 |  *         this.accessToken = accessToken;
   22 |  *         this.refreshToken = refreshToken;
   23 |  *     }
   24 |  *
   25 |  *     public String getAccessToken() {
   26 |  *         return accessToken;
   27 |  *     }
   28 |  *
   29 |  *     public void setAccessToken(String accessToken) {
   30 |  *         this.accessToken = accessToken;
   31 |  *     }
   32 |  *
   33 |  *     public String getRefreshToken() {
   34 |  *         return refreshToken;
   35 |  *     }
   36 |  *
   37 |  *     public void setRefreshToken(String refreshToken) {
   38 |  *         this.refreshToken = refreshToken;
   39 |  *     }
   40 |  *
   41 |  *     public String toString() {
   42 |  *         return "TokenDto [accessToken=" + accessToken + ", refreshToken=" + refreshToken + "]";
   43 |  *     }
   44 |  *
   45 |  *     public int hashCode() {
   46 |  *
   47 |  *     }
   48 |  * }
   49 |  *
   50 |  * */

#--------------------------------------------------------------------------------


# File: backend/src/main/java/com/authentication/auth/DTO/token/principalDetails.java
#=============================================================================

    1 | package com.career_block.auth.DTO.token;
    2 | 
    3 | import lombok.RequiredArgsConstructor;
    4 | import lombok.extern.slf4j.Slf4j;
    5 | import org.springframework.security.core.GrantedAuthority;
    6 | import org.springframework.security.core.authority.SimpleGrantedAuthority;
    7 | import org.springframework.security.core.userdetails.UserDetails;
    8 | 
    9 | import com.authentication.auth.domain.users;
   10 | 
   11 | import java.util.Collection;
   12 | import java.util.Collections;
   13 | 
   14 | @Slf4j
   15 | @RequiredArgsConstructor
   16 | public class principalDetails implements UserDetails{
   17 | 
   18 |     private final users user;
   19 | 
   20 |     @Override
   21 |     public Collection<? extends GrantedAuthority> getAuthorities() {
   22 |         return Collections.singletonList(new SimpleGrantedAuthority(user.getRole().name()));
   23 |     }
   24 |     @Override
   25 |     public String getPassword() {
   26 |         return user.getUserPw();
   27 |     }
   28 |     @Override
   29 |     public String getUsername() {
   30 |         return user.getUserName();
   31 |     }
   32 |     @Override
   33 |     public boolean isAccountNonExpired() {
   34 |         return true;
   35 |     }
   36 |     @Override
   37 |     public boolean isAccountNonLocked() {
   38 |         return true;
   39 |     }
   40 |     @Override
   41 |     public boolean isCredentialsNonExpired() {
   42 |         return true;
   43 |     }
   44 |     @Override
   45 |     public boolean isEnabled() {
   46 |         return true;
   47 |     }
   48 |     public String getNickname(){
   49 |         return user.getNickname();
   50 |     }
   51 |     public String getUserId(){
   52 |         return user.getUserId();
   53 |     }
   54 | 
   55 | }

#--------------------------------------------------------------------------------


# File: backend/src/main/java/com/authentication/auth/DTO/token/tokenRefreshRequest.java
#=============================================================================

    1 | package com.career_block.auth.DTO.token;
    2 | 
    3 | import lombok.Data;
    4 | 
    5 | @Data
    6 | public class tokenRefreshRequest {
    7 |     private String expiredToken;
    8 |     private String provider;
    9 | }

#--------------------------------------------------------------------------------


# File: backend/src/main/java/com/authentication/auth/filter/PathPatternFilterCondition.java
#=============================================================================

    1 | package com.authentication.auth.filter;
    2 | 
    3 | import jakarta.servlet.http.HttpServletRequest;
    4 | import org.springframework.http.HttpMethod;
    5 | import org.springframework.util.AntPathMatcher;
    6 | 
    7 | import java.util.HashSet;
    8 | import java.util.Set;
    9 | 
   10 | /**
   11 |  * @Author: choisimo
   12 |  * @Date: 2025-05-05
   13 |  * @Description: ê²½ë¡œ íŒ¨í„´ ê¸°ë°˜ í•„í„° ì¡°ê±´
   14 |  * @Details: URL íŒ¨í„´ê³¼ HTTP ë©”ì†Œë“œ ê¸°ë°˜ìœ¼ë¡œ í•„í„° ì ìš© ì—¬ë¶€ë¥¼ ê²°ì •
   15 |  */
   16 | public class PathPatternFilterCondition implements FilterCondition {
   17 |     
   18 |     private final Set<String> patterns = new HashSet<>();
   19 |     private final Set<HttpMethod> methods = new HashSet<>();
   20 |     private final AntPathMatcher pathMatcher = new AntPathMatcher();
   21 |     private final String description;
   22 |     
   23 |     /**
   24 |      * ê²½ë¡œ íŒ¨í„´ë§Œ ì§€ì •í•˜ëŠ” ìƒì„±ì
   25 |      * @param description ì¡°ê±´ ì„¤ëª…
   26 |      * @param patterns í¬í•¨í•  URL íŒ¨í„´ (Ant-style)
   27 |      */
   28 |     public PathPatternFilterCondition(String description, String... patterns) {
   29 |         this.description = description;
   30 |         for (String pattern : patterns) {
   31 |             this.patterns.add(pattern);
   32 |         }
   33 |     }
   34 |     
   35 |     /**
   36 |      * ê²½ë¡œ íŒ¨í„´ê³¼ HTTP ë©”ì†Œë“œë¥¼ ì§€ì •í•˜ëŠ” ìƒì„±ì
   37 |      * @param description ì¡°ê±´ ì„¤ëª…
   38 |      * @param methods í¬í•¨í•  HTTP ë©”ì†Œë“œ
   39 |      * @param patterns í¬í•¨í•  URL íŒ¨í„´ (Ant-style)
   40 |      */
   41 |     public PathPatternFilterCondition(String description, HttpMethod[] methods, String... patterns) {
   42 |         this(description, patterns);
   43 |         for (HttpMethod method : methods) {
   44 |             this.methods.add(method);
   45 |         }
   46 |     }
   47 |     
   48 |     /**
   49 |      * íŒ¨í„´ ì¶”ê°€
   50 |      * @param pattern ì¶”ê°€í•  íŒ¨í„´
   51 |      * @return í˜„ì¬ ê°ì²´ (ì²´ì´ë‹ìš©)
   52 |      */
   53 |     public PathPatternFilterCondition addPattern(String pattern) {
   54 |         this.patterns.add(pattern);
   55 |         return this;
   56 |     }
   57 |     
   58 |     /**
   59 |      * HTTP ë©”ì†Œë“œ ì¶”ê°€
   60 |      * @param method ì¶”ê°€í•  HTTP ë©”ì†Œë“œ
   61 |      * @return í˜„ì¬ ê°ì²´ (ì²´ì´ë‹ìš©)
   62 |      */
   63 |     public PathPatternFilterCondition addMethod(HttpMethod method) {
   64 |         this.methods.add(method);
   65 |         return this;
   66 |     }
   67 | 
   68 |     @Override
   69 |     public boolean shouldNotFilter(HttpServletRequest request) {
   70 |         String requestPath = request.getRequestURI();
   71 |         
   72 |         // ì–´ëŠ í•˜ë‚˜ì˜ íŒ¨í„´ì´ë¼ë„ ë§ìœ¼ë©´ í•„í„° ì œì™¸
   73 |         boolean matchesPattern = patterns.stream()
   74 |                 .anyMatch(pattern -> pathMatcher.match(pattern, requestPath));
   75 |         
   76 |         // HTTP ë©”ì†Œë“œ ì œí•œì´ ì—†ê±°ë‚˜, ìš”ì²­ ë©”ì†Œë“œê°€ ì§€ì •ëœ ë©”ì†Œë“œ ì¤‘ í•˜ë‚˜ì™€ ì¼ì¹˜í•˜ë©´ í•„í„° ì œì™¸
   77 |         boolean matchesMethod = methods.isEmpty() || 
   78 |                                methods.contains(HttpMethod.valueOf(request.getMethod()));
   79 |         
   80 |         return matchesPattern && matchesMethod;
   81 |     }
   82 | 
   83 |     @Override
   84 |     public String getDescription() {
   85 |         return description;
   86 |     }
   87 |     
   88 |     @Override
   89 |     public String toString() {
   90 |         return "PathPatternFilterCondition{" +
   91 |                 "description='" + description + '\'' +
   92 |                 ", patterns=" + patterns +
   93 |                 ", methods=" + methods +
   94 |                 '}';
   95 |     }
   96 | }

#--------------------------------------------------------------------------------


# File: backend/src/main/java/com/authentication/auth/filter/RoleBasedAccessFilter.java
#=============================================================================

    1 | package com.authentication.auth.filter;
    2 | 
    3 | import jakarta.servlet.FilterChain;
    4 | import jakarta.servlet.ServletException;
    5 | import jakarta.servlet.http.HttpServletRequest;
    6 | import jakarta.servlet.http.HttpServletResponse;
    7 | import lombok.RequiredArgsConstructor;
    8 | import lombok.extern.slf4j.Slf4j;
    9 | import org.springframework.security.access.AccessDeniedException;
   10 | import org.springframework.security.core.Authentication;
   11 | import org.springframework.security.core.context.SecurityContextHolder;
   12 | import org.springframework.stereotype.Component;
   13 | import org.springframework.web.filter.OncePerRequestFilter;
   14 | 
   15 | import java.io.IOException;
   16 | import java.util.HashMap;
   17 | import java.util.Map;
   18 | import java.util.function.Predicate;
   19 | 
   20 | /**
   21 |  * @Author: choisimo
   22 |  * @Date: 2025-05-05
   23 |  * @Description: ì—­í•  ê¸°ë°˜ ì ‘ê·¼ ì œì–´ í•„í„°
   24 |  * @Details: ë” ì„¸ë¶„í™”ëœ ì—­í•  ê¸°ë°˜ ì ‘ê·¼ ì œì–´ë¥¼ êµ¬í˜„í•œ í•„í„°
   25 |  */
   26 | @Slf4j
   27 | @Component
   28 | @RequiredArgsConstructor
   29 | public class RoleBasedAccessFilter extends OncePerRequestFilter implements PluggableFilter {
   30 | 
   31 |     // URI íŒ¨í„´ì— ë”°ë¥¸ ì ‘ê·¼ ì œì–´ ê·œì¹™ ë§µ
   32 |     private final Map<Predicate<String>, Predicate<Authentication>> accessRules = new HashMap<>();
   33 |     
   34 |     // ìƒì„±ìì—ì„œ ì ‘ê·¼ ì œì–´ ê·œì¹™ ì´ˆê¸°í™”
   35 |     public RoleBasedAccessFilter() {
   36 |         // ê´€ë¦¬ì ì „ìš© ê²½ë¡œ ì„¤ì •
   37 |         accessRules.put(
   38 |             uri -> uri.startsWith("/admin"),
   39 |             auth -> auth.getAuthorities().stream()
   40 |                         .anyMatch(a -> a.getAuthority().equals("ROLE_ADMIN"))
   41 |         );
   42 |         
   43 |         // ì‚¬ìš©ì ì „ìš© ê²½ë¡œ ì„¤ì •
   44 |         accessRules.put(
   45 |             uri -> uri.startsWith("/user"),
   46 |             auth -> auth.getAuthorities().stream()
   47 |                         .anyMatch(a -> a.getAuthority().equals("ROLE_USER") || 
   48 |                                        a.getAuthority().equals("ROLE_ADMIN"))
   49 |         );
   50 |         
   51 |         // API ê²½ë¡œ ì„¤ì •
   52 |         accessRules.put(
   53 |             uri -> uri.startsWith("/api/reports"),
   54 |             auth -> auth.getAuthorities().stream()
   55 |                         .anyMatch(a -> a.getAuthority().equals("ROLE_ANALYST") || 
   56 |                                        a.getAuthority().equals("ROLE_ADMIN"))
   57 |         );
   58 |     }
   59 | 
   60 |     @Override
   61 |     protected void doFilterInternal(HttpServletRequest request, HttpServletResponse response,
   62 |                                    FilterChain filterChain) throws ServletException, IOException {
   63 |         
   64 |         String uri = request.getRequestURI();
   65 |         Authentication authentication = SecurityContextHolder.getContext().getAuthentication();
   66 |         
   67 |         // ì¸ì¦ë˜ì§€ ì•Šì€ ìš”ì²­ì€ ë‹¤ìŒ í•„í„°ë¡œ ë„˜ê¹€ (ì¸ì¦ í•„í„°ì—ì„œ ì²˜ë¦¬)
   68 |         if (authentication == null || !authentication.isAuthenticated()) {
   69 |             filterChain.doFilter(request, response);
   70 |             return;
   71 |         }
   72 |         
   73 |         // URIì— ë§ëŠ” ì ‘ê·¼ ê·œì¹™ ì ìš©
   74 |         for (Map.Entry<Predicate<String>, Predicate<Authentication>> rule : accessRules.entrySet()) {
   75 |             if (rule.getKey().test(uri)) {
   76 |                 if (!rule.getValue().test(authentication)) {
   77 |                     log.warn("ì—­í•  ê¸°ë°˜ ì ‘ê·¼ ê±°ë¶€: ì‚¬ìš©ì={}, URI={}", 
   78 |                             authentication.getName(), uri);
   79 |                     throw new AccessDeniedException("í•´ë‹¹ ë¦¬ì†ŒìŠ¤ì— ì ‘ê·¼í•  ê¶Œí•œì´ ì—†ìŠµë‹ˆë‹¤.");
   80 |                 }
   81 |                 break;
   82 |             }
   83 |         }
   84 |         
   85 |         filterChain.doFilter(request, response);
   86 |     }
   87 |     
   88 |     @Override
   89 |     public void configure(HttpSecurity http) throws Exception {
   90 |         http.addFilterAfter(this, AuthorizationFilter.class);
   91 |     }
   92 | 
   93 |     @Override
   94 |     public int getOrder() {
   95 |         return 400; // AuthorizationFilter ë‹¤ìŒ ìˆœì„œ
   96 |     }
   97 | 
   98 |     @Override
   99 |     public Class<? extends Filter> getBeforeFilter() {
  100 |         return AuthorizationFilter.class;
  101 |     }
  102 | 
  103 |     @Override
  104 |     public Class<? extends Filter> getAfterFilter() {
  105 |         return null;
  106 |     }
  107 | }

#--------------------------------------------------------------------------------


# File: backend/src/main/java/com/authentication/auth/filter/authenticationFilter.java
#=============================================================================

    1 | package com.career_block.auth.filter;
    2 | 
    3 | import com.authentication.auth.DTO.token.principalDetails;
    4 | import com.authentication.auth.DTO.token.tokenDto;
    5 | import com.authentication.auth.DTO.users.loginRequest;
    6 | import com.authentication.auth.configuration.token.jwtUtility;
    7 | import com.authentication.auth.others.constants.SecurityConstants;
    8 | import com.authentication.auth.service.redis.redisService;
    9 | import com.fasterxml.jackson.databind.ObjectMapper;
   10 | import jakarta.servlet.FilterChain;
   11 | import jakarta.servlet.http.Cookie;
   12 | import jakarta.servlet.http.HttpServletRequest;
   13 | import jakarta.servlet.http.HttpServletResponse;
   14 | import lombok.extern.slf4j.Slf4j;
   15 | import org.springframework.http.HttpStatus;
   16 | package com.authentication.auth.filter;
   17 | 
   18 | import com.authentication.auth.domain.User;
   19 | import com.authentication.auth.service.redis.RedisService;
   20 | import com.authentication.auth.utility.JwtUtility;
   21 | import jakarta.servlet.ServletException;
   22 | import jakarta.servlet.ServletRequest;
   23 | import jakarta.servlet.ServletResponse;
   24 | import org.springframework.http.MediaType;
   25 | import org.springframework.security.authentication.AuthenticationManager;
   26 | import org.springframework.security.authentication.BadCredentialsException;
   27 | import org.springframework.security.authentication.UsernamePasswordAuthenticationToken;
   28 | import org.springframework.security.core.Authentication;
   29 | import org.springframework.security.core.AuthenticationException;
   30 | import org.springframework.security.core.userdetails.UserDetails;
   31 | import org.springframework.security.web.authentication.UsernamePasswordAuthenticationFilter;
   32 | import org.springframework.security.web.util.matcher.AntPathRequestMatcher;
   33 | 
   34 | import java.io.IOException;
   35 | import java.time.LocalDateTime;
   36 | import java.util.HashMap;
   37 | import java.util.Map;
   38 | import java.util.Objects;
   39 | import java.util.UUID;
   40 | 
   41 | /**
   42 |  * @Author: choisimo
   43 |  * @Date: 2025-05-05
   44 |  * @Description: JWT ì¸ì¦ í•„í„°
   45 |  * @Details: ì‚¬ìš©ì ë¡œê·¸ì¸ ìš”ì²­ì„ ì²˜ë¦¬í•˜ê³ , ì¸ì¦ ì„±ê³µ ì‹œ JWT í† í°ì„ ë°œê¸‰í•˜ëŠ” í•„í„°
   46 |  * @Usage: Spring Security í•„í„° ì²´ì¸ì— ë“±ë¡í•˜ì—¬ ì‚¬ìš©
   47 |  */
   48 | @Slf4j
   49 | public class AuthenticationFilter extends UsernamePasswordAuthenticationFilter implements PluggableFilter {
   50 | 
   51 |     private final AuthenticationManager authenticationManager;
   52 |     private final JwtUtility jwtUtility;
   53 |     private final ObjectMapper objectMapper;
   54 |     private final RedisService redisService;
   55 |     private final String domain;
   56 |     private final String cookieDomain;
   57 | 
   58 |     /**
   59 |      * ì¸ì¦ í•„í„° ìƒì„±ì
   60 |      * @param authenticationManager Spring Security ì¸ì¦ ê´€ë¦¬ì
   61 |      * @param jwtUtility JWT í† í° ìœ í‹¸ë¦¬í‹°
   62 |      * @param objectMapper JSON ë³€í™˜ìš© ê°ì²´ ë§¤í¼
   63 |      * @param redisService Redis ì„œë¹„ìŠ¤ (í† í° ì €ì¥ìš©)
   64 |      * @param domain ì• í”Œë¦¬ì¼€ì´ì…˜ ë„ë©”ì¸
   65 |      * @param cookieDomain ì¿ í‚¤ì— ì‚¬ìš©í•  ë„ë©”ì¸
   66 |      */
   67 |     public AuthenticationFilter(AuthenticationManager authenticationManager, JwtUtility jwtUtility, ObjectMapper objectMapper, RedisService redisService, String domain, String cookieDomain) {
   68 |         this.authenticationManager = authenticationManager;
   69 |         this.jwtUtility = jwtUtility;
   70 |         this.objectMapper = objectMapper;
   71 |         this.redisService = redisService;
   72 |         this.domain = domain;
   73 |         this.cookieDomain = cookieDomain;
   74 |         // ë¡œê·¸ì¸ URL ì„¤ì • - POST /api/auth/loginìœ¼ë¡œ ë³€ê²½
   75 |         setRequiresAuthenticationRequestMatcher(new AntPathRequestMatcher("/api/auth/login", "POST"));
   76 |     }
   77 | 
   78 |     /**
   79 |      * ì‚¬ìš©ì ì¸ì¦ ì‹œë„ ë©”ì„œë“œ
   80 |      * ìš”ì²­ì—ì„œ ì‚¬ìš©ì ìê²© ì¦ëª…ì„ ì¶”ì¶œí•˜ê³  ì¸ì¦ì„ ì‹œë„í•©ë‹ˆë‹¤.
   81 |      * @param request HTTP ìš”ì²­
   82 |      * @param response HTTP ì‘ë‹µ
   83 |      * @return ì¸ì¦ ê°ì²´
   84 |      * @throws AuthenticationException ì¸ì¦ ì˜ˆì™¸
   85 |      */
   86 |     @Override
   87 |     public Authentication attemptAuthentication(HttpServletRequest request, HttpServletResponse response)
   88 |             throws AuthenticationException {
   89 |         log.info("ì¸ì¦ ì‹œë„: {}", request.getRequestURI());
   90 |         
   91 |         try {
   92 |             // ìš”ì²­ ë°”ë””ì—ì„œ ì‚¬ìš©ì ìê²© ì¦ëª… ì¶”ì¶œ
   93 |             Map<String, String> credentials = objectMapper.readValue(request.getInputStream(), Map.class);
   94 |             String username = credentials.get("username");
   95 |             String password = credentials.get("password");
   96 |             
   97 |             if (username == null || password == null) {
   98 |                 throw new BadCredentialsException("ì‚¬ìš©ì ì´ë¦„ ë˜ëŠ” ë¹„ë°€ë²ˆí˜¸ê°€ ëˆ„ë½ë˜ì—ˆìŠµë‹ˆë‹¤.");
   99 |             }
  100 |             
  101 |             log.debug("ì‚¬ìš©ì ì¸ì¦ ì‹œë„: {}", username);
  102 |             
  103 |             // ì¸ì¦ í† í° ìƒì„± ë° ì¸ì¦ ì‹œë„
  104 |             UsernamePasswordAuthenticationToken authenticationToken = 
  105 |                 new UsernamePasswordAuthenticationToken(username, password);
  106 |                 
  107 |             return authenticationManager.authenticate(authenticationToken);
  108 |         } catch (IOException e) {
  109 |             log.error("ì¸ì¦ ìš”ì²­ ì²˜ë¦¬ ì¤‘ ì˜¤ë¥˜ ë°œìƒ: {}", e.getMessage());
  110 |             throw new BadCredentialsException("ì¸ì¦ ìš”ì²­ì„ ì²˜ë¦¬í•  ìˆ˜ ì—†ìŠµë‹ˆë‹¤.");
  111 |         }
  112 |     }
  113 | 
  114 |     /**
  115 |      * ì¸ì¦ ì„±ê³µ ì²˜ë¦¬ ë©”ì„œë“œ
  116 |      * ì¸ì¦ ì„±ê³µ ì‹œ JWT í† í°ì„ ìƒì„±í•˜ê³  í´ë¼ì´ì–¸íŠ¸ì—ê²Œ ì œê³µí•©ë‹ˆë‹¤.
  117 |      * @param request HTTP ìš”ì²­
  118 |      * @param response HTTP ì‘ë‹µ
  119 |      * @param chain í•„í„° ì²´ì¸
  120 |      * @param authResult ì¸ì¦ ê²°ê³¼
  121 |      * @throws IOException IO ì˜ˆì™¸
  122 |      * @throws ServletException ì„œë¸”ë¦¿ ì˜ˆì™¸
  123 |      */
  124 |     @Override
  125 |     protected void successfulAuthentication(HttpServletRequest request, HttpServletResponse response,
  126 |                                            FilterChain chain, Authentication authResult) 
  127 |                                            throws IOException, ServletException {
  128 |         log.info("ì¸ì¦ ì„±ê³µ ì²˜ë¦¬");
  129 |         
  130 |         UserDetails userDetails = (UserDetails) authResult.getPrincipal();
  131 |         String username = userDetails.getUsername();
  132 |         
  133 |         // ì•¡ì„¸ìŠ¤ í† í° ìƒì„±
  134 |         String accessToken = jwtUtility.generateAccessToken(username, userDetails.getAuthorities());
  135 |         
  136 |         // ë¦¬í”„ë ˆì‹œ í† í° ìƒì„± ë° Redisì— ì €ì¥
  137 |         String refreshTokenId = UUID.randomUUID().toString();
  138 |         String refreshToken = jwtUtility.generateRefreshToken(username, refreshTokenId);
  139 |         
  140 |         // ì‚¬ìš©ì ID ì •ë³´ ì¶”ì¶œ
  141 |         User user = (User) userDetails;
  142 |         String userId = user.getId().toString();
  143 |         
  144 |         // Redisì— ë¦¬í”„ë ˆì‹œ í† í° ì €ì¥ (ì‚¬ìš©ì IDì™€ í•¨ê»˜)
  145 |         String redisKey = "JWT_RToken_" + userId + "_" + refreshTokenId;
  146 |         redisService.setValueWithExpiration(redisKey, refreshToken, jwtUtility.getRefreshTokenExpiration());
  147 |         
  148 |         // ì•¡ì„¸ìŠ¤ í† í°ê³¼ ë¦¬í”„ë ˆì‹œ í† í°ì„ ì¿ í‚¤ì— ì„¤ì •
  149 |         Cookie accessTokenCookie = createCookie("access_token", accessToken, jwtUtility.getAccessTokenExpiration() / 1000);
  150 |         Cookie refreshTokenCookie = createCookie("refresh_token", refreshToken, jwtUtility.getRefreshTokenExpiration() / 1000);
  151 |         
  152 |         response.addCookie(accessTokenCookie);
  153 |         response.addCookie(refreshTokenCookie);
  154 |         
  155 |         // ì‘ë‹µ ë°ì´í„° êµ¬ì„±
  156 |         Map<String, Object> responseData = new HashMap<>();
  157 |         responseData.put("status", "success");
  158 |         responseData.put("message", "ë¡œê·¸ì¸ ì„±ê³µ");
  159 |         responseData.put("timestamp", LocalDateTime.now().toString());
  160 |         
  161 |         // JSON ì‘ë‹µ ì „ì†¡
  162 |         response.setContentType(MediaType.APPLICATION_JSON_VALUE);
  163 |         response.setStatus(HttpStatus.OK.value());
  164 |         objectMapper.writeValue(response.getWriter(), responseData);
  165 |         
  166 |         log.debug("ì‚¬ìš©ì {} ì¸ì¦ ì™„ë£Œ, í† í° ë°œê¸‰ ì„±ê³µ", username);
  167 |     }
  168 | 
  169 |     /**
  170 |      * ì¿ í‚¤ ìƒì„± í—¬í¼ ë©”ì„œë“œ
  171 |      * @param name ì¿ í‚¤ ì´ë¦„
  172 |      * @param value ì¿ í‚¤ ê°’
  173 |      * @param maxAge ì¿ í‚¤ ë§Œë£Œ ì‹œê°„ (ì´ˆ)
  174 |      * @return ìƒì„±ëœ ì¿ í‚¤
  175 |      */
  176 |     private Cookie createCookie(String name, String value, long maxAge) {
  177 |         Cookie cookie = new Cookie(name, value);
  178 |         cookie.setHttpOnly(true);
  179 |         cookie.setSecure(true); // HTTPSì—ì„œë§Œ ì „ì†¡
  180 |         cookie.setPath("/");
  181 |         cookie.setDomain(cookieDomain);
  182 |         cookie.setMaxAge((int) maxAge);
  183 |         return cookie;
  184 |     }
  185 | 
  186 |     /**
  187 |      * ì¸ì¦ ì‹¤íŒ¨ ì²˜ë¦¬ ë©”ì„œë“œ
  188 |      * ì¸ì¦ ì‹¤íŒ¨ ì‹œ ì ì ˆí•œ ì˜¤ë¥˜ ë©”ì‹œì§€ë¥¼ í´ë¼ì´ì–¸íŠ¸ì—ê²Œ ì œê³µí•©ë‹ˆë‹¤.
  189 |      * @param request HTTP ìš”ì²­
  190 |      * @param response HTTP ì‘ë‹µ
  191 |      * @param failed ì¸ì¦ ì˜ˆì™¸
  192 |      * @throws IOException IO ì˜ˆì™¸
  193 |      * @throws ServletException ì„œë¸”ë¦¿ ì˜ˆì™¸
  194 |      */
  195 |     @Override
  196 |     protected void unsuccessfulAuthentication(HttpServletRequest request, HttpServletResponse response,
  197 |                                              AuthenticationException failed) 
  198 |                                              throws IOException, ServletException {
  199 |         log.warn("ì¸ì¦ ì‹¤íŒ¨: {}", failed.getMessage());
  200 |         
  201 |         Map<String, Object> errorResponse = new HashMap<>();
  202 |         errorResponse.put("status", "error");
  203 |         errorResponse.put("message", "ë¡œê·¸ì¸ ì‹¤íŒ¨: ì‚¬ìš©ì ì´ë¦„ ë˜ëŠ” ë¹„ë°€ë²ˆí˜¸ê°€ ì˜¬ë°”ë¥´ì§€ ì•ŠìŠµë‹ˆë‹¤.");
  204 |         errorResponse.put("timestamp", LocalDateTime.now().toString());
  205 |         
  206 |         response.setContentType(MediaType.APPLICATION_JSON_VALUE);
  207 |         response.setStatus(HttpStatus.UNAUTHORIZED.value());
  208 |         objectMapper.writeValue(response.getWriter(), errorResponse);
  209 |     }
  210 | 
  211 |     /**
  212 |      * PluggableFilter ì¸í„°í˜ì´ìŠ¤ êµ¬í˜„
  213 |      * í•„í„° ì„¤ì • ë©”ì„œë“œ
  214 |      */
  215 |     @Override
  216 |     public void configure(HttpSecurity http) throws Exception {
  217 |         http.addFilter(this);
  218 |     }
  219 | 
  220 |     /**
  221 |      * PluggableFilter ì¸í„°í˜ì´ìŠ¤ êµ¬í˜„
  222 |      * í•„í„° ìˆœì„œ ë°˜í™˜ ë©”ì„œë“œ
  223 |      */
  224 |     @Override
  225 |     public int getOrder() {
  226 |         return 2; // ì¸ì¦ í•„í„°ëŠ” ìš°ì„ ìˆœìœ„ê°€ ë¹„êµì  ë†’ì•„ì•¼ í•¨
  227 |     }
  228 | 
  229 |     /**
  230 |      * PluggableFilter ì¸í„°í˜ì´ìŠ¤ êµ¬í˜„
  231 |      * ì´ í•„í„° ì´ì „ì— ì ìš©ë  í•„í„° í´ë˜ìŠ¤ ë°˜í™˜
  232 |      */
  233 |     @Override
  234 |     public Class<? extends Filter> getBeforeFilter() {
  235 |         return UsernamePasswordAuthenticationFilter.class;
  236 |     }
  237 | 
  238 |     /**
  239 |      * PluggableFilter ì¸í„°í˜ì´ìŠ¤ êµ¬í˜„
  240 |      * ì´ í•„í„° ì´í›„ì— ì ìš©ë  í•„í„° í´ë˜ìŠ¤ ë°˜í™˜
  241 |      */
  242 |     @Override
  243 |     public Class<? extends Filter> getAfterFilter() {
  244 |         return null; // í˜„ì¬ í•„í„° ì´í›„ì— íŠ¹ì • í•„í„°ê°€ ì—†ìŒ
  245 |     }
  246 | 
  247 |     /**
  248 |      * PluggableFilter ì¸í„°í˜ì´ìŠ¤ êµ¬í˜„
  249 |      * í•„í„° ì²´ì¸ ë¡œì§ ì‹¤í–‰ ë©”ì„œë“œ
  250 |      */
  251 |     @Override
  252 |     public void doFilter(ServletRequest request, ServletResponse response, FilterChain chain) 
  253 |             throws IOException, ServletException {
  254 |         // ê¸°ë³¸ í•„í„° ë¡œì§ì€ UsernamePasswordAuthenticationFilterì—ì„œ ìƒì†ë¨
  255 |         // ì¶”ê°€ í•„í„° ë¡œì§ì´ í•„ìš”í•œ ê²½ìš° ì—¬ê¸°ì— êµ¬í˜„
  256 |         super.doFilter(request, response, chain);
  257 |     }
  258 | }
  259 |             throws AuthenticationException {
  260 |         log.info("â•”â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•—");
  261 |         log.info("â•‘                       Authentication Filter                   â•‘");
  262 |         log.info("â•šâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•");
  263 |         if (request.getCookies() != null) log.debug("request.getCookies() is not null");//jwtutility.deleteHttpOnlyCookie(request, response);
  264 | 
  265 |         // JSON ìš”ì²­ì—ì„œ ì‚¬ìš©ì ë¡œê·¸ì¸ ì •ë³´ ì½ê¸°
  266 |         loginRequest loginRequest;
  267 |         try {
  268 |             log.info("get loginRequest");
  269 |             loginRequest = objectMapper.readValue(request.getInputStream(), loginRequest.class);
  270 |         } catch (IOException e) {
  271 |             throw new RuntimeException(e);
  272 |         }
  273 | 
  274 |         log.info("login, userId : {}",loginRequest.getUserId());
  275 | 
  276 |         UsernamePasswordAuthenticationToken authenticationToken =
  277 |                 new UsernamePasswordAuthenticationToken(loginRequest.getUserId(), loginRequest.getPassword());
  278 | 
  279 |         log.info("login, authentication token created successfully");
  280 | 
  281 |         // ì‚¬ìš©ì ì¸ì¦ ì‹œë„
  282 |         Authentication authentication = null;
  283 |         try{
  284 |             authentication = authenticationManager.authenticate(authenticationToken);
  285 |         } catch (Exception e){
  286 |             log.error("authentication processing error", e);
  287 |         }
  288 | 
  289 |         if(!Objects.requireNonNull(authentication).isAuthenticated()){
  290 |             log.error("authentication failed");
  291 |             response.setStatus(401);
  292 |         }
  293 | 
  294 |         return authentication;
  295 |     }
  296 | 
  297 | 
  298 |     @Override
  299 |     protected void successfulAuthentication(HttpServletRequest request, HttpServletResponse response,
  300 |                                             FilterChain filterChain, Authentication authentication) throws  IOException{
  301 | 
  302 |         principalDetails principalDetails = (principalDetails) authentication.getPrincipal();
  303 |         tokenDto tokendto = jwtUtility.buildToken(principalDetails.getUserId(),
  304 |                 principalDetails.getNickname(), principalDetails.getAuthorities());
  305 | 
  306 |         log.info("Authentication successful for userId : {}", principalDetails.getUserId());
  307 |         log.info("Authentication token dto created");
  308 | 
  309 |         boolean RTokenSave = redisService.saveRToken(principalDetails.getUserId(), "server", tokendto.getRefreshToken());
  310 |         boolean accessTokenSave = redisService.saveAccessToken(tokendto.getRefreshToken(), tokendto.getAccessToken(), principalDetails.getUserId());
  311 |         log.info("redis save result R : {}, A : {} for userId {}", RTokenSave, accessTokenSave, principalDetails.getUserId());
  312 |         if (accessTokenSave && RTokenSave && jwtUtility.validateRefreshJWT(tokendto.getRefreshToken())){
  313 | 
  314 |             loginResponse(response, tokendto);
  315 | 
  316 |             response.setContentType("application/json");
  317 |             response.setCharacterEncoding("UTF-8");
  318 |             response.setStatus(HttpStatus.OK.value());
  319 | 
  320 |             // JSON í˜•ì‹ìœ¼ë¡œ ì‘ë‹µ ìƒì„± ë° ì „ì†¡ (access_token)
  321 |             String jsonResponse = new ObjectMapper().writeValueAsString(Map.of(
  322 |                     "access_token", tokendto.getAccessToken()
  323 |             ));
  324 |             response.getWriter().write(jsonResponse);
  325 | 
  326 |         } else {
  327 |             log.error("REDIS token save failed return SERVER_INTERNAL_ERROR");
  328 |             response.setStatus(HttpStatus.INTERNAL_SERVER_ERROR.value());
  329 |         }
  330 |     }
  331 | 
  332 | 
  333 |     private void loginResponse(HttpServletResponse response, tokenDto tokendto){
  334 |         Cookie newCookie = new Cookie("refreshToken", tokendto.getRefreshToken());
  335 |         newCookie.setHttpOnly(true);
  336 |         newCookie.setDomain(cookieDomain);
  337 |         newCookie.setPath("/");
  338 |         response.addCookie(newCookie);
  339 |         response.addHeader(SecurityConstants.TOKEN_HEADER,
  340 |                 SecurityConstants.TOKEN_PREFIX + tokendto.getAccessToken());
  341 |     }
  342 | 
  343 | }
  344 | 

#--------------------------------------------------------------------------------


# File: backend/src/main/java/com/authentication/auth/filter/snsRequestFilter.java
#=============================================================================

    1 | package com.authentication.auth.filter;
    2 | 
    3 | import com.authentication.auth.DTO.token.tokenDto;
    4 | import com.authentication.auth.configuration.token.jwtUtility;
    5 | import com.authentication.auth.domain.users;
    6 | import com.authentication.auth.others.constants.SecurityConstants;
    7 | import com.authentication.auth.service.oauth2.oauth2Service;
    8 | import com.authentication.auth.service.oauth2.snsTokenValidator;
    9 | import com.authentication.auth.service.redis.redisService;
   10 | 
   11 | import jakarta.servlet.FilterChain;
   12 | import jakarta.servlet.ServletException;
   13 | import jakarta.servlet.http.Cookie;
   14 | import jakarta.servlet.http.HttpServletRequest;
   15 | import jakarta.servlet.http.HttpServletResponse;
   16 | import lombok.extern.slf4j.Slf4j;
   17 | import org.springframework.beans.factory.annotation.Value;
   18 | import org.springframework.security.core.Authentication;
   19 | import org.springframework.security.core.authority.SimpleGrantedAuthority;
   20 | import org.springframework.security.core.context.SecurityContextHolder;
   21 | import org.springframework.stereotype.Component;
   22 | import org.springframework.web.filter.OncePerRequestFilter;
   23 | 
   24 | import java.io.IOException;
   25 | import java.security.SecureRandom;
   26 | import java.text.ParseException;
   27 | import java.text.SimpleDateFormat;
   28 | import java.util.Collections;
   29 | import java.util.Date;
   30 | import java.util.Map;
   31 | import java.util.Random;
   32 | 
   33 | @Slf4j
   34 | @Component
   35 | public class snsRequestFilter implements PluggableFilter {
   36 | 
   37 |     private final JwtUtility jwtUtility;
   38 |     private final RedisService redisService;
   39 | 
   40 | 
   41 |     @Value("${site.domain}")
   42 |     private String domain;
   43 | 
   44 |     public snsRequestFilter(jwtUtility jwtUtility, redisService redisService, snsTokenValidator snsTokenValidator, oauth2Service oauth2Service) {
   45 |         this.jwtUtility = jwtUtility;
   46 |         this.redisService = redisService;
   47 |         this.snsTokenValidator = snsTokenValidator;
   48 |         this.oauth2Service = oauth2Service;
   49 |     }
   50 | 
   51 |     @Override
   52 |     protected void doFilterInternal(HttpServletRequest request, HttpServletResponse response, FilterChain filterChain) throws ServletException, IOException {
   53 | 
   54 |         String providerHeader = request.getHeader("provider"); // SNS ì •ë³´ ì œê³µì ì¶”ê°€í•˜ê¸°
   55 |         String authorizationHolder = request.getHeader(SecurityConstants.TOKEN_HEADER);
   56 |         log.info("authorizationHolder logging for test {}", authorizationHolder);
   57 | 
   58 |         log.info("current SNS providerHeader is {} ", providerHeader);
   59 | 
   60 |         if (providerHeader == null || "server".equals(providerHeader)) {
   61 |             filterChain.doFilter(request, response);
   62 |             return;
   63 |         }
   64 | 
   65 |         if (!isBearerToken(authorizationHolder)) {
   66 |             log.error("authorization is null");
   67 |             filterChain.doFilter(request, response);
   68 |             return;
   69 |         }
   70 | 
   71 |         String JWT = extractToken(authorizationHolder);
   72 | 
   73 |         if (JWT == null) {
   74 |             filterChain.doFilter(request, response);
   75 |             return;
   76 |         }
   77 | 
   78 |         if (jwtUtility.validateJWT(JWT)) {
   79 |             setAuthentication(JWT);
   80 |         } else {
   81 |             handleRefreshToken(request, response, JWT, providerHeader);
   82 |         }
   83 | 
   84 |         filterChain.doFilter(request, response);
   85 |     }
   86 | 
   87 | 
   88 |     private void handleRefreshToken(HttpServletRequest request, HttpServletResponse response, String JWT, String providerHeader) throws IOException {
   89 |         String snsRefreshToken = jwtUtility.checkSnsCookie(request, response);
   90 |         if (snsRefreshToken == null) {
   91 |             log.warn("no refresh token exists in cookies .. ");
   92 |             return;
   93 |         }
   94 | 
   95 |         String userId = getUserIdFromJWT(JWT);
   96 |         if (RedisMatchSnsRToken(userId, snsRefreshToken)) {
   97 |             refreshTokenAndAuthenticate(request, response, snsRefreshToken, providerHeader, userId);
   98 |         } else {
   99 |             log.warn("sns refreshToken does not exist in redis .. ");
  100 |         }
  101 |     }
  102 | 
  103 |     private void refreshTokenAndAuthenticate(HttpServletRequest request, HttpServletResponse response, String snsRefreshToken, String providerHeader, String userId) throws IOException {
  104 |         Map<String, String> newTokens = snsTokenValidator.getNewTokenByRefreshToken(snsRefreshToken, providerHeader);
  105 |         String newSnsAccessToken = newTokens.get("access_token");
  106 | 
  107 |         if (newSnsAccessToken == null) {
  108 |             log.error("access token does not exist");
  109 |             return;
  110 |         }
  111 | 
  112 |         Map<String, Object> snsUserProfile = getSnsUserProfile(newSnsAccessToken, providerHeader);
  113 |         if (snsUserProfile == null) {
  114 |             log.error("cannot get any sns userProfiles");
  115 |             return;
  116 |         }
  117 | 
  118 |         String oauthId = extractOauthId(snsUserProfile, providerHeader);
  119 |         redisService.saveRToken(oauthId, providerHeader, snsRefreshToken);
  120 | 
  121 |         users user = oauth2Service.saveOrUpdateOauth2User(providerHeader, oauthId, snsUserProfile);
  122 |         tokenDto accessToken = jwtUtility.createToken(user.getUserId(), user.getNickname(), Collections.singletonList(new SimpleGrantedAuthority(user.getRole().name())));
  123 |         loginResponse(response, accessToken.getAccessToken(), snsRefreshToken, providerHeader);
  124 | 
  125 |         setAuthentication(accessToken.getAccessToken());
  126 |     }
  127 | 
  128 |     private String extractOauthId(Map<String, Object> snsUserProfile, String providerHeader) {
  129 |         return switch (providerHeader) {
  130 |             case "naver" -> ((Map<String, Object>) snsUserProfile.get("response")).get("id").toString();
  131 |             case "kakao" -> snsUserProfile.get("id").toString();
  132 |             default -> snsUserProfile.get("sub").toString();
  133 |         };
  134 |     }
  135 | 
  136 | 
  137 |     private String getUserIdFromJWT(String JWT) {
  138 |         return (String) jwtUtility.getClaimsFromAccessToken(JWT).get("userId");
  139 |     }
  140 | 
  141 | 
  142 | 
  143 |     private boolean RedisMatchSnsRToken(String userId, String RToken) {
  144 |         return redisService.findRToken(userId, "server", RToken);
  145 |     }
  146 | 
  147 |     private Map<String, Object> getSnsUserProfile(String access_token, String provider) {
  148 |         Map<String, Object> userProfile = null;
  149 |         switch (provider) {
  150 |             case "kakao" :
  151 |                 userProfile = oauth2Service.getKakaoUserProfile(access_token);
  152 |                 break;
  153 |             case "naver" :
  154 |                 userProfile = oauth2Service.getNaverUserProfile(access_token);
  155 |                 break;
  156 |             case "google" :
  157 |                 userProfile = oauth2Service.getGoogleUserProfile(access_token);
  158 |                 break;
  159 |             default:
  160 |                 throw new IllegalArgumentException("Unsupported provider: " + provider);
  161 |         }
  162 |         return userProfile;
  163 |     }
  164 | 
  165 |     private void loginResponse(HttpServletResponse response, String accessToken, String refreshToken, String provider) {
  166 |         Cookie newCookie = new Cookie(provider + "_refreshToken", refreshToken);
  167 |         newCookie.setHttpOnly(true);
  168 |         newCookie.setDomain(domain);
  169 |         newCookie.setPath("/");
  170 |         response.addCookie(newCookie);
  171 | 
  172 |         response.addHeader(SecurityConstants.TOKEN_HEADER, SecurityConstants.TOKEN_PREFIX + accessToken);
  173 |     }
  174 | 
  175 | 
  176 |     private Date parseBirthday(String birthday) {
  177 |         if (birthday != null && birthday.length() == 5) {
  178 |             try {
  179 |                 SimpleDateFormat sdf = new SimpleDateFormat("MM-dd");
  180 |                 Date date = sdf.parse(birthday);
  181 |                 return date;
  182 |             } catch (ParseException e) {
  183 |                 log.error("Error parsing birthday: ", e);
  184 |             }
  185 |         }
  186 |         return null; // Implement proper parsing if different format
  187 |     }
  188 | 
  189 | 
  190 |     private String generateRandomString(int length) {
  191 |         final String characters = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789";
  192 |         Random random = new SecureRandom();
  193 |         StringBuilder sb = new StringBuilder(length);
  194 | 
  195 |         for (int i = 0; i < length; i++) {
  196 |             sb.append(characters.charAt(random.nextInt(characters.length())));
  197 |         }
  198 | 
  199 |         return sb.toString();
  200 |     }
  201 | 
  202 |     private String extractToken(String authorizationHolder) {
  203 |         return authorizationHolder != null ? authorizationHolder.split(" ")[1] : null;
  204 |     }
  205 | 
  206 | 
  207 |     private boolean isBearerToken(String authorization) {
  208 |         return authorization != null && authorization.startsWith("Bearer ");
  209 |     }
  210 | 
  211 |     private void setAuthentication(String JWT) {
  212 |         try {
  213 |             Authentication authentication = jwtUtility.getAuthentication(JWT);
  214 |             SecurityContextHolder.getContext().setAuthentication(authentication);
  215 |             log.info("ìœ íš¨í•œ SNS authorization access_token");
  216 |         } catch (Exception e) {
  217 |             log.error("ì¸ì¦ ì‹¤íŒ¨!!");
  218 |         }
  219 |     }
  220 |         
  221 |         @Override
  222 |         public void configure(HttpSecurity http) throws Exception {
  223 |             http.addFilterBefore(this, JwtVerificationFilter.class);
  224 |         }
  225 |     
  226 |         @Override
  227 |         public int getOrder() {
  228 |             return 150; // AuthenticationFilterì™€ JwtVerificationFilter ì‚¬ì´ ìˆœì„œ
  229 |         }
  230 |     
  231 |         @Override
  232 |         public Class<? extends Filter> getBeforeFilter() {
  233 |             return AuthenticationFilter.class;
  234 |         }
  235 |     
  236 |         @Override
  237 |         public Class<? extends Filter> getAfterFilter() {
  238 |             return JwtVerificationFilter.class;
  239 |         }
  240 | }

#--------------------------------------------------------------------------------


# File: backend/src/main/java/com/authentication/auth/filter/securityFilterOrder.java
#=============================================================================

    1 | package com.authentication.auth.filter;
    2 | 
    3 | import java.util.HashMap;
    4 | import java.util.Map;
    5 | 
    6 | import lombok.Getter;
    7 | 
    8 | /**
    9 |  * @Author : choisimo 
   10 |  * @Date : 2025-05-05
   11 |  * @Description : SecurityFilterOrder enum class
   12 |  * @Details : í•„í„° ì²´ì¸ì—ì„œ í•„í„°ì˜ ìˆœì„œë¥¼ ì§€ì •í•˜ëŠ” ì—´ê±°í˜• í´ë˜ìŠ¤
   13 |  */
   14 | 
   15 | @Getter
   16 | public enum SecurityFilterOrder {
   17 |     /**
   18 |      * í•„í„° ì‹¤í–‰ ìˆœì„œë¥¼ ë‚˜íƒ€ë‚´ëŠ” enum
   19 |      * order ê°’ì´ ë‚®ì„ìˆ˜ë¡ ìš°ì„ ìˆœìœ„ê°€ ë†’ìŒ
   20 |      */
   21 |     AUTHENTICATION_FILTER(100),
   22 |     AUTHORIZATION_FILTER(200),
   23 |     SNS_REQUEST_FILTER(300);
   24 | 
   25 |     // í•„í„° ìˆœì„œ ê°’
   26 |     private final int order;
   27 |     
   28 |     // order ê°’ìœ¼ë¡œ í•„í„°ë¥¼ ë¹ ë¥´ê²Œ ì¡°íšŒí•˜ê¸° ìœ„í•œ ë§µ (BigO(1))
   29 |     private static final Map<Integer, SecurityFilterOrder> ORDER_MAP = new HashMap<>();
   30 | 
   31 |     static {
   32 |         for (SecurityFilterOrder filter : SecurityFilterOrder.values()) {
   33 |             ORDER_MAP.put(filter.order, filter);
   34 |         }
   35 |     }
   36 | 
   37 |     SecurityFilterOrder(int order) {
   38 |         this.order = order;
   39 |     }
   40 | 
   41 |     /**
   42 |      * ìˆœì„œ ê°’ìœ¼ë¡œ í•„í„° ì—´ê±°í˜•ì„ ì¡°íšŒ
   43 |      * @param order í•„í„° ìˆœì„œ ê°’
   44 |      * @return í•´ë‹¹ ìˆœì„œì˜ í•„í„° ì—´ê±°í˜•
   45 |      * @throws IllegalArgumentException ìœ íš¨í•˜ì§€ ì•Šì€ ìˆœì„œê°’ ì…ë ¥ ì‹œ
   46 |      */
   47 |     public static SecurityFilterOrder fromOrder(int order) {
   48 |         SecurityFilterOrder filter = ORDER_MAP.get(order);
   49 |         if (filter == null) {
   50 |             throw new IllegalArgumentException("ìœ íš¨í•˜ì§€ ì•Šì€ í•„í„° ìˆœì„œ: " + order);
   51 |         }
   52 |         return filter;
   53 |     }
   54 | 
   55 |     /**
   56 |      * ë¬¸ìì—´ì„ ì•ˆì „í•˜ê²Œ í•„í„° ì—´ê±°í˜•ìœ¼ë¡œ ë³€í™˜
   57 |      * @param name í•„í„° ì´ë¦„
   58 |      * @return í•´ë‹¹ ì´ë¦„ì˜ í•„í„° ì—´ê±°í˜•, ì—†ìœ¼ë©´ ê¸°ë³¸ê°’ ë°˜í™˜
   59 |      */
   60 |     public static SecurityFilterOrder safeValueOf(String name) {
   61 |         try {
   62 |             return SecurityFilterOrder.valueOf(name);
   63 |         } catch (IllegalArgumentException e) {
   64 |             return SecurityFilterOrder.AUTHENTICATION_FILTER; // ê¸°ë³¸ê°’
   65 |         }
   66 |     }
   67 | }

#--------------------------------------------------------------------------------


# File: backend/src/main/java/com/authentication/auth/filter/FilterCondition.java
#=============================================================================

    1 | package com.authentication.auth.filter;
    2 | 
    3 | import jakarta.servlet.http.HttpServletRequest;
    4 | 
    5 | /**
    6 |  * @Author: choisimo
    7 |  * @Date: 2025-05-05
    8 |  * @Description: í•„í„° ì¡°ê±´ ì¸í„°í˜ì´ìŠ¤
    9 |  * @Details: í•„í„° ì ìš© ì¡°ê±´ì„ ì •ì˜í•˜ëŠ” ì¸í„°í˜ì´ìŠ¤
   10 |  */
   11 | public interface FilterCondition {
   12 |     
   13 |     /**
   14 |      * ìš”ì²­ì— í•„í„°ë¥¼ ì ìš©í• ì§€ ì—¬ë¶€ë¥¼ ê²°ì •
   15 |      * @param request HTTP ìš”ì²­
   16 |      * @return trueì´ë©´ í•„í„°ë¥¼ ì ìš©í•˜ì§€ ì•ŠìŒ, falseì´ë©´ í•„í„° ì ìš©
   17 |      */
   18 |     boolean shouldNotFilter(HttpServletRequest request);
   19 |     
   20 |     /**
   21 |      * ì¡°ê±´ì— ì„¤ëª…ì„ ì œê³µ
   22 |      * @return ì¡°ê±´ ì„¤ëª…
   23 |      */
   24 |     String getDescription();
   25 | }

#--------------------------------------------------------------------------------


# File: backend/src/main/java/com/authentication/auth/filter/AbstractAuthenticationFilter.java
#=============================================================================

    1 | package com.authentication.auth.filter;
    2 | 
    3 | import com.authentication.auth.configuration.token.JwtUtility;
    4 | import com.authentication.auth.service.RedisService;
    5 | import com.fasterxml.jackson.databind.ObjectMapper;
    6 | import jakarta.servlet.Filter;
    7 | import jakarta.servlet.FilterChain;
    8 | import jakarta.servlet.ServletException;
    9 | import jakarta.servlet.http.HttpServletRequest;
   10 | import jakarta.servlet.http.HttpServletResponse;
   11 | import lombok.RequiredArgsConstructor;
   12 | import lombok.extern.slf4j.Slf4j;
   13 | import org.springframework.security.authentication.AuthenticationManager;
   14 | import org.springframework.security.authentication.UsernamePasswordAuthenticationToken;
   15 | import org.springframework.security.config.annotation.web.builders.HttpSecurity;
   16 | import org.springframework.security.core.Authentication;
   17 | import org.springframework.security.core.AuthenticationException;
   18 | import org.springframework.security.web.authentication.UsernamePasswordAuthenticationFilter;
   19 | import org.springframework.stereotype.Component;
   20 | 
   21 | import java.io.IOException;
   22 | 
   23 | /**
   24 |  * @Author: choisimo
   25 |  * @Date: 2025-05-05
   26 |  * @Description: ì¸ì¦ í•„í„° ì¶”ìƒ í´ë˜ìŠ¤
   27 |  * @Details: ì‚¬ìš©ì ë¡œê·¸ì¸ ìš”ì²­ì„ ì²˜ë¦¬í•˜ê³  JWT í† í°ì„ ìƒì„±í•˜ëŠ” í•„í„°ì˜ ê¸°ë³¸ êµ¬ì¡° ì •ì˜
   28 |  * 
   29 |  * ì¶”ìƒ(abstract) í´ë˜ìŠ¤ vs êµ¬ì²´ì  êµ¬í˜„ í´ë˜ìŠ¤ ì°¨ì´ì :
   30 |  * 1. ì¶”ìƒ í´ë˜ìŠ¤: 
   31 |  *    - ë¶ˆì™„ì „í•œ ì„¤ê³„ë¥¼ ì œê³µí•˜ë©° ìƒì†ì„ í†µí•´ êµ¬ì²´ì  êµ¬í˜„ì„ ê°•ì œí•©ë‹ˆë‹¤.
   32 |  *    - ìì‹ í´ë˜ìŠ¤ê°€ ë°˜ë“œì‹œ êµ¬í˜„í•´ì•¼ í•˜ëŠ” ë©”ì†Œë“œë¥¼ ì •ì˜í•  ìˆ˜ ìˆìŠµë‹ˆë‹¤.
   33 |  *    - ê³µí†µ ê¸°ëŠ¥ì„ ì œê³µí•˜ë©´ì„œ í™•ì¥ì„±ì„ ë³´ì¥í•©ë‹ˆë‹¤.
   34 |  *    - ì´ ë°©ì‹ì€ í”„ë ˆì„ì›Œí¬ë‚˜ ë¼ì´ë¸ŒëŸ¬ë¦¬ë¥¼ ì„¤ê³„í•  ë•Œ ìœ ìš©í•©ë‹ˆë‹¤.
   35 |  *    
   36 |  * 2. êµ¬ì²´ì  êµ¬í˜„ í´ë˜ìŠ¤: 
   37 |  *    - ì§ì ‘ ì¸ìŠ¤í„´ìŠ¤í™” ê°€ëŠ¥í•˜ê³  ëª¨ë“  ë©”ì†Œë“œê°€ êµ¬í˜„ë˜ì–´ ìˆìŠµë‹ˆë‹¤.
   38 |  *    - íŠ¹ì •í•œ ë¹„ì¦ˆë‹ˆìŠ¤ ë¡œì§ì— ë§ê²Œ ìµœì í™”ë˜ì–´ ìˆìŠµë‹ˆë‹¤.
   39 |  *    - ìƒì†ë³´ë‹¤ëŠ” íŠ¹ì • ì¸í„°í˜ì´ìŠ¤ êµ¬í˜„ì— ì¤‘ì ì„ ë‘¡ë‹ˆë‹¤.
   40 |  *    - ì´ ë°©ì‹ì€ ì‹¤ì œ ì• í”Œë¦¬ì¼€ì´ì…˜ ë¡œì§ì„ êµ¬í˜„í•  ë•Œ ì í•©í•©ë‹ˆë‹¤.
   41 |  *    
   42 |  * ì ‘ê·¼ ì œí•œì ì‚¬ìš©:
   43 |  * - private: í´ë˜ìŠ¤ ë‚´ë¶€ì—ì„œë§Œ ì ‘ê·¼ ê°€ëŠ¥í•œ í•„ë“œë“¤(authenticationManager ë“±)ì€ ìº¡ìŠí™”ë¥¼ ìœ„í•´ ì‚¬ìš©
   44 |  * - protected: ìƒì† ê´€ê³„ì—ì„œ ìì‹ í´ë˜ìŠ¤ì—ê²Œ ì ‘ê·¼ì„ í—ˆìš©í•˜ê¸° ìœ„í•´ ì¼ë¶€ ë©”ì†Œë“œì— ì‚¬ìš©
   45 |  * - public: ì™¸ë¶€ì—ì„œ í˜¸ì¶œ ê°€ëŠ¥í•œ APIë¥¼ ì œê³µí•˜ê¸° ìœ„í•´ ì‚¬ìš©
   46 |  */
   47 | @Slf4j
   48 | @Component
   49 | @RequiredArgsConstructor
   50 | public abstract class AbstractAuthenticationFilter extends UsernamePasswordAuthenticationFilter implements PluggableFilter {
   51 |     
   52 |     private final AuthenticationManager authenticationManager;
   53 |     private final JwtUtility jwtUtility;
   54 |     private final ObjectMapper objectMapper;
   55 |     private final RedisService redisService;
   56 |     private final String domain;
   57 |     private final String cookieDomain;
   58 |     
   59 |     /**
   60 |      * ì¶”ìƒ í´ë˜ìŠ¤ êµ¬í˜„ì—ì„œëŠ” ê³µí†µëœ ì¸ì¦ ë¡œì§ì„ ì œê³µí•©ë‹ˆë‹¤.
   61 |      * ì´ ë©”ì†Œë“œëŠ” publicìœ¼ë¡œ ì„ ì–¸ë˜ì–´ Spring Security í•„í„° ì²´ì¸ì—ì„œ ì§ì ‘ í˜¸ì¶œë  ìˆ˜ ìˆìŠµë‹ˆë‹¤.
   62 |      * 
   63 |      * ë°˜ë©´ êµ¬ì²´ì  êµ¬í˜„ í´ë˜ìŠ¤ì—ì„œëŠ” doFilterInternal ë©”ì†Œë“œë¥¼ í™œìš©í•´ ë” ì„¸ë¶€ì ì¸ ì¸ì¦ ë¡œì§ì„ êµ¬í˜„í•©ë‹ˆë‹¤.
   64 |      * ì´ ë°©ì‹ì€ JWT í† í° ê²€ì¦ê³¼ ê°™ì€ íŠ¹ì • ì¸ì¦ ë°©ì‹ì— ìµœì í™”ë˜ì–´ ìˆìŠµë‹ˆë‹¤.
   65 |      */
   66 |     @Override
   67 |     public Authentication attemptAuthentication(HttpServletRequest request, HttpServletResponse response) throws AuthenticationException {
   68 |         log.info("ì¸ì¦ ì‹œë„");
   69 |         try {
   70 |             // ì‚¬ìš©ì ì¸ì¦ ë¡œì§
   71 |             // ë¡œê·¸ì¸ ìš”ì²­ì—ì„œ ì‚¬ìš©ì ì´ë¦„ê³¼ ë¹„ë°€ë²ˆí˜¸ ì¶”ì¶œ
   72 |             // ì¸ì¦ ê´€ë¦¬ìë¥¼ í†µí•´ ì¸ì¦ ì‹œë„
   73 |             return authenticationManager.authenticate(
   74 |                     new UsernamePasswordAuthenticationToken(request.getParameter("username"), request.getParameter("password"))
   75 |             );
   76 |         } catch (Exception e) {
   77 |             log.error("ì¸ì¦ ì‹œë„ ì¤‘ ì˜¤ë¥˜ ë°œìƒ: ", e);
   78 |             throw new AuthenticationException("ì¸ì¦ ì‹¤íŒ¨") {};
   79 |         }
   80 |     }
   81 | package com.authentication.auth.filter;
   82 | 
   83 | import com.authentication.auth.configuration.token.JwtUtility;
   84 | import com.authentication.auth.service.RedisService;
   85 | import com.fasterxml.jackson.databind.ObjectMapper;
   86 | import jakarta.servlet.FilterChain;
   87 | import jakarta.servlet.ServletException;
   88 | import jakarta.servlet.http.HttpServletRequest;
   89 | import jakarta.servlet.http.HttpServletResponse;
   90 | import lombok.extern.slf4j.Slf4j;
   91 | import org.springframework.security.authentication.AuthenticationManager;
   92 | import org.springframework.security.authentication.UsernamePasswordAuthenticationToken;
   93 | import org.springframework.security.core.Authentication;
   94 | import org.springframework.security.core.AuthenticationException;
   95 | import org.springframework.security.web.authentication.UsernamePasswordAuthenticationFilter;
   96 | 
   97 | import java.io.IOException;
   98 | import java.util.Map;
   99 | 
  100 | /**
  101 |  * @Author: choisimo
  102 |  * @Date: 2025-05-05
  103 |  * @Description: ì¶”ìƒ ì¸ì¦ í•„í„°
  104 |  * @Details: ì¸ì¦ ì²˜ë¦¬ë¥¼ ìœ„í•œ ê¸°ë³¸ ê¸°ëŠ¥ì„ ì œê³µí•˜ëŠ” ì¶”ìƒ í•„í„° í´ë˜ìŠ¤
  105 |  */
  106 | @Slf4j
  107 | public abstract class AbstractAuthenticationFilter extends UsernamePasswordAuthenticationFilter implements PluggableFilter {
  108 |     
  109 |     protected final AuthenticationManager authenticationManager;
  110 |     protected final JwtUtility jwtUtility;
  111 |     protected final ObjectMapper objectMapper;
  112 |     protected final RedisService redisService;
  113 |     protected final String domain;
  114 |     protected final String cookieDomain;
  115 |     
  116 |     protected AbstractAuthenticationFilter(
  117 |             AuthenticationManager authenticationManager,
  118 |             JwtUtility jwtUtility,
  119 |             ObjectMapper objectMapper,
  120 |             RedisService redisService,
  121 |             String domain,
  122 |             String cookieDomain) {
  123 |         this.authenticationManager = authenticationManager;
  124 |         this.jwtUtility = jwtUtility;
  125 |         this.objectMapper = objectMapper;
  126 |         this.redisService = redisService;
  127 |         this.domain = domain;
  128 |         this.cookieDomain = cookieDomain;
  129 |         
  130 |         setAuthenticationManager(authenticationManager);
  131 |     }
  132 |     
  133 |     @Override
  134 |     public Authentication attemptAuthentication(HttpServletRequest request, HttpServletResponse response) 
  135 |             throws AuthenticationException {
  136 |         try {
  137 |             // ìš”ì²­ ë³¸ë¬¸ì—ì„œ ì‚¬ìš©ì ì •ë³´ íŒŒì‹±
  138 |             Map<String, String> credentials = objectMapper.readValue(
  139 |                     request.getInputStream(), Map.class);
  140 |             
  141 |             String username = credentials.get("username");
  142 |             String password = credentials.get("password");
  143 |             
  144 |             log.debug("ì‚¬ìš©ì ë¡œê·¸ì¸ ì‹œë„: {}", username);
  145 |             
  146 |             // ì¸ì¦ í† í° ìƒì„± ë° ì¸ì¦ ìš”ì²­
  147 |             UsernamePasswordAuthenticationToken authToken = 
  148 |                     new UsernamePasswordAuthenticationToken(username, password);
  149 |             
  150 |             return authenticationManager.authenticate(authToken);
  151 |         } catch (IOException e) {
  152 |             log.error("ì¸ì¦ ìš”ì²­ ì²˜ë¦¬ ì¤‘ ì˜¤ë¥˜ ë°œìƒ", e);
  153 |             throw new RuntimeException("ì¸ì¦ ìš”ì²­ì„ ì²˜ë¦¬í•  ìˆ˜ ì—†ìŠµë‹ˆë‹¤", e);
  154 |         }
  155 |     }
  156 |     
  157 |     @Override
  158 |     public String getFilterId() {
  159 |         return this.getClass().getSimpleName();
  160 |     }
  161 | }
  162 |     @Override
  163 |     protected void successfulAuthentication(HttpServletRequest request, HttpServletResponse response,
  164 |                                            FilterChain chain, Authentication authResult) throws IOException, ServletException {
  165 |         log.info("ì¸ì¦ ì„±ê³µ");
  166 |         // JWT í† í° ìƒì„± ë° ì‘ë‹µì— ì¶”ê°€
  167 |         // SecurityContextì— ì¸ì¦ ì •ë³´ ì„¤ì •
  168 |     }

#--------------------------------------------------------------------------------


# File: backend/src/main/java/com/authentication/auth/filter/authorizationFilter.java
#=============================================================================

    1 | package com.authentication.auth.filter;
    2 | package com.authentication.auth.filter;
    3 | 
    4 | import com.authentication.auth.configuration.token.JwtUtility;
    5 | import com.fasterxml.jackson.databind.ObjectMapper;
    6 | import jakarta.annotation.PostConstruct;
    7 | import jakarta.servlet.Filter;
    8 | import jakarta.servlet.FilterChain;
    9 | import jakarta.servlet.ServletException;
   10 | import jakarta.servlet.http.HttpServletRequest;
   11 | import jakarta.servlet.http.HttpServletResponse;
   12 | import lombok.extern.slf4j.Slf4j;
   13 | import org.springframework.beans.factory.annotation.Autowired;
   14 | import org.springframework.http.HttpMethod;
   15 | import org.springframework.http.MediaType;
   16 | import org.springframework.security.authentication.UsernamePasswordAuthenticationToken;
   17 | import org.springframework.security.config.annotation.web.builders.HttpSecurity;
   18 | import org.springframework.security.core.Authentication;
   19 | import org.springframework.security.core.authority.SimpleGrantedAuthority;
   20 | import org.springframework.security.core.context.SecurityContextHolder;
   21 | import org.springframework.stereotype.Component;
   22 | 
   23 | import java.io.IOException;
   24 | import java.util.Collections;
   25 | import java.util.HashMap;
   26 | import java.util.Map;
   27 | import java.util.Set;
   28 | 
   29 | /**
   30 |  * @Author: choisimo
   31 |  * @Date: 2025-05-05
   32 |  * @Description: ê¶Œí•œ ë¶€ì—¬ í•„í„°
   33 |  * @Details: JWT í† í°ì˜ ìœ íš¨ì„±ì„ ê²€ì¦í•˜ê³  ì‚¬ìš©ì ê¶Œí•œì„ ê²€ì‚¬í•˜ëŠ” í•„í„°
   34 |  */
   35 | @Slf4j
   36 | @Component
   37 | public class authorizationFilter extends AbstractSecurityFilter {
   38 | 
   39 |     private final JwtUtility jwtUtility;
   40 |     private final ObjectMapper objectMapper;
   41 |     private final FilterRegistry filterRegistry;
   42 |     private final Set<String> adminRoles = Set.of("ROLE_ADMIN", "ADMIN");
   43 | 
   44 |     @Autowired
   45 |     public authorizationFilter(
   46 |             JwtUtility jwtUtility,
   47 |             ObjectMapper objectMapper,
   48 |             FilterRegistry filterRegistry) {
   49 |         super(SecurityFilterOrder.AUTHORIZATION_FILTER);
   50 |         this.jwtUtility = jwtUtility;
   51 |         this.objectMapper = objectMapper;
   52 |         this.filterRegistry = filterRegistry;
   53 |     }
   54 | 
   55 |     /**
   56 |      * í•„í„° ì´ˆê¸°í™” ë° ë ˆì§€ìŠ¤íŠ¸ë¦¬ì— ë“±ë¡
   57 |      */
   58 |     @PostConstruct
   59 |     public void init() {
   60 |         // í•„í„° ë ˆì§€ìŠ¤íŠ¸ë¦¬ì— ì´ í•„í„° ë“±ë¡
   61 |         filterRegistry.registerFilter(this);
   62 | 
   63 |         // ê¸°ë³¸ í•„í„° ì¡°ê±´ ì„¤ì • - ê³µê°œ APIëŠ” ê¶Œí•œ í•„í„° ì ìš©í•˜ì§€ ì•ŠìŒ
   64 |         PathPatternFilterCondition publicApiCondition = new PathPatternFilterCondition(
   65 |                 "ê¶Œí•œ í™•ì¸ ë¶ˆí•„ìš” ê²½ë¡œ",
   66 |                 "/api/public/**",
   67 |                 "/api/auth/login",
   68 |                 "/api/auth/register",
   69 |                 "/api/auth/refresh",
   70 |                 "/swagger-ui/**",
   71 |                 "/v3/api-docs/**"
   72 |         );
   73 | 
   74 |         // ê´€ë¦¬ì ì „ìš© APIëŠ” ADMIN ì—­í•  í•„ìš”
   75 |         PathPatternFilterCondition adminApiCondition = new PathPatternFilterCondition(
   76 |                 "ê´€ë¦¬ì ì „ìš© API",
   77 |                 "/api/admin/**"
   78 |         );
   79 | 
   80 |         // í•„í„° ë ˆì§€ìŠ¤íŠ¸ë¦¬ì— ì¡°ê±´ ì¶”ê°€
   81 |         filterRegistry.addCondition(getFilterId(), publicApiCondition);
   82 |     }
   83 | 
   84 |     @Override
   85 |     protected void doFilterInternal(HttpServletRequest request, HttpServletResponse response, FilterChain chain)
   86 |             throws IOException, ServletException {
   87 |         
   88 |         String path = request.getRequestURI();
   89 |         log.debug("ê¶Œí•œ ë¶€ì—¬ í•„í„° ì‹¤í–‰: {}", path);
   90 |         
   91 |         try {
   92 |             // í† í°ì—ì„œ ì¸ì¦ ì •ë³´ ì¶”ì¶œ
   93 |             String token = extractToken(request);
   94 |             
   95 |             if (token != null && jwtUtility.validateToken(token)) {
   96 |                 String username = jwtUtility.getUsernameFromToken(token);
   97 |                 Set<String> roles = jwtUtility.getRolesFromToken(token);
   98 |                 
   99 |                 // ê´€ë¦¬ì ì „ìš© API ì ‘ê·¼ ì œí•œ
  100 |                 if (path.startsWith("/api/admin") && !hasAdminRole(roles)) {
  101 |                     sendForbiddenResponse(response, "ê´€ë¦¬ì ê¶Œí•œì´ í•„ìš”í•©ë‹ˆë‹¤.");
  102 |                     return;
  103 |                 }
  104 |                 
  105 |                 // ì¸ì¦ ì •ë³´ ì„¤ì •
  106 |                 Authentication authentication = createAuthentication(username, roles);
  107 |                 SecurityContextHolder.getContext().setAuthentication(authentication);
  108 |                 
  109 |                 log.debug("ì‚¬ìš©ì '{}' ì¸ì¦ ì„±ê³µ, ê¶Œí•œ: {}", username, roles);
  110 |             }
  111 |             
  112 |             chain.doFilter(request, response);
  113 |         } catch (Exception e) {
  114 |             log.error("ê¶Œí•œ ë¶€ì—¬ í•„í„° ì‹¤í–‰ ì¤‘ ì˜¤ë¥˜ ë°œìƒ: {}", e.getMessage());
  115 |             sendErrorResponse(response, "ì¸ì¦ ì²˜ë¦¬ ì¤‘ ì˜¤ë¥˜ê°€ ë°œìƒí–ˆìŠµë‹ˆë‹¤: " + e.getMessage());
  116 |         } finally {
  117 |             // ì´ë¯¸ ì‘ë‹µì´ ì»¤ë°‹ë˜ì§€ ì•Šì€ ê²½ìš°ì—ë§Œ í•„í„° ì²´ì¸ ê³„ì† ì§„í–‰
  118 |             if (!response.isCommitted()) {
  119 |                 chain.doFilter(request, response);
  120 |             }
  121 |         }
  122 |     }
  123 | 
  124 |     /**
  125 |      * ìš”ì²­ì—ì„œ JWT í† í° ì¶”ì¶œ
  126 |      */
  127 |     private String extractToken(HttpServletRequest request) {
  128 |         String authHeader = request.getHeader("Authorization");
  129 |         
  130 |         if (authHeader != null && authHeader.startsWith("Bearer ")) {
  131 |             return authHeader.substring(7);
  132 |         }
  133 |         
  134 |         return null;
  135 |     }
  136 | 
  137 |     /**
  138 |      * ì‚¬ìš©ìê°€ ê´€ë¦¬ì ê¶Œí•œì„ ê°€ì§€ê³  ìˆëŠ”ì§€ í™•ì¸
  139 |      */
  140 |     private boolean hasAdminRole(Set<String> roles) {
  141 |         return roles.stream().anyMatch(adminRoles::contains);
  142 |     }
  143 | 
  144 |     /**
  145 |      * ì¸ì¦ ê°ì²´ ìƒì„±
  146 |      */
  147 |     private Authentication createAuthentication(String username, Set<String> roles) {
  148 |         Set<SimpleGrantedAuthority> authorities = roles.stream()
  149 |                 .map(SimpleGrantedAuthority::new)
  150 |                 .collect(Collections.toSet());
  151 |         
  152 |         return new UsernamePasswordAuthenticationToken(
  153 |                 username, null, authorities);
  154 |     }
  155 | 
  156 |     /**
  157 |      * ê¶Œí•œ ì—†ìŒ ì‘ë‹µ ì „ì†¡
  158 |      */
  159 |     private void sendForbiddenResponse(HttpServletResponse response, String message) throws IOException {
  160 |         response.setStatus(HttpServletResponse.SC_FORBIDDEN);
  161 |         response.setContentType(MediaType.APPLICATION_JSON_VALUE);
  162 |         
  163 |         Map<String, String> error = new HashMap<>();
  164 |         error.put("error", "ì ‘ê·¼ ê±°ë¶€");
  165 |         error.put("message", message);
  166 |         
  167 |         objectMapper.writeValue(response.getOutputStream(), error);
  168 |     }
  169 | 
  170 |     /**
  171 |      * ì˜¤ë¥˜ ì‘ë‹µ ì „ì†¡
  172 |      */
  173 |     private void sendErrorResponse(HttpServletResponse response, String message) throws IOException {
  174 |         response.setStatus(HttpServletResponse.SC_UNAUTHORIZED);
  175 |         response.setContentType(MediaType.APPLICATION_JSON_VALUE);
  176 |         
  177 |         Map<String, String> error = new HashMap<>();
  178 |         error.put("error", "ì¸ì¦ ì˜¤ë¥˜");
  179 |         error.put("message", message);
  180 |         
  181 |         objectMapper.writeValue(response.getOutputStream(), error);
  182 |     }
  183 | 
  184 |     @Override
  185 |     protected boolean shouldSkipFilter(HttpServletRequest request) {
  186 |         return filterRegistry.shouldNotFilter(getFilterId(), request);
  187 |     }
  188 | 
  189 |     @Override
  190 |     public void configure(HttpSecurity http) throws Exception {
  191 |         http.addFilterAfter(this, JwtVerificationFilter.class);
  192 |         log.debug("ê¶Œí•œ ë¶€ì—¬ í•„í„° HttpSecurityì— êµ¬ì„±ë¨");
  193 |     }
  194 | 
  195 |     @Override
  196 |     public Class<? extends Filter> getBeforeFilter() {
  197 |         return JwtVerificationFilter.class;
  198 |     }
  199 | 
  200 |     @Override
  201 |     public Class<? extends Filter> getAfterFilter() {
  202 |         return null;
  203 |     }
  204 | 
  205 |     /**
  206 |      * í•„í„°ì— ìƒˆë¡œìš´ ì¡°ê±´ ì¶”ê°€
  207 |      */
  208 |     public void addFilterCondition(FilterCondition condition) {
  209 |         filterRegistry.addCondition(getFilterId(), condition);
  210 |     }
  211 | 
  212 |     /**
  213 |      * í•„í„°ì—ì„œ ì¡°ê±´ ì œê±°
  214 |      */
  215 |     public boolean removeFilterCondition(FilterCondition condition) {
  216 |         return filterRegistry.removeCondition(getFilterId(), condition);
  217 |     }
  218 | }
  219 | import com.authentication.auth.DTO.token.tokenDto;
  220 | import com.authentication.auth.DTO.users.loginRequest;
  221 | import com.authentication.auth.configuration.security.publicAPI;
  222 | import com.authentication.auth.configuration.token.jwtUtility;
  223 | import com.fasterxml.jackson.databind.ObjectMapper;
  224 | import jakarta.servlet.FilterChain;
  225 | import jakarta.servlet.ServletException;
  226 | import jakarta.servlet.http.Cookie;
  227 | import jakarta.servlet.http.HttpServletRequest;
  228 | import jakarta.servlet.http.HttpServletResponse;
  229 | import lombok.extern.slf4j.Slf4j;
  230 | import org.springframework.beans.factory.annotation.Value;
  231 | import org.springframework.security.core.Authentication;
  232 | import org.springframework.security.core.GrantedAuthority;
  233 | import org.springframework.security.core.context.SecurityContextHolder;
  234 | import org.springframework.web.filter.OncePerRequestFilter;
  235 | 
  236 | import java.io.IOException;
  237 | import java.io.PrintWriter;
  238 | import java.util.Collection;
  239 | import java.util.Collections;
  240 | import java.util.Map;
  241 | import java.util.Objects;
  242 | 
  243 | @Slf4j
  244 | public class authorizationFilter extends OncePerRequestFilter {
  245 | 
  246 |     @Value("${site.domain}")
  247 |     private String domain;
  248 | 
  249 |     @Value("${server.cookie.domain}")
  250 |     private String cookieDomain;
  251 | 
  252 |     @Value("${auth_proxy_header}")
  253 |     private String AuthorizedProxyHeader;
  254 | 
  255 | 
  256 |     private final jwtUtility  jwtUtility;
  257 |     private final redisService  redisService;
  258 |     private final ObjectMapper objectMapper;
  259 |     private final publicAPI apiChecker;
  260 |     public authorizationFilter(jwtUtility jwtUtility, redisService redisService, ObjectMapper objectMapper, publicAPI apiChecker) {
  261 |         this.jwtUtility = jwtUtility;
  262 |         this.redisService = redisService;
  263 |         this.objectMapper = objectMapper;
  264 |         this.apiChecker = apiChecker;
  265 |     }
  266 |     @Override
  267 |     protected boolean shouldNotFilter(HttpServletRequest request){
  268 |         // true ì¼ ê²½ìš° filter ì‘ë™ skip.
  269 |         return apiChecker.checkRequestAPI(request);
  270 |     }
  271 | 
  272 | 
  273 |     @Override
  274 |     protected void doFilterInternal(HttpServletRequest request, HttpServletResponse response, FilterChain filterChain) throws ServletException, IOException {
  275 | 
  276 |         // Authorization Header í™•ì¸ : Bearer Token í™•ì¸
  277 |         String authorizationHeader = request.getHeader(SecurityConstants.TOKEN_HEADER);
  278 | 
  279 |         if (authorizationHeader == null || !authorizationHeader.startsWith("Bearer ")) {
  280 |             log.warn("Invalid or missing Authorization header. Skipping filter.");
  281 |             return;
  282 |         }
  283 | 
  284 |         log.info("â•”â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•—");
  285 |         log.info("â•‘                       Authorization Filter                    â•‘");
  286 |         log.info("â•šâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•");
  287 | 
  288 |         String RToken = null;
  289 |         if (requiresCookieCheck(request)) {
  290 |             RToken = checkCookie(request, response);
  291 | 
  292 |             if (RToken == null) {
  293 |                 log.error("cookie í•„ìš” request ì— ì¿ í‚¤ê°€ ì—†ì–´ 401 ì˜¤ë¥˜ë¥¼ ë°˜í™˜í•©ë‹ˆë‹¤");
  294 |                 return;
  295 |             }
  296 |         }
  297 | 
  298 |         String provider = request.getHeader("provider");
  299 | 
  300 |         if (provider != null) {
  301 |             log.info("{} ì˜ í† í°ì…ë‹ˆë‹¤.", provider);
  302 |         }
  303 | 
  304 |         if (!authorizationHeader.startsWith(SecurityConstants.TOKEN_PREFIX)){
  305 | 
  306 |             if (Objects.requireNonNull(RToken).isEmpty()) {
  307 |                 log.warn("refresh token ì—†ìŒ -> ì„ì‹œë¡œ ê²€ì‚¬ ì•ˆí•¨ [ìˆ˜ì • í•„ìš”]");
  308 |                 filterChain.doFilter(request, response);
  309 |                 return;
  310 |             }
  311 | 
  312 |             // RToken ìœ¼ë¡œ AccessToken ì°¾ê¸°
  313 |             String findAccessToken = redisService.getAccessToken(RToken);
  314 | 
  315 |             if(findAccessToken != null && !findAccessToken.isEmpty()){
  316 |                 response.addHeader(SecurityConstants.TOKEN_HEADER,
  317 |                         SecurityConstants.TOKEN_PREFIX + findAccessToken);
  318 |             }
  319 | 
  320 |         }
  321 | 
  322 |         String JWT = null;
  323 |         if(authorizationHeader.startsWith(SecurityConstants.TOKEN_PREFIX)){
  324 |             JWT = authorizationHeader.split(" ")[1];
  325 |         }
  326 | 
  327 |         if(JWT == null) {
  328 |             filterChain.doFilter(request, response);
  329 |             return;
  330 |         }
  331 | 
  332 |         // ê¸°ì¡´ JWT ê²€ì¦ ë° ì¸ì¦ ì²˜ë¦¬
  333 |         // Authorized Token ìƒì„± ë° Response Header ì— ì¶”ê°€
  334 |         if (jwtUtility.validateJWT(JWT)) {
  335 |             log.info("ìœ íš¨í•œ í† í°ì…ë‹ˆë‹¤.");
  336 |             Authentication getAuth = authenticateUser(JWT);
  337 | 
  338 |             log.info("ì¸ì¦ ì •ë³´ : {}", getAuth);
  339 |             // ì¸ì¦ ì‹¤íŒ¨ ì²˜ë¦¬
  340 |             if (getAuth != null && getAuth.isAuthenticated()) {
  341 |                 // ì¸ì¦ ì„±ê³µ: í•„í„° ì²´ì¸ìœ¼ë¡œ ìš”ì²­ ì „ë‹¬
  342 |                 response.setStatus(HttpServletResponse.SC_OK);
  343 |             } else {
  344 |                 // ì¸ì¦ ì‹¤íŒ¨: ìƒíƒœì™€ ë©”ì‹œì§€ ë°˜í™˜
  345 |                 sendResponseStatus(response, HttpServletResponse.SC_UNAUTHORIZED, "Authentication failed");
  346 |             }
  347 |             return;
  348 |         } else if (RToken == null) {
  349 |             log.error("there is no refreshToken in cookie");
  350 |             sendResponseStatus(response, HttpServletResponse.SC_UNAUTHORIZED, "no refresh token in cookie");
  351 |         } else if (jwtUtility.validateRefreshJWT(RToken)) {
  352 |             handleRefreshToken(request, response, filterChain, RToken, JWT);
  353 |         } else {
  354 |             sendResponseStatus(response, HttpServletResponse.SC_UNAUTHORIZED, "Invalid or expired JWT");
  355 |         }
  356 | 
  357 |         filterChain.doFilter(request, response);
  358 |     }
  359 | 
  360 |     private String checkCookie(HttpServletRequest request, HttpServletResponse response) throws IOException {
  361 |         Cookie[] cookies = request.getCookies();
  362 |         String RToken = null;
  363 |         if (cookies != null){
  364 |             for (Cookie cookie : cookies){
  365 |                 if (cookie.getName().equals("refreshToken")){
  366 |                     RToken = cookie.getValue();
  367 |                     break;
  368 |                 }
  369 |             }
  370 |         }
  371 |         if (RToken == null){
  372 |             sendResponseStatus(response, 403, "ã… ã… ã… ã… ã… ã… ã… ã… ã… ã… ã… ã… ã… ã… ã… ã… ã… ã… ã… ã… ã… ã… ã… ã… ã… ã… ã… ");
  373 |         }
  374 |         return RToken;
  375 |     }
  376 | 
  377 | 
  378 |     private void sendResponseStatus(HttpServletResponse response, int status, String message)
  379 |             throws IOException{
  380 |         response.setStatus(status);
  381 |         PrintWriter writer = response.getWriter();
  382 |         response.setContentType("application/json");
  383 |         response.setCharacterEncoding("UTF-8");
  384 |         Map<String, String> responseBody = Collections.singletonMap("message", message);
  385 |         objectMapper.writeValue(response.getWriter(), responseBody);
  386 |     }
  387 | 
  388 |     private void sendFrontNewCookie(HttpServletResponse response, int status, tokenDto tokendto){
  389 |         response.setStatus(status);
  390 |         response.addHeader(SecurityConstants.TOKEN_HEADER, SecurityConstants.TOKEN_PREFIX + tokendto.getAccessToken());
  391 |         Cookie refreshTokenCookie = new Cookie("refreshToken", tokendto.getRefreshToken());
  392 |         refreshTokenCookie.setHttpOnly(true);
  393 |         refreshTokenCookie.setDomain(this.cookieDomain);
  394 |         refreshTokenCookie.setPath("/");
  395 |         response.addCookie(refreshTokenCookie);
  396 |     }
  397 | 
  398 |     private boolean RedisMatchRToken(String userId, String RToken){
  399 |         return redisService.findRToken(userId, "server", RToken);
  400 |     }
  401 | 
  402 | 
  403 |     private boolean requiresCookieCheck(HttpServletRequest request) {
  404 |         return !apiChecker.checkRequestAPI(request);
  405 |     }
  406 | 
  407 | 
  408 |     // JWT í† í°ì„ ì´ìš©í•˜ì—¬ ì‚¬ìš©ì ì¸ì¦ ì²˜ë¦¬
  409 |     // Spring Security Context ì— ì¸ì¦ ì •ë³´ë¥¼ ì €ì¥
  410 |     private Authentication authenticateUser(String JWT) {
  411 |         try {
  412 |             Authentication authentication = jwtUtility.getAuthentication(JWT);
  413 |             SecurityContextHolder.getContext().setAuthentication(authentication);
  414 |             return authentication;
  415 |         } catch (Exception e) {
  416 |             log.error("ì¸ì¦ ì‹¤íŒ¨");
  417 |             return null;
  418 |         }
  419 |     }
  420 | 
  421 |     private void handleRefreshToken(HttpServletRequest request, HttpServletResponse response, FilterChain filterChain, String RToken, String JWT) throws IOException, ServletException {
  422 |         Map<String, Object> pToken = jwtUtility.getClaimsFromAccessToken(JWT);
  423 |         String userId = (String) pToken.get("userId");
  424 | 
  425 |         if (RedisMatchRToken(userId, RToken)) {
  426 |             log.info("refresh token is exist in redis");
  427 |             tokenDto tokendto = jwtUtility.buildToken(userId, (String) pToken.get("nickname"), (Collection<? extends GrantedAuthority>) pToken.get("role"));
  428 | 
  429 |             if (redisService.changeRToken(userId, "server", RToken, tokendto.getRefreshToken())) {
  430 |                 log.info("access token and refresh token have been changed");
  431 |                 sendFrontNewCookie(response, HttpServletResponse.SC_CREATED, tokendto);
  432 |                 authenticateUser(tokendto.getAccessToken());
  433 |                 filterChain.doFilter(request, response);
  434 |             } else {
  435 |                 log.error("refresh token change failed");
  436 |                 sendResponseStatus(response, HttpServletResponse.SC_UNAUTHORIZED, "refresh token change failed");
  437 |             }
  438 |         } else {
  439 |             log.error("refresh token from redis does not exist");
  440 |             sendResponseStatus(response, HttpServletResponse.SC_UNAUTHORIZED, "refresh token from redis does not exist");
  441 |         }
  442 |     }
  443 | 
  444 | }

#--------------------------------------------------------------------------------


# File: backend/src/main/java/com/authentication/auth/filter/JwtVerificationFilter.java
#=============================================================================

    1 | package com.authentication.auth.filter;
    2 | package com.authentication.auth.filter;
    3 | 
    4 | import com.authentication.auth.configuration.token.JwtUtility;
    5 | import com.fasterxml.jackson.databind.ObjectMapper;
    6 | import jakarta.annotation.PostConstruct;
    7 | import jakarta.servlet.Filter;
    8 | import jakarta.servlet.FilterChain;
    9 | import jakarta.servlet.ServletException;
   10 | import jakarta.servlet.http.HttpServletRequest;
   11 | import jakarta.servlet.http.HttpServletResponse;
   12 | import lombok.extern.slf4j.Slf4j;
   13 | import org.springframework.beans.factory.annotation.Autowired;
   14 | import org.springframework.http.MediaType;
   15 | import org.springframework.security.authentication.UsernamePasswordAuthenticationToken;
   16 | import org.springframework.security.config.annotation.web.builders.HttpSecurity;
   17 | import org.springframework.security.core.authority.SimpleGrantedAuthority;
   18 | import org.springframework.security.core.context.SecurityContextHolder;
   19 | import org.springframework.stereotype.Component;
   20 | 
   21 | import java.io.IOException;
   22 | import java.util.HashMap;
   23 | import java.util.Map;
   24 | import java.util.Set;
   25 | import java.util.stream.Collectors;
   26 | 
   27 | /**
   28 |  * @Author: choisimo
   29 |  * @Date: 2025-05-05
   30 |  * @Description: JWT í† í° ê²€ì¦ í•„í„°
   31 |  * @Details: ìš”ì²­ì— í¬í•¨ëœ JWT í† í°ì„ ê²€ì¦í•˜ê³  ì‚¬ìš©ì ì¸ì¦ ì •ë³´ë¥¼ ì„¤ì •
   32 |  */
   33 | @Slf4j
   34 | @Component
   35 | public class JwtVerificationFilter extends AbstractSecurityFilter {
   36 | 
   37 |     private final JwtUtility jwtUtility;
   38 |     private final ObjectMapper objectMapper;
   39 |     private final FilterRegistry filterRegistry;
   40 | 
   41 |     @Autowired
   42 |     public JwtVerificationFilter(
   43 |             JwtUtility jwtUtility,
   44 |             ObjectMapper objectMapper,
   45 |             FilterRegistry filterRegistry) {
   46 |         super(SecurityFilterOrder.JWT_VERIFICATION_FILTER);
   47 |         this.jwtUtility = jwtUtility;
   48 |         this.objectMapper = objectMapper;
   49 |         this.filterRegistry = filterRegistry;
   50 |     }
   51 | 
   52 |     /**
   53 |      * í•„í„° ì´ˆê¸°í™” ë° ë ˆì§€ìŠ¤íŠ¸ë¦¬ì— ë“±ë¡
   54 |      */
   55 |     @PostConstruct
   56 |     public void init() {
   57 |         // í•„í„° ë ˆì§€ìŠ¤íŠ¸ë¦¬ì— ì´ í•„í„° ë“±ë¡
   58 |         filterRegistry.registerFilter(this);
   59 | 
   60 |         // ê¸°ë³¸ í•„í„° ì¡°ê±´ ì„¤ì • - ê³µê°œ APIëŠ” JWT ê²€ì¦ í•„í„° ì ìš©í•˜ì§€ ì•ŠìŒ
   61 |         PathPatternFilterCondition publicApiCondition = new PathPatternFilterCondition(
   62 |                 "JWT ê²€ì¦ ë¶ˆí•„ìš” ê²½ë¡œ",
   63 |                 "/api/public/**",
   64 |                 "/api/auth/login",
   65 |                 "/api/auth/register",
   66 |                 "/api/auth/refresh",
   67 |                 "/swagger-ui/**",
   68 |                 "/v3/api-docs/**"
   69 |         );
   70 | 
   71 |         // í•„í„° ë ˆì§€ìŠ¤íŠ¸ë¦¬ì— ì¡°ê±´ ì¶”ê°€
   72 |         filterRegistry.addCondition(getFilterId(), publicApiCondition);
   73 |     }
   74 | 
   75 |     @Override
   76 |     protected void doFilterInternal(HttpServletRequest request, HttpServletResponse response, FilterChain chain)
   77 |             throws IOException, ServletException {
   78 |         
   79 |         String path = request.getRequestURI();
   80 |         log.debug("JWT ê²€ì¦ í•„í„° ì‹¤í–‰: {}", path);
   81 |         
   82 |         try {
   83 |             String token = extractToken(request);
   84 |             
   85 |             if (token != null) {
   86 |                 if (jwtUtility.validateToken(token)) {
   87 |                     String username = jwtUtility.getUsernameFromToken(token);
   88 |                     Set<String> roles = jwtUtility.getRolesFromToken(token);
   89 |                     
   90 |                     // ê¶Œí•œ ì„¤ì •
   91 |                     Set<SimpleGrantedAuthority> authorities = roles.stream()
   92 |                             .map(SimpleGrantedAuthority::new)
   93 |                             .collect(Collectors.toSet());
   94 |                     
   95 |                     UsernamePasswordAuthenticationToken authToken = 
   96 |                             new UsernamePasswordAuthenticationToken(username, null, authorities);
   97 |                     
   98 |                     SecurityContextHolder.getContext().setAuthentication(authToken);
   99 |                     log.debug("JWT í† í° ê²€ì¦ ì„±ê³µ: {}", username);
  100 |                 } else {
  101 |                     log.warn("ìœ íš¨í•˜ì§€ ì•Šì€ JWT í† í°");
  102 |                     sendErrorResponse(response, "ìœ íš¨í•˜ì§€ ì•Šì€ í† í°ì…ë‹ˆë‹¤.");
  103 |                     return;
  104 |                 }
  105 |             } else {
  106 |                 log.debug("JWT í† í°ì´ ì—†ìŒ");
  107 |             }
  108 |             
  109 |             chain.doFilter(request, response);
  110 |         } catch (Exception e) {
  111 |             log.error("JWT ê²€ì¦ ì¤‘ ì˜¤ë¥˜ ë°œìƒ: {}", e.getMessage());
  112 |             SecurityContextHolder.clearContext();
  113 |             sendErrorResponse(response, "í† í° ê²€ì¦ ì¤‘ ì˜¤ë¥˜ê°€ ë°œìƒí–ˆìŠµë‹ˆë‹¤: " + e.getMessage());
  114 |         }
  115 |     }
  116 | 
  117 |     /**
  118 |      * ìš”ì²­ì—ì„œ JWT í† í° ì¶”ì¶œ
  119 |      */
  120 |     private String extractToken(HttpServletRequest request) {
  121 |         String authHeader = request.getHeader("Authorization");
  122 |         
  123 |         if (authHeader != null && authHeader.startsWith("Bearer ")) {
  124 |             return authHeader.substring(7);
  125 |         }
  126 |         
  127 |         return null;
  128 |     }
  129 | 
  130 |     /**
  131 |      * ì˜¤ë¥˜ ì‘ë‹µ ì „ì†¡
  132 |      */
  133 |     private void sendErrorResponse(HttpServletResponse response, String message) throws IOException {
  134 |         response.setStatus(HttpServletResponse.SC_UNAUTHORIZED);
  135 |         response.setContentType(MediaType.APPLICATION_JSON_VALUE);
  136 |         
  137 |         Map<String, String> error = new HashMap<>();
  138 |         error.put("error", "ì¸ì¦ ì˜¤ë¥˜");
  139 |         error.put("message", message);
  140 |         
  141 |         objectMapper.writeValue(response.getOutputStream(), error);
  142 |     }
  143 | 
  144 |     @Override
  145 |     protected boolean shouldSkipFilter(HttpServletRequest request) {
  146 |         return filterRegistry.shouldNotFilter(getFilterId(), request);
  147 |     }
  148 | 
  149 |     @Override
  150 |     public void configure(HttpSecurity http) throws Exception {
  151 |         http.addFilterAfter(this, AuthenticationFilter.class);
  152 |         log.debug("JWT ê²€ì¦ í•„í„° HttpSecurityì— êµ¬ì„±ë¨");
  153 |     }
  154 | 
  155 |     @Override
  156 |     public Class<? extends Filter> getBeforeFilter() {
  157 |         return AuthenticationFilter.class;
  158 |     }
  159 | 
  160 |     @Override
  161 |     public Class<? extends Filter> getAfterFilter() {
  162 |         return authorizationFilter.class;
  163 |     }
  164 | }
  165 | import com.authentication.auth.service.redis.RedisService;
  166 | import com.authentication.auth.utility.JwtUtility;
  167 | import com.fasterxml.jackson.databind.ObjectMapper;
  168 | import io.jsonwebtoken.Claims;
  169 | import io.jsonwebtoken.ExpiredJwtException;
  170 | import io.jsonwebtoken.JwtException;
  171 | import jakarta.servlet.FilterChain;
  172 | import jakarta.servlet.ServletException;
  173 | import jakarta.servlet.ServletRequest;
  174 | import jakarta.servlet.ServletResponse;
  175 | import jakarta.servlet.http.Cookie;
  176 | import jakarta.servlet.http.HttpServletRequest;
  177 | import jakarta.servlet.http.HttpServletResponse;
  178 | import lombok.RequiredArgsConstructor;
  179 | import lombok.extern.slf4j.Slf4j;
  180 | import org.springframework.http.HttpHeaders;
  181 | import org.springframework.http.HttpStatus;
  182 | import org.springframework.http.MediaType;
  183 | import org.springframework.security.authentication.UsernamePasswordAuthenticationToken;
  184 | import org.springframework.security.core.authority.SimpleGrantedAuthority;
  185 | import org.springframework.security.core.context.SecurityContextHolder;
  186 | import org.springframework.security.core.userdetails.UserDetailsService;
  187 | import org.springframework.security.web.authentication.WebAuthenticationDetailsSource;
  188 | import org.springframework.security.web.util.matcher.AntPathRequestMatcher;
  189 | import org.springframework.security.web.util.matcher.OrRequestMatcher;
  190 | import org.springframework.security.web.util.matcher.RequestMatcher;
  191 | import org.springframework.web.filter.OncePerRequestFilter;
  192 | 
  193 | import javax.security.auth.login.CredentialExpiredException;
  194 | import java.io.IOException;
  195 | import java.time.LocalDateTime;
  196 | import java.util.*;
  197 | import java.util.stream.Collectors;
  198 | 
  199 | /**
  200 |  * @Author: choisimo
  201 |  * @Date: 2025-05-05
  202 |  * @Description: JWT í† í° ê²€ì¦ í•„í„°
  203 |  * @Details: ìš”ì²­ì—ì„œ JWT í† í°ì„ ì¶”ì¶œí•˜ê³  ìœ íš¨ì„±ì„ ê²€ì‚¬í•˜ëŠ” í•„í„°
  204 |  * @Usage: Spring Security í•„í„° ì²´ì¸ì— ë“±ë¡í•˜ì—¬ ì‚¬ìš©
  205 |  */
  206 | @Slf4j
  207 | @RequiredArgsConstructor
  208 | public class JwtVerificationFilter extends OncePerRequestFilter implements PluggableFilter {
  209 |     
  210 |     private final JwtUtility jwtUtility;
  211 |     private final RedisService redisService;
  212 |     private final UserDetailsService userDetailsService;
  213 |     private final ObjectMapper objectMapper;
  214 |     private final RequestMatcher excludePathMatcher;
  215 | 
  216 |     /**
  217 |      * JWT ê²€ì¦ í•„í„° ìƒì„±ì
  218 |      * @param jwtUtility JWT í† í° ìœ í‹¸ë¦¬í‹°
  219 |      * @param redisService Redis ì„œë¹„ìŠ¤
  220 |      * @param userDetailsService ì‚¬ìš©ì ì„¸ë¶€ì •ë³´ ì„œë¹„ìŠ¤
  221 |      * @param objectMapper JSON ë³€í™˜ìš© ê°ì²´ ë§¤í¼
  222 |      * @param excludePaths í•„í„° ì ìš©ì„ ì œì™¸í•  ê²½ë¡œ ëª©ë¡
  223 |      */
  224 |     public JwtVerificationFilter(JwtUtility jwtUtility, RedisService redisService, 
  225 |                                 UserDetailsService userDetailsService, ObjectMapper objectMapper,
  226 |                                 List<String> excludePaths) {
  227 |         this.jwtUtility = jwtUtility;
  228 |         this.redisService = redisService;
  229 |         this.userDetailsService = userDetailsService;
  230 |         this.objectMapper = objectMapper;
  231 |         
  232 |         // ì œì™¸ ê²½ë¡œ íŒ¨í„´ ë§¤ì²˜ ì„¤ì •
  233 |         List<RequestMatcher> matchers = excludePaths.stream()
  234 |                 .map(path -> new AntPathRequestMatcher(path))
  235 |                 .collect(Collectors.toList());
  236 |         this.excludePathMatcher = new OrRequestMatcher(matchers.toArray(new RequestMatcher[0]));
  237 |     }
  238 | 
  239 |     /**
  240 |      * í•„í„° ì ìš© ì—¬ë¶€ ê²°ì • ë©”ì„œë“œ
  241 |      * íŠ¹ì • ê²½ë¡œëŠ” JWT ê²€ì¦ì—ì„œ ì œì™¸
  242 |      * @param request í˜„ì¬ ìš”ì²­
  243 |      * @return í•„í„° ì ìš© ì—¬ë¶€
  244 |      */
  245 |     @Override
  246 |     protected boolean shouldNotFilter(HttpServletRequest request) {
  247 |         return excludePathMatcher.matches(request);
  248 |     }
  249 |         
  250 |         @Override
  251 |         public void configure(HttpSecurity http) throws Exception {
  252 |             http.addFilterBefore(this, AuthorizationFilter.class);
  253 |         }
  254 |     
  255 |         @Override
  256 |         public int getOrder() {
  257 |             return 200; // AuthenticationFilter ë‹¤ìŒ ìˆœì„œ
  258 |         }
  259 |     
  260 |         @Override
  261 |         public Class<? extends Filter> getBeforeFilter() {
  262 |             return AuthenticationFilter.class;
  263 |         }
  264 |     
  265 |         @Override
  266 |         public Class<? extends Filter> getAfterFilter() {
  267 |             return AuthorizationFilter.class;
  268 |         }
  269 | 
  270 |     /**
  271 |      * JWT í† í° ê²€ì¦ ë° ì¸ì¦ ì²˜ë¦¬ ë©”ì„œë“œ
  272 |      * @param request ìš”ì²­
  273 |      * @param response ì‘ë‹µ
  274 |      * @param filterChain í•„í„° ì²´ì¸
  275 |      * @throws ServletException ì„œë¸”ë¦¿ ì˜ˆì™¸
  276 |      * @throws IOException IO ì˜ˆì™¸
  277 |      */
  278 |     @Override
  279 |     protected void doFilterInternal(HttpServletRequest request, HttpServletResponse response, FilterChain filterChain)
  280 |             throws ServletException, IOException {
  281 |         
  282 |         log.debug("JWT ê²€ì¦ í•„í„° ì‹œì‘: {}", request.getRequestURI());
  283 |         
  284 |         try {
  285 |             // í† í° ì¶”ì¶œ
  286 |             String token = extractToken(request);
  287 |             
  288 |             if (token == null) {
  289 |                 log.debug("í† í°ì´ ì—†ìŒ, ì¸ì¦ ìƒëµ");
  290 |                 filterChain.doFilter(request, response);
  291 |                 return;
  292 |             }
  293 |             
  294 |             // í† í° ìœ íš¨ì„± ê²€ì¦
  295 |             if (jwtUtility.validateToken(token)) {
  296 |                 // í† í°ì—ì„œ ì‚¬ìš©ì ì •ë³´ ì¶”ì¶œ
  297 |                 Claims claims = jwtUtility.getClaims(token);
  298 |                 String username = claims.getSubject();
  299 |                 
  300 |                 // ë¸”ë™ë¦¬ìŠ¤íŠ¸ í™•ì¸ (ë¡œê·¸ì•„ì›ƒëœ í† í°ì¸ì§€)
  301 |                 String tokenId = claims.getId();
  302 |                 if (tokenId != null && redisService.hasKey("JWT_Blacklist_" + tokenId)) {
  303 |                     throw new CredentialExpiredException("ë¡œê·¸ì•„ì›ƒëœ í† í°ì…ë‹ˆë‹¤.");
  304 |                 }
  305 |                 
  306 |                 // ì‚¬ìš©ì ê¶Œí•œ ì¶”ì¶œ
  307 |                 List<String> authorities = claims.get("authorities", List.class);
  308 |                 List<SimpleGrantedAuthority> grantedAuthorities = null;
  309 |                 
  310 |                 if (authorities != null) {
  311 |                     grantedAuthorities = authorities.stream()
  312 |                             .map(SimpleGrantedAuthority::new)
  313 |                             .collect(Collectors.toList());
  314 |                 }
  315 |                 
  316 |                 // ì¸ì¦ ê°ì²´ ìƒì„± ë° ì„¤ì •
  317 |                 UsernamePasswordAuthenticationToken authentication = 
  318 |                         new UsernamePasswordAuthenticationToken(username, null, grantedAuthorities);
  319 |                 authentication.setDetails(new WebAuthenticationDetailsSource().buildDetails(request));
  320 |                 
  321 |                 // ë³´ì•ˆ ì»¨í…ìŠ¤íŠ¸ì— ì¸ì¦ ê°ì²´ ì„¤ì •
  322 |                 SecurityContextHolder.getContext().setAuthentication(authentication);
  323 |                 log.debug("ì‚¬ìš©ì {} ì¸ì¦ ì™„ë£Œ", username);
  324 |             }
  325 |             
  326 |             // í•„í„° ì²´ì¸ ê³„ì† ì§„í–‰
  327 |             filterChain.doFilter(request, response);
  328 |             
  329 |         } catch (ExpiredJwtException e) {
  330 |             log.warn("ë§Œë£Œëœ JWT í† í°: {}", e.getMessage());
  331 |             handleExpiredToken(request, response, e);
  332 |         } catch (JwtException | CredentialExpiredException e) {
  333 |             log.warn("ìœ íš¨í•˜ì§€ ì•Šì€ JWT í† í°: {}", e.getMessage());
  334 |             handleInvalidToken(response, e);
  335 |         }
  336 |     }
  337 | 
  338 |     /**
  339 |      * ìš”ì²­ì—ì„œ JWT í† í° ì¶”ì¶œ ë©”ì„œë“œ
  340 |      * Authorization í—¤ë” ë˜ëŠ” ì¿ í‚¤ì—ì„œ í† í° ì¶”ì¶œ
  341 |      * @param request HTTP ìš”ì²­
  342 |      * @return ì¶”ì¶œëœ í† í° ë˜ëŠ” null
  343 |      */
  344 |     private String extractToken(HttpServletRequest request) {
  345 |         // Authorization í—¤ë”ì—ì„œ í† í° ì¶”ì¶œ ì‹œë„
  346 |         String bearerToken = request.getHeader(HttpHeaders.AUTHORIZATION);
  347 |         if (bearerToken != null && bearerToken.startsWith("Bearer ")) {
  348 |             return bearerToken.substring(7);
  349 |         }
  350 |         
  351 |         // ì¿ í‚¤ì—ì„œ í† í° ì¶”ì¶œ ì‹œë„
  352 |         Cookie[] cookies = request.getCookies();
  353 |         if (cookies != null) {
  354 |             return Arrays.stream(cookies)
  355 |                     .filter(cookie -> "access_token".equals(cookie.getName()))
  356 |                     .map(Cookie::getValue)
  357 |                     .findFirst()
  358 |                     .orElse(null);
  359 |         }
  360 |         
  361 |         return null;
  362 |     }
  363 | 
  364 |     /**
  365 |      * ë§Œë£Œëœ í† í° ì²˜ë¦¬ ë©”ì„œë“œ
  366 |      * ë¦¬í”„ë ˆì‹œ í† í°ì„ ì‚¬ìš©í•˜ì—¬ ìƒˆ ì•¡ì„¸ìŠ¤ í† í° ë°œê¸‰ ì‹œë„
  367 |      * @param request HTTP ìš”ì²­
  368 |      * @param response HTTP ì‘ë‹µ
  369 |      * @param e ë§Œë£Œ ì˜ˆì™¸
  370 |      * @throws IOException IO ì˜ˆì™¸
  371 |      */
  372 |     private void handleExpiredToken(HttpServletRequest request, HttpServletResponse response, ExpiredJwtException e) 
  373 |             throws IOException {
  374 |         log.info("ë§Œë£Œëœ í† í° ì²˜ë¦¬ ì‹œë„");
  375 |         
  376 |         // ë¦¬í”„ë ˆì‹œ í† í° ì¶”ì¶œ
  377 |         String refreshToken = null;
  378 |         Cookie[] cookies = request.getCookies();
  379 |         
  380 |         if (cookies != null) {
  381 |             Optional<Cookie> refreshCookie = Arrays.stream(cookies)
  382 |                     .filter(cookie -> "refresh_token".equals(cookie.getName()))
  383 |                     .findFirst();
  384 |                     
  385 |             if (refreshCookie.isPresent()) {
  386 |                 refreshToken = refreshCookie.get().getValue();
  387 |             }
  388 |         }
  389 |         
  390 |         // ë¦¬í”„ë ˆì‹œ í† í°ì´ ì—†ê±°ë‚˜ ìœ íš¨í•˜ì§€ ì•Šì€ ê²½ìš°
  391 |         if (refreshToken == null || !jwtUtility.validateToken(refreshToken)) {
  392 |             handleInvalidToken(response, e);
  393 |             return;
  394 |         }
  395 |         
  396 |         try {
  397 |             // ë¦¬í”„ë ˆì‹œ í† í°ì—ì„œ ì •ë³´ ì¶”ì¶œ
  398 |             Claims refreshClaims = jwtUtility.getClaims(refreshToken);
  399 |             String username = refreshClaims.getSubject();
  400 |             String tokenId = refreshClaims.getId();
  401 |             
  402 |             // Redisì—ì„œ ë¦¬í”„ë ˆì‹œ í† í° ìœ íš¨ì„± ê²€ì¦
  403 |             String redisKey = "JWT_RToken_" + username + "_" + tokenId;
  404 |             if (!redisService.hasKey(redisKey)) {
  405 |                 throw new JwtException("ìœ íš¨í•˜ì§€ ì•Šì€ ë¦¬í”„ë ˆì‹œ í† í°");
  406 |             }
  407 |             
  408 |             // ì‚¬ìš©ì ì •ë³´ ë¡œë“œ ë° ìƒˆ ì•¡ì„¸ìŠ¤ í† í° ìƒì„±
  409 |             var userDetails = userDetailsService.loadUserByUsername(username);
  410 |             String newAccessToken = jwtUtility.generateAccessToken(username, userDetails.getAuthorities());
  411 |             
  412 |             // ìƒˆ ì•¡ì„¸ìŠ¤ í† í°ì„ ì¿ í‚¤ì— ì„¤ì •
  413 |             Cookie newAccessTokenCookie = new Cookie("access_token", newAccessToken);
  414 |             newAccessTokenCookie.setHttpOnly(true);
  415 |             newAccessTokenCookie.setSecure(true);
  416 |             newAccessTokenCookie.setPath("/");
  417 |             newAccessTokenCookie.setMaxAge((int) (jwtUtility.getAccessTokenExpiration() / 1000));
  418 |             response.addCookie(newAccessTokenCookie);
  419 |             
  420 |             // í´ë¼ì´ì–¸íŠ¸ì—ê²Œ í† í° ê°±ì‹  ì‘ë‹µ
  421 |             Map<String, Object> tokenResponse = new HashMap<>();
  422 |             tokenResponse.put("status", "renewed");
  423 |             tokenResponse.put("message", "ì•¡ì„¸ìŠ¤ í† í°ì´ ê°±ì‹ ë˜ì—ˆìŠµë‹ˆë‹¤");
  424 |             tokenResponse.put("timestamp", LocalDateTime.now().toString());
  425 |             
  426 |             response.setContentType(MediaType.APPLICATION_JSON_VALUE);
  427 |             response.setStatus(HttpStatus.OK.value());
  428 |             objectMapper.writeValue(response.getWriter(), tokenResponse);
  429 |             
  430 |             log.info("ì•¡ì„¸ìŠ¤ í† í° ê°±ì‹  ì™„ë£Œ: ì‚¬ìš©ì {}", username);
  431 |             
  432 |         } catch (Exception refreshError) {
  433 |             log.error("í† í° ê°±ì‹  ì‹¤íŒ¨: {}", refreshError.getMessage());
  434 |             handleInvalidToken(response, refreshError);
  435 |         }
  436 |     }
  437 | 
  438 |     /**
  439 |      * ìœ íš¨í•˜ì§€ ì•Šì€ í† í° ì²˜ë¦¬ ë©”ì„œë“œ
  440 |      * ì¸ì¦ ì˜¤ë¥˜ ì‘ë‹µ ë°˜í™˜
  441 |      * @param response HTTP ì‘ë‹µ
  442 |      * @param e ì˜ˆì™¸
  443 |      * @throws IOException IO ì˜ˆì™¸
  444 |      */
  445 |     private void handleInvalidToken(HttpServletResponse response, Exception e) throws IOException {
  446 |         Map<String, Object> errorResponse = new HashMap<>();
  447 |         errorResponse.put("status", "error");
  448 |         errorResponse.put("message", "ì¸ì¦ ì˜¤ë¥˜: " + e.getMessage());
  449 |         errorResponse.put("timestamp", LocalDateTime.now().toString());
  450 |         
  451 |         response.setContentType(MediaType.APPLICATION_JSON_VALUE);
  452 |         response.setStatus(HttpStatus.UNAUTHORIZED.value());
  453 |         objectMapper.writeValue(response.getWriter(), errorResponse);
  454 |     }
  455 | 
  456 |     /**
  457 |      * PluggableFilter ì¸í„°í˜ì´ìŠ¤ êµ¬í˜„
  458 |      * í•„í„° ì„¤ì • ë©”ì„œë“œ
  459 |      */
  460 |     @Override
  461 |     public void configure(HttpSecurity http) throws Exception {
  462 |         http.addFilterBefore(this, UsernamePasswordAuthenticationFilter.class);
  463 |     }
  464 | 
  465 |     /**
  466 |      * PluggableFilter ì¸í„°í˜ì´ìŠ¤ êµ¬í˜„
  467 |      * í•„í„° ìˆœì„œ ë°˜í™˜ ë©”ì„œë“œ
  468 |      */
  469 |     @Override
  470 |     public int getOrder() {
  471 |         return 1; // JWT ê²€ì¦ì€ ë‹¤ë¥¸ í•„í„°ë³´ë‹¤ ë¨¼ì € ì‹¤í–‰ë˜ì–´ì•¼ í•¨
  472 |     }
  473 | 
  474 |     /**
  475 |      * PluggableFilter ì¸í„°í˜ì´ìŠ¤ êµ¬í˜„
  476 |      * ì´ í•„í„° ì´ì „ì— ì ìš©ë  í•„í„° í´ë˜ìŠ¤ ë°˜í™˜
  477 |      */
  478 |     @Override
  479 |     public Class<? extends Filter> getBeforeFilter() {
  480 |         return null; // ì´ í•„í„° ì´ì „ì— ì ìš©ë  íŠ¹ì • í•„í„°ê°€ ì—†ìŒ
  481 |     }
  482 | 
  483 |     /**
  484 |      * PluggableFilter ì¸í„°í˜ì´ìŠ¤ êµ¬í˜„
  485 |      * ì´ í•„í„° ì´í›„ì— ì ìš©ë  í•„í„° í´ë˜ìŠ¤ ë°˜í™˜
  486 |      */
  487 |     @Override
  488 |     public Class<? extends Filter> getAfterFilter() {
  489 |         return UsernamePasswordAuthenticationFilter.class;
  490 |     }
  491 | }

#--------------------------------------------------------------------------------


# File: backend/src/main/java/com/authentication/auth/filter/PluggableFilter.java
#=============================================================================

    1 | package com.authentication.auth.filter;
    2 | import jakarta.servlet.Filter;
    3 | import org.springframework.security.config.annotation.web.builders.HttpSecurity;
    4 | package com.authentication.auth.filter;
    5 | 
    6 | import jakarta.servlet.Filter;
    7 | import org.springframework.security.config.annotation.web.builders.HttpSecurity;
    8 | 
    9 | /**
   10 |  * @Author: choisimo
   11 |  * @Date: 2025-05-05
   12 |  * @Description: í”ŒëŸ¬ê·¸í˜• í•„í„° ì¸í„°í˜ì´ìŠ¤
   13 |  * @Details: ë™ì ìœ¼ë¡œ ì¶”ê°€/ì œê±° ê°€ëŠ¥í•œ í•„í„°ë¥¼ ìœ„í•œ ì¸í„°í˜ì´ìŠ¤
   14 |  */
   15 | public interface PluggableFilter extends Filter {
   16 |     
   17 |     /**
   18 |      * HttpSecurityì— ì´ í•„í„°ë¥¼ êµ¬ì„±
   19 |      * @param http HttpSecurity ê°ì²´
   20 |      * @throws Exception êµ¬ì„± ì¤‘ ì˜ˆì™¸ ë°œìƒ ì‹œ
   21 |      */
   22 |     void configure(HttpSecurity http) throws Exception;
   23 |     
   24 |     /**
   25 |      * í•„í„°ì˜ ì‹¤í–‰ ìˆœì„œ ë°˜í™˜
   26 |      * ë‚®ì€ ê°’ì´ ë†’ì€ ìš°ì„ ìˆœìœ„ë¥¼ ì˜ë¯¸í•¨
   27 |      * @return í•„í„° ì‹¤í–‰ ìˆœì„œ
   28 |      */
   29 |     int getOrder();
   30 |     
   31 |     /**
   32 |      * ì´ í•„í„° ì´ì „ì— ì‹¤í–‰ë˜ì–´ì•¼ í•˜ëŠ” í•„í„° í´ë˜ìŠ¤ ë°˜í™˜
   33 |      * @return ì´ì „ í•„í„° í´ë˜ìŠ¤, ì—†ìœ¼ë©´ null
   34 |      */
   35 |     Class<? extends Filter> getBeforeFilter();
   36 |     
   37 |     /**
   38 |      * ì´ í•„í„° ì´í›„ì— ì‹¤í–‰ë˜ì–´ì•¼ í•˜ëŠ” í•„í„° í´ë˜ìŠ¤ ë°˜í™˜
   39 |      * @return ì´í›„ í•„í„° í´ë˜ìŠ¤, ì—†ìœ¼ë©´ null
   40 |      */
   41 |     Class<? extends Filter> getAfterFilter();
   42 |     
   43 |     /**
   44 |      * í•„í„° ID ë°˜í™˜ (ê¸°ë³¸ êµ¬í˜„ì€ í´ë˜ìŠ¤ëª…)
   45 |      * @return í•„í„° ID
   46 |      */
   47 |     default String getFilterId() {
   48 |         return this.getClass().getSimpleName();
   49 |     }
   50 | }
   51 | /**
   52 |  * @Author: choisimo
   53 |  * @Date: 2025-05-05
   54 |  * @Description: í”ŒëŸ¬ê·¸í˜• í•„í„° ì¸í„°í˜ì´ìŠ¤
   55 |  * @Details: Spring Security í•„í„° ì²´ì¸ì— ì‰½ê²Œ í†µí•©ë  ìˆ˜ ìˆëŠ” í•„í„° ì •ì˜
   56 |  */
   57 | public interface PluggableFilter extends Filter {
   58 |     
   59 |     /**
   60 |      * HttpSecurity êµ¬ì„±ì— í˜„ì¬ í•„í„°ë¥¼ ì¶”ê°€
   61 |      * @param http HttpSecurity êµ¬ì„± ê°ì²´
   62 |      * @throws Exception êµ¬ì„± ì¤‘ ë°œìƒí•  ìˆ˜ ìˆëŠ” ì˜ˆì™¸
   63 |      */
   64 |     void configure(HttpSecurity http) throws Exception;
   65 |     
   66 |     /**
   67 |      * í•„í„° ì²´ì¸ ë‚´ ìˆœì„œë¥¼ ê²°ì •í•˜ëŠ” ìš°ì„ ìˆœìœ„ ê°’
   68 |      * ê°’ì´ ë‚®ì„ìˆ˜ë¡ ë†’ì€ ìš°ì„ ìˆœìœ„(ë¨¼ì € ì‹¤í–‰)ë¥¼ ê°€ì§
   69 |      * @return ìˆœì„œ ê°’
   70 |      */
   71 |     int getOrder();
   72 |     
   73 |     /**
   74 |      * ì´ í•„í„° ì´ì „ì— ì ìš©ë˜ì–´ì•¼ í•˜ëŠ” í•„í„° í´ë˜ìŠ¤
   75 |      * @return ì´ì „ í•„í„° í´ë˜ìŠ¤ ë˜ëŠ” null
   76 |      */
   77 |     Class<? extends Filter> getBeforeFilter();
   78 |     
   79 |     /**
   80 |      * ì´ í•„í„° ì´í›„ì— ì ìš©ë˜ì–´ì•¼ í•˜ëŠ” í•„í„° í´ë˜ìŠ¤
   81 |      * @return ì´í›„ í•„í„° í´ë˜ìŠ¤ ë˜ëŠ” null
   82 |      */
   83 |     Class<? extends Filter> getAfterFilter();
   84 | }

#--------------------------------------------------------------------------------


# File: backend/src/main/java/com/authentication/auth/filter/FilterRegistry.java
#=============================================================================

    1 | package com.authentication.auth.filter;
    2 | 
    3 | import lombok.extern.slf4j.Slf4j;
    4 | import org.springframework.security.config.annotation.web.builders.HttpSecurity;
    5 | import org.springframework.stereotype.Component;
    6 | 
    7 | import java.util.*;
    8 | import java.util.concurrent.ConcurrentHashMap;
    9 | import java.util.concurrent.CopyOnWriteArrayList;
   10 | 
   11 | /**
   12 |  * @Author: choisimo
   13 |  * @Date: 2025-05-05
   14 |  * @Description: í•„í„° ë ˆì§€ìŠ¤íŠ¸ë¦¬
   15 |  * @Details: ë³´ì•ˆ í•„í„° ë“±ë¡ ë° ê´€ë¦¬ë¥¼ ìœ„í•œ ì¤‘ì•™ ë ˆì§€ìŠ¤íŠ¸ë¦¬
   16 |  */
   17 | @Slf4j
   18 | @Component
   19 | public class FilterRegistry {
   20 | 
   21 |     // í•„í„° ì¸ìŠ¤í„´ìŠ¤ ì €ì¥ ë§µ (í•„í„° ì´ë¦„ -> í•„í„° ì¸ìŠ¤í„´ìŠ¤)
   22 |     private final Map<String, PluggableFilter> filterMap = new ConcurrentHashMap<>();
   23 |     
   24 |     // í•„í„° ìš°ì„ ìˆœìœ„ ìˆœì„œëŒ€ë¡œ ì €ì¥ëœ ë¦¬ìŠ¤íŠ¸
   25 |     private final List<PluggableFilter> orderedFilters = new CopyOnWriteArrayList<>();
   26 |     
   27 |     // í•„í„° ì¡°ê±´ ì €ì¥ ë§µ (í•„í„° ì´ë¦„ -> í•„í„° ì¡°ê±´ ë¦¬ìŠ¤íŠ¸)
   28 |     private final Map<String, List<FilterCondition>> filterConditions = new ConcurrentHashMap<>();
   29 | 
   30 |     /**
   31 |      * í•„í„° ë“±ë¡
   32 |      * @param filter ë“±ë¡í•  í•„í„°
   33 |      */
   34 |     public void registerFilter(PluggableFilter filter) {
   35 |         String filterName = filter.getClass().getSimpleName();
   36 |         filterMap.put(filterName, filter);
   37 |         
   38 |         // ìš°ì„ ìˆœìœ„ì— ë”°ë¼ ì •ë ¬ëœ ìœ„ì¹˜ì— í•„í„° ì‚½ì…
   39 |         insertFilterInOrder(filter);
   40 |         
   41 |         log.info("í•„í„° ë“±ë¡ ì™„ë£Œ: {}, ìš°ì„ ìˆœìœ„: {}", filterName, filter.getOrder());
   42 |     }
   43 | 
   44 |     /**
   45 |      * í•„í„°ì— ì¡°ê±´ ì¶”ê°€
   46 |      * @param filterName í•„í„° ì´ë¦„
   47 |      * @param condition í•„í„° ì¡°ê±´
   48 |      */
   49 |     public void addCondition(String filterName, FilterCondition condition) {
   50 |         filterConditions.computeIfAbsent(filterName, k -> new CopyOnWriteArrayList<>())
   51 |                         .add(condition);
   52 |         log.info("í•„í„° '{}' ì— ì¡°ê±´ ì¶”ê°€: {}", filterName, condition.getDescription());
   53 |     }
   54 | 
   55 |     /**
   56 |      * í•„í„°ì— ì¡°ê±´ ì œê±°
   57 |      * @param filterName í•„í„° ì´ë¦„
   58 |      * @param condition ì œê±°í•  ì¡°ê±´
   59 |      * @return ì œê±° ì„±ê³µ ì—¬ë¶€
   60 |      */
   61 |     public boolean removeCondition(String filterName, FilterCondition condition) {
   62 |         List<FilterCondition> conditions = filterConditions.get(filterName);
   63 |         if (conditions != null) {
   64 |             boolean result = conditions.remove(condition);
   65 |             if (result) {
   66 |                 log.info("í•„í„° '{}' ì—ì„œ ì¡°ê±´ ì œê±°: {}", filterName, condition.getDescription());
   67 |             }
   68 |             return result;
   69 |         }
   70 |         return false;
   71 |     }
   72 | 
   73 |     /**
   74 |      * í•„í„° ì œê±°
   75 |      * @param filterName ì œê±°í•  í•„í„° ì´ë¦„
   76 |      * @return ì œê±°ëœ í•„í„°, ì—†ìœ¼ë©´ null
   77 |      */
   78 |     public PluggableFilter unregisterFilter(String filterName) {
   79 |         PluggableFilter filter = filterMap.remove(filterName);
   80 |         if (filter != null) {
   81 |             orderedFilters.remove(filter);
   82 |             filterConditions.remove(filterName);
   83 |             log.info("í•„í„° ì œê±° ì™„ë£Œ: {}", filterName);
   84 |         }
   85 |         return filter;
   86 |     }
   87 | 
   88 |     /**
   89 |      * íŠ¹ì • ìš”ì²­ì— ëŒ€í•´ í•„í„°ë¥¼ ì ìš©í•´ì•¼ í•˜ëŠ”ì§€ í™•ì¸
   90 |      * @param filterName í•„í„° ì´ë¦„
   91 |      * @param request HTTP ìš”ì²­
   92 |      * @return trueë©´ í•„í„°ë¥¼ ì ìš©í•˜ì§€ ì•ŠìŒ, falseë©´ í•„í„° ì ìš©
   93 |      */
   94 |     public boolean shouldNotFilter(String filterName, jakarta.servlet.http.HttpServletRequest request) {
   95 |         List<FilterCondition> conditions = filterConditions.get(filterName);
   96 |         if (conditions == null || conditions.isEmpty()) {
   97 |             return false; // ì¡°ê±´ì´ ì—†ìœ¼ë©´ í•­ìƒ í•„í„° ì ìš©
   98 |         }
   99 |         
  100 |         // ì–´ëŠ í•˜ë‚˜ì˜ ì¡°ê±´ì´ë¼ë„ trueë¥¼ ë°˜í™˜í•˜ë©´ í•„í„°ë¥¼ ì ìš©í•˜ì§€ ì•ŠìŒ (OR ì¡°ê±´)
  101 |         return conditions.stream().anyMatch(condition -> condition.shouldNotFilter(request));
  102 |     }
  103 | 
  104 |     /**
  105 |      * ìš°ì„ ìˆœìœ„ì— ë”°ë¼ ì •ë ¬ëœ ìœ„ì¹˜ì— í•„í„° ì‚½ì…
  106 |      * @param filter ì‚½ì…í•  í•„í„°
  107 |      */
  108 |     private void insertFilterInOrder(PluggableFilter filter) {
  109 |         // ê¸°ì¡´ í•„í„°ê°€ ìˆìœ¼ë©´ ì œê±°
  110 |         orderedFilters.remove(filter);
  111 |         
  112 |         // ìƒˆ í•„í„°ì˜ ìˆœì„œ
  113 |         int newFilterOrder = filter.getOrder();
  114 |         
  115 |         int insertIndex = 0;
  116 |         while (insertIndex < orderedFilters.size() && 
  117 |                orderedFilters.get(insertIndex).getOrder() <= newFilterOrder) {
  118 |             insertIndex++;
  119 |         }
  120 |         
  121 |         orderedFilters.add(insertIndex, filter);
  122 |     }
  123 | 
  124 |     /**
  125 |      * ë“±ë¡ëœ ëª¨ë“  í•„í„°ë¥¼ SecurityConfigì— ë“±ë¡
  126 |      * @param http HttpSecurity ê°ì²´
  127 |      * @throws Exception ì„¤ì • ì¤‘ ì˜ˆì™¸ ë°œìƒ ì‹œ
  128 |      */
  129 |     public void registerFilters(HttpSecurity http) throws Exception {
  130 |         for (PluggableFilter filter : orderedFilters) {
  131 |             filter.configure(http);
  132 |             log.debug("í•„í„° êµ¬ì„± ì ìš©: {}", filter.getClass().getSimpleName());
  133 |         }
  134 |         log.info("ì´ {}ê°œì˜ í•„í„°ê°€ SecurityConfigì— ë“±ë¡ë¨", orderedFilters.size());
  135 |     }
  136 | 
  137 |     /**
  138 |      * ë“±ë¡ëœ ëª¨ë“  í•„í„° ëª©ë¡ ë°˜í™˜
  139 |      * @return í•„í„° ëª©ë¡
  140 |      */
  141 |     public List<PluggableFilter> getRegisteredFilters() {
  142 |         return Collections.unmodifiableList(orderedFilters);
  143 |     }
  144 |     
  145 |     /**
  146 |      * íŠ¹ì • í•„í„° ì¡°íšŒ
  147 |      * @param filterName í•„í„° ì´ë¦„
  148 |      * @return ì°¾ì€ í•„í„°, ì—†ìœ¼ë©´ null
  149 |      */
  150 |     public PluggableFilter getFilter(String filterName) {
  151 |         return filterMap.get(filterName);
  152 |     }
  153 | }

#--------------------------------------------------------------------------------


# File: backend/src/main/java/com/authentication/auth/filter/README.md
#=============================================================================

    1 | # ì¸ì¦(Authentication) ë° ì¸ê°€(Authorization) í•„í„° ì‹œìŠ¤í…œ
    2 | 
    3 | ## ê°œìš”
    4 | ì´ ì‹œìŠ¤í…œì€ Jakarta EEì™€ Spring Securityë¥¼ ê¸°ë°˜ìœ¼ë¡œ í•˜ë©°, í”ŒëŸ¬ê·¸í˜• í•„í„° ì•„í‚¤í…ì²˜ë¥¼ ì‚¬ìš©í•˜ì—¬ ì¸ì¦ ë° ì¸ê°€ ë¡œì§ì„ ë¶„ë¦¬í•˜ê³  í™•ì¥ ê°€ëŠ¥í•˜ê²Œ êµ¬í˜„í•©ë‹ˆë‹¤.
    5 | 
    6 | ## í”ŒëŸ¬ê·¸í˜• í•„í„° ì•„í‚¤í…ì²˜
    7 | 
    8 | ### êµ¬ì¡°ì  íŠ¹ì§•
    9 | - `PluggableFilter` ì¸í„°í˜ì´ìŠ¤: ëª¨ë“  í•„í„°ì˜ ê¸°ë³¸ ì¸í„°í˜ì´ìŠ¤ë¡œ, í•„í„° ìˆœì„œì™€ ì˜ì¡´ì„±ì„ ì •ì˜
   10 | - `filterRegistry`: í•„í„° ë“±ë¡ ë° ìˆœì„œ ê´€ë¦¬ë¥¼ ìœ„í•œ í´ë˜ìŠ¤
   11 | - ìœ„ìƒ ì •ë ¬(Topological Sort): í•„í„° ê°„ ì˜ì¡´ì„±ì„ ê³ ë ¤í•œ ì‹¤í–‰ ìˆœì„œ ê²°ì •
   12 | 
   13 | ### ì£¼ìš” ì¸ì¦/ì¸ê°€ í•„í„°
   14 | 
   15 | #### 1. ì¸ì¦(Authentication) í•„í„°
   16 | - **AuthenticationFilter**: ì‚¬ìš©ì ë¡œê·¸ì¸ ë° ìê²© ì¦ëª… ê²€ì¦ ë‹´ë‹¹
   17 | - **JwtVerificationFilter**: JWT í† í° ìœ íš¨ì„± ê²€ì¦ ë‹´ë‹¹
   18 | - **SnsRequestFilter**: ì†Œì…œ ë¡œê·¸ì¸ ìš”ì²­ ì²˜ë¦¬ ë‹´ë‹¹
   19 | 
   20 | #### 2. ì¸ê°€(Authorization) í•„í„°
   21 | - **AuthorizationFilter**: ì‚¬ìš©ì ê¶Œí•œ í™•ì¸ ë° ì ‘ê·¼ ì œì–´ ë‹´ë‹¹
   22 | - **RoleBasedAccessFilter**: ì—­í•  ê¸°ë°˜ ë¦¬ì†ŒìŠ¤ ì ‘ê·¼ ì œì–´ ë‹´ë‹¹
   23 | 
   24 | ## í•„í„° ì ìš© íë¦„
   25 | 1. ìš”ì²­ ì ‘ìˆ˜
   26 | 2. ì¸ì¦(Authentication) í•„í„°ë¥¼ í†µí•œ ì‚¬ìš©ì ì‹ ì› í™•ì¸
   27 |    - JWT í† í° ê²€ì¦ ë˜ëŠ” ì†Œì…œ ë¡œê·¸ì¸ ì¸ì¦
   28 |    - ì¸ì¦ ì„±ê³µ ì‹œ `SecurityContext`ì— ì¸ì¦ ì •ë³´ ì„¤ì •
   29 | 3. ì¸ê°€(Authorization) í•„í„°ë¥¼ í†µí•œ ê¶Œí•œ í™•ì¸
   30 |    - ì‚¬ìš©ì ì—­í•  ë° ê¶Œí•œ í™•ì¸
   31 |    - ì ‘ê·¼ ê°€ëŠ¥í•œ ë¦¬ì†ŒìŠ¤ì¸ì§€ ê²€ì¦
   32 | 4. ì ì ˆí•œ ê¶Œí•œì´ ìˆëŠ” ê²½ìš° ìš”ì²­ ì²˜ë¦¬, ì—†ëŠ” ê²½ìš° ì ‘ê·¼ ê±°ë¶€
   33 | 
   34 | ## í•„í„° ë“±ë¡ ë°©ë²•
   35 | 
   36 | í•„í„°ë¥¼ ë“±ë¡í•˜ë ¤ë©´ ë‹¤ìŒ ë‹¨ê³„ë¥¼ ë”°ë¥´ì„¸ìš”:
   37 | 
   38 | 1. `PluggableFilter` ì¸í„°í˜ì´ìŠ¤ë¥¼ êµ¬í˜„í•œ í•„í„° í´ë˜ìŠ¤ ì‘ì„±
   39 | 2. í•„í„°ì˜ ìš°ì„ ìˆœìœ„(`getOrder()`) ë° ì˜ì¡´ ê´€ê³„(`getBeforeFilter()`, `getAfterFilter()`) ì •ì˜
   40 | 3. Spring Beanìœ¼ë¡œ ë“±ë¡í•˜ì—¬ ìë™ìœ¼ë¡œ `filterRegistry`ì— ë“±ë¡ë˜ë„ë¡ í•¨
   41 | 
   42 | ## í™•ì¥ ë° ì»¤ìŠ¤í„°ë§ˆì´ì§•
   43 | 
   44 | ìƒˆë¡œìš´ ì¸ì¦/ì¸ê°€ ë°©ì‹ì„ ì¶”ê°€í•˜ë ¤ë©´:
   45 | 
   46 | 1. `PluggableFilter` ì¸í„°í˜ì´ìŠ¤ë¥¼ êµ¬í˜„í•œ ìƒˆ í•„í„° í´ë˜ìŠ¤ ìƒì„±
   47 | 2. ì ì ˆí•œ ì‹¤í–‰ ìˆœì„œì™€ ì˜ì¡´ì„± ì •ì˜
   48 | 3. Spring Beanìœ¼ë¡œ ë“±ë¡
   49 | 
   50 | ## ì£¼ì˜ì‚¬í•­
   51 | - í•„í„° ê°„ ìˆœí™˜ ì˜ì¡´ì„±ì´ ì—†ë„ë¡ ì£¼ì˜í•´ì•¼ í•¨
   52 | - ì„±ëŠ¥ì„ ìœ„í•´ ë¶ˆí•„ìš”í•œ í•„í„° ì¤‘ë³µ ì ìš© ë°©ì§€
   53 | - ë³´ì•ˆì— ë¯¼ê°í•œ ê²½ë¡œëŠ” í•­ìƒ ì ì ˆí•œ ì¸ì¦/ì¸ê°€ í•„í„°ë¥¼ í†µê³¼í•˜ë„ë¡ ì„¤ì •

#--------------------------------------------------------------------------------


# File: backend/src/main/java/com/authentication/auth/filter/AuthorizationFilter.java
#=============================================================================

    1 | package com.authentication.auth.filter;
    2 | 
    3 | import jakarta.servlet.FilterChain;
    4 | import jakarta.servlet.ServletException;
    5 | import jakarta.servlet.http.HttpServletRequest;
    6 | import jakarta.servlet.http.HttpServletResponse;
    7 | import lombok.RequiredArgsConstructor;
    8 | import lombok.extern.slf4j.Slf4j;
    9 | import org.springframework.security.access.AccessDeniedException;
   10 | import org.springframework.security.core.Authentication;
   11 | import org.springframework.security.core.GrantedAuthority;
   12 | import org.springframework.security.core.context.SecurityContextHolder;
   13 | import org.springframework.security.web.access.intercept.AuthorizationFilter;
   14 | import org.springframework.security.web.util.matcher.AntPathRequestMatcher;
   15 | import org.springframework.security.web.util.matcher.RequestMatcher;
   16 | import org.springframework.stereotype.Component;
   17 | import org.springframework.web.filter.OncePerRequestFilter;
   18 | 
   19 | import java.io.IOException;
   20 | import java.util.Collection;
   21 | import java.util.HashMap;
   22 | import java.util.List;
   23 | import java.util.Map;
   24 | 
   25 | /**
   26 |  * @Author: choisimo
   27 |  * @Date: 2025-05-05
   28 |  * @Description: ì¸ê°€ í•„í„°
   29 |  * @Details: ì‚¬ìš©ìì˜ ê¶Œí•œì— ë”°ë¼ íŠ¹ì • ë¦¬ì†ŒìŠ¤ ì ‘ê·¼ ì œì–´ë¥¼ ë‹´ë‹¹í•˜ëŠ” í•„í„°
   30 |  */
   31 | @Slf4j
   32 | @Component
   33 | @RequiredArgsConstructor
   34 | public class AuthorizationFilter extends OncePerRequestFilter implements PluggableFilter {
   35 | 
   36 |     // URL íŒ¨í„´ë³„ í•„ìš” ê¶Œí•œ ë§¤í•‘
   37 |     private final Map<RequestMatcher, List<String>> urlAuthorizationMap = new HashMap<>();
   38 |     
   39 |     // ìƒì„±ìì—ì„œ URL íŒ¨í„´ë³„ í•„ìš” ê¶Œí•œ ì´ˆê¸°í™”
   40 |     public AuthorizationFilter() {
   41 |         // ì˜ˆì‹œ: ê´€ë¦¬ì ì „ìš© URL íŒ¨í„´
   42 |         urlAuthorizationMap.put(
   43 |             new AntPathRequestMatcher("/admin/**"),
   44 |             List.of("ROLE_ADMIN")
   45 |         );
   46 |         
   47 |         // ì˜ˆì‹œ: ì‚¬ìš©ì ë° ê´€ë¦¬ì ì ‘ê·¼ ê°€ëŠ¥ URL íŒ¨í„´
   48 |         urlAuthorizationMap.put(
   49 |             new AntPathRequestMatcher("/api/users/**"),
   50 |             List.of("ROLE_USER", "ROLE_ADMIN")
   51 |         );
   52 |     }
   53 | 
   54 |     @Override
   55 |     protected void doFilterInternal(HttpServletRequest request, HttpServletResponse response,
   56 |                                    FilterChain filterChain) throws ServletException, IOException {
   57 |         Authentication authentication = SecurityContextHolder.getContext().getAuthentication();
   58 |         
   59 |         // ì¸ì¦ ì •ë³´ê°€ ì—†ê±°ë‚˜ ìµëª… ì‚¬ìš©ìì¸ ê²½ìš° ë°”ë¡œ í†µê³¼ (ì¸ì¦ í•„í„°ì—ì„œ ì²˜ë¦¬)
   60 |         if (authentication == null || !authentication.isAuthenticated()) {
   61 |             filterChain.doFilter(request, response);
   62 |             return;
   63 |         }
   64 |         
   65 |         // URL íŒ¨í„´ë³„ ê¶Œí•œ í™•ì¸
   66 |         for (Map.Entry<RequestMatcher, List<String>> entry : urlAuthorizationMap.entrySet()) {
   67 |             if (entry.getKey().matches(request)) {
   68 |                 if (!hasAnyAuthority(authentication.getAuthorities(), entry.getValue())) {
   69 |                     log.warn("ì ‘ê·¼ ê¶Œí•œ ì—†ìŒ. ì‚¬ìš©ì: {}, URL: {}", authentication.getName(), request.getRequestURI());
   70 |                     throw new AccessDeniedException("ì ‘ê·¼ ê¶Œí•œì´ ì—†ìŠµë‹ˆë‹¤.");
   71 |                 }
   72 |                 break;
   73 |             }
   74 |         }
   75 |         
   76 |         // ê¶Œí•œ ê²€ì‚¬ë¥¼ í†µê³¼í•˜ë©´ ë‹¤ìŒ í•„í„°ë¡œ ì§„í–‰
   77 |         filterChain.doFilter(request, response);
   78 |     }
   79 |     
   80 |     // ì‚¬ìš©ìê°€ í•„ìš”í•œ ê¶Œí•œ ì¤‘ í•˜ë‚˜ë¼ë„ ê°€ì§€ê³  ìˆëŠ”ì§€ í™•ì¸
   81 |     private boolean hasAnyAuthority(Collection<? extends GrantedAuthority> authorities, List<String> requiredAuthorities) {
   82 |         return authorities.stream()
   83 |                 .map(GrantedAuthority::getAuthority)
   84 |                 .anyMatch(requiredAuthorities::contains);
   85 |     }
   86 |     
   87 |     @Override
   88 |     public void configure(HttpSecurity http) throws Exception {
   89 |         http.addFilterAfter(this, JwtVerificationFilter.class);
   90 |     }
   91 | 
   92 |     @Override
   93 |     public int getOrder() {
   94 |         return 300; // JwtVerificationFilter ë‹¤ìŒ ìˆœì„œ
   95 |     }
   96 | 
   97 |     @Override
   98 |     public Class<? extends Filter> getBeforeFilter() {
   99 |         return JwtVerificationFilter.class;
  100 |     }
  101 | 
  102 |     @Override
  103 |     public Class<? extends Filter> getAfterFilter() {
  104 |         return null; // ì´ í•„í„° ì´í›„ì— ì‹¤í–‰ë˜ì–´ì•¼ í•˜ëŠ” íŠ¹ì • í•„í„°ê°€ ì—†ìŒ
  105 |     }
  106 | }

#--------------------------------------------------------------------------------


# File: backend/src/main/java/com/authentication/auth/filter/ApiChecker.java
#=============================================================================

    1 | package com.authentication.auth.filter;
    2 | 
    3 | import jakarta.servlet.http.HttpServletRequest;
    4 | import lombok.extern.slf4j.Slf4j;
    5 | import org.springframework.stereotype.Component;
    6 | 
    7 | import java.util.Arrays;
    8 | import java.util.List;
    9 | 
   10 | /**
   11 |  * í•„í„° ì ìš© ì—¬ë¶€ë¥¼ ê²°ì •í•˜ëŠ” API ìš”ì²­ ê²€ì‚¬ í´ë˜ìŠ¤
   12 |  */
   13 | @Slf4j
   14 | @Component
   15 | public class ApiChecker {
   16 | 
   17 |     // ì¸ì¦ í•„í„°ë¥¼ ì ìš©í•˜ì§€ ì•Šì„ ê³µê°œ ê²½ë¡œ ëª©ë¡
   18 |     private final List<String> PUBLIC_PATHS = Arrays.asList(
   19 |         "/api/auth/login",
   20 |         "/api/auth/register",
   21 |         "/api/auth/refresh",
   22 |         "/swagger-ui",
   23 |         "/v3/api-docs",
   24 |         "/h2-console",
   25 |         "/error",
   26 |         "/favicon.ico"
   27 |     );
   28 | 
   29 |     /**
   30 |      * ìš”ì²­ì´ í•„í„°ë¥¼ ì ìš©í•˜ì§€ ì•Šì•„ë„ ë˜ëŠ”ì§€ ê²€ì‚¬
   31 |      * @param request HTTP ìš”ì²­
   32 |      * @return trueì¼ ê²½ìš° í•„í„° ì ìš© ì œì™¸
   33 |      */
   34 |     public boolean checkRequestAPI(HttpServletRequest request) {
   35 |         String requestURI = request.getRequestURI();
   36 |         
   37 |         // í—ˆìš©ëœ ê²½ë¡œì¸ì§€ í™•ì¸
   38 |         for (String path : PUBLIC_PATHS) {
   39 |             if (requestURI.startsWith(path)) {
   40 |                 log.debug("í•„í„° ì ìš© ì œì™¸ ê²½ë¡œ: {}", requestURI);
   41 |                 return true;
   42 |             }
   43 |         }
   44 |         
   45 |         // OPTIONS ë©”ì„œë“œëŠ” í•„í„°ë§ ì œì™¸ (CORS preflight ìš”ì²­)
   46 |         if ("OPTIONS".equalsIgnoreCase(request.getMethod())) {
   47 |             return true;
   48 |         }
   49 |         
   50 |         return false;
   51 |     }
   52 | }

#--------------------------------------------------------------------------------


# File: backend/src/main/java/com/authentication/auth/filter/filterRegistry.java
#=============================================================================

    1 | package com.authentication.auth.filter;
    2 | package com.authentication.auth.filter;
    3 | 
    4 | import com.authentication.auth.service.redis.RedisService;
    5 | import com.authentication.auth.utility.JwtUtility;
    6 | import com.fasterxml.jackson.databind.ObjectMapper;
    7 | import lombok.extern.slf4j.Slf4j;
    8 | import org.springframework.beans.factory.annotation.Value;
    9 | import org.springframework.context.annotation.Bean;
   10 | import org.springframework.context.annotation.Configuration;
   11 | import org.springframework.security.authentication.AuthenticationManager;
   12 | import org.springframework.security.config.annotation.web.builders.HttpSecurity;
   13 | import org.springframework.security.core.userdetails.UserDetailsService;
   14 | 
   15 | import java.util.ArrayList;
   16 | import java.util.Arrays;
   17 | import java.util.List;
   18 | 
   19 | /**
   20 |  * @Author: choisimo
   21 |  * @Date: 2025-05-05
   22 |  * @Description: í•„í„° ë ˆì§€ìŠ¤íŠ¸ë¦¬ êµ¬ì„± í´ë˜ìŠ¤
   23 |  * @Details: ì• í”Œë¦¬ì¼€ì´ì…˜ì—ì„œ ì‚¬ìš©í•  ë³´ì•ˆ í•„í„°ë¥¼ ë“±ë¡í•˜ê³  ê´€ë¦¬í•©ë‹ˆë‹¤.
   24 |  */
   25 | @Slf4j
   26 | @Configuration
   27 | public class FilterRegistry {
   28 | 
   29 |     @Value("${application.domain:localhost}")
   30 |     private String domain;
   31 | 
   32 |     @Value("${application.cookie.domain:localhost}")
   33 |     private String cookieDomain;
   34 | 
   35 |     /**
   36 |      * JWT ê²€ì¦ í•„í„° ë¹ˆ ìƒì„±
   37 |      * @param jwtUtility JWT ìœ í‹¸ë¦¬í‹°
   38 |      * @param redisService Redis ì„œë¹„ìŠ¤
   39 |      * @param userDetailsService ì‚¬ìš©ì ì„¸ë¶€ ì •ë³´ ì„œë¹„ìŠ¤
   40 |      * @param objectMapper ê°ì²´ ë§¤í¼
   41 |      * @return êµ¬ì„±ëœ JWT ê²€ì¦ í•„í„°
   42 |      */
   43 |     @Bean
   44 |     public JwtVerificationFilter jwtVerificationFilter(
   45 |             JwtUtility jwtUtility,
   46 |             RedisService redisService,
   47 |             UserDetailsService userDetailsService,
   48 |             ObjectMapper objectMapper) {
   49 |         
   50 |         List<String> excludePaths = Arrays.asList(
   51 |             "/api/auth/login",
   52 |             "/api/auth/register",
   53 |             "/api/auth/password/reset",
   54 |             "/api/health",
   55 |             "/swagger-ui/**",
   56 |             "/v3/api-docs/**",
   57 |             "/error"
   58 |         );
   59 |         
   60 |         log.info("JWT ê²€ì¦ í•„í„° ë“±ë¡. ì œì™¸ ê²½ë¡œ: {}", excludePaths);
   61 |         return new JwtVerificationFilter(jwtUtility, redisService, userDetailsService, objectMapper, excludePaths);
   62 |     }
   63 | 
   64 |     /**
   65 |      * ì¸ì¦ í•„í„° ë¹ˆ ìƒì„±
   66 |      * @param authenticationManager ì¸ì¦ ê´€ë¦¬ì
   67 |      * @param jwtUtility JWT ìœ í‹¸ë¦¬í‹°
   68 |      * @param objectMapper ê°ì²´ ë§¤í¼
   69 |      * @param redisService Redis ì„œë¹„ìŠ¤
   70 |      * @return êµ¬ì„±ëœ ì¸ì¦ í•„í„°
   71 |      */
   72 |     @Bean
   73 |     public AuthenticationFilter authenticationFilter(
   74 |             AuthenticationManager authenticationManager,
   75 |             JwtUtility jwtUtility,
   76 |             ObjectMapper objectMapper,
   77 |             RedisService redisService) {
   78 |         
   79 |         log.info("ì¸ì¦ í•„í„° ë“±ë¡. ë„ë©”ì¸: {}, ì¿ í‚¤ ë„ë©”ì¸: {}", domain, cookieDomain);
   80 |         return new AuthenticationFilter(authenticationManager, jwtUtility, objectMapper, redisService, domain, cookieDomain);
   81 |     }
   82 | 
   83 |     /**
   84 |      * ëª¨ë“  í•„í„°ë¥¼ ë“±ë¡í•˜ì—¬ ë³´ì•ˆ êµ¬ì„±ì— ì ìš©
   85 |      * @param http HTTP ë³´ì•ˆ êµ¬ì„±
   86 |      * @param filters ë“±ë¡í•  í•„í„° ëª©ë¡
   87 |      * @throws Exception ë³´ì•ˆ êµ¬ì„± ì˜ˆì™¸
   88 |      */
   89 |     public void registerFilters(HttpSecurity http, List<PluggableFilter> filters) throws Exception {
   90 |         log.info("{} í•„í„° ë“±ë¡ ì¤‘...", filters.size());
   91 |         
   92 |         // í•„í„°ë¥¼ order ê¸°ì¤€ìœ¼ë¡œ ì •ë ¬
   93 |         filters.sort((f1, f2) -> Integer.compare(f1.getOrder(), f2.getOrder()));
   94 |         
   95 |         // ê° í•„í„°ë¥¼ êµ¬ì„±ì— ì ìš©
   96 |         for (PluggableFilter filter : filters) {
   97 |             log.debug("í•„í„° ë“±ë¡: {}, ìˆœì„œ: {}", filter.getClass().getSimpleName(), filter.getOrder());
   98 |             filter.configure(http);
   99 |         }
  100 |     }
  101 | 
  102 |     /**
  103 |      * êµ¬ì„± ê°€ëŠ¥í•œ ëª¨ë“  í•„í„° ìˆ˜ì§‘
  104 |      * @param authenticationFilter ì¸ì¦ í•„í„°
  105 |      * @param jwtVerificationFilter JWT ê²€ì¦ í•„í„°
  106 |      * @return êµ¬ì„± ê°€ëŠ¥í•œ í•„í„° ëª©ë¡
  107 |      */
  108 |     @Bean
  109 |     public List<PluggableFilter> pluggableFilters(
  110 |             AuthenticationFilter authenticationFilter,
  111 |             JwtVerificationFilter jwtVerificationFilter) {
  112 |         
  113 |         List<PluggableFilter> filters = new ArrayList<>();
  114 |         filters.add(jwtVerificationFilter);
  115 |         filters.add(authenticationFilter);
  116 |         
  117 |         log.info("ì´ {} í•„í„°ê°€ ë“±ë¡ë˜ì—ˆìŠµë‹ˆë‹¤.", filters.size());
  118 |         return filters;
  119 |     }
  120 | }
  121 | import java.util.ArrayList;
  122 | import java.util.Collections;
  123 | import java.util.HashMap;
  124 | import java.util.LinkedList;
  125 | import java.util.List;
  126 | import java.util.Map;
  127 | import java.util.Queue;
  128 | 
  129 | import org.springframework.security.config.annotation.web.builders.HttpSecurity;
  130 | import org.springframework.security.web.authentication.UsernamePasswordAuthenticationFilter;
  131 | import org.springframework.stereotype.Component;
  132 | import org.springframework.web.filter.GenericFilterBean;
  133 | 
  134 | import jakarta.servlet.FilterChain;
  135 | import jakarta.servlet.ServletException;
  136 | import jakarta.servlet.ServletRequest;
  137 | import jakarta.servlet.ServletResponse;
  138 | import jakarta.servlet.Filter;
  139 | import java.io.IOException;
  140 | 
  141 | /**
  142 |  * @Author : choisimo 
  143 |  * @Date : 2025-05-05
  144 |  * @Description : filterRegistry class
  145 |  * @Details : ë“±ë¡ëœ í•„í„°ë“¤ì„ ìˆœì„œëŒ€ë¡œ ë“±ë¡í•˜ëŠ” í´ë˜ìŠ¤ (order ê¸°ë°˜)
  146 |  * @Usage : Spring Security ì˜ addFilterBefore, addFilterAfter, addFilter ë©”ì†Œë“œë¥¼ ì‚¬ìš©í•˜ì—¬ í•„í„°ë¥¼ ë“±ë¡í•  ë•Œ ì‚¬ìš©
  147 |  */
  148 | 
  149 | @Component
  150 | @RequiredArgsConstructor
  151 | @Slf4j
  152 | public class filterRegistry {
  153 |     private final List<PluggableFilter> filters = new ArrayList<>();
  154 |     
  155 |     @Autowired
  156 |     public filterRegistry(List<PluggableFilter> pluggableFilters) {
  157 |         // ìë™ìœ¼ë¡œ ëª¨ë“  PluggableFilter êµ¬í˜„ì²´ë¥¼ ì£¼ì…ë°›ìŒ
  158 |         this.filters.addAll(pluggableFilters);
  159 |         log.info("ì´ {} ê°œì˜ í•„í„°ê°€ ë“±ë¡ë˜ì—ˆìŠµë‹ˆë‹¤.", filters.size());
  160 |     }
  161 | 
  162 |     public void addFilter(PluggableFilter filter) {
  163 |         filters.add(filter);
  164 |     }
  165 | 
  166 |     /**
  167 |      * ì •ë ¬ëœ í•„í„°ë¥¼ Spring Security í•„í„° ì²´ì¸ì— ë“±ë¡í•©ë‹ˆë‹¤.
  168 |      * í•„í„° ìˆœì„œëŠ” ìœ„ìƒ ì •ë ¬ ì•Œê³ ë¦¬ì¦˜ì„ í†µí•´ ê²°ì •ë©ë‹ˆë‹¤.
  169 |      * @param http HttpSecurity êµ¬ì„± ê°ì²´
  170 |      * @throws Exception êµ¬ì„± ì¤‘ ë°œìƒí•  ìˆ˜ ìˆëŠ” ì˜ˆì™¸
  171 |      */
  172 |     public void configureFilters(HttpSecurity http) throws Exception {
  173 |         List<PluggableFilter> sortedFilters = topologicalSort();
  174 |         
  175 |         for (PluggableFilter filter : sortedFilters) {
  176 |             log.info("í•„í„° ë“±ë¡: {}, ìˆœì„œ: {}", filter.getClass().getSimpleName(), filter.getOrder());
  177 |             filter.configure(http);
  178 |         }
  179 |     }
  180 |     
  181 |     /**
  182 |      * í•„í„° ì˜ì¡´ì„±ì„ ê¸°ë°˜ìœ¼ë¡œ ìœ„ìƒ ì •ë ¬ì„ ìˆ˜í–‰í•©ë‹ˆë‹¤.
  183 |      * @return ì •ë ¬ëœ í•„í„° ëª©ë¡
  184 |      */
  185 |     private List<PluggableFilter> topologicalSort() {
  186 |         Map<Class<?>, PluggableFilter> filterMap = new HashMap<>();
  187 |         Map<PluggableFilter, List<PluggableFilter>> graph = new HashMap<>();
  188 |         Set<PluggableFilter> visited = new HashSet<>();
  189 |         List<PluggableFilter> result = new ArrayList<>();
  190 |         
  191 |         // í•„í„° ë§µ ì´ˆê¸°í™”
  192 |         for (PluggableFilter filter : filters) {
  193 |             filterMap.put(filter.getClass(), filter);
  194 |             graph.put(filter, new ArrayList<>());
  195 |         }
  196 |         
  197 |         // ê·¸ë˜í”„ êµ¬ì„±
  198 |         for (PluggableFilter filter : filters) {
  199 |             // ì´ í•„í„° ì´ì „ì— ì‹¤í–‰ë˜ì–´ì•¼ í•˜ëŠ” í•„í„°
  200 |             Class<? extends Filter> beforeFilter = filter.getBeforeFilter();
  201 |             if (beforeFilter != null && filterMap.containsKey(beforeFilter)) {
  202 |                 graph.get(filterMap.get(beforeFilter)).add(filter);
  203 |             }
  204 |             
  205 |             // ì´ í•„í„° ì´í›„ì— ì‹¤í–‰ë˜ì–´ì•¼ í•˜ëŠ” í•„í„°
  206 |             Class<? extends Filter> afterFilter = filter.getAfterFilter();
  207 |             if (afterFilter != null && filterMap.containsKey(afterFilter)) {
  208 |                 graph.get(filter).add(filterMap.get(afterFilter));
  209 |             }
  210 |         }
  211 |         
  212 |         // DFSë¥¼ í†µí•œ ìœ„ìƒ ì •ë ¬
  213 |         for (PluggableFilter filter : filters) {
  214 |             if (!visited.contains(filter)) {
  215 |                 dfs(filter, graph, visited, result);
  216 |             }
  217 |         }
  218 |         
  219 |         // ìˆœì„œ(Order) ê¸°ë°˜ ì¶”ê°€ ì •ë ¬
  220 |         result.sort(Comparator.comparingInt(PluggableFilter::getOrder));
  221 |         
  222 |         return result;
  223 |     }
  224 |     
  225 |     /**
  226 |      * ê¹Šì´ ìš°ì„  íƒìƒ‰ì„ í†µí•œ ìœ„ìƒ ì •ë ¬ ìˆ˜í–‰
  227 |      */
  228 |     private void dfs(PluggableFilter filter, Map<PluggableFilter, List<PluggableFilter>> graph,
  229 |                      Set<PluggableFilter> visited, List<PluggableFilter> result) {
  230 |         visited.add(filter);
  231 |         
  232 |         for (PluggableFilter dependency : graph.get(filter)) {
  233 |             if (!visited.contains(dependency)) {
  234 |                 dfs(dependency, graph, visited, result);
  235 |             }
  236 |         }
  237 |         
  238 |         result.add(filter);
  239 |     }
  240 | }
  241 |      */
  242 |     public void registerFilters(HttpSecurity http) throws Exception {
  243 |         List<PluggableFilter> sortedFilters = topologicalSort(filters);
  244 |         
  245 |         for (PluggableFilter filter : sortedFilters) {
  246 |             try {
  247 |                 if (filter.getBeforeFilter() != null) {
  248 |                     // ì§€ì •ëœ í•„í„° ì´ì „ì— ì‹¤í–‰
  249 |                     http.addFilterBefore(
  250 |                         new FilterWrapper(filter), 
  251 |                         (Class<? extends Filter>) filter.getBeforeFilter()
  252 |                     );
  253 |                 } else if (filter.getAfterFilter() != null) {
  254 |                     // ì§€ì •ëœ í•„í„° ì´í›„ì— ì‹¤í–‰
  255 |                     http.addFilterAfter(
  256 |                         new FilterWrapper(filter), 
  257 |                         (Class<? extends Filter>) filter.getAfterFilter()
  258 |                     );
  259 |                 } else {
  260 |                     // ê¸°ë³¸ ìˆœì„œë¡œ ì‹¤í–‰ (UsernamePasswordAuthenticationFilter ìœ„ì¹˜)
  261 |                     http.addFilterBefore(new FilterWrapper(filter), UsernamePasswordAuthenticationFilter.class);
  262 |                 }
  263 |             } catch (Exception e) {
  264 |                 throw new RuntimeException("Filter registration failed: " + filter.getClass().getSimpleName(), e);
  265 |             }
  266 |         }
  267 |     }
  268 | 
  269 |     private List<PluggableFilter> topologicalSort(List<PluggableFilter> filters) {
  270 | 
  271 |         // ê·¸ë˜í”„ ì¸ì ‘ ë¦¬ìŠ¤íŠ¸ ìƒì„±
  272 |         Map<Class<?>, List<Class<?>>> adjacencyList = new HashMap<>();
  273 |         
  274 |         // ê° í•„í„°ì˜ ì§„ì… ì°¨ìˆ˜ ì €ì¥
  275 |         Map<Class<?>, Integer> inDegree = new HashMap<>();
  276 | 
  277 |         // í•„í„° í´ë˜ìŠ¤ë¥¼ í•„í„° ì¸ìŠ¤í„´ìŠ¤ì— ë§¤í•‘
  278 |         Map<Class<?>, PluggableFilter> filterMap = new HashMap<>();    
  279 | 
  280 | 
  281 |         // ê·¸ë˜í”„ì™€ ì§„ì… ì°¨ìˆ˜ ì´ˆê¸°í™”
  282 |         for (PluggableFilter filter : filters) {
  283 |             Class<?> filterClass = filter.getClass();
  284 |             adjacencyList.putIfAbsent(filterClass, new ArrayList<>());
  285 |             inDegree.putIfAbsent(filterClass, 0);
  286 |             filterMap.put(filterClass, filter);
  287 |         }
  288 | 
  289 |     // before/after ê´€ê³„ë¥¼ ê¸°ë°˜ìœ¼ë¡œ ê·¸ë˜í”„ êµ¬ì¶•
  290 |     for (PluggableFilter filter : filters) {
  291 |         Class<?> filterClass = filter.getClass();
  292 |         
  293 |         if (filter.getBeforeFilter() != null) {
  294 |             // Aê°€ B ì´ì „ì— ì˜¤ë©´, Aì—ì„œ Bë¡œ ê°„ì„  ì¶”ê°€
  295 |             adjacencyList.get(filterClass).add(filter.getBeforeFilter());
  296 |             inDegree.merge(filter.getBeforeFilter(), 1, Integer::sum);
  297 |         }
  298 |         
  299 |         if (filter.getAfterFilter() != null) {
  300 |             // Aê°€ B ì´í›„ì— ì˜¤ë©´, Bì—ì„œ Aë¡œ ê°„ì„  ì¶”ê°€
  301 |             adjacencyList.putIfAbsent(filter.getAfterFilter(), new ArrayList<>());
  302 |             adjacencyList.get(filter.getAfterFilter()).add(filterClass);
  303 |             inDegree.merge(filterClass, 1, Integer::sum);
  304 |         }
  305 |     }
  306 |     
  307 |     // ìœ„ìƒ ì •ë ¬ ìˆ˜í–‰
  308 |     return performKahnsAlgorithm(adjacencyList, inDegree, filterMap);
  309 | }
  310 | 
  311 | private List<PluggableFilter> performKahnsAlgorithm(
  312 |         Map<Class<?>, List<Class<?>>> adjacencyList,
  313 |         Map<Class<?>, Integer> inDegree,
  314 |         Map<Class<?>, PluggableFilter> filterMap) {
  315 |     
  316 |     List<PluggableFilter> sortedFilters = new ArrayList<>();
  317 |     Queue<Class<?>> queue = new LinkedList<>();
  318 |     
  319 |     // ì§„ì… ì°¨ìˆ˜ê°€ 0ì¸ ë…¸ë“œ(ì˜ì¡´ì„±ì´ ì—†ëŠ” í•„í„°)ë¶€í„° ì‹œì‘
  320 |     for (Map.Entry<Class<?>, Integer> entry : inDegree.entrySet()) {
  321 |         if (entry.getValue() == 0) {
  322 |             queue.add(entry.getKey());
  323 |         }
  324 |     }
  325 |     
  326 |     // ìœ„ìƒ ì •ë ¬ ìˆœì„œëŒ€ë¡œ ë…¸ë“œ ì²˜ë¦¬
  327 |     while (!queue.isEmpty()) {
  328 |         Class<?> current = queue.poll();
  329 |         PluggableFilter filter = filterMap.get(current);
  330 |         
  331 |         if (filter != null) {
  332 |             sortedFilters.add(filter);
  333 |         }
  334 |         
  335 |         // ê° ì¢…ì† í•„í„°ì˜ ì§„ì… ì°¨ìˆ˜ë¥¼ ê°ì†Œì‹œí‚¤ê³  ì¤€ë¹„ëëŠ”ì§€ í™•ì¸
  336 |         for (Class<?> dependent : adjacencyList.getOrDefault(current, Collections.emptyList())) {
  337 |             inDegree.put(dependent, inDegree.get(dependent) - 1);
  338 |             if (inDegree.get(dependent) == 0) {
  339 |                 queue.add(dependent);
  340 |             }
  341 |         }
  342 |     }
  343 |     
  344 |     // ì¢…ì†ì„± ê·¸ë˜í”„ì— ìˆœí™˜ì´ ìˆëŠ”ì§€ í™•ì¸
  345 |     if (sortedFilters.size() != filterMap.size()) {
  346 |         throw new IllegalStateException("í•„í„° ê°„ì— ìˆœí™˜ ì˜ì¡´ì„±ì´ ê°ì§€ë˜ì—ˆìŠµë‹ˆë‹¤");
  347 |     }
  348 |     
  349 |     return sortedFilters;
  350 | }
  351 | 
  352 | /**
  353 |  * í•„í„° ì–´ëŒ‘í„° í´ë˜ìŠ¤
  354 |  * Spring Security Filterì™€ PluggableFilter ê°„ì˜ í˜¸í™˜ì„± ì œê³µ
  355 |  */
  356 | private static class FilterWrapper extends GenericFilterBean {
  357 |     private final PluggableFilter delegate;
  358 | 
  359 |     public FilterWrapper(PluggableFilter delegate) {
  360 |         this.delegate = delegate;
  361 |     }
  362 | 
  363 |     @Override
  364 |     public void doFilter(
  365 |         ServletRequest request,
  366 |         ServletResponse response,
  367 |         FilterChain chain
  368 |     ) throws ServletException, IOException {
  369 |         delegate.doFilter(request, response, chain);
  370 |     }
  371 | }
  372 | }

#--------------------------------------------------------------------------------


# File: backend/src/main/java/com/authentication/auth/filter/AuthenticationFilter.java
#=============================================================================

    1 | package com.authentication.auth.filter;
    2 | 
    3 | import com.authentication.auth.configuration.token.JwtUtility;
    4 | import com.authentication.auth.service.RedisService;
    5 | import com.fasterxml.jackson.databind.ObjectMapper;
    6 | import jakarta.servlet.Filter;
    7 | import jakarta.servlet.FilterChain;
    8 | import jakarta.servlet.ServletException;
    9 | import jakarta.servlet.http.Cookie;
   10 | import jakarta.servlet.http.HttpServletRequest;
   11 | import jakarta.servlet.http.HttpServletResponse;
   12 | import lombok.extern.slf4j.Slf4j;
   13 | import org.springframework.security.authentication.AuthenticationManager;
   14 | import org.springframework.security.authentication.UsernamePasswordAuthenticationToken;
   15 | import org.springframework.security.config.annotation.web.builders.HttpSecurity;
   16 | import org.springframework.security.core.Authentication;
   17 | import org.springframework.security.core.AuthenticationException;
   18 | import org.springframework.security.core.context.SecurityContextHolder;
   19 | import org.springframework.security.core.userdetails.UserDetails;
   20 | import org.springframework.stereotype.Component;
   21 | 
   22 | import java.io.IOException;
   23 | import java.util.HashMap;
   24 | package com.authentication.auth.filter;
   25 | 
   26 | import com.authentication.auth.configuration.token.JwtUtility;
   27 | import com.authentication.auth.service.RedisService;
   28 | import com.fasterxml.jackson.databind.ObjectMapper;
   29 | import jakarta.annotation.PostConstruct;
   30 | import jakarta.servlet.Filter;
   31 | import jakarta.servlet.FilterChain;
   32 | import jakarta.servlet.ServletException;
   33 | import jakarta.servlet.http.Cookie;
   34 | import jakarta.servlet.http.HttpServletRequest;
   35 | import jakarta.servlet.http.HttpServletResponse;
   36 | import lombok.extern.slf4j.Slf4j;
   37 | import org.springframework.beans.factory.annotation.Autowired;
   38 | import org.springframework.http.HttpMethod;
   39 | import org.springframework.security.authentication.AuthenticationManager;
   40 | import org.springframework.security.authentication.UsernamePasswordAuthenticationToken;
   41 | import org.springframework.security.config.annotation.web.builders.HttpSecurity;
   42 | import org.springframework.security.core.Authentication;
   43 | import org.springframework.security.core.AuthenticationException;
   44 | import org.springframework.security.core.context.SecurityContextHolder;
   45 | import org.springframework.security.core.userdetails.UserDetails;
   46 | import org.springframework.stereotype.Component;
   47 | 
   48 | import java.io.IOException;
   49 | import java.util.HashMap;
   50 | import java.util.Map;
   51 | 
   52 | /**
   53 |  * @Author: choisimo
   54 |  * @Date: 2025-05-05
   55 |  * @Description: ì‚¬ìš©ì ì¸ì¦ í•„í„°
   56 |  * @Details: ì‚¬ìš©ì ë¡œê·¸ì¸ ìš”ì²­ì„ ì²˜ë¦¬í•˜ê³  JWT í† í°ì„ ìƒì„±í•˜ëŠ” í•„í„°ì˜ êµ¬ì²´ì ì¸ êµ¬í˜„
   57 |  *          ìœ ë™ì ì¸ í•„í„° ì¡°ê±´ ì§€ì›ì„ ìœ„í•´ ê°œì„ ë¨
   58 |  */
   59 | @Slf4j
   60 | @Component
   61 | public class AuthenticationFilter extends AbstractAuthenticationFilter {
   62 |     
   63 |     private final FilterRegistry filterRegistry;
   64 |     
   65 |     @Autowired
   66 |     public AuthenticationFilter(
   67 |             AuthenticationManager authenticationManager,
   68 |             JwtUtility jwtUtility,
   69 |             ObjectMapper objectMapper,
   70 |             RedisService redisService,
   71 |             String domain,
   72 |             String cookieDomain,
   73 |             FilterRegistry filterRegistry) {
   74 |         super(authenticationManager, jwtUtility, objectMapper, redisService, domain, cookieDomain);
   75 |         this.filterRegistry = filterRegistry;
   76 |         setFilterProcessesUrl("/api/auth/login"); // ë¡œê·¸ì¸ URL ì„¤ì •
   77 |     }
   78 |     
   79 |     /**
   80 |      * í•„í„° ì´ˆê¸°í™” ë° ë ˆì§€ìŠ¤íŠ¸ë¦¬ì— ë“±ë¡
   81 |      */
   82 |     @PostConstruct
   83 |     public void init() {
   84 |         // í•„í„° ë ˆì§€ìŠ¤íŠ¸ë¦¬ì— ì´ í•„í„° ë“±ë¡
   85 |         filterRegistry.registerFilter(this);
   86 |         
   87 |         // ê¸°ë³¸ í•„í„° ì¡°ê±´ ì„¤ì • - ê³µê°œ APIëŠ” ì¸ì¦ í•„í„° ì ìš©í•˜ì§€ ì•ŠìŒ
   88 |         PathPatternFilterCondition publicApiCondition = new PathPatternFilterCondition(
   89 |                 "ê³µê°œ API ê²½ë¡œ ì œì™¸",
   90 |                 "/api/public/**", 
   91 |                 "/api/auth/register", 
   92 |                 "/api/auth/refresh",
   93 |                 "/swagger-ui/**", 
   94 |                 "/v3/api-docs/**"
   95 |         );
   96 |         
   97 |         // ë¡œê·¸ì¸ ê²½ë¡œì—ëŠ” POST ë©”ì†Œë“œë§Œ í—ˆìš©í•˜ê³  ë‹¤ë¥¸ ë©”ì†Œë“œëŠ” í•„í„°ë§
   98 |         PathPatternFilterCondition loginPathCondition = new PathPatternFilterCondition(
   99 |                 "ë¡œê·¸ì¸ ê²½ë¡œ ë©”ì†Œë“œ ì œí•œ",
  100 |                 new HttpMethod[] {HttpMethod.GET, HttpMethod.PUT, HttpMethod.DELETE},
  101 |                 "/api/auth/login"
  102 |         );
  103 |         
  104 |         // í•„í„° ë ˆì§€ìŠ¤íŠ¸ë¦¬ì— ì¡°ê±´ ì¶”ê°€
  105 |         filterRegistry.addCondition(getFilterId(), publicApiCondition);
  106 |         filterRegistry.addCondition(getFilterId(), loginPathCondition);
  107 |     }
  108 | 
  109 |     @Override
  110 |     public Authentication attemptAuthentication(HttpServletRequest request, HttpServletResponse response) 
  111 |             throws AuthenticationException {
  112 |         // í•„í„° ì ìš© ì—¬ë¶€ ê²€ì‚¬
  113 |         if (shouldNotFilter(request)) {
  114 |             log.debug("ì¸ì¦ í•„í„° ì ìš©ë˜ì§€ ì•ŠìŒ: {}", request.getRequestURI());
  115 |             return null;
  116 |         }
  117 |         
  118 |         log.info("ì¸ì¦ ì‹œë„: {}", request.getRequestURI());
  119 |         return super.attemptAuthentication(request, response);
  120 |     }
  121 | 
  122 |     @Override
  123 |     protected void successfulAuthentication(HttpServletRequest request, HttpServletResponse response,
  124 |                                            FilterChain chain, Authentication authResult) throws IOException, ServletException {
  125 |         log.info("ë¡œê·¸ì¸ ì„±ê³µ: í† í° ìƒì„± ì‹œì‘");
  126 |         
  127 |         UserDetails userDetails = (UserDetails) authResult.getPrincipal();
  128 |         String username = userDetails.getUsername();
  129 |         
  130 |         // ì•¡ì„¸ìŠ¤ ë° ë¦¬í”„ë ˆì‹œ í† í° ìƒì„±
  131 |         String accessToken = jwtUtility.generateAccessToken(username);
  132 |         String refreshToken = jwtUtility.generateRefreshToken(username);
  133 |         
  134 |         // ë¦¬í”„ë ˆì‹œ í† í°ì„ Redisì— ì €ì¥
  135 |         redisService.setData("RT:" + username, refreshToken, jwtUtility.getRefreshTokenExpirationTime());
  136 |         
  137 |         // í† í°ì„ ì¿ í‚¤ì— ì €ì¥
  138 |         Cookie accessTokenCookie = new Cookie("access_token", accessToken);
  139 |         accessTokenCookie.setHttpOnly(true);
  140 |         accessTokenCookie.setPath("/");
  141 |         accessTokenCookie.setDomain(cookieDomain);
  142 |         accessTokenCookie.setSecure(true);
  143 |         
  144 |         Cookie refreshTokenCookie = new Cookie("refresh_token", refreshToken);
  145 |         refreshTokenCookie.setHttpOnly(true);
  146 |         refreshTokenCookie.setPath("/");
  147 |         refreshTokenCookie.setDomain(cookieDomain);
  148 |         refreshTokenCookie.setSecure(true);
  149 |         
  150 |         response.addCookie(accessTokenCookie);
  151 |         response.addCookie(refreshTokenCookie);
  152 |         
  153 |         // ì‘ë‹µ ë³¸ë¬¸ì—ë„ í† í° ì •ë³´ í¬í•¨
  154 |         Map<String, String> tokens = new HashMap<>();
  155 |         tokens.put("access_token", accessToken);
  156 |         tokens.put("refresh_token", refreshToken);
  157 |         tokens.put("username", username);
  158 |         
  159 |         response.setContentType("application/json");
  160 |         objectMapper.writeValue(response.getOutputStream(), tokens);
  161 |         
  162 |         // SecurityContextì— ì¸ì¦ ì •ë³´ ì„¤ì •
  163 |         SecurityContextHolder.getContext().setAuthentication(authResult);
  164 |         
  165 |         log.info("ë¡œê·¸ì¸ ì„±ê³µ: í† í° ìƒì„± ì™„ë£Œ ë° ì¿ í‚¤ ì„¤ì •");
  166 |     }
  167 |     
  168 |     @Override
  169 |     protected void unsuccessfulAuthentication(HttpServletRequest request, HttpServletResponse response,
  170 |                                              AuthenticationException failed) throws IOException, ServletException {
  171 |         log.error("ë¡œê·¸ì¸ ì‹¤íŒ¨: {}", failed.getMessage());
  172 |         
  173 |         SecurityContextHolder.clearContext();
  174 |         
  175 |         response.setStatus(HttpServletResponse.SC_UNAUTHORIZED);
  176 |         response.setContentType("application/json");
  177 |         
  178 |         Map<String, String> error = new HashMap<>();
  179 |         error.put("error", "ì¸ì¦ ì‹¤íŒ¨");
  180 |         error.put("message", failed.getMessage());
  181 |         
  182 |         objectMapper.writeValue(response.getOutputStream(), error);
  183 |     }
  184 |     
  185 |     /**
  186 |      * ë™ì  í•„í„° ì¡°ê±´ì„ í†µí•´ í•„í„° ì ìš© ì—¬ë¶€ ê²°ì •
  187 |      */
  188 |     protected boolean shouldNotFilter(HttpServletRequest request) {
  189 |         return filterRegistry.shouldNotFilter(getFilterId(), request);
  190 |     }
  191 |     
  192 |     @Override
  193 |     public void configure(HttpSecurity http) throws Exception {
  194 |         http.addFilterAt(this, AbstractAuthenticationFilter.class);
  195 |         log.debug("ì¸ì¦ í•„í„° HttpSecurityì— êµ¬ì„±ë¨");
  196 |     }
  197 |     
  198 |     @Override
  199 |     public int getOrder() {
  200 |         return SecurityFilterOrder.AUTHENTICATION_FILTER.getOrder();
  201 |     }
  202 |     
  203 |     @Override
  204 |     public Class<? extends Filter> getBeforeFilter() {
  205 |         return null; // ì´ í•„í„° ì´ì „ì— ì‹¤í–‰ë˜ì–´ì•¼ í•˜ëŠ” í•„í„°ê°€ ì—†ìŒ
  206 |     }
  207 |     
  208 |     @Override
  209 |     public Class<? extends Filter> getAfterFilter() {
  210 |         return JwtVerificationFilter.class; // JWT ê²€ì¦ í•„í„° ì´ì „ì— ì‹¤í–‰
  211 |     }
  212 |     
  213 |     /**
  214 |      * í•„í„°ì— ìƒˆë¡œìš´ ì¡°ê±´ ì¶”ê°€
  215 |      * @param condition ì¶”ê°€í•  í•„í„° ì¡°ê±´
  216 |      */
  217 |     public void addFilterCondition(FilterCondition condition) {
  218 |         filterRegistry.addCondition(getFilterId(), condition);
  219 |     }
  220 |     
  221 |     /**
  222 |      * í•„í„°ì—ì„œ ì¡°ê±´ ì œê±°
  223 |      * @param condition ì œê±°í•  í•„í„° ì¡°ê±´
  224 |      * @return ì œê±° ì„±ê³µ ì—¬ë¶€
  225 |      */
  226 |     public boolean removeFilterCondition(FilterCondition condition) {
  227 |         return filterRegistry.removeCondition(getFilterId(), condition);
  228 |     }
  229 | }
  230 |             String cookieDomain,
  231 |             ApiChecker apiChecker) {
  232 |         super(authenticationManager, jwtUtility, objectMapper, redisService, domain, cookieDomain);
  233 |         this.apiChecker = apiChecker;
  234 |         setFilterProcessesUrl("/api/auth/login"); // ë¡œê·¸ì¸ URL ì„¤ì •
  235 |     }
  236 |     
  237 |     @Override
  238 |     public Authentication attemptAuthentication(HttpServletRequest request, HttpServletResponse response) 
  239 |             throws AuthenticationException {
  240 |         // ë¶€ëª¨ í´ë˜ìŠ¤ì˜ ì¸ì¦ ë©”ì†Œë“œ í˜¸ì¶œ
  241 |         return super.attemptAuthentication(request, response);
  242 |     }
  243 | 
  244 |     @Override
  245 |     protected void successfulAuthentication(HttpServletRequest request, HttpServletResponse response,
  246 |                                            FilterChain chain, Authentication authResult) throws IOException, ServletException {
  247 |         log.info("ë¡œê·¸ì¸ ì„±ê³µ: í† í° ìƒì„± ì‹œì‘");
  248 |         
  249 |         UserDetails userDetails = (UserDetails) authResult.getPrincipal();
  250 |         String username = userDetails.getUsername();
  251 |         
  252 |         // ì•¡ì„¸ìŠ¤ ë° ë¦¬í”„ë ˆì‹œ í† í° ìƒì„±
  253 |         String accessToken = jwtUtility.generateAccessToken(username);
  254 |         String refreshToken = jwtUtility.generateRefreshToken(username);
  255 |         
  256 |         // ë¦¬í”„ë ˆì‹œ í† í°ì„ Redisì— ì €ì¥
  257 |         redisService.setData("RT:" + username, refreshToken, jwtUtility.getRefreshTokenExpirationTime());
  258 |         
  259 |         // í† í°ì„ ì¿ í‚¤ì— ì €ì¥
  260 |         Cookie accessTokenCookie = new Cookie("access_token", accessToken);
  261 |         accessTokenCookie.setHttpOnly(true);
  262 |         accessTokenCookie.setPath("/");
  263 |         accessTokenCookie.setDomain(cookieDomain);
  264 |         accessTokenCookie.setSecure(true);
  265 |         
  266 |         Cookie refreshTokenCookie = new Cookie("refresh_token", refreshToken);
  267 |         refreshTokenCookie.setHttpOnly(true);
  268 |         refreshTokenCookie.setPath("/");
  269 |         refreshTokenCookie.setDomain(cookieDomain);
  270 |         refreshTokenCookie.setSecure(true);
  271 |         
  272 |         response.addCookie(accessTokenCookie);
  273 |         response.addCookie(refreshTokenCookie);
  274 |         
  275 |         // ì‘ë‹µ ë³¸ë¬¸ì—ë„ í† í° ì •ë³´ í¬í•¨
  276 |         Map<String, String> tokens = new HashMap<>();
  277 |         tokens.put("access_token", accessToken);
  278 |         tokens.put("refresh_token", refreshToken);
  279 |         
  280 |         response.setContentType("application/json");
  281 |         objectMapper.writeValue(response.getOutputStream(), tokens);
  282 |         
  283 |         // SecurityContextì— ì¸ì¦ ì •ë³´ ì„¤ì •
  284 |         SecurityContextHolder.getContext().setAuthentication(authResult);
  285 |         
  286 |         log.info("ë¡œê·¸ì¸ ì„±ê³µ: í† í° ìƒì„± ì™„ë£Œ ë° ì¿ í‚¤ ì„¤ì •");
  287 |     }
  288 |     
  289 |     @Override
  290 |     protected void unsuccessfulAuthentication(HttpServletRequest request, HttpServletResponse response,
  291 |                                              AuthenticationException failed) throws IOException, ServletException {
  292 |         log.error("ë¡œê·¸ì¸ ì‹¤íŒ¨: {}", failed.getMessage());
  293 |         
  294 |         SecurityContextHolder.clearContext();
  295 |         
  296 |         response.setStatus(HttpServletResponse.SC_UNAUTHORIZED);
  297 |         response.setContentType("application/json");
  298 |         
  299 |         Map<String, String> error = new HashMap<>();
  300 |         error.put("error", "ì¸ì¦ ì‹¤íŒ¨");
  301 |         error.put("message", failed.getMessage());
  302 |         
  303 |         objectMapper.writeValue(response.getOutputStream(), error);
  304 |     }
  305 |     
  306 |     @Override
  307 |     public void configure(HttpSecurity http) throws Exception {
  308 |         http.addFilterAt(this, AbstractAuthenticationFilter.class);
  309 |     }
  310 |     
  311 |     @Override
  312 |     public int getOrder() {
  313 |         return 100; // ê¸°ë³¸ ì¸ì¦ í•„í„° ìˆœì„œ
  314 |     }
  315 |     
  316 |     @Override
  317 |     public Class<? extends Filter> getBeforeFilter() {
  318 |         return null; // ì´ í•„í„° ì´ì „ì— ì‹¤í–‰ë˜ì–´ì•¼ í•˜ëŠ” í•„í„°ê°€ ì—†ìŒ
  319 |     }
  320 |     
  321 |     @Override
  322 |     public Class<? extends Filter> getAfterFilter() {
  323 |         return JwtVerificationFilter.class; // JWT ê²€ì¦ í•„í„° ì´ì „ì— ì‹¤í–‰
  324 |     }
  325 | }
  326 |     
  327 |     /**
  328 |      * extendsì™€ implements ë³µìˆ˜ ì‚¬ìš©ì— ê´€í•œ ì„¤ëª…:
  329 |      * 
  330 |      * 1. ë‹¤ì¤‘ ìƒì† êµ¬ì¡°:
  331 |      *    - Javaì—ì„œëŠ” ë‹¨ì¼ ìƒì†ë§Œ ê°€ëŠ¥í•©ë‹ˆë‹¤(extendsëŠ” í•œ í´ë˜ìŠ¤ë§Œ ê°€ëŠ¥)
  332 |      *    - í•˜ì§€ë§Œ ë³µìˆ˜ì˜ ì¸í„°í˜ì´ìŠ¤ êµ¬í˜„(implements)ì€ ê°€ëŠ¥í•©ë‹ˆë‹¤
  333 |      *    - ì¶”ìƒ í´ë˜ìŠ¤ ì˜ˆì œì—ì„œëŠ” UsernamePasswordAuthenticationFilterë¥¼ ìƒì†í•˜ë©´ì„œ
  334 |      *      PluggableFilter ì¸í„°í˜ì´ìŠ¤ë¥¼ êµ¬í˜„í•˜ëŠ” ë°©ì‹ì„ ì‚¬ìš©í–ˆìŠµë‹ˆë‹¤
  335 |      * 
  336 |      * 2. ì¥ì :
  337 |      *    - ìƒì†(extends)ì„ í†µí•´ ê¸°ì¡´ í´ë˜ìŠ¤ì˜ ê¸°ëŠ¥ì„ ì¬ì‚¬ìš©
  338 |      *    - ì¸í„°í˜ì´ìŠ¤ êµ¬í˜„(implements)ì„ í†µí•´ ë‹¤ì–‘í•œ ê³„ì•½ì„ ì¤€ìˆ˜
  339 |      *    - ìœ ì—°í•œ ì„¤ê³„ ê°€ëŠ¥: í•˜ë‚˜ì˜ í´ë˜ìŠ¤ê°€ ë‹¤ì–‘í•œ ì—­í•  ìˆ˜í–‰ ê°€ëŠ¥
  340 |      * 
  341 |      * 3. ë‹¨ì :
  342 |      *    - ë³µì¡í•œ ìƒì† êµ¬ì¡°ëŠ” ì½”ë“œ ì´í•´ë¥¼ ì–´ë µê²Œ ë§Œë“¤ ìˆ˜ ìˆìŒ
  343 |      *    - ë‹¤ì´ì•„ëª¬ë“œ ë¬¸ì œ ë°œìƒ ê°€ëŠ¥(ìƒì† ê³„ì¸µì´ ë³µì¡í•  ë•Œ)
  344 |      *    - ìƒìœ„ í´ë˜ìŠ¤ ë³€ê²½ ì‹œ í•˜ìœ„ í´ë˜ìŠ¤ì— ì˜í–¥
  345 |      * 
  346 |      * 4. êµ¬ì²´ì  êµ¬í˜„ í´ë˜ìŠ¤ì—ì„œëŠ”:
  347 |      *    - AbstractSecurityFilterë¥¼ ìƒì†í•˜ëŠ” ë” ë‹¨ìˆœí•œ êµ¬ì¡° ì±„íƒ
  348 |      *    - ëª…í™•í•œ ì±…ì„ê³¼ ì—­í•  ë¶„ë¦¬ë¡œ ìœ ì§€ë³´ìˆ˜ì„± í–¥ìƒ
  349 |      */

#--------------------------------------------------------------------------------


# File: backend/src/main/java/com/authentication/auth/filter/SecurityFilterOrder.java
#=============================================================================

    1 | package com.authentication.auth.filter;
    2 | 
    3 | /**
    4 |  * @Author: choisimo
    5 |  * @Date: 2025-05-05
    6 |  * @Description: ë³´ì•ˆ í•„í„° ìˆœì„œ ìƒìˆ˜
    7 |  * @Details: í•„í„° ì²´ì¸ ë‚´ì—ì„œ í•„í„°ì˜ ì‹¤í–‰ ìˆœì„œë¥¼ ì •ì˜í•˜ëŠ” ì—´ê±°í˜•
    8 |  */
    9 | public enum SecurityFilterOrder {
   10 |     
   11 |     // ê°’ì´ ë‚®ì„ìˆ˜ë¡ ë¨¼ì € ì‹¤í–‰ë¨
   12 |     REQUEST_LOGGING_FILTER(50),
   13 |     CORS_FILTER(100),
   14 |     CSRF_FILTER(200),
   15 |     AUTHENTICATION_FILTER(300),
   16 |     JWT_VERIFICATION_FILTER(400),
   17 |     AUTHORIZATION_FILTER(500),
   18 |     SESSION_MANAGEMENT_FILTER(600),
   19 |     EXCEPTION_TRANSLATION_FILTER(700);
   20 |     
   21 |     private final int order;
   22 |     
   23 |     SecurityFilterOrder(int order) {
   24 |         this.order = order;
   25 |     }
   26 |     
   27 |     public int getOrder() {
   28 |         return order;
   29 |     }
   30 | }

#--------------------------------------------------------------------------------


# File: backend/src/main/java/com/authentication/auth/filter/SnsRequestFilter.java
#=============================================================================

    1 | package com.authentication.auth.filter;
    2 | 
    3 | import jakarta.servlet.FilterChain;
    4 | import jakarta.servlet.ServletException;
    5 | import jakarta.servlet.http.HttpServletRequest;
    6 | import jakarta.servlet.http.HttpServletResponse;
    7 | import lombok.RequiredArgsConstructor;
    8 | import lombok.extern.slf4j.Slf4j;
    9 | import org.springframework.stereotype.Component;
   10 | 
   11 | import java.io.IOException;
   12 | 
   13 | /**
   14 |  * SNS ë¡œê·¸ì¸ ìš”ì²­ ì²˜ë¦¬ í•„í„°
   15 |  * ì†Œì…œ ë¯¸ë””ì–´ ì¸ì¦ ìš”ì²­ì„ ì²˜ë¦¬í•˜ê³  ë¦¬ë‹¤ì´ë ‰ì…˜
   16 |  */
   17 | @Slf4j
   18 | @Component
   19 | @RequiredArgsConstructor
   20 | public class SnsRequestFilter extends AbstractSecurityFilter {
   21 | 
   22 |     private final ApiChecker apiChecker;
   23 | 
   24 |     public SnsRequestFilter(ApiChecker apiChecker) {
   25 |         super(SecurityFilterOrder.SNS_REQUEST_FILTER);
   26 |         this.apiChecker = apiChecker;
   27 |     }
   28 | 
   29 |     @Override
   30 |     protected void doFilterInternal(HttpServletRequest request, HttpServletResponse response, FilterChain chain)
   31 |             throws IOException, ServletException {
   32 |         
   33 |         String requestURI = request.getRequestURI();
   34 |         
   35 |         // SNS ì¸ì¦ ê´€ë ¨ ê²½ë¡œ ì²˜ë¦¬
   36 |         if (requestURI.startsWith("/api/auth/social/")) {
   37 |             // SNS ì œê³µì ì¶”ì¶œ (ì˜ˆ: /api/auth/social/google)
   38 |             String provider = requestURI.substring("/api/auth/social/".length());
   39 |             
   40 |             log.debug("SNS ì¸ì¦ ìš”ì²­ ê°ì§€: {}", provider);
   41 |             
   42 |             // SNS ë³„ ì¸ì¦ ì²˜ë¦¬ ë¡œì§ êµ¬í˜„
   43 |             // ì˜ˆ: ìš”ì²­ íŒŒë¼ë¯¸í„° ê²€ì¦, ë¦¬ë‹¤ì´ë ‰ì…˜ URL ìƒì„± ë“±
   44 |             
   45 |             // ì¸ì¦ ì½”ë“œê°€ í¬í•¨ëœ ê²½ìš° í† í° êµí™˜ ì²˜ë¦¬
   46 |             String code = request.getParameter("code");
   47 |             if (code != null && !code.isEmpty()) {
   48 |                 log.debug("ì¸ì¦ ì½”ë“œ ì²˜ë¦¬: {}", code);
   49 |                 // ì¸ì¦ ì½”ë“œë¡œ ì•¡ì„¸ìŠ¤ í† í° êµí™˜ ë¡œì§ êµ¬í˜„
   50 |             }
   51 |         }
   52 |         
   53 |         // ë‹¤ìŒ í•„í„°ë¡œ ìš”ì²­ ì „ë‹¬
   54 |         chain.doFilter(request, response);
   55 |     }
   56 | 
   57 |     @Override
   58 |     protected boolean shouldNotFilter(HttpServletRequest request) {
   59 |         String requestURI = request.getRequestURI();
   60 |         
   61 |         // SNS ì¸ì¦ ê²½ë¡œë§Œ í•„í„°ë§
   62 |         if (requestURI.startsWith("/api/auth/social/")) {
   63 |             return false; // í•„í„° ì ìš©
   64 |         }
   65 |         
   66 |         // ë‹¤ë¥¸ ëª¨ë“  ê²½ë¡œëŠ” ì´ í•„í„°ë¥¼ ê±´ë„ˆëœ€
   67 |         return true;
   68 |     }
   69 | }

#--------------------------------------------------------------------------------


# File: backend/src/main/java/com/authentication/auth/filter/AbstractSecurityFilter.java
#=============================================================================

    1 | package com.authentication.auth.filter;
    2 | 
    3 | import jakarta.servlet.Filter;
    4 | import jakarta.servlet.FilterChain;
    5 | import jakarta.servlet.ServletException;
    6 | import jakarta.servlet.ServletRequest;
    7 | import jakarta.servlet.ServletResponse;
    8 | import jakarta.servlet.http.HttpServletRequest;
    9 | import jakarta.servlet.http.HttpServletResponse;
   10 | import lombok.extern.slf4j.Slf4j;
   11 | 
   12 | import java.io.IOException;
   13 | 
   14 | /**
   15 |  * ëª¨ë“  ë³´ì•ˆ í•„í„°ì˜ ê¸°ë³¸ ì¶”ìƒ í´ë˜ìŠ¤
   16 |  * í•„í„° ì‹¤í–‰ íë¦„ ì œì–´ ë° ê³µí†µ ê¸°ëŠ¥ ì œê³µ
   17 |  */
   18 | @Slf4j
   19 | public abstract class AbstractSecurityFilter implements Filter {
   20 | 
   21 |     private final SecurityFilterOrder filterOrder;
   22 | 
   23 |     protected AbstractSecurityFilter(SecurityFilterOrder filterOrder) {
   24 |         this.filterOrder = filterOrder;
   25 |     }
   26 | 
   27 |     @Override
   28 |     public void doFilter(ServletRequest request, ServletResponse response, FilterChain chain)
   29 |             throws IOException, ServletException {
   30 |         
   31 |         HttpServletRequest httpRequest = (HttpServletRequest) request;
   32 |         HttpServletResponse httpResponse = (HttpServletResponse) response;
   33 |         
   34 |         // í•„í„° ê±´ë„ˆë›°ê¸° ì—¬ë¶€ í™•ì¸
   35 |         if (shouldNotFilter(httpRequest)) {
   36 |             chain.doFilter(request, response);
   37 |             return;
   38 |         }
   39 |         
   40 |         try {
   41 |             log.debug("í•„í„° ì‹œì‘: {}", filterOrder.name());
   42 |             doFilterInternal(httpRequest, httpResponse, chain);
   43 |             log.debug("í•„í„° ì¢…ë£Œ: {}", filterOrder.name());
   44 |         } catch (Exception e) {
   45 |             log.error("í•„í„° ì‹¤í–‰ ì¤‘ ì˜¤ë¥˜ ë°œìƒ: {}", filterOrder.name(), e);
   46 |             handleFilterException(httpRequest, httpResponse, e);
   47 |         }
   48 |     }
   49 |     
   50 |     /**
   51 |      * í•„í„°ì˜ ì£¼ìš” ë¹„ì¦ˆë‹ˆìŠ¤ ë¡œì§ êµ¬í˜„
   52 |      */
   53 |     protected abstract void doFilterInternal(HttpServletRequest request, HttpServletResponse response, 
   54 |                                            FilterChain chain) throws IOException, ServletException;
   55 |     
   56 |     package com.authentication.auth.filter;
   57 |     
   58 |     import jakarta.servlet.Filter;
   59 |     import jakarta.servlet.FilterChain;
   60 |     import jakarta.servlet.ServletException;
   61 |     import jakarta.servlet.ServletRequest;
   62 |     import jakarta.servlet.ServletResponse;
   63 |     import jakarta.servlet.http.HttpServletRequest;
   64 |     import jakarta.servlet.http.HttpServletResponse;
   65 |     import lombok.extern.slf4j.Slf4j;
   66 |     import org.springframework.web.filter.OncePerRequestFilter;
   67 |     
   68 |     import java.io.IOException;
   69 |     
   70 |     /**
   71 |      * @Author: choisimo
   72 |      * @Date: 2025-05-05
   73 |      * @Description: ì¶”ìƒ ë³´ì•ˆ í•„í„°
   74 |      * @Details: ëª¨ë“  ë³´ì•ˆ í•„í„°ì˜ ê¸°ë³¸ êµ¬í˜„ì„ ì œê³µí•˜ëŠ” ì¶”ìƒ í´ë˜ìŠ¤
   75 |      */
   76 |     @Slf4j
   77 |     public abstract class AbstractSecurityFilter extends OncePerRequestFilter implements PluggableFilter {
   78 |     
   79 |         // í•„í„° ì‹¤í–‰ ìˆœì„œ
   80 |         private final SecurityFilterOrder securityFilterOrder;
   81 |     
   82 |         /**
   83 |          * ìƒì„±ì
   84 |          * @param securityFilterOrder í•„í„° ì‹¤í–‰ ìˆœì„œ
   85 |          */
   86 |         protected AbstractSecurityFilter(SecurityFilterOrder securityFilterOrder) {
   87 |             this.securityFilterOrder = securityFilterOrder;
   88 |         }
   89 |     
   90 |         @Override
   91 |         public final void doFilter(ServletRequest request, ServletResponse response, FilterChain chain)
   92 |                 throws IOException, ServletException {
   93 |             doFilter((HttpServletRequest) request, (HttpServletResponse) response, chain);
   94 |         }
   95 |     
   96 |         /**
   97 |          * HTTP ìš”ì²­ì— ëŒ€í•œ í•„í„° ì²˜ë¦¬
   98 |          * @param request HTTP ìš”ì²­
   99 |          * @param response HTTP ì‘ë‹µ
  100 |          * @param chain í•„í„° ì²´ì¸
  101 |          * @throws IOException IO ì˜ˆì™¸ ë°œìƒ ì‹œ
  102 |          * @throws ServletException ì„œë¸”ë¦¿ ì˜ˆì™¸ ë°œìƒ ì‹œ
  103 |          */
  104 |         private void doFilter(HttpServletRequest request, HttpServletResponse response, FilterChain chain)
  105 |                 throws IOException, ServletException {
  106 |             super.doFilter(request, response, chain);
  107 |         }
  108 |     
  109 |         @Override
  110 |         protected final boolean shouldNotFilter(HttpServletRequest request) throws ServletException {
  111 |             String path = request.getRequestURI();
  112 |             boolean shouldNotFilter = shouldSkipFilter(request);
  113 |             
  114 |             if (shouldNotFilter) {
  115 |                 log.trace("í•„í„° ê±´ë„ˆëœ€ ({}): {}", getFilterId(), path);
  116 |             } else {
  117 |                 log.trace("í•„í„° ì ìš© ({}): {}", getFilterId(), path);
  118 |             }
  119 |             
  120 |             return shouldNotFilter;
  121 |         }
  122 |         
  123 |         /**
  124 |          * í•„í„° ì ìš© ì—¬ë¶€ ê²°ì •
  125 |          * @param request HTTP ìš”ì²­
  126 |          * @return trueì¸ ê²½ìš° í•„í„° ì‹¤í–‰ ê±´ë„ˆëœ€
  127 |          */
  128 |         protected abstract boolean shouldSkipFilter(HttpServletRequest request);
  129 |     
  130 |         @Override
  131 |         public int getOrder() {
  132 |             return securityFilterOrder.getOrder();
  133 |         }
  134 |         
  135 |         @Override
  136 |         public String getFilterId() {
  137 |             return this.getClass().getSimpleName();
  138 |         }
  139 |     }
  140 |     
  141 |     /**
  142 |      * í•„í„° ì˜ˆì™¸ ì²˜ë¦¬ ë©”ì„œë“œ
  143 |      */
  144 |     protected void handleFilterException(HttpServletRequest request, HttpServletResponse response, Exception e) 
  145 |             throws IOException, ServletException {
  146 |         // ê¸°ë³¸ êµ¬í˜„ì—ì„œëŠ” ì˜ˆì™¸ë¥¼ ì „íŒŒ
  147 |         // í•„ìš”ì‹œ í•˜ìœ„ í´ë˜ìŠ¤ì—ì„œ ì¬ì •ì˜
  148 |         if (e instanceof IOException) {
  149 |             throw (IOException) e;
  150 |         } else if (e instanceof ServletException) {
  151 |             throw (ServletException) e;
  152 |         } else {
  153 |             throw new ServletException("í•„í„° ì²˜ë¦¬ ì¤‘ ì˜¤ë¥˜ ë°œìƒ", e);
  154 |         }
  155 |     }
  156 |     
  157 |     /**
  158 |      * í•„í„° ìˆœì„œ ë°˜í™˜
  159 |      */
  160 |     public int getOrder() {
  161 |         return filterOrder.getOrder();
  162 |     }
  163 | }

#--------------------------------------------------------------------------------


# File: backend/src/main/java/com/authentication/auth/domain/Diary.java
#=============================================================================

    1 | package com.authentication.auth.domain;
    2 | 
    3 | import jakarta.persistence.*;
    4 | import lombok.AllArgsConstructor;
    5 | import lombok.Data;
    6 | import lombok.NoArgsConstructor;
    7 | 
    8 | import java.time.LocalDateTime;
    9 | 
   10 | @Entity
   11 | @Table(name = "Diary")
   12 | @Data
   13 | @NoArgsConstructor
   14 | @AllArgsConstructor
   15 | public class Diary {
   16 | 
   17 |     @Id
   18 |     @GeneratedValue(strategy = GenerationType.IDENTITY)
   19 |     private Long id;
   20 | 
   21 |     @ManyToOne(fetch = FetchType.LAZY)
   22 |     @JoinColumn(name = "user_id", nullable = false)
   23 |     private User user;
   24 | 
   25 |     @Column(name = "created_at")
   26 |     private LocalDateTime createdAt;
   27 | 
   28 |     @Column(name = "updated_at")
   29 |     private LocalDateTime updatedAt;
   30 | 
   31 |     private String title;
   32 | 
   33 |     @Column(nullable = false)
   34 |     private String content;
   35 | 
   36 |     @Column(name = "alternative_thought")
   37 |     private String alternativeThought;
   38 | 
   39 |     @OneToOne(mappedBy = "diary", cascade = CascadeType.ALL, orphanRemoval = true)
   40 |     private DiaryAnswer diaryAnswer;
   41 | 
   42 |     @PrePersist
   43 |     protected void onCreate() {
   44 |         createdAt = LocalDateTime.now();
   45 |         updatedAt = LocalDateTime.now();
   46 |     }
   47 | 
   48 |     @PreUpdate
   49 |     protected void onUpdate() {
   50 |         updatedAt = LocalDateTime.now();
   51 |     }
   52 | }

#--------------------------------------------------------------------------------


# File: backend/src/main/java/com/authentication/auth/domain/DiaryAnswer.java
#=============================================================================

    1 | package com.authentication.auth.domain;
    2 | 
    3 | import jakarta.persistence.*;
    4 | import lombok.AllArgsConstructor;
    5 | import lombok.Data;
    6 | import lombok.NoArgsConstructor;
    7 | 
    8 | import java.time.LocalDateTime;
    9 | 
   10 | @Entity
   11 | @Table(name = "Diary_Answer")
   12 | @Data
   13 | @NoArgsConstructor
   14 | @AllArgsConstructor
   15 | public class DiaryAnswer {
   16 | 
   17 |     @Id
   18 |     @GeneratedValue(strategy = GenerationType.IDENTITY)
   19 |     private Long id;
   20 | 
   21 |     @OneToOne(fetch = FetchType.LAZY)
   22 |     @JoinColumn(name = "diary_id", nullable = false)
   23 |     private Diary diary;
   24 | 
   25 |     @Column(name = "created_at")
   26 |     private LocalDateTime createdAt;
   27 | 
   28 |     @Column(name = "updated_at")
   29 |     private LocalDateTime updatedAt;
   30 | 
   31 |     @Column(name = "emotion_detection")
   32 |     private String emotionDetection;
   33 | 
   34 |     @Column(name = "automatic_thought")
   35 |     private String automaticThought;
   36 | 
   37 |     @Column(name = "prompt_for_change")
   38 |     private String promptForChange;
   39 | 
   40 |     @Column(name = "alternative_thought")
   41 |     private String alternativeThought;
   42 | 
   43 |     @Enumerated(EnumType.STRING)
   44 |     @Column(nullable = false)
   45 |     private EmotionStatus status = EmotionStatus.NEUTRAL;
   46 | 
   47 |     public enum EmotionStatus {
   48 |         POSITIVE, NEGATIVE, NEUTRAL
   49 |     }
   50 | }

#--------------------------------------------------------------------------------


# File: backend/src/main/java/com/authentication/auth/domain/AuthProvider.java
#=============================================================================

    1 | @Entity
    2 | @Table(name = "Auth_Provider")
    3 | @Data
    4 | @NoArgsConstructor
    5 | @AllArgsConstructor
    6 | public class AuthProvider {
    7 |     @Id
    8 |     @GeneratedValue(strategy = GenerationType.IDENTITY)
    9 |     private Integer id;
   10 |     
   11 |     @Column(name = "provider_name", nullable = false, length = 50)
   12 |     private String providerName = "SERVER";
   13 |     
   14 |     private String description;
   15 |     
   16 |     @Column(name = "is_active")
   17 |     private Boolean isActive = true;
   18 |     
   19 |     @OneToMany(mappedBy = "authProvider", cascade = CascadeType.ALL)
   20 |     private List<UserAuthentication> userAuthentications = new ArrayList<>();
   21 | }

#--------------------------------------------------------------------------------


# File: backend/src/main/java/com/authentication/auth/domain/User.java
#=============================================================================

    1 | package com.authentication.auth.domain;
    2 | 
    3 | import jakarta.persistence.*;
    4 | import lombok.AllArgsConstructor;
    5 | import lombok.Data;
    6 | import lombok.NoArgsConstructor;
    7 | import java.time.LocalDateTime;
    8 | import java.util.ArrayList;
    9 | import java.util.List;
   10 | 
   11 | @Entity
   12 | @Table(name = "Users")
   13 | @Data
   14 | @NoArgsConstructor
   15 | @AllArgsConstructor
   16 | public class User {
   17 |     @Id
   18 |     @GeneratedValue(strategy = GenerationType.IDENTITY)
   19 |     private Long id;
   20 | 
   21 |     @Column(nullable = false)
   22 |     private String password;
   23 | 
   24 |     @Column(name = "created_at")
   25 |     private LocalDateTime createdAt;
   26 | 
   27 |     @Column(name = "updated_at")
   28 |     private LocalDateTime updatedAt;
   29 | 
   30 |     @Column(name = "user_name", nullable = false, length = 30)
   31 |     private String userName;
   32 | 
   33 |     @Enumerated(EnumType.STRING)
   34 |     @Column(name = "user_role", nullable = false)
   35 |     private UserRole userRole = UserRole.USER;
   36 | 
   37 |     @Column(name = "is_premium")
   38 |     private Boolean isPremium = false;
   39 | 
   40 |     @Column(name = "last_login")
   41 |     private LocalDateTime lastLogin;
   42 | 
   43 |     @Enumerated(EnumType.STRING)
   44 |     @Column(name = "is_active", nullable = false)
   45 |     private UserStatus isActive = UserStatus.WAITING;
   46 | 
   47 |     @OneToMany(mappedBy = "user")
   48 |     private List<Diary> diaries = new ArrayList<>();
   49 | 
   50 |     @PrePersist
   51 |     protected void onCreate() {
   52 |         createdAt = LocalDateTime.now();
   53 |         updatedAt = LocalDateTime.now();
   54 |     }
   55 | 
   56 |     @PreUpdate
   57 |     protected void onUpdate() {
   58 |         updatedAt = LocalDateTime.now();
   59 |     }
   60 | 
   61 |     public enum UserRole {
   62 |         USER, ADMIN
   63 |     }
   64 | 
   65 |     /**
   66 |      * ì‚¬ìš©ì ìƒíƒœë¥¼ ë‚˜íƒ€ë‚´ëŠ” ì—´ê±°í˜•
   67 |      * schema.sqlì˜ enum('active','waiting','blocked','suspend','delete') ê°’ê³¼ ì¼ì¹˜
   68 |      */
   69 |     public enum UserStatus {
   70 |         // DB ìŠ¤í‚¤ë§ˆì˜ ê°’ê³¼ ì¼ì¹˜ì‹œí‚¤ê¸° ìœ„í•´ ì†Œë¬¸ìë¡œ ì •ì˜
   71 |         // JPAì—ì„œëŠ” UPPERCASEë¡œ ë³€í™˜í•˜ë¯€ë¡œ @Enumerated(EnumType.STRING) ì‚¬ìš© ì‹œ ì£¼ì˜ í•„ìš”
   72 |         ACTIVE("active"), 
   73 |         WAITING("waiting"), 
   74 |         BLOCKED("blocked"), 
   75 |         SUSPEND("suspend"), 
   76 |         DELETE("delete");
   77 |         
   78 |         private final String value;
   79 |         
   80 |         UserStatus(String value) {
   81 |             this.value = value;
   82 |         }
   83 |         
   84 |         public String getValue() {
   85 |             return value;
   86 |         }
   87 |         
   88 |         @Override
   89 |         public String toString() {
   90 |             return value;
   91 |         }
   92 |     }
   93 | }

#--------------------------------------------------------------------------------


# File: backend/src/main/java/com/authentication/auth/domain/UserAuthentication.java
#=============================================================================

    1 | @Entity
    2 | @Table(name = "User_Authentication", uniqueConstraints = {
    3 |     @UniqueConstraint(columnNames = {"auth_provider_id", "social_id"})
    4 | })
    5 | @Data
    6 | @NoArgsConstructor
    7 | @AllArgsConstructor
    8 | public class UserAuthentication {
    9 |     @EmbeddedId
   10 |     private UserAuthenticationId id;
   11 |     
   12 |     @ManyToOne(fetch = FetchType.LAZY)
   13 |     @MapsId("userId")
   14 |     @JoinColumn(name = "user_id")
   15 |     private User user;
   16 |     
   17 |     @ManyToOne(fetch = FetchType.LAZY)
   18 |     @MapsId("authProviderId")
   19 |     @JoinColumn(name = "auth_provider_id")
   20 |     private AuthProvider authProvider;
   21 |     
   22 |     @Column(name = "social_id", nullable = false)
   23 |     private String socialId;
   24 |     
   25 |     private String email;
   26 |     
   27 |     @Column(name = "created_at")
   28 |     private LocalDateTime createdAt;
   29 |     
   30 |     @Column(name = "updated_at")
   31 |     private LocalDateTime updatedAt;
   32 | }
   33 | 
   34 | @Embeddable
   35 | @Data
   36 | @NoArgsConstructor
   37 | @AllArgsConstructor
   38 | public class UserAuthenticationId implements Serializable {
   39 |     @Column(name = "user_id")
   40 |     private Long userId;
   41 |     
   42 |     @Column(name = "auth_provider_id")
   43 |     private Integer authProviderId;
   44 |     
   45 |     @Column(name = "social_id")
   46 |     private String socialId;
   47 | }

#--------------------------------------------------------------------------------


# File: backend/src/main/java/com/authentication/auth/domain/SettingsOption.java
#=============================================================================

    1 | package com.authentication.auth.domain;
    2 | 
    3 | import java.util.ArrayList;
    4 | import java.util.List;
    5 | import jakarta.persistence.*;
    6 | import lombok.AllArgsConstructor;
    7 | import lombok.Data;
    8 | import lombok.NoArgsConstructor;
    9 | 
   10 | @Entity
   11 | @Table(name = "Settings_option")
   12 | @Data
   13 | @NoArgsConstructor
   14 | @AllArgsConstructor
   15 | public class SettingsOption {
   16 |     @Id
   17 |     @GeneratedValue(strategy = GenerationType.IDENTITY)
   18 |     private Integer id;
   19 |     
   20 |     @Column(name = "setting_key", nullable = false, unique = true, length = 50)
   21 |     private String settingKey;
   22 |     
   23 |     @Column(name = "default_value", nullable = false)
   24 |     private String defaultValue;
   25 |     
   26 |     @Enumerated(EnumType.STRING)
   27 |     @Column(name = "data_type", nullable = false)
   28 |     private DataType dataType;
   29 |     
   30 |     private String description;
   31 |     
   32 |     @Column(name = "is_user_editable")
   33 |     private Boolean isUserEditable = true;
   34 |     
   35 |     @OneToMany(mappedBy = "settingsOption", cascade = CascadeType.ALL)
   36 |     private List<UserCustomSetting> userCustomSettings = new ArrayList<>();
   37 |     
   38 |     public enum DataType {
   39 |         STRING, NUMBER, BOOLEAN, JSON
   40 |     }
   41 | }

#--------------------------------------------------------------------------------


# File: backend/src/main/java/com/authentication/auth/domain/UserCustomSetting.java
#=============================================================================

    1 | package com.authentication.auth.domain;
    2 | 
    3 | @Entity
    4 | @Table(name = "User_custom_setting")
    5 | @Data
    6 | @NoArgsConstructor
    7 | @AllArgsConstructor
    8 | public class UserCustomSetting {
    9 |     @EmbeddedId
   10 |     private UserCustomSettingId id;
   11 |     
   12 |     @ManyToOne(fetch = FetchType.LAZY)
   13 |     @MapsId("userId")
   14 |     @JoinColumn(name = "user_id")
   15 |     private User user;
   16 |     
   17 |     @ManyToOne(fetch = FetchType.LAZY)
   18 |     @MapsId("settingId")
   19 |     @JoinColumn(name = "setting_id")
   20 |     private SettingsOption settingsOption;
   21 |     
   22 |     @Column(name = "override_value", nullable = false)
   23 |     private String overrideValue;
   24 |     
   25 |     @Column(name = "created_at")
   26 |     private LocalDateTime createdAt;
   27 |     
   28 |     @Column(name = "updated_at")
   29 |     private LocalDateTime updatedAt;
   30 | }
   31 | 
   32 | @Embeddable
   33 | @Data
   34 | @NoArgsConstructor
   35 | @AllArgsConstructor
   36 | public class UserCustomSettingId implements Serializable {
   37 |     @Column(name = "user_id")
   38 |     private Long userId;
   39 |     
   40 |     @Column(name = "setting_id")
   41 |     private Integer settingId;
   42 | }

#--------------------------------------------------------------------------------


# File: backend/src/main/java/com/authentication/auth/controller/usersController.java
#=============================================================================

    1 | package com.career_block.auth.controller;
    2 | 
    3 | import io.swagger.v3.oas.annotations.Operation;
    4 | import io.swagger.v3.oas.annotations.media.Content;
    5 | import io.swagger.v3.oas.annotations.responses.ApiResponse;
    6 | import io.swagger.v3.oas.annotations.responses.ApiResponses;
    7 | import io.swagger.v3.oas.annotations.tags.Tag;
    8 | import jakarta.servlet.http.Cookie;
    9 | import jakarta.servlet.http.HttpServletRequest;
   10 | import jakarta.servlet.http.HttpServletResponse;
   11 | import lombok.RequiredArgsConstructor;
   12 | import lombok.extern.slf4j.Slf4j;
   13 | import org.apache.commons.io.FilenameUtils;
   14 | import org.springframework.beans.factory.annotation.Value;
   15 | import org.springframework.http.HttpStatus;
   16 | import org.springframework.http.ResponseEntity;
   17 | import org.springframework.web.bind.annotation.*;
   18 | import org.springframework.web.multipart.MultipartFile;
   19 | 
   20 | import com.authentication.auth.DTO.token.tokenDto;
   21 | import com.authentication.auth.DTO.users.joinRequest;
   22 | import com.authentication.auth.configuration.token.jwtUtility;
   23 | import com.authentication.auth.others.constants.SecurityConstants;
   24 | import com.authentication.auth.service.redis.redisService;
   25 | import com.authentication.auth.service.smtp.emailService;
   26 | import com.authentication.auth.service.users.userService;
   27 | 
   28 | import java.io.File;
   29 | import java.io.IOException;
   30 | import java.nio.file.Files;
   31 | import java.util.*;
   32 | 
   33 | @Slf4j
   34 | @RestController
   35 | @RequiredArgsConstructor
   36 | @RequestMapping("/api")
   37 | @Tag(name = "User Management", description = "ìœ ì € ê´€ë¦¬ API")
   38 | public class usersController {
   39 | 
   40 |     @Value("${file.profile-path}")
   41 |     private String profilePath;
   42 |     @Value("${file.server}")
   43 |     private String fileServer;
   44 |     @Value("${site.domain}")
   45 |     private String domain;
   46 |     private final userService userService;
   47 |     private final emailService emailService;
   48 |     private final redisService redisService;
   49 |     private final jwtUtility jwtUtility;
   50 | 
   51 |     @Operation(summary = "íšŒì› ê°€ì…", description = "ìƒˆë¡œìš´ ìœ ì €ë¥¼ ë“±ë¡í•©ë‹ˆë‹¤.")
   52 |     @ApiResponses(value = {
   53 |             @ApiResponse(responseCode = "200", description = "íšŒì› ê°€ì… ì„±ê³µ", content = @Content(mediaType = "application/json")),
   54 |             @ApiResponse(responseCode = "500", description = "íšŒì› ê°€ì… ì‹¤íŒ¨", content = @Content(mediaType = "application/json"))
   55 |     })
   56 |     @PostMapping("/public/join")
   57 |     public ResponseEntity<?> join(@RequestBody joinRequest request) throws Exception {
   58 |         if (!redisService.checkEmailCode(request.getEmail(), request.getCode()))
   59 |             return ResponseEntity.status(HttpStatus.BAD_REQUEST).body("Email validation is not accessed");
   60 |         ResponseEntity<?> save = userService.join(request);
   61 |         if (save.getStatusCode() == HttpStatus.CONFLICT)
   62 |             return ResponseEntity.status(HttpStatus.CONFLICT).body("already exist userId or nickname");
   63 |         if (save.getStatusCode() == HttpStatus.OK) {
   64 |             return ResponseEntity.status(HttpStatus.OK).body("join successfully");
   65 |         } else {
   66 |             return ResponseEntity.status(HttpStatus.INTERNAL_SERVER_ERROR).body("join save failed");
   67 |         }
   68 |     }
   69 | 
   70 |     @Operation(summary = "í”„ë¡œí•„ ì—…ë¡œë“œ", description = "ìœ ì € í”„ë¡œí•„ ì´ë¯¸ì§€ë¥¼ ì—…ë¡œë“œí•©ë‹ˆë‹¤.")
   71 |     @ApiResponses(value = {
   72 |             @ApiResponse(responseCode = "200", description = "í”„ë¡œí•„ ì—…ë¡œë“œ ì„±ê³µ", content = @Content(mediaType = "application/json")),
   73 |             @ApiResponse(responseCode = "400", description = "ì˜ëª»ëœ íŒŒì¼ ì´ë¦„ ë˜ëŠ” í™•ì¥ì", content = @Content(mediaType = "application/json")),
   74 |             @ApiResponse(responseCode = "500", description = "ì„œë²„ ì˜¤ë¥˜", content = @Content(mediaType = "application/json"))
   75 |     })
   76 |     @PostMapping("/public/profileUpload")
   77 |     public ResponseEntity<?> fileUpload(@RequestParam("profile") MultipartFile[] files) {
   78 |         Map<String, String> response = new HashMap<>();
   79 |         for (MultipartFile file : files) {
   80 |             try {
   81 |                 String originName = file.getOriginalFilename();
   82 |                 if (originName == null || originName.contains("..")) {
   83 |                     log.error("invalid file name : " + originName);
   84 |                     return ResponseEntity.status(HttpStatus.BAD_REQUEST).body("invalid file name : " + originName);
   85 |                 }
   86 | 
   87 |                 String originNameOnly = FilenameUtils.getBaseName(originName);
   88 |                 String extension = FilenameUtils.getExtension(originName);
   89 |                 if (!isValidExtension(extension)) {
   90 |                     log.error("invalid file extension : " + extension);
   91 |                     return ResponseEntity.status(HttpStatus.BAD_REQUEST).body("invalid file extension : " + extension);
   92 |                 }
   93 | 
   94 |                 String fileName = UUID.randomUUID().toString() + "_" + originNameOnly + "." + extension;
   95 | 
   96 |                 File directory = new File(profilePath);
   97 |                 if (!directory.exists()) {
   98 |                     directory.mkdirs();
   99 |                 }
  100 |                 File targetFile = new File(profilePath, fileName);
  101 |                 file.transferTo(targetFile);
  102 | 
  103 |                 log.info("Saving file to {}", targetFile.getAbsolutePath());
  104 | 
  105 |                 if (!isValidFileContent(targetFile, extension)) {
  106 |                     targetFile.delete();
  107 |                     log.error("invalid file content");
  108 |                     return ResponseEntity.status(HttpStatus.BAD_REQUEST).body("invalid file content");
  109 |                 }
  110 | 
  111 |                 log.info("saving file dir to {}", targetFile.getAbsolutePath());
  112 | 
  113 |                 response.put("fileName", fileServer + "/attach/profile/" + fileName);
  114 | 
  115 |             } catch (IOException e) {
  116 |                 log.error("í”„ë¡œí•„ íŒŒì¼ ì—…ë¡œë“œ ì¤‘ ì˜¤ë¥˜ ë°œìƒ!", e);
  117 |                 return ResponseEntity.status(HttpStatus.INTERNAL_SERVER_ERROR).body("profile upload error");
  118 |             }
  119 |         }
  120 |         return ResponseEntity.status(HttpStatus.OK).body(response);
  121 |     }
  122 | 
  123 | 
  124 |     private boolean isValidExtension(String extension) {
  125 |         List<String> allowedExtensions = Arrays.asList("jpg", "jpeg", "png", "gif", "bmp", "webp", "svg", "tiff");
  126 |         return allowedExtensions.contains(extension);
  127 |     }
  128 | 
  129 |     private boolean isValidFileContent(File file, String extension) {
  130 |         try {
  131 |             String mimeType = Files.probeContentType(file.toPath());
  132 |             List<String> allowedMimeTypes = Arrays.asList(
  133 |                     "image/jpeg", "image/png", "image/gif", "image/bmp", "image/webp", "image/svg+xml", "image/tiff"
  134 |             );
  135 |             return allowedMimeTypes.contains(mimeType);
  136 |         } catch (IOException e) {
  137 |             log.error("íŒŒì¼ ë‚´ìš© ê²€ì¦ ì¤‘ ì˜¤ë¥˜ ë°œìƒ", e);
  138 |             return false;
  139 |         }
  140 |     }
  141 | 
  142 |     @Operation(summary = "ì•„ì´ë”” ì¤‘ë³µ ì²´í¬", description = "ì•„ì´ë””ì˜ ì¤‘ë³µ ì—¬ë¶€ë¥¼ ì²´í¬í•©ë‹ˆë‹¤.")
  143 |     @ApiResponses(value = {
  144 |             @ApiResponse(responseCode = "200", description = "ì¤‘ë³µ ì²´í¬ ì„±ê³µ", content = @Content(mediaType = "application/json"))
  145 |     })
  146 |     @PostMapping("/public/check/userId/IsDuplicate")
  147 |     public boolean checkUserIdIsDuplicate(@RequestBody HashMap<String, String> user) {
  148 |         log.info("/check/userId/IsDuplicate : {}", user.get("userId"));
  149 |         return userService.checkUserIdIsDuplicate(user.get("userId"));
  150 |     }
  151 | 
  152 |     @Operation(summary = "ë‹‰ë„¤ì„ ì¤‘ë³µ ì²´í¬", description = "ë‹‰ë„¤ì„ì˜ ì¤‘ë³µ ì—¬ë¶€ë¥¼ ì²´í¬í•©ë‹ˆë‹¤.")
  153 |     @ApiResponses(value = {
  154 |             @ApiResponse(responseCode = "200", description = "ì¤‘ë³µ ì²´í¬ ì„±ê³µ", content = @Content(mediaType = "application/json"))
  155 |     })
  156 |     @PostMapping("/public/check/nickname/IsDuplicate")
  157 |     public boolean checkNickNameDuplicate(@RequestBody HashMap<String, String> user) {
  158 |         log.info("/check/nickname/IsDuplicate : {}", user.get("nickname"));
  159 |         return userService.checkNickNameIsDuplicate(user.get("nickname"));
  160 |     }
  161 | 
  162 |     @PostMapping("/public/clean/userTokenCookie")
  163 |     public ResponseEntity<?> cleanUserTokenCookie(HttpServletRequest request, HttpServletResponse response) {
  164 |         String cookieName = "refreshToken";
  165 |         Cookie[] cookies = request.getCookies();
  166 |         if (cookies != null) {
  167 |             for (Cookie cookie : cookies) {
  168 |                 if (cookieName.equals(cookie.getName())) {
  169 |                     cookie.setMaxAge(0);
  170 |                     cookie.setPath("/");
  171 |                     cookie.setHttpOnly(true);
  172 |                     response.addCookie(cookie);
  173 |                 }
  174 |             }
  175 |         }
  176 |         return ResponseEntity.ok().body("refreshToken deleted");
  177 |     }
  178 | 
  179 |     private void sendFrontNewCookie(HttpServletResponse response, int status, tokenDto tokendto) {
  180 |         response.setStatus(status);
  181 |         response.addHeader(SecurityConstants.TOKEN_HEADER, SecurityConstants.TOKEN_PREFIX + tokendto.getAccessToken());
  182 |         Cookie refreshTokenCookie = new Cookie("refreshToken", tokendto.getRefreshToken());
  183 |         refreshTokenCookie.setHttpOnly(true);
  184 |         refreshTokenCookie.setDomain(domain);
  185 |         refreshTokenCookie.setPath("/");
  186 |         response.addCookie(refreshTokenCookie);
  187 |     }
  188 | 
  189 |     private String getRefreshTokenFromCookie(HttpServletRequest request) {
  190 |         // cookie ë°°ì—´ ê°€ì§€ê³  ì˜¤ê¸°
  191 |         Cookie[] cookies = request.getCookies();
  192 | 
  193 |         if (cookies != null) {
  194 |             for (Cookie cookie : cookies) {
  195 |                 if ("refreshToken".equals(cookie.getName())) {
  196 |                     return cookie.getValue();
  197 |                 }
  198 |             }
  199 |         }
  200 |         log.error("[getRefreshTokenFromCookie] cookie ì—ì„œ refreshToken ì°¾ê¸° ì‹¤íŒ¨");
  201 |         return null;
  202 |     }
  203 | 
  204 |     private boolean RedisMatchRToken(String userId, String RToken) {
  205 |         return redisService.findRToken(userId, "server", RToken);
  206 |     }
  207 | }

#--------------------------------------------------------------------------------


# File: backend/src/main/java/com/authentication/auth/controller/sseController.java
#=============================================================================

    1 | package com.career_block.auth.controller;
    2 | 
    3 | import io.swagger.v3.oas.annotations.Operation;
    4 | import io.swagger.v3.oas.annotations.media.Content;
    5 | import io.swagger.v3.oas.annotations.responses.ApiResponse;
    6 | import io.swagger.v3.oas.annotations.responses.ApiResponses;
    7 | import lombok.RequiredArgsConstructor;
    8 | import lombok.extern.slf4j.Slf4j;
    9 | import org.springframework.http.HttpStatus;
   10 | import org.springframework.http.MediaType;
   11 | import org.springframework.http.ResponseEntity;
   12 | import org.springframework.security.core.annotation.AuthenticationPrincipal;
   13 | import org.springframework.web.bind.annotation.*;
   14 | import org.springframework.web.servlet.mvc.method.annotation.SseEmitter;
   15 | 
   16 | import com.authentication.auth.DTO.token.principalDetails;
   17 | import com.authentication.auth.service.sse.sseService;
   18 | 
   19 | import java.util.Map;
   20 | 
   21 | @Slf4j
   22 | @RestController
   23 | @RequiredArgsConstructor
   24 | @RequestMapping("/api")
   25 | public class sseController {
   26 | 
   27 |     private final sseService sseService;
   28 | 
   29 | 
   30 |     /**
   31 |      * í´ë¼ì´ì–¸íŠ¸ê°€ SSE ìŠ¤íŠ¸ë¦¼ì— êµ¬ë…í•˜ê¸° ìœ„í•œ ì—”ë“œí¬ì¸íŠ¸
   32 |      * ì˜ˆ: GET /sse/subscribe/{userId}
   33 |      *
   34 |      * @param userId ì‚¬ìš©ìì˜ ê³ ìœ  ID
   35 |      * @return SseEmitter ê°ì²´
   36 |      */
   37 |     @Operation(summary = "SSE êµ¬ë…", description = "ì„œë²„ì—ì„œ SSE ì´ë²¤íŠ¸ë¥¼ êµ¬ë…í•©ë‹ˆë‹¤.")
   38 |     @ApiResponses(value = {
   39 |             @ApiResponse(responseCode = "200", description = "êµ¬ë… ì„±ê³µ", content = @Content(mediaType = "application/json")),
   40 |             @ApiResponse(responseCode = "401", description = "ì¸ì¦ ì‹¤íŒ¨", content = @Content(mediaType = "application/json")),
   41 |             @ApiResponse(responseCode = "500", description = "ì„œë²„ ì˜¤ë¥˜", content = @Content(mediaType = "application/json"))
   42 |     })
   43 |     @GetMapping(value = "/protected/sse/subscribe", produces = MediaType.TEXT_EVENT_STREAM_VALUE)
   44 |     public ResponseEntity<SseEmitter> subscribeSse(@AuthenticationPrincipal principalDetails principalDetails,
   45 |                                                    @RequestHeader(value = "Last-Event-ID", required = false, defaultValue = "") String lastEventId) {
   46 |         SseEmitter emitter = new SseEmitter(30 * 60 * 1000L);
   47 | 
   48 |         String userId = principalDetails.getUserId();
   49 |         boolean saved = sseService.saveSseEmitter(userId, emitter);
   50 |         if (!saved) {
   51 |             log.error("Failed to save SseEmitter for userId : {}", userId);
   52 |             emitter.completeWithError(new IllegalStateException("Failed to save SseEmitter for userId : " + userId));
   53 |         }
   54 | 
   55 |         // Initial Data ì „ì†¡
   56 |         try {
   57 |             emitter.send(SseEmitter.event()
   58 |                     .name("INIT")
   59 |                     .data("Subscription successful"));
   60 |         } catch (Exception e) {
   61 |             log.error("Error sending initial event to userId : {}", userId, e);
   62 |             sseService.removeEmitter(userId, emitter);
   63 |             emitter.completeWithError(e);
   64 |         }
   65 | 
   66 |         return ResponseEntity.status(HttpStatus.OK).body(emitter);
   67 |     }
   68 | 
   69 | 
   70 | 
   71 |     /**
   72 |      * ë”ë¯¸ ë°ì´í„°ë¥¼ íŠ¹ì • ì‚¬ìš©ìì—ê²Œ ì „ì†¡í•˜ëŠ” ì—”ë“œí¬ì¸íŠ¸
   73 |      * ì˜ˆ: POST /sse/dummyData/{user_id}
   74 |      *
   75 |      * @param principalDetails ì¸ì¦ëœ ì‚¬ìš©ì ì •ë³´
   76 |      * @param userId ëŒ€ìƒ ì‚¬ìš©ìì˜ ID
   77 |      * @param payload ì „ì†¡í•  ë°ì´í„°
   78 |      * @return ResponseEntity
   79 |      */
   80 |     @Operation(summary = "ë”ë¯¸ ë°ì´í„° ì „ì†¡", description = "íŠ¹ì • ì‚¬ìš©ìì—ê²Œ ë”ë¯¸ ë°ì´í„°ë¥¼ ì „ì†¡í•©ë‹ˆë‹¤.")
   81 |     @ApiResponses(value = {
   82 |             @ApiResponse(responseCode = "200", description = "ë°ì´í„° ì „ì†¡ ì„±ê³µ", content = @Content(mediaType = "application/json")),
   83 |             @ApiResponse(responseCode = "400", description = "ì˜ëª»ëœ ìš”ì²­", content = @Content(mediaType = "application/json")),
   84 |             @ApiResponse(responseCode = "401", description = "ì¸ì¦ ì‹¤íŒ¨", content = @Content(mediaType = "application/json")),
   85 |             @ApiResponse(responseCode = "500", description = "ì„œë²„ ì˜¤ë¥˜", content = @Content(mediaType = "application/json"))
   86 |     })
   87 |     @PostMapping("/public/dummyData/{user_id}")
   88 |     public ResponseEntity<?> sseDummyData(@AuthenticationPrincipal principalDetails principalDetails,
   89 |                                           @PathVariable("user_id") String userId,
   90 |                                           @RequestBody Map<String, String> payload){
   91 |         String message = payload.get("message");
   92 |         if (message == null || message.isEmpty()){
   93 |             return ResponseEntity.status(HttpStatus.BAD_REQUEST).body("Message is required");
   94 |         }
   95 | 
   96 |         sseService.sendEventToUser(userId, message);
   97 |         return ResponseEntity.ok().build();
   98 |     }
   99 | 
  100 | 
  101 | }

#--------------------------------------------------------------------------------


# File: backend/src/main/java/com/authentication/auth/controller/errorController.java
#=============================================================================

    1 | /*
    2 | 
    3 | package com.career_block.auth.controller;
    4 | 
    5 | import jakarta.servlet.http.HttpServlet;
    6 | import jakarta.servlet.http.HttpServletRequest;
    7 | import org.springframework.boot.web.servlet.error.ErrorController;
    8 | import org.springframework.stereotype.Controller;
    9 | import org.springframework.ui.Model;
   10 | import org.springframework.web.bind.annotation.GetMapping;
   11 | import org.springframework.web.bind.annotation.RequestMapping;
   12 | import org.springframework.web.bind.annotation.RestController;
   13 | 
   14 | 
   15 | @Controller
   16 | public class errorController implements ErrorController {
   17 | 
   18 |     @RequestMapping("/errorPage")
   19 |     public String handleError(HttpServletRequest request, Model model) {
   20 |         Object status = request.getAttribute("javax.servlet.error.status_code");
   21 | 
   22 |         if (status != null) {
   23 |             int statusCode = Integer.parseInt(status.toString());
   24 |             model.addAttribute("statusCode", statusCode);
   25 | 
   26 |             if (statusCode == 404) {
   27 |                 return "notExist";  // src/main/resources/templates/notExist.html í…œí”Œë¦¿ ë°˜í™˜
   28 |             } else if (statusCode == 401) {
   29 |                 return "unauthorized"; // src/main/resources/templates/unauthorized.html í…œí”Œë¦¿ ë°˜í™˜
   30 |             }
   31 |         }
   32 | 
   33 |         return "error"; // ë‹¤ë¥¸ ì˜¤ë¥˜ì—ëŠ” ê¸°ë³¸ ì—ëŸ¬ í˜ì´ì§€ ë°˜í™˜ (src/main/resources/templates/error.html)
   34 | 
   35 | }
   36 | */
   37 | 

#--------------------------------------------------------------------------------


# File: backend/src/main/java/com/authentication/auth/controller/auth/oauth2Controller.java
#=============================================================================

    1 | package com.career_block.auth.controller.auth;
    2 | 
    3 | import jakarta.servlet.http.HttpServletResponse;
    4 | import lombok.RequiredArgsConstructor;
    5 | import lombok.extern.slf4j.Slf4j;
    6 | import org.springframework.http.ResponseEntity;
    7 | import org.springframework.web.bind.annotation.PostMapping;
    8 | import org.springframework.web.bind.annotation.RequestBody;
    9 | import org.springframework.web.bind.annotation.RequestMapping;
   10 | import org.springframework.web.bind.annotation.RestController;
   11 | 
   12 | import com.authentication.auth.configuration.token.jwtUtility;
   13 | import com.authentication.auth.service.oauth2.oauth2Service;
   14 | import com.authentication.auth.service.redis.redisService;
   15 | 
   16 | import java.util.Map;
   17 | import java.util.UUID;
   18 | 
   19 | @Slf4j
   20 | @RestController
   21 | @RequiredArgsConstructor
   22 | @RequestMapping("/oauth2")
   23 | public class oauth2Controller {
   24 | 
   25 |     //í•˜í•«.. ë„ˆëŠ” ì„œë¹„ìŠ¤ë‹¤...
   26 |     private final oauth2Service  oauth2Service;
   27 |     private final redisService  redisService;
   28 |     private final jwtUtility jwtUtility;
   29 | 
   30 | 
   31 |     @PostMapping("/callback/kakao")
   32 |     public ResponseEntity<?> oauth2KakaoLogin(@RequestBody Map<String, String> requestBody, HttpServletResponse response) {
   33 |         log.info("/oauth2/callback/kakao");
   34 |         return oauth2Service.handleOauth2Login(requestBody, response, "kakao");
   35 |     }
   36 |     @PostMapping("/callback/naver")
   37 |     public ResponseEntity<?> oauth2NaverLogin(@RequestBody Map<String, String> requestBody, HttpServletResponse response) {
   38 |         log.info("/oauth2/callback/naver");
   39 |         String state = UUID.randomUUID().toString();
   40 |         return oauth2Service.handleOauth2Login(requestBody, response, "naver");
   41 |     }
   42 |     @PostMapping("/callback/google")
   43 |     public ResponseEntity<?> oauth2GoogleLogin(@RequestBody Map<String, String> requestBody, HttpServletResponse response) {
   44 |         log.info("/oauth2/callback/google");
   45 |         log.info("tempCode for google from client server : {}", requestBody.get("tempCode"));
   46 |         return oauth2Service.handleOauth2Login(requestBody, response, "google");
   47 |     }
   48 | 
   49 | }

#--------------------------------------------------------------------------------


# File: backend/src/main/java/com/authentication/auth/controller/auth/tokenController.java
#=============================================================================

    1 | package com.career_block.auth.controller.auth;
    2 | 
    3 | import io.swagger.v3.oas.annotations.Operation;
    4 | import io.swagger.v3.oas.annotations.responses.ApiResponse;
    5 | import io.swagger.v3.oas.annotations.responses.ApiResponses;
    6 | import jakarta.servlet.http.HttpServletRequest;
    7 | import jakarta.servlet.http.HttpServletResponse;
    8 | import lombok.extern.slf4j.Slf4j;
    9 | import org.springframework.http.HttpStatus;
   10 | import org.springframework.http.ResponseEntity;
   11 | import org.springframework.web.bind.annotation.PostMapping;
   12 | import org.springframework.web.bind.annotation.RequestBody;
   13 | import org.springframework.web.bind.annotation.RequestMapping;
   14 | import org.springframework.web.bind.annotation.RestController;
   15 | 
   16 | import com.authentication.auth.DTO.token.tokenRefreshRequest;
   17 | import com.authentication.auth.configuration.token.jwtUtility;
   18 | import com.authentication.auth.service.redis.redisService;
   19 | import com.authentication.auth.service.token.tokenService;
   20 | 
   21 | import java.io.IOException;
   22 | 
   23 | @Slf4j
   24 | @RestController
   25 | @RequestMapping("/auth")
   26 | public class tokenController {
   27 | 
   28 |     private final jwtUtility jwtUtility;
   29 |     private final redisService redisService;
   30 |     private final tokenService  tokenService;
   31 | 
   32 |     public tokenController(jwtUtility jwtUtility, redisService redisService, tokenService tokenService){
   33 |         this.jwtUtility = jwtUtility;
   34 |         this.redisService = redisService;
   35 |         this.tokenService = tokenService;
   36 |     }
   37 | 
   38 |     @Operation(summary = "Refresh JWT Token", description = "Refreshes the expired JWT token and returns a new token if valid.")
   39 |     @ApiResponses(value = {
   40 |             @ApiResponse(responseCode = "200", description = "Token refreshed successfully, new token returned."),
   41 |             @ApiResponse(responseCode = "406", description = "Not acceptable, invalid token or no refresh token in Redis."),
   42 |             @ApiResponse(responseCode = "401", description = "Unauthorized, refresh token not found in cookies."),
   43 |     })
   44 |     @PostMapping("/api/protected/refresh")
   45 |     public ResponseEntity<?> refreshToken(HttpServletRequest httpRequest, HttpServletResponse httpResponse, @RequestBody tokenRefreshRequest request) throws IOException {
   46 | 
   47 |         if (request == null || request.getExpiredToken() == null || request.getProvider() == null) {
   48 |             return ResponseEntity.status(HttpStatus.NOT_ACCEPTABLE).build();
   49 |         }
   50 | 
   51 |         return tokenService.refreshToken(httpRequest, httpResponse, request);
   52 |     }
   53 | }
   54 | 
   55 | 

#--------------------------------------------------------------------------------


# File: backend/src/main/java/com/authentication/auth/controller/auth/AuthController.java
#=============================================================================

    1 | package com.career_block.auth.controller.auth;
    2 | 
    3 | import org.springframework.http.ResponseEntity;
    4 | import org.springframework.web.bind.annotation.GetMapping;
    5 | import org.springframework.web.bind.annotation.RestController;
    6 | 
    7 | @RestController
    8 | public class AuthController {
    9 | 
   10 |     @GetMapping("/auth_check")
   11 |     public ResponseEntity<String> authCheck() {
   12 |         return ResponseEntity.ok("Authorized");
   13 |     }
   14 | }

#--------------------------------------------------------------------------------


# File: backend/src/main/java/com/authentication/auth/controller/emailController.java
#=============================================================================

    1 | package com.career_block.auth.controller;
    2 | 
    3 | 
    4 | import io.swagger.v3.oas.annotations.Operation;
    5 | import io.swagger.v3.oas.annotations.media.Content;
    6 | import io.swagger.v3.oas.annotations.responses.ApiResponse;
    7 | import io.swagger.v3.oas.annotations.responses.ApiResponses;
    8 | import io.swagger.v3.oas.annotations.tags.Tag;
    9 | import jakarta.validation.Valid;
   10 | import lombok.RequiredArgsConstructor;
   11 | import lombok.extern.slf4j.Slf4j;
   12 | import org.springframework.http.HttpStatus;
   13 | import org.springframework.http.ResponseEntity;
   14 | import org.springframework.security.core.annotation.AuthenticationPrincipal;
   15 | import org.springframework.web.bind.annotation.*;
   16 | 
   17 | import com.authentication.auth.DTO.smtp.customEmailRequest;
   18 | import com.authentication.auth.DTO.smtp.emailCheckDto;
   19 | import com.authentication.auth.DTO.smtp.emailFindById;
   20 | import com.authentication.auth.DTO.smtp.emailRequest;
   21 | import com.authentication.auth.DTO.token.principalDetails;
   22 | import com.authentication.auth.service.redis.redisService;
   23 | import com.authentication.auth.service.smtp.emailService;
   24 | import com.authentication.auth.service.users.userService;
   25 | 
   26 | @Slf4j
   27 | @Tag(name="email ê´€ë ¨", description = "email")
   28 | @RestController
   29 | @RequiredArgsConstructor
   30 | @RequestMapping("/api")
   31 | public class emailController {
   32 | 
   33 |     private final emailService service;
   34 |     private final userService  userService;
   35 |     private final redisService  redisService;
   36 | 
   37 |     @Operation(summary="ì´ë©”ì¼ ë³´ë‚´ê¸°", description = "ì´ë©”ì¼ ì½”ë“œ ì „ì†¡ ê´€ë ¨")
   38 |     @ApiResponses(value = {
   39 |             @ApiResponse(responseCode = "200", description = "ì´ë©”ì¼ ì „ì†¡ ì„±ê³µ", content = @Content(mediaType = "application/json")),
   40 |             @ApiResponse(responseCode = "500", description = "ì´ë©”ì¼ ì „ì†¡ ì‹¤íŒ¨", content = @Content(mediaType = "application/json"))
   41 |     })
   42 |     @PostMapping("/public/emailSend")
   43 |     public ResponseEntity<?> emailSend(@RequestBody @Valid emailRequest request) {
   44 |         try {
   45 |             if(service.checkIsExistEmail(request.getEmail()))
   46 |             {
   47 |                 return ResponseEntity.status(HttpStatus.BAD_REQUEST).body("user with this email already exist");
   48 |             }
   49 |             String code = service.joinEmail(request.getEmail());
   50 |             this.redisService.saveEmailCode(request.getEmail(), code);
   51 |             return ResponseEntity.status(HttpStatus.OK).body("A temporary code has been sent to your email");
   52 |         } catch (Exception e) {
   53 |             return ResponseEntity.status(HttpStatus.INTERNAL_SERVER_ERROR).body("email sent failed");
   54 |         }
   55 |     }
   56 | 
   57 | 
   58 |     @Operation(summary="ì»¤ìŠ¤í…€ ì´ë©”ì¼ ë³´ë‚´ê¸°", description = "ì»¤ìŠ¤í…€ ì´ë©”ì¼ ì „ì†¡ ê´€ë ¨")
   59 |     @ApiResponses(value = {
   60 |             @ApiResponse(responseCode = "200", description = "ì´ë©”ì¼ ì „ì†¡ ì„±ê³µ", content = @Content(mediaType = "application/json")),
   61 |             @ApiResponse(responseCode = "500", description = "ì´ë©”ì¼ ì „ì†¡ ì‹¤íŒ¨", content = @Content(mediaType = "application/json"))
   62 |     })
   63 |     @PostMapping("/api/private/customEmailSend")
   64 |     public ResponseEntity<?> customEmailSend(@RequestBody @Valid customEmailRequest request) {
   65 |         try {
   66 |             if (request.getEmail() == null) {
   67 |                 return ResponseEntity.status(HttpStatus.BAD_REQUEST).body("email is blank");
   68 |             }
   69 |             if (request.getContent() == null){
   70 |                 return ResponseEntity.status(HttpStatus.BAD_REQUEST).body("there's no content in the request");
   71 |             }
   72 |             service.sendCustomEmail(request);
   73 |             return ResponseEntity.status(HttpStatus.OK).body("custom email send success");
   74 |         } catch (Exception e) {
   75 |             return ResponseEntity.status(HttpStatus.INTERNAL_SERVER_ERROR).body("email sent failed");
   76 |         }
   77 |     }
   78 | 
   79 | 
   80 |     @Operation(summary = "ì´ë©”ì¼ ì½”ë“œ í™•ì¸", description = "ì´ë©”ì¼ë¡œ ì „ì†¡ëœ ì½”ë“œë¥¼ í™•ì¸í•©ë‹ˆë‹¤")
   81 |     @ApiResponses(value = {
   82 |             @ApiResponse(responseCode = "202", description = "ì´ë©”ì¼ ì½”ë“œ ìœ íš¨", content = @Content(mediaType = "application/json")),
   83 |             @ApiResponse(responseCode = "401", description = "ì´ë©”ì¼ ì½”ë“œ ë¬´íš¨", content = @Content(mediaType = "application/json"))
   84 |     })
   85 |     @PostMapping("/public/emailCheck")
   86 |     public ResponseEntity<?> emailCodeCheck(@RequestBody @Valid emailCheckDto checkdto) {
   87 |         boolean isValid = redisService.checkEmailCode(checkdto.getEmail(), checkdto.getCode());
   88 |         if (isValid) {
   89 |             return ResponseEntity.status(HttpStatus.ACCEPTED).body("email code is valid");
   90 |         } else {
   91 |             return ResponseEntity.status(HttpStatus.UNAUTHORIZED).body("email code is invalid");
   92 |         }
   93 |     }
   94 | 
   95 |     @Operation(summary = "ì„ì‹œ ë¹„ë°€ë²ˆí˜¸ ì´ë©”ì¼ ì „ì†¡", description = "ì¸ì¦ëœ ì‚¬ìš©ìì—ê²Œ ì„ì‹œ ë¹„ë°€ë²ˆí˜¸ë¥¼ ì´ë©”ì¼ë¡œ ì „ì†¡í•©ë‹ˆë‹¤")
   96 |     @ApiResponses(value = {
   97 |             @ApiResponse(responseCode = "200", description = "ì„ì‹œ ë¹„ë°€ë²ˆí˜¸ ì „ì†¡ ì„±ê³µ", content = @Content(mediaType = "application/json")),
   98 |             @ApiResponse(responseCode = "500", description = "ì„ì‹œ ë¹„ë°€ë²ˆí˜¸ ì „ì†¡ ì‹¤íŒ¨", content = @Content(mediaType = "application/json"))
   99 |     })
  100 |     @PostMapping("/protected/sendEmailPassword")
  101 |     public ResponseEntity<?> emailSendPassword(@AuthenticationPrincipal principalDetails principalDetails) {
  102 |         try {
  103 |             String userId = principalDetails.getUserId();
  104 |             String email = userService.getEmailByUserId(userId);
  105 |             String temporalPassword = service.changePwEmail(email);
  106 |             userService.UpdateUserPassword(userId, temporalPassword);
  107 |             return ResponseEntity.status(HttpStatus.OK).body("A temporary password has been sent to your email");
  108 |         } catch (Exception e) {
  109 |             return ResponseEntity.status(HttpStatus.INTERNAL_SERVER_ERROR).body("error occurred while sending an temporary password");
  110 |         }
  111 |     }
  112 | 
  113 |     @Operation(summary = "ì´ë©”ì¼ë¡œ ë¹„ë°€ë²ˆí˜¸ ì°¾ê¸°", description = "ì‚¬ìš©ì IDë¥¼ í†µí•´ ì´ë©”ì¼ë¡œ ì„ì‹œ ë¹„ë°€ë²ˆí˜¸ë¥¼ ì „ì†¡í•©ë‹ˆë‹¤")
  114 |     @ApiResponses(value = {
  115 |             @ApiResponse(responseCode = "200", description = "ì„ì‹œ ë¹„ë°€ë²ˆí˜¸ ì „ì†¡ ì„±ê³µ", content = @Content(mediaType = "application/json")),
  116 |             @ApiResponse(responseCode = "500", description = "ì„ì‹œ ë¹„ë°€ë²ˆí˜¸ ì „ì†¡ ì‹¤íŒ¨", content = @Content(mediaType = "application/json"))
  117 |     })
  118 |     @GetMapping("/public/findPassWithEmail")
  119 |     public ResponseEntity<?> findPassWithEmail(@RequestBody emailFindById emailFindById) {
  120 |         try {
  121 |             String email = userService.getEmailByUserId(emailFindById.getUserId());
  122 |             String temporalPassword = service.changePwEmail(email);
  123 |             userService.UpdateUserPassword(emailFindById.getUserId(), temporalPassword);
  124 |             return ResponseEntity.status(HttpStatus.OK).body("A temporary password has been sent to your email");
  125 |         } catch (Exception e) {
  126 |             log.error("Error find Password with Email sent", e);
  127 |             return ResponseEntity.status(HttpStatus.INTERNAL_SERVER_ERROR).body("error occurred while sending an temporary password");
  128 |         }
  129 |     }
  130 | 
  131 | 
  132 | }

#--------------------------------------------------------------------------------


# File: backend/src/main/java/com/authentication/auth/AuthApplication.java
#=============================================================================

    1 | package com.authentication.auth;
    2 | 
    3 | import jakarta.annotation.PostConstruct;
    4 | import org.springframework.boot.SpringApplication;
    5 | import org.springframework.boot.autoconfigure.SpringBootApplication;
    6 | import org.springframework.data.mongodb.repository.config.EnableMongoRepositories;
    7 | 
    8 | import java.util.TimeZone;
    9 | 
   10 | @SpringBootApplication
   11 | @EnableMongoRepositories
   12 | public class AuthApplication {
   13 | 
   14 | 	public static void main(String[] args) {
   15 | 		SpringApplication.run(AuthApplication.class, args);
   16 | 	}
   17 | 
   18 | 
   19 | 	@PostConstruct
   20 | 	void set_time_zone() {
   21 | 		TimeZone.setDefault(TimeZone.getTimeZone("Asia/Seoul"));
   22 | 	}
   23 | }

#--------------------------------------------------------------------------------


# File: backend/src/main/java/com/authentication/auth/configuration/SecurityConfig.java
#=============================================================================

    1 | package com.authentication.auth.configuration;
    2 | 
    3 | import com.authentication.auth.filter.filterRegistry;
    4 | import lombok.RequiredArgsConstructor;
    5 | import lombok.extern.slf4j.Slf4j;
    6 | import org.springframework.context.annotation.Bean;
    7 | import org.springframework.context.annotation.Configuration;
    8 | import org.springframework.security.config.annotation.web.builders.HttpSecurity;
    9 | import org.springframework.security.config.annotation.web.configuration.EnableWebSecurity;
   10 | import org.springframework.security.config.http.SessionCreationPolicy;
   11 | import org.springframework.security.web.SecurityFilterChain;
   12 | 
   13 | /**
   14 |  * @Author: choisimo
   15 |  * @Date: 2025-05-05
   16 |  * @Description: Spring Security êµ¬ì„± í´ë˜ìŠ¤
   17 |  * @Details: ë³´ì•ˆ í•„í„° ì²´ì¸ ë° ì¸ì¦/ì¸ê°€ ì„¤ì •ì„ ê´€ë¦¬
   18 |  */
   19 | @Configuration
   20 | @EnableWebSecurity
   21 | @RequiredArgsConstructor
   22 | @Slf4j
   23 | public class SecurityConfig {
   24 | 
   25 |     private final filterRegistry filterRegistry;
   26 |     
   27 |     @Bean
   28 |     public SecurityFilterChain securityFilterChain(HttpSecurity http) throws Exception {
   29 |         log.info("ë³´ì•ˆ í•„í„° ì²´ì¸ êµ¬ì„± ì¤‘...");
   30 |         
   31 |         http
   32 |             .csrf().disable()
   33 |             .formLogin().disable()
   34 |             .httpBasic().disable()
   35 |             .sessionManagement().sessionCreationPolicy(SessionCreationPolicy.STATELESS)
   36 |             .and()
   37 |             .authorizeHttpRequests()
   38 |                 .requestMatchers("/auth/**", "/login", "/signup", "/public/**").permitAll()
   39 |                 .anyRequest().authenticated();
   40 |         
   41 |         // í”ŒëŸ¬ê·¸í˜• í•„í„° ë“±ë¡
   42 |         filterRegistry.configureFilters(http);
   43 |         
   44 |         return http.build();
   45 |     }
   46 | }

#--------------------------------------------------------------------------------


# File: backend/src/main/java/com/authentication/auth/configuration/smtp/smtpConfig.java
#=============================================================================

    1 | package com.career_block.auth.configuration.smtp;
    2 | 
    3 | import org.springframework.context.annotation.Bean;
    4 | import org.springframework.context.annotation.Configuration;
    5 | import org.springframework.mail.javamail.JavaMailSender;
    6 | import org.springframework.mail.javamail.JavaMailSenderImpl;
    7 | 
    8 | import java.util.Properties;
    9 | 
   10 | @Configuration
   11 | public class smtpConfig {
   12 | 
   13 |     @Bean
   14 |     public JavaMailSender mailSender() {
   15 |         JavaMailSenderImpl mailSender = new JavaMailSenderImpl();
   16 |         mailSender.setHost("smtp.gmail.com");
   17 |         mailSender.setPort(587);
   18 |         mailSender.setUsername("careernoteproject@gmail.com");
   19 |         mailSender.setPassword("akzm ifxr ahou copf");
   20 | 
   21 |         Properties javaMailProperties = new Properties();
   22 |         javaMailProperties.put("mail.transport.protocol", "smtp");
   23 |         javaMailProperties.put("mail.smtp.auth", "true");
   24 |         javaMailProperties.put("mail.smtp.socketFactory.class", "javax.net.ssl.SSLSocketFactory");
   25 |         javaMailProperties.put("mail.smtp.starttls.enable", "true");
   26 |         javaMailProperties.put("mail.debug", "true");//ë””ë²„ê¹… ì •ë³´ ì¶œë ¥
   27 |         javaMailProperties.put("mail.smtp.ssl.trust", "smtp.gmail.com");//smtp ì„œë²„ì˜ ssl ì¸ì¦ì„œë¥¼ ì‹ ë¢°
   28 |         javaMailProperties.put("mail.smtp.ssl.protocols", "TLSv1.2");//ì‚¬ìš©í•  ssl í”„ë¡œí† ì½œ ë²„ì ¼
   29 |         mailSender.setJavaMailProperties(javaMailProperties);
   30 |         return mailSender;
   31 |     }
   32 | }

#--------------------------------------------------------------------------------


# File: backend/src/main/java/com/authentication/auth/configuration/resource/webMvcConfig.java
#=============================================================================

    1 | package com.authentication.auth.configuration.resource;
    2 | 
    3 | import org.springframework.context.annotation.Configuration;
    4 | 
    5 | @Configuration
    6 | public class webMvcConfig {
    7 | 
    8 | 
    9 | }

#--------------------------------------------------------------------------------


# File: backend/src/main/java/com/authentication/auth/configuration/security/publicAPI.java
#=============================================================================

    1 | package com.authentication.auth.configuration.security;
    2 | 
    3 | import jakarta.servlet.http.HttpServletRequest;
    4 | import lombok.Data;
    5 | import lombok.extern.slf4j.Slf4j;
    6 | import org.springframework.context.annotation.Bean;
    7 | import org.springframework.context.annotation.Configuration;
    8 | import org.springframework.stereotype.Service;
    9 | 
   10 | import java.util.ArrayList;
   11 | import java.util.Arrays;
   12 | import java.util.List;
   13 | 
   14 | 
   15 | @Slf4j
   16 | @Data
   17 | @Service
   18 | public class publicAPI {
   19 | 
   20 |     private final List<String> apiEndPoints = Arrays.asList(
   21 |             "/login", "/public", "/api/public", "/errorPage", "/notExist", "/unauthorized", "/swagger-ui.html", "/v2/api-docs", "/swagger-resources", "/webjars", "/swagger-resources/configuration/ui", "/swagger-resources/configuration/security"
   22 |             ,"/oauth2/authorization/google", "/oauth2/authorization/google", "/oauth2/authorization/facebook", "/oauth2/authorization/github", "/oauth2/authorization/linkedin", "/oauth2/authorization/instagram", "/oauth2/authorization/twitter", "/oauth2/authorization/yahoo", "/oauth2/authorization/spotify", "/oauth2/authorization/amazon", "/oauth2/authorization/microsoft", "/oauth2/authorization/okta", "/oauth2/authorization/slack"
   23 |             ,"/oauth2/callback/google", "/oauth2/callback/google", "/oauth2/callback/facebook", "/oauth2/callback/github", "/oauth2/callback/linkedin", "/oauth2/callback/instagram", "/oauth2/callback/twitter", "/oauth2/callback/yahoo", "/oauth2/callback/spotify", "/oauth2/callback/amazon", "/oauth2/callback/microsoft", "/oauth2/callback/okta", "/oauth2/callback/slack",
   24 |             "/user/login", "/user/register", "/user/verify", "/user/forgetPassword", "/user/resetPassword", "/user/verifyResetPassword", "/user/verifyEmail", "/user/resendVerificationEmail"
   25 |     );
   26 | 
   27 |     public boolean checkRequestAPI(HttpServletRequest request){
   28 | 
   29 |     String requestURI = request.getRequestURI();
   30 |         log.info("Request URI: {}", requestURI); // log the request URI
   31 |         return (apiEndPoints.contains(requestURI));
   32 |     }
   33 | }

#--------------------------------------------------------------------------------


# File: backend/src/main/java/com/authentication/auth/configuration/security/SecurityConfig.java
#=============================================================================

    1 | package com.authentication.auth.configuration.security;
    2 | 
    3 | import com.fasterxml.jackson.databind.ObjectMapper;
    4 | import lombok.RequiredArgsConstructor;
    5 | import lombok.extern.slf4j.Slf4j;
    6 | import org.springframework.context.annotation.Bean;
    7 | import org.springframework.context.annotation.Configuration;
    8 | import org.springframework.security.authentication.AuthenticationManager;
    9 | import org.springframework.security.config.annotation.authentication.configuration.AuthenticationConfiguration;
   10 | import org.springframework.security.config.annotation.web.builders.HttpSecurity;
   11 | import org.springframework.security.config.annotation.web.configuration.EnableWebSecurity;
   12 | import org.springframework.security.config.annotation.web.configurers.AbstractHttpConfigurer;
   13 | import org.springframework.security.config.http.SessionCreationPolicy;
   14 | import org.springframework.security.crypto.bcrypt.BCryptPasswordEncoder;
   15 | import org.springframework.security.web.SecurityFilterChain;
   16 | import org.springframework.security.web.authentication.UsernamePasswordAuthenticationFilter;
   17 | import org.springframework.web.cors.CorsConfigurationSource;
   18 | 
   19 | @Slf4j
   20 | @Configuration
   21 | @EnableWebSecurity
   22 | @RequiredArgsConstructor
   23 | public class SecurityConfig {
   24 | 
   25 |     private final FilterRegistry filterRegistry; 
   26 | 
   27 |     @Bean
   28 |     public SecurityFilterChain filterChain(HttpSecurity http) throws Exception {
   29 |         // cors
   30 |         http.cors(cors -> cors.configurationSource(corsConfigurationSource));
   31 |         // í¼ ë¡œê·¸ì¸ ë¹„í™œì„±í™”
   32 |         http.formLogin(AbstractHttpConfigurer::disable);
   33 |         // Cross-Site Request Forgery ê³µê²© ë°©ì–´ ë¹„í™œì„±í™”
   34 |         http.csrf(AbstractHttpConfigurer::disable);
   35 |         // HTTP ê¸°ë³¸ ì¸ì¦ ë¹„í™œì„±í™”
   36 |         http.httpBasic(AbstractHttpConfigurer::disable);
   37 |         // session ê¸°ë°˜ ë¡œê·¸ì¸ ë¹„í™œì„±í™”
   38 |         http.sessionManagement(management ->
   39 |                 management.sessionCreationPolicy(SessionCreationPolicy.STATELESS));
   40 | 
   41 |         //filter
   42 |         filterRegistry.registerFilters(http);
   43 | 
   44 |         // authorization
   45 |         http.authorizeHttpRequests((authorize) -> {
   46 |             authorize
   47 |                     .requestMatchers(PathRequest.toStaticResources().atCommonLocations()).permitAll()
   48 |                     .requestMatchers("/api/public/**").permitAll()
   49 |                     .requestMatchers(userRestrict).hasAnyAuthority("ADMIN", "USER", "COMPANY")
   50 |                     .requestMatchers(adminRestrict).hasAnyAuthority("ADMIN")
   51 |                     .requestMatchers(companyRestrict).hasAnyAuthority("COMPANY", "ADMIN")
   52 |                     .requestMatchers(oauth2Restrict).permitAll()
   53 |                     .anyRequest().permitAll();
   54 |         });
   55 | 
   56 | 
   57 | 
   58 |         http.formLogin(formLogin -> formLogin
   59 |                 .loginPage("/login").defaultSuccessUrl("/"));
   60 | 
   61 |         // ì‚¬ìš©ì ì •ë³´ ì„œë¹„ìŠ¤ ë° ì•”í˜¸í™” ì„¤ì •
   62 |         http.userDetailsService(principalDetailService);
   63 | 
   64 |         // OAUTH ë¡œê·¸ì¸ ì„¤ì •
   65 |         //http.oauth2Login(login -> login.loginPage("/login"));
   66 | 
   67 |         return http.build();
   68 |     }
   69 | 
   70 | 
   71 |     @Bean
   72 |     public BCryptPasswordEncoder passwordEncoder() {
   73 |         return new BCryptPasswordEncoder();
   74 |     }
   75 | 
   76 |     @Bean
   77 |     public ObjectMapper objectMapper() {
   78 |         return new ObjectMapper();
   79 |     }
   80 | 
   81 | }

#--------------------------------------------------------------------------------


# File: backend/src/main/java/com/authentication/auth/configuration/security/corsConfig.java
#=============================================================================

    1 | package com.authentication.auth.configuration.security;
    2 | 
    3 | import org.springframework.beans.factory.annotation.Value;
    4 | import org.springframework.context.annotation.Bean;
    5 | import org.springframework.context.annotation.Configuration;
    6 | import org.springframework.web.cors.CorsConfiguration;
    7 | import org.springframework.web.cors.CorsConfigurationSource;
    8 | import org.springframework.web.cors.UrlBasedCorsConfigurationSource;
    9 | 
   10 | import java.util.Arrays;
   11 | import java.util.List;
   12 | 
   13 | @Configuration
   14 | public class corsConfig {
   15 | 
   16 |     @Value("${site.domain}")
   17 |     private String siteDomain;
   18 |     @Value("${server.cookie.domain}")
   19 |     private String rootDomain;
   20 | 
   21 |     @Bean
   22 |     public CorsConfigurationSource corsConfigurationSource() {
   23 |         CorsConfiguration corsConfiguration = new CorsConfiguration();
   24 |         corsConfiguration.setAllowedOrigins(List.of(
   25 |                         "http://localhost:3000",
   26 |                         "http://127.0.0.1:3000",
   27 |                         "https://" + rootDomain,
   28 |                         "https://" + siteDomain,
   29 |                         "http://192.168.0.44",
   30 |                         "http://192.168.0.44:3000"
   31 |                 ));
   32 |         corsConfiguration.setAllowedMethods(Arrays.asList("GET", "POST", "OPTIONS", "PATCH", "DELETE", "UPDATE"));
   33 |         corsConfiguration.setAllowedHeaders(Arrays.asList("Content-Type", "Authorization", "provider"));
   34 |         corsConfiguration.setAllowCredentials(true);
   35 | 
   36 |         UrlBasedCorsConfigurationSource source = new UrlBasedCorsConfigurationSource();
   37 |         source.registerCorsConfiguration("/**", corsConfiguration);
   38 |         return source;
   39 |     }
   40 | }

#--------------------------------------------------------------------------------


# File: backend/src/main/java/com/authentication/auth/configuration/token/jwtUtility.java
#=============================================================================

    1 | package com.authentication.auth.configuration.token;
    2 | 
    3 | import com.authentication.auth.DTO.token.TokenDto;
    4 | import io.jsonwebtoken.*;
    5 | import io.jsonwebtoken.security.Keys;
    6 | import jakarta.servlet.http.Cookie;
    7 | import jakarta.servlet.http.HttpServletRequest;
    8 | import jakarta.servlet.http.HttpServletResponse;
    9 | import lombok.extern.slf4j.Slf4j;
   10 | import org.springframework.beans.factory.annotation.Value;
   11 | import org.springframework.context.annotation.Bean;
   12 | import org.springframework.security.authentication.UsernamePasswordAuthenticationToken;
   13 | import org.springframework.security.core.GrantedAuthority;
   14 | import org.springframework.security.core.userdetails.UserDetails;
   15 | import org.springframework.stereotype.Component;
   16 | import org.springframework.transaction.annotation.Transactional;
   17 | import org.springframework.web.client.RestTemplate;
   18 | 
   19 | import java.io.IOException;
   20 | import java.io.PrintWriter;
   21 | import java.security.Key;
   22 | import java.time.Instant;
   23 | import java.util.*;
   24 | 
   25 | @Slf4j
   26 | @Component
   27 | public class jwtUtility {
   28 | 
   29 |     
   30 | 
   31 | 
   32 |     public jwtUtility(
   33 |             @Value("${jwt.secret-key}") String secretKey,
   34 |             @Value("${jwt.secret-key2}") String secretKey2,
   35 |             @Value("${ACCESS_TOKEN_VALIDITY}") Long ACCESS_TOKEN_VALIDITY,
   36 |             @Value("${REFRESH_TOKEN_VALIDITY}") Long REFRESH_TOKEN_VALIDITY){
   37 |         this.key = Keys.hmacShaKeyFor(secretKey.getBytes());
   38 |         this.key2 = Keys.hmacShaKeyFor(secretKey2.getBytes());
   39 |         this.ACCESS_TOKEN_VALIDITY = ACCESS_TOKEN_VALIDITY;
   40 |         this.REFRESH_TOKEN_VALIDITY = REFRESH_TOKEN_VALIDITY;
   41 |     }
   42 | 
   43 | 
   44 |     public TokenDto buildToken(String userId, String nickname, Collection<? extends GrantedAuthority> role) {
   45 |         Claims claims = createClaims(userId, nickname, role);
   46 | 
   47 |         // í† í° ë§Œë£Œ ì‹œê°„ ì„¤ì •
   48 |         Instant now = Instant.now();
   49 |         Instant validity = now.plusSeconds(ACCESS_TOKEN_VALIDITY);
   50 |         Instant validity2 = now.plusSeconds(REFRESH_TOKEN_VALIDITY);
   51 | 
   52 |         // ì•¡ì„¸ìŠ¤ í† í° ìƒì„±
   53 |         String accessToken = buildToken(claims, now, validity, key, SecurityConstants.TOKEN_TYPE);
   54 |         // ë¦¬í”„ë ˆì‹œ í† í° ìƒì„±
   55 |         String refreshToken = buildToken(Jwts.claims(), now, validity2, key2, SecurityConstants.TOKEN_TYPE2);
   56 | 
   57 |         return TokenDto.builder()
   58 | 
   59 |         return tokenDto.builder()
   60 |                 .refreshToken(refreshToken)
   61 |                 .accessToken(accessToken)
   62 |                 .build();
   63 |     }
   64 | /* <<<<<<<<<<  2f21aafa-d159-41a6-892b-76ef4b9b83f8  >>>>>>>>>>> */
   65 | 
   66 |     // í´ë ˆì„ ìƒì„± ìœ í‹¸ë¦¬í‹° ë©”ì„œë“œ
   67 |     private Claims createClaims(String userId, String nickname, Collection<? extends GrantedAuthority> role) {
   68 |         Claims claims = Jwts.claims();
   69 |         claims.put("userId", userId);
   70 |         claims.put("nickname", nickname);
   71 |         claims.put("role", role);
   72 |         return claims;
   73 |     }
   74 | 
   75 |     // í† í° ìƒì„± ìœ í‹¸ë¦¬í‹° ë©”ì„œë“œ
   76 |     private String buildToken(Claims claims, Instant issuedAt, Instant expiry, Key signingKey, String type) {
   77 |         return Jwts.builder()
   78 |                 .setClaims(claims)
   79 |                 .setIssuedAt(Date.from(issuedAt))
   80 |                 .setExpiration(Date.from(expiry))
   81 |                 .signWith(signingKey, SignatureAlgorithm.HS512)
   82 |                 .claim("type", type)
   83 |                 .compact();
   84 |     }
   85 | 
   86 |     public UsernamePasswordAuthenticationToken getAuthentication(String JWT){
   87 |         try {
   88 |             Jws<Claims> parsedToken = Jwts.parserBuilder()
   89 |                     .setSigningKey(key)
   90 |                     .build()
   91 |                     .parseClaimsJws(JWT);
   92 | 
   93 |             log.info("parsedToken : " + parsedToken);
   94 |             users user = new users();
   95 | 
   96 |             List<LinkedHashMap<String, String>> roleList =
   97 |                     (List<LinkedHashMap<String, String>>) parsedToken.getBody().get("role");
   98 | 
   99 |             Role role = Role .valueOf(roleList.get(0).get("authority"));
  100 |             log.info("role : {}", role.toString());
  101 |             user = user.builder()
  102 |                     .userId((String) parsedToken.getBody().get("userId"))
  103 |                     .role(role)
  104 |                     .build();
  105 | 
  106 |             UserDetails userDetails = new principalDetails(user);
  107 | 
  108 | 
  109 |             log.info(userDetails.getUsername());
  110 |             log.info(userDetails.getAuthorities().toString());
  111 | 
  112 |             Collection<? extends GrantedAuthority> authorities = userDetails.getAuthorities();
  113 |             return new UsernamePasswordAuthenticationToken(userDetails, null, authorities);
  114 |         } catch (Exception e){
  115 |             log.error("authentication ê³¼ì •ì—ì„œ Exception ë°œìƒ! " + e.getMessage());
  116 |             return null;
  117 |         }
  118 |     }
  119 | 
  120 |     public boolean validateJWT(String JWT) {
  121 |         try {
  122 |             Jws<Claims> parsedToken = Jwts.parserBuilder()
  123 |                     .setSigningKey(key)
  124 |                     .build()
  125 |                     .parseClaimsJws(JWT);
  126 | 
  127 |             log.info("JWT ìœ íš¨ì„± ê²€ì¦ í†µê³¼ - ë§Œë£Œì¼: {}", parsedToken.getBody().getExpiration());
  128 |             return !parsedToken.getBody().getExpiration().before(new Date());
  129 |         } catch (ExpiredJwtException e) {
  130 |             log.error("JWT ë§Œë£Œ - {}", e.getMessage());
  131 |             return false;
  132 |         } catch (UnsupportedJwtException e) {
  133 |             log.error("ì§€ì›ë˜ì§€ ì•ŠëŠ” JWT - {}", e.getMessage());
  134 |             return false;
  135 |         } catch (MalformedJwtException e) {
  136 |             log.error("ì˜ëª»ëœ í˜•ì‹ì˜ JWT - {}", e.getMessage());
  137 |             return false;
  138 |         } catch (JwtException e) {
  139 |             log.error("JWT ì˜ˆì™¸ ë°œìƒ - {}", e.getMessage());
  140 |             return false;
  141 |         } catch (Exception e) {
  142 |             log.error("JWT ì²˜ë¦¬ ì¤‘ ì¼ë°˜ ì˜ˆì™¸ ë°œìƒ - {}", e.getMessage());
  143 |             return false;
  144 |         }
  145 | 
  146 |     }
  147 | 
  148 |     public boolean validateRefreshJWT(String refreshJWT) {
  149 |         try{
  150 |             Jws<Claims> parsedRefreshToken = Jwts.parserBuilder()
  151 |                     .setSigningKey(key2)
  152 |                     .build()
  153 |                     .parseClaimsJws(refreshJWT);
  154 |             return !parsedRefreshToken.getBody().getExpiration().before(new Date());
  155 |         } catch(ExpiredJwtException e){
  156 |             log.error("refresh token expired");
  157 |             return false;
  158 |         } catch (JwtException e){
  159 |             log.error("refresh token tampered");
  160 |             return false;
  161 |         } catch(NullPointerException e){
  162 |             log.error("refresh token is null");
  163 |             return false;
  164 |         } catch (Exception e){
  165 |             log.error("refresh token error");
  166 |             return false;
  167 |         }
  168 |     }
  169 | 
  170 | 
  171 | 
  172 |     public Map<String, Object> getClaimsFromAccessToken(String JWT) {
  173 |         try {
  174 |             Jws<Claims> parsedToken = Jwts.parserBuilder()
  175 |                     .setSigningKey(key)
  176 |                     .build()
  177 |                     .parseClaimsJws(JWT);
  178 | 
  179 |             Claims claims = parsedToken.getBody();
  180 | 
  181 |             Map<String, Object> claimMap = new HashMap<>();
  182 |             claimMap.put("userId", claims.get("userId"));
  183 |             claimMap.put("nickname", claims.get("nickname"));
  184 |             claimMap.put("role", claims.get("role"));
  185 |             return claimMap;
  186 |         } catch (ExpiredJwtException e) {
  187 |             log.error("| jwt utils | expired Token!");
  188 |             Map<String, Object> claimMap = new HashMap<>();
  189 |             claimMap.put("userId", e.getClaims().get("userId"));
  190 |             claimMap.put("nickname", e.getClaims().get("nickname"));
  191 |             claimMap.put("role", e.getClaims().get("role"));
  192 |             return claimMap;
  193 |         } catch (JwtException e) {
  194 |             throw new RuntimeException("token error");
  195 |         }
  196 |     }
  197 | 
  198 | 
  199 |     // ê¸°ì¡´ í† í°ì„ ê¸°ë°˜ìœ¼ë¡œ ìƒˆë¡œìš´ í† í°ì„ ë°œê¸‰í•˜ëŠ” ë©”ì„œë“œ
  200 |     public String refreshToken(String expiredToken) {
  201 |         Claims claims; Instant now = Instant.now();Instant newExpiry = now.plusSeconds(ACCESS_TOKEN_VALIDITY);
  202 |         try {
  203 |             claims = extractClaims(expiredToken);
  204 |         } catch (ExpiredJwtException e) {
  205 |             claims = e.getClaims();
  206 |         } catch (JwtException e) {
  207 |             throw new RuntimeException("token error");
  208 |         }
  209 |         return buildToken(claims, now, newExpiry, key, SecurityConstants.TOKEN_TYPE);
  210 |     }
  211 | 
  212 | 
  213 |     public String getUserIdFromToken(String token) {
  214 |         if (token == null) {
  215 |             throw new IllegalArgumentException("Token is null");
  216 |         }
  217 | 
  218 |         Claims getClaims = this.extractClaims(token);
  219 |         return getClaims.get("userId", String.class);  // userIdë¥¼ Stringìœ¼ë¡œ ë°˜í™˜
  220 |     }
  221 | 
  222 | 
  223 |     // access í† í°ì—ì„œ Claims ë¥¼ ì¶”ì¶œí•˜ëŠ” ìœ í‹¸ë¦¬í‹° ë©”ì„œë“œ
  224 |     public Claims extractClaims(String token) {
  225 |         return Jwts.parserBuilder()
  226 |                 .setSigningKey(key)
  227 |                 .build()
  228 |                 .parseClaimsJws(token)
  229 |                 .getBody();
  230 |     }
  231 | 
  232 |     public String checkSnsCookie(HttpServletRequest request, HttpServletResponse response) throws IOException {
  233 |         String providerHeader = request.getHeader("provider"); // SNS ì •ë³´ ì œê³µì ì¶”ê°€í•˜ê¸°
  234 |         Cookie[] cookies = request.getCookies();
  235 |         String RToken = null;
  236 |         if (cookies != null) {
  237 |             for (Cookie cookie : cookies) {
  238 |                 if (cookie.getName().equals(providerHeader + "_refreshToken")) {
  239 |                     RToken = cookie.getValue();
  240 |                     break;
  241 |                 }
  242 |             }
  243 |         }
  244 |         if (RToken == null) {
  245 |             sendResponseStatus(response, HttpServletResponse.SC_UNAUTHORIZED, "there's no refreshToken");
  246 |         }
  247 |         return RToken;
  248 |     }
  249 | 
  250 |     private void sendResponseStatus(HttpServletResponse response, int status, String message)
  251 |             throws IOException{
  252 |         response.setStatus(status);
  253 |         PrintWriter writer = response.getWriter();
  254 |         response.setContentType("application/json");
  255 |         response.setCharacterEncoding("UTF-8");
  256 |         writer.print("{\"message\":\"" + message + "\"}");
  257 |         writer.flush();
  258 |     }
  259 | 
  260 | 
  261 |     @Transactional
  262 |     public String checkCookie(HttpServletRequest request, HttpServletResponse response, String provider) throws IOException {
  263 |         Cookie[] cookies = request.getCookies();
  264 |         String RToken = null;
  265 | 
  266 |         if (cookies == null) {
  267 |             sendResponseStatus(response, HttpServletResponse.SC_UNAUTHORIZED, "there's no cookies");
  268 |             return null;
  269 |         }
  270 | 
  271 |         if (!"server".equals(provider)) {
  272 |             for (Cookie cookie : cookies) {
  273 |                 if (cookie.getName().equals(provider + "_refreshToken")) {
  274 |                     RToken = cookie.getValue();
  275 |                     break;
  276 |                 }
  277 |             }
  278 |         } else {
  279 |             for (Cookie cookie : cookies) {
  280 |                 if (cookie.getName().equals("refreshToken")) {
  281 |                     RToken = cookie.getValue();
  282 |                     break;
  283 |                 }
  284 |             }
  285 |         }
  286 | 
  287 |         if (RToken == null) {
  288 |             sendResponseStatus(response, HttpServletResponse.SC_UNAUTHORIZED, "there's no refreshToken");
  289 |         }
  290 | 
  291 |         return RToken;
  292 |     }
  293 | 
  294 | 
  295 |     @Bean
  296 |     public RestTemplate restTemplate() {
  297 |         return new RestTemplate();
  298 |     }
  299 | 
  300 | }

#--------------------------------------------------------------------------------


# File: backend/src/main/java/com/authentication/auth/configuration/redis/redisConfig.java
#=============================================================================

    1 | package com.authentication.auth.configuration.redis;
    2 | 
    3 | import org.springframework.beans.factory.annotation.Value;
    4 | import org.springframework.context.annotation.Bean;
    5 | import org.springframework.context.annotation.Configuration;
    6 | import org.springframework.data.redis.connection.RedisConnectionFactory;
    7 | import org.springframework.data.redis.connection.RedisStandaloneConfiguration;
    8 | import org.springframework.data.redis.connection.lettuce.LettuceConnectionFactory;
    9 | import org.springframework.data.redis.core.RedisTemplate;
   10 | import org.springframework.data.redis.serializer.StringRedisSerializer;
   11 | 
   12 | @Configuration
   13 | public class redisConfig {
   14 | 
   15 |     @Value("${spring.data.redis.host}")
   16 |     private String host;
   17 | 
   18 |     @Value("${spring.data.redis.port}")
   19 |     private int port;
   20 | 
   21 |     @Value("${spring.data.redis.password}")
   22 |     private String password;
   23 | 
   24 | 
   25 |     @Bean
   26 |     public RedisConnectionFactory redisConnectionFactory() {
   27 |         RedisStandaloneConfiguration redisStandaloneConfiguration = new RedisStandaloneConfiguration();
   28 |         redisStandaloneConfiguration.setHostName(host);
   29 |         redisStandaloneConfiguration.setPort(port);
   30 |         redisStandaloneConfiguration.setPassword(password);
   31 |         return new LettuceConnectionFactory(redisStandaloneConfiguration);
   32 |     }
   33 | 
   34 | 
   35 |     @Bean
   36 |     public RedisTemplate<?, ?> redisTemplate() {
   37 |         RedisTemplate<?, ?> redisTemplate = new RedisTemplate<>();
   38 |         redisTemplate.setKeySerializer(new StringRedisSerializer());
   39 |         redisTemplate.setValueSerializer(new StringRedisSerializer());
   40 |         redisTemplate.setConnectionFactory(redisConnectionFactory());
   41 |         return redisTemplate;
   42 |     }
   43 | }

#--------------------------------------------------------------------------------


# File: backend/src/main/java/com/authentication/auth/repository/usersRepository.java
#=============================================================================

    1 | package com.career_block.auth.repository;
    2 | 
    3 | import com.authentication.auth.domain.User;
    4 | import com.authentication.auth.domain.users;
    5 | 
    6 | import org.springframework.data.jpa.repository.JpaRepository;
    7 | import org.springframework.data.jpa.repository.Modifying;
    8 | import org.springframework.data.jpa.repository.Query;
    9 | import org.springframework.transaction.annotation.Transactional;
   10 | 
   11 | import java.util.Optional;
   12 | 
   13 | public interface usersRepository extends JpaRepository<users, Long> {
   14 | 
   15 |     User findByUserId(String userId);
   16 |     boolean existsByEmail(String email);
   17 |     boolean existsByUserIdOrNickname(String userId, String nickname);
   18 |     boolean existsByNickname(String nickname);
   19 | 
   20 |     boolean existsByUserId(String userId);
   21 | 
   22 |     @Modifying
   23 |     @Transactional
   24 |     @Query("UPDATE users u SET u.userPw = :password WHERE u.userId = :userId")
   25 |     int updatePassword(String userId, String password);
   26 | 
   27 |     Optional<User> findByProviderAndProviderId(String provider, String providerId);
   28 | }

#--------------------------------------------------------------------------------


# File: backend/src/main/java/com/authentication/auth/repository/AuthProviderRepository.java
#=============================================================================


#--------------------------------------------------------------------------------


# File: backend/src/main/java/com/authentication/auth/service/sse/sseService.java
#=============================================================================

    1 | package com.career_block.auth.service.sse;
    2 | 
    3 | import lombok.extern.slf4j.Slf4j;
    4 | import org.springframework.security.core.parameters.P;
    5 | import org.springframework.stereotype.Service;
    6 | import org.springframework.web.servlet.mvc.method.annotation.SseEmitter;
    7 | 
    8 | import java.io.IOException;
    9 | import java.util.List;
   10 | import java.util.concurrent.ConcurrentHashMap;
   11 | import java.util.concurrent.CopyOnWriteArrayList;
   12 | 
   13 | @Slf4j
   14 | @Service
   15 | public class sseService {
   16 | 
   17 |     // ì‚¬ìš©ì IDë¥¼ í‚¤ë¡œ, SseEmitter ëª©ë¡ì„ ê°’ìœ¼ë¡œ ì €ì¥
   18 |     private final ConcurrentHashMap<String, List<SseEmitter>> emittersMap = new ConcurrentHashMap<>();
   19 | 
   20 | 
   21 |     // SseEmitter ì €ì¥
   22 |     public boolean saveSseEmitter(String userId, SseEmitter emitter) {
   23 |         if (userId == null || userId.isEmpty() || emitter == null) {
   24 |             log.error("userId or emitter is null");
   25 |             return false;
   26 |         }
   27 | 
   28 |         emittersMap.computeIfAbsent(userId, k -> new CopyOnWriteArrayList<>()).add(emitter);
   29 | 
   30 |         // ì—°ê²° ì¢…ë£Œ ì‹œ ì œê±°
   31 |         emitter.onCompletion(() -> removeEmitter(userId, emitter));
   32 |         emitter.onTimeout(() -> removeEmitter(userId, emitter));
   33 |         emitter.onError((e) -> removeEmitter(userId, emitter));
   34 | 
   35 |         log.info("SseEmitter saved for userId: {}", userId);
   36 |         return true;
   37 |     }
   38 | 
   39 | 
   40 |     // SseEmitter ì œê±°
   41 |     public void removeEmitter(String userId, SseEmitter emitter){
   42 |         List<SseEmitter> emitters = emittersMap.get(userId);
   43 |         if (emitters != null) {
   44 |             emitters.remove(emitter);
   45 |             if (emitters.isEmpty()) {
   46 |                 emittersMap.remove(userId);
   47 |             }
   48 |         }
   49 |     }
   50 | 
   51 | 
   52 |     // íŠ¹ì • ì‚¬ìš©ìì—ê²Œ ì´ë²¤íŠ¸ ì „ì†¡
   53 |     public void sendEventToUser(String userId, Object data) {
   54 |         List<SseEmitter> emitters = emittersMap.get(userId);
   55 |         if (emitters != null) {
   56 |             emitters.forEach(emitter -> {
   57 |                 try {
   58 |                     emitter.send(SseEmitter.event().name("message").data(data));
   59 |                 } catch (IOException e) {
   60 |                     log.error("Error sending event to userId: {}", userId, e);
   61 |                     removeEmitter(userId, emitter);
   62 |                 }
   63 |             });
   64 |         }
   65 |     }
   66 | 
   67 | 
   68 |     // ëª¨ë“  ì‚¬ìš©ìì—ê²Œ ì´ë²¤íŠ¸ ì „ì†¡
   69 |     public void sendEventToAll(Object data) {
   70 |         emittersMap.forEach((userId, emitters) -> {
   71 |             sendEventToUser(userId, data);
   72 |         });
   73 |     }
   74 | 
   75 | 
   76 | }

#--------------------------------------------------------------------------------


# File: backend/src/main/java/com/authentication/auth/service/users/userService.java
#=============================================================================

    1 | package com.career_block.auth.service.users;
    2 | 
    3 | import lombok.RequiredArgsConstructor;
    4 | import lombok.extern.slf4j.Slf4j;
    5 | import org.springframework.http.HttpStatus;
    6 | import org.springframework.http.ResponseEntity;
    7 | import org.springframework.security.crypto.bcrypt.BCryptPasswordEncoder;
    8 | import org.springframework.stereotype.Service;
    9 | import org.springframework.transaction.annotation.Transactional;
   10 | 
   11 | import com.authentication.auth.DTO.users.joinRequest;
   12 | import com.authentication.auth.domain.Role;
   13 | import com.authentication.auth.domain.users;
   14 | import com.authentication.auth.repository.usersRepository;
   15 | 
   16 | @Slf4j
   17 | @Service
   18 | @RequiredArgsConstructor
   19 | public class userService {
   20 | 
   21 |     private final usersRepository usersRepository;
   22 |     private final BCryptPasswordEncoder passwordEncoder;
   23 | 
   24 |     @Transactional
   25 |     public ResponseEntity<?> join(joinRequest request){
   26 |         if (usersRepository.existsByUserIdOrNickname(request.getUserId(), request.getNickname())) {
   27 |             log.error("ì´ë¯¸ ì¡´ì¬í•˜ëŠ” ì•„ì´ë”” í˜¹ì€ ë‹‰ë„¤ì„ ì…ë‹ˆë‹¤.");
   28 |             return ResponseEntity.status(HttpStatus.CONFLICT).build();
   29 |         }
   30 | 
   31 |         try {
   32 |             joinRequest joinRequestBuilder = joinRequest.builder()
   33 |                     .userId(request.getUserId())
   34 |                     .userPw(passwordEncoder.encode(request.getUserPw()))
   35 |                     .userName(request.getUserName())
   36 |                     .nickname(request.getNickname())
   37 |                     .phone(request.getPhone())
   38 |                     .email(request.getEmail())
   39 |                     .role(Role.USER)
   40 |                     .birthDate(request.getBirthDate())
   41 |                     .gender(request.getGender())
   42 |                     .isPrivate(request.isPrivate())
   43 |                     .profile(request.getProfile() != null ? request.getProfile() : "ëŒ€ì¶© ì´ë¯¸ì§€")
   44 |                     .build();
   45 |             users joinUser = joinRequestBuilder.toEntity();
   46 |             usersRepository.save(joinUser);
   47 |             return ResponseEntity.status(HttpStatus.OK).build();
   48 |         } catch (Exception e) {
   49 |             log.error("íšŒì› ê°€ì… ì‹¤íŒ¨", e);
   50 |             return ResponseEntity.status(HttpStatus.INTERNAL_SERVER_ERROR).build();
   51 |         }
   52 |     }
   53 | 
   54 | 
   55 |     @Transactional
   56 |     public String getEmailByUserId(String userId){
   57 |         try{
   58 |             users user = usersRepository.findByUserId(userId);
   59 |             return user.getEmail();
   60 |         } catch (Exception e){
   61 |             log.error("ì´ë©”ì¼ ì°¾ê¸° ì‹¤íŒ¨", e);
   62 |             return null;
   63 |         }
   64 |     }
   65 | 
   66 | 
   67 |     @Transactional
   68 |     public void UpdateUserPassword(String userId, String temporalPassword) {
   69 |         try {
   70 |             int updateCount = usersRepository.updatePassword(userId, passwordEncoder.encode(temporalPassword));
   71 |             if (updateCount == 0) throw new Exception("ë¹„ë°€ë²ˆí˜¸ ë³€ê²½ ì‹¤íŒ¨! ì‚¬ìš©ìë¥¼ ì°¾ì„ ìˆ˜ ì—†ìŒ");
   72 |         } catch (Exception e) {
   73 |             log.error("ë¹„ë°€ë²ˆí˜¸ ë³€ê²½ ì‹¤íŒ¨", e);
   74 |         }
   75 |     }
   76 | 
   77 | 
   78 | 
   79 |     @Transactional
   80 |     public boolean checkUserIdIsDuplicate(String userId) {
   81 |         return usersRepository.existsByUserId(userId);
   82 |     }
   83 | 
   84 |     @Transactional
   85 |     public boolean checkNickNameIsDuplicate(String nickname) {
   86 |         return usersRepository.existsByNickname(nickname);
   87 |     }
   88 | 
   89 | 
   90 | 
   91 | }

#--------------------------------------------------------------------------------


# File: backend/src/main/java/com/authentication/auth/service/oauth2/snsTokenValidator.java
#=============================================================================

    1 | package com.career_block.auth.service.oauth2;
    2 | 
    3 | import lombok.extern.slf4j.Slf4j;
    4 | import org.springframework.beans.factory.annotation.Value;
    5 | import org.springframework.http.*;
    6 | import org.springframework.stereotype.Service;
    7 | import org.springframework.util.LinkedMultiValueMap;
    8 | import org.springframework.util.MultiValueMap;
    9 | import org.springframework.web.client.RestTemplate;
   10 | 
   11 | import java.util.HashMap;
   12 | import java.util.Map;
   13 | 
   14 | @Slf4j
   15 | @Service
   16 | public class snsTokenValidator {
   17 | 
   18 | 
   19 |     @Value("${kakao.token.validate.url}")
   20 |     private String kakaoValidateURL;
   21 | 
   22 |     @Value("${naver.token.validate.url}")
   23 |     private String naverValidateURL;
   24 | 
   25 |     @Value("${google.token.validate.url}")
   26 |     private String googleValidateURL;
   27 | 
   28 |     @Value("${spring.security.oauth2.client.registration.kakao.client-id}")
   29 |     private String kakaoClientId;
   30 | 
   31 |     @Value("${spring.security.oauth2.client.registration.kakao.client-secret}")
   32 |     private String kakaoClientSecret;
   33 | 
   34 |     @Value("${spring.security.oauth2.client.registration.kakao.redirect-uri}")
   35 |     private String kakaoRedirectUri;
   36 | 
   37 |     @Value("${spring.security.oauth2.client.registration.naver.client-id}")
   38 |     private String naverClientId;
   39 | 
   40 |     @Value("${spring.security.oauth2.client.registration.naver.client-secret}")
   41 |     private String naverClientSecret;
   42 | 
   43 |     @Value("${spring.security.oauth2.client.registration.naver.redirect-uri}")
   44 |     private String naverRedirectUri;
   45 | 
   46 |     @Value("${spring.security.oauth2.client.registration.google.client-id}")
   47 |     private String googleClientId;
   48 | 
   49 |     @Value("${spring.security.oauth2.client.registration.google.client-secret}")
   50 |     private String googleClientSecret;
   51 | 
   52 |     @Value("${spring.security.oauth2.client.registration.google.redirect-uri}")
   53 |     private String googleRedirectUri;
   54 | 
   55 |     @Value("${site.domain}")
   56 |     private String domain;
   57 | 
   58 |     private final RestTemplate restTemplate;
   59 | 
   60 |     public snsTokenValidator(RestTemplate restTemplate) {
   61 |         this.restTemplate = restTemplate;
   62 |     }
   63 | 
   64 | 
   65 |     public boolean validateToken(String token, String provider) {
   66 |         log.info("provider : [{}] token validation start", provider);
   67 |         return switch (provider) {
   68 |             case "kakao" -> kakaoValidateToken(token);
   69 |             case "naver" -> naverValidateToken(token);
   70 |             case "google" -> googleValidateToken(token);
   71 |             default -> false;
   72 |         };
   73 |     }
   74 | 
   75 |     public Map<String, String> getNewTokenByRefreshToken(String refreshToken, String provider) {
   76 |         String url = null;
   77 |         MultiValueMap<String, String> params = new LinkedMultiValueMap<>();
   78 |         RestTemplate restTemplate = new RestTemplate();
   79 |         HttpHeaders headers = new HttpHeaders();
   80 |         headers.add("Content-Type", "application/x-www-form-urlencoded");
   81 | 
   82 |         switch (provider) {
   83 |             case "kakao":
   84 |                 url = "https://kauth.kakao.com/oauth/token";
   85 |                 params.add("grant_type", "refresh_token");
   86 |                 params.add("client_id", kakaoClientId);
   87 |                 params.add("refresh_token", refreshToken);
   88 |                 params.add("client_secret", kakaoClientSecret);
   89 |                 break;
   90 |             case "naver":
   91 |                 url = "https://nid.naver.com/oauth2.0/token";
   92 |                 params.add("grant_type", "refresh_token");
   93 |                 params.add("client_id", naverClientId);
   94 |                 params.add("refresh_token", refreshToken);
   95 |                 params.add("client_secret", naverClientSecret);
   96 |                 break;
   97 |             case "google":
   98 |                 url = "https://oauth2.googleapis.com/token";
   99 |                 params.add("grant_type", "refresh_token");
  100 |                 params.add("client_id", googleClientId);
  101 |                 params.add("refresh_token", refreshToken);
  102 |                 params.add("client_secret", googleClientSecret);
  103 |                 break;
  104 |             default:
  105 |                 throw new IllegalArgumentException("Unsupported provider: " + provider);
  106 |         }
  107 | 
  108 |         HttpEntity<MultiValueMap<String, String>> entity = new HttpEntity<>(params, headers);
  109 |         ResponseEntity<Map> response = restTemplate.exchange(url, HttpMethod.POST, entity, Map.class);
  110 | 
  111 |         if (response.getStatusCode() == HttpStatus.OK && response.getBody() != null) {
  112 |             Map<String, String> tokens = new HashMap<>();
  113 |             tokens.put("access_token", response.getBody().get("access_token").toString());
  114 |             if (response.getBody().containsKey("refresh_token")) {
  115 |                 tokens.put("refresh_token", response.getBody().get("refresh_token").toString());
  116 |             }
  117 |             return tokens;
  118 |         } else {
  119 |             throw new RuntimeException("Failed to get sns tokens for provider: " + provider);
  120 |         }
  121 |     }
  122 | 
  123 | 
  124 | 
  125 |     private boolean kakaoValidateToken(String token) {
  126 |         String url = kakaoValidateURL;
  127 |         HttpHeaders headers = new HttpHeaders();
  128 |         headers.set("Authorization", "Bearer " + token);
  129 |         HttpEntity<String> entity = new HttpEntity<>(headers);
  130 |         try {
  131 |             ResponseEntity<String> response = restTemplate.exchange(url, HttpMethod.GET, entity, String.class);
  132 |             return response.getStatusCode().is2xxSuccessful();
  133 |         } catch (Exception e) {
  134 |             log.error("ì¹´ì¹´ì˜¤ í† í° ê²€ì¦ ì¤‘ ì—ëŸ¬ ë°œìƒ", e);
  135 |             return false;
  136 |         }
  137 |     }
  138 | 
  139 |     private boolean naverValidateToken(String token) {
  140 |         String url = naverValidateURL;
  141 |         HttpHeaders headers = new HttpHeaders();
  142 |         headers.set("Authorization", "Bearer " + token);
  143 |         HttpEntity<String> entity = new HttpEntity<>(headers);
  144 |         try {
  145 |             ResponseEntity<String> response = restTemplate.exchange(url, HttpMethod.GET, entity, String.class);
  146 |             return response.getStatusCode().is2xxSuccessful();
  147 |         } catch (Exception e) {
  148 |             log.error("ë„¤ì´ë²„ í† í° ê²€ì¦ ì¤‘ ì—ëŸ¬ ë°œìƒ", e);
  149 |             return false;
  150 |         }
  151 |     }
  152 | 
  153 |     private boolean googleValidateToken(String token) {
  154 |         String url = googleValidateURL + "?id_token=" + token;
  155 |         try {
  156 |             ResponseEntity<String> response = restTemplate.getForEntity(url, String.class);
  157 |             return response.getStatusCode().is2xxSuccessful();
  158 |         } catch (Exception e) {
  159 |             log.error("êµ¬ê¸€ í† í° ê²€ì¦ ì¤‘ ì—ëŸ¬ ë°œìƒ", e);
  160 |             return false;
  161 |         }
  162 |     }
  163 | }

#--------------------------------------------------------------------------------


# File: backend/src/main/java/com/authentication/auth/service/oauth2/oauth2Service.java
#=============================================================================

    1 | package com.career_block.auth.service.oauth2;
    2 | 
    3 | import jakarta.servlet.http.Cookie;
    4 | import jakarta.servlet.http.HttpServletResponse;
    5 | import lombok.RequiredArgsConstructor;
    6 | import lombok.extern.slf4j.Slf4j;
    7 | import org.springframework.beans.factory.annotation.Value;
    8 | import org.springframework.http.*;
    9 | import org.springframework.security.core.authority.SimpleGrantedAuthority;
   10 | import org.springframework.stereotype.Service;
   11 | import org.springframework.transaction.annotation.Transactional;
   12 | import org.springframework.util.LinkedMultiValueMap;
   13 | import org.springframework.util.MultiValueMap;
   14 | import org.springframework.web.client.HttpClientErrorException;
   15 | import org.springframework.web.client.RestTemplate;
   16 | 
   17 | import com.authentication.auth.DTO.token.tokenDto;
   18 | import com.authentication.auth.configuration.token.jwtUtility;
   19 | import com.authentication.auth.domain.Role;
   20 | import com.authentication.auth.domain.users;
   21 | import com.authentication.auth.others.nickNameGenerator;
   22 | import com.authentication.auth.others.constants.SecurityConstants;
   23 | import com.authentication.auth.repository.usersRepository;
   24 | import com.authentication.auth.service.redis.redisService;
   25 | 
   26 | import java.net.URLDecoder;
   27 | import java.nio.charset.StandardCharsets;
   28 | import java.security.SecureRandom;
   29 | import java.text.ParseException;
   30 | import java.text.SimpleDateFormat;
   31 | import java.util.*;
   32 | 
   33 | 
   34 | @Slf4j
   35 | @Service
   36 | @RequiredArgsConstructor
   37 | public class oauth2Service {
   38 | 
   39 |     @Value("${spring.security.oauth2.client.registration.kakao.client-id}")
   40 |     private String kakaoClientId;
   41 | 
   42 |     @Value("${spring.security.oauth2.client.registration.kakao.client-secret}")
   43 |     private String kakaoClientSecret;
   44 | 
   45 |     @Value("${spring.security.oauth2.client.registration.kakao.redirect-uri}")
   46 |     private String kakaoRedirectUri;
   47 | 
   48 |     @Value("${spring.security.oauth2.client.registration.naver.client-id}")
   49 |     private String naverClientId;
   50 | 
   51 |     @Value("${spring.security.oauth2.client.registration.naver.client-secret}")
   52 |     private String naverClientSecret;
   53 | 
   54 |     @Value("${spring.security.oauth2.client.registration.naver.redirect-uri}")
   55 |     private String naverRedirectUri;
   56 | 
   57 |     @Value("${spring.security.oauth2.client.registration.google.client-id}")
   58 |     private String googleClientId;
   59 | 
   60 |     @Value("${spring.security.oauth2.client.registration.google.client-secret}")
   61 |     private String googleClientSecret;
   62 | 
   63 |     @Value("${spring.security.oauth2.client.registration.google.redirect-uri}")
   64 |     private String googleRedirectUri;
   65 | 
   66 |     @Value("${site.domain}")
   67 |     private String domain;
   68 | 
   69 |     private final usersRepository usersRepository;
   70 |     private final redisService redisService;
   71 |     private final jwtUtility jwtUtility;
   72 |     private final nickNameGenerator nickNameGenerator;
   73 | 
   74 | 
   75 |     public Map<String, String> getKakaoTokens(String tempCode) {
   76 |         log.info("current : getKakaoTokens");
   77 | 
   78 |         String url = "https://kauth.kakao.com/oauth/token";
   79 | 
   80 |         RestTemplate restTemplate = new RestTemplate();
   81 | 
   82 |         HttpHeaders headers = new HttpHeaders();
   83 |         headers.add("Content-Type", "application/x-www-form-urlencoded");
   84 | 
   85 |         MultiValueMap<String, String> params = new LinkedMultiValueMap<>();
   86 |         params.add("grant_type", "authorization_code");
   87 |         params.add("client_id", kakaoClientId);
   88 |         params.add("redirect_uri", kakaoRedirectUri);
   89 |         params.add("code", tempCode);
   90 |         params.add("client_secret", kakaoClientSecret);
   91 | 
   92 |         HttpEntity<MultiValueMap<String, String>> entity = new HttpEntity<>(params, headers);
   93 | 
   94 |         try {
   95 |             ResponseEntity<Map> response = restTemplate.exchange(url, HttpMethod.POST, entity, Map.class);
   96 | 
   97 |             if (response.getBody() != null && response.getBody().containsKey("access_token") && response.getBody().containsKey("refresh_token")) {
   98 |                 return Map.of(
   99 |                         "access_token", response.getBody().get("access_token").toString(),
  100 |                         "refresh_token", response.getBody().get("refresh_token").toString()
  101 |                 );
  102 |             } else {
  103 |                 throw new RuntimeException("ì•¡ì„¸ìŠ¤ í† í°ì„ ê°€ì ¸ì˜¤ì§€ ëª»í–ˆìŠµë‹ˆë‹¤.");
  104 |             }
  105 |         } catch (Exception e) {
  106 |             log.error("Error while requesting tokens: ", e);
  107 |             throw e;
  108 |         }
  109 |     }
  110 | 
  111 |     public Map<String, Object> getKakaoUserProfile(String accessToken) {
  112 |         log.info("current : getKakaoUserProfile");
  113 | 
  114 |         String url = "https://kapi.kakao.com/v2/user/me";
  115 | 
  116 |         RestTemplate restTemplate = new RestTemplate();
  117 | 
  118 |         HttpHeaders headers = new HttpHeaders();
  119 |         headers.add("Authorization", "Bearer " + accessToken);
  120 | 
  121 |         log.info("Requesting user profile with accessToken: {}", accessToken);
  122 | 
  123 |         HttpEntity<Void> entity = new HttpEntity<>(headers);
  124 | 
  125 |         try {
  126 |             ResponseEntity<Map> response = restTemplate.exchange(url, HttpMethod.GET, entity, Map.class);
  127 | 
  128 |             if (response.getBody() != null) {
  129 |                 return response.getBody();
  130 |             } else {
  131 |                 throw new RuntimeException("ì‚¬ìš©ì í”„ë¡œí•„ì„ ê°€ì ¸ì˜¤ì§€ ëª»í–ˆìŠµë‹ˆë‹¤.");
  132 |             }
  133 |         } catch (Exception e) {
  134 |             log.error("Error while requesting user profile: ", e);
  135 |             throw e;
  136 |         }
  137 |     }
  138 | 
  139 |     public Map<String, String> getNaverTokens(String tempCode, String state) {
  140 |         log.info("current : getNaverTokens");
  141 | 
  142 |         String url = "https://nid.naver.com/oauth2.0/token";
  143 | 
  144 |         RestTemplate restTemplate = new RestTemplate();
  145 | 
  146 |         HttpHeaders headers = new HttpHeaders();
  147 |         headers.add("Content-Type", "application/x-www-form-urlencoded");
  148 | 
  149 |         MultiValueMap<String, String> params = new LinkedMultiValueMap<>();
  150 |         params.add("grant_type", "authorization_code");
  151 |         params.add("client_id", naverClientId);
  152 |         params.add("redirect_uri", naverRedirectUri);
  153 |         params.add("code", tempCode);
  154 |         params.add("client_secret", naverClientSecret);
  155 |         params.add("state", state);
  156 | 
  157 |         log.info("Requesting tokens with params: {}", params);
  158 | 
  159 |         HttpEntity<MultiValueMap<String, String>> entity = new HttpEntity<>(params, headers);
  160 | 
  161 |         try {
  162 |             ResponseEntity<Map> response = restTemplate.exchange(url, HttpMethod.POST, entity, Map.class);
  163 | 
  164 |             log.info("Response from Naver: {}", response);
  165 | 
  166 |             if (response.getStatusCode() == HttpStatus.OK) {
  167 |                 Map<String, Object> responseBody = response.getBody();
  168 |                 log.info("responseBody info : {}", responseBody.toString());
  169 | 
  170 |                 if (responseBody != null && responseBody.containsKey("access_token") && responseBody.containsKey("refresh_token")) {
  171 |                     log.info("Received tokens: {}", responseBody);
  172 |                     return Map.of(
  173 |                             "access_token", responseBody.get("access_token").toString(),
  174 |                             "refresh_token", responseBody.get("refresh_token").toString()
  175 |                     );
  176 |                 } else {
  177 |                     log.error("Response body is missing required tokens: {}", responseBody);
  178 |                     throw new RuntimeException("ì•¡ì„¸ìŠ¤ í† í°ì„ ê°€ì ¸ì˜¤ì§€ ëª»í–ˆìŠµë‹ˆë‹¤.");
  179 |                 }
  180 |             } else {
  181 |                 log.error("Failed to get tokens, status code: {}, response: {}", response.getStatusCode(), response.getBody());
  182 |                 throw new RuntimeException("ì•¡ì„¸ìŠ¤ í† í°ì„ ê°€ì ¸ì˜¤ì§€ ëª»í–ˆìŠµë‹ˆë‹¤.");
  183 |             }
  184 |         } catch (Exception e) {
  185 |             log.error("Error while requesting tokens: ", e);
  186 |             throw e;
  187 |         }
  188 |     }
  189 | 
  190 | 
  191 |     public Map<String, Object> getNaverUserProfile(String accessToken) {
  192 |         log.info("current : getNaverUserProfile");
  193 | 
  194 |         String url = "https://openapi.naver.com/v1/nid/me";
  195 | 
  196 |         RestTemplate restTemplate = new RestTemplate();
  197 | 
  198 |         HttpHeaders headers = new HttpHeaders();
  199 |         headers.add("Authorization", "Bearer " + accessToken);
  200 | 
  201 |         log.info("Requesting user profile with accessToken: {}", accessToken);
  202 | 
  203 |         HttpEntity<Void> entity = new HttpEntity<>(headers);
  204 | 
  205 |         try {
  206 |             ResponseEntity<Map> response = restTemplate.exchange(url, HttpMethod.GET, entity, Map.class);
  207 | 
  208 |             if (response.getBody() != null) {
  209 |                 return response.getBody();
  210 |             } else {
  211 |                 throw new RuntimeException("ì‚¬ìš©ì í”„ë¡œí•„ì„ ê°€ì ¸ì˜¤ì§€ ëª»í–ˆìŠµë‹ˆë‹¤.");
  212 |             }
  213 |         } catch (Exception e) {
  214 |             log.error("Error while requesting user profile: ", e);
  215 |             throw e;
  216 |         }
  217 |     }
  218 | 
  219 |     public Map<String, String> getGoogleTokens(String tempCode) {
  220 |         log.info("current : getGoogleTokens");
  221 | 
  222 |         String url = "https://oauth2.googleapis.com/token";
  223 | 
  224 |         RestTemplate restTemplate = new RestTemplate();
  225 | 
  226 |         HttpHeaders headers = new HttpHeaders();
  227 |         headers.add("Content-Type", "application/x-www-form-urlencoded");
  228 | 
  229 |         String decode =URLDecoder.decode(tempCode, StandardCharsets.UTF_8);
  230 | 
  231 |         MultiValueMap<String, String> params = new LinkedMultiValueMap<>();
  232 |         params.add("grant_type", "authorization_code");
  233 |         params.add("client_id", googleClientId);
  234 |         params.add("redirect_uri", googleRedirectUri);
  235 |         params.add("code", decode);
  236 |         params.add("client_secret", googleClientSecret);
  237 |         params.add("access_type", "offline");
  238 |         params.add("prompt", "consent");
  239 | 
  240 |         log.info("Requesting tokens with params: {}", params);
  241 | 
  242 |         HttpEntity<MultiValueMap<String, String>> entity = new HttpEntity<>(params, headers);
  243 | 
  244 |         try {
  245 |             ResponseEntity<Map> response = restTemplate.exchange(url, HttpMethod.POST, entity, Map.class);
  246 | 
  247 |             if (response.getBody() != null && response.getBody().containsKey("access_token") && response.getBody().containsKey("refresh_token")) {
  248 |                 log.info("Received tokens: {}", response.getBody());
  249 |                 return Map.of(
  250 |                         "access_token", response.getBody().get("access_token").toString(),
  251 |                         "refresh_token", response.getBody().get("refresh_token").toString()
  252 |                 );
  253 |             } else {
  254 |                 log.info("response.getBody() :  {}", response.getBody());
  255 |                 throw new RuntimeException("ì•¡ì„¸ìŠ¤ í† í°ì„ ê°€ì ¸ì˜¤ì§€ ëª»í–ˆìŠµë‹ˆë‹¤.");
  256 |             }
  257 | 
  258 |         } catch (HttpClientErrorException e) {
  259 |             if (e.getStatusCode() == HttpStatus.BAD_REQUEST) {
  260 |                 log.error("Oauth 2.0 compliance error: {}", e.getResponseBodyAsString());
  261 |             } else {
  262 |                 log.error("Error while requesting tokens : ", e);
  263 |             }
  264 |             throw e;
  265 |         }
  266 |     }
  267 | 
  268 |     public Map<String, Object> getGoogleUserProfile(String accessToken) {
  269 |         log.info("current : getGoogleUserProfile");
  270 | 
  271 |         String url = "https://www.googleapis.com/oauth2/v3/userinfo";
  272 | 
  273 |         RestTemplate restTemplate = new RestTemplate();
  274 | 
  275 |         HttpHeaders headers = new HttpHeaders();
  276 |         headers.add("Authorization", "Bearer " + accessToken);
  277 | 
  278 |         log.info("Requesting user profile with accessToken: {}", accessToken);
  279 | 
  280 |         HttpEntity<Void> entity = new HttpEntity<>(headers);
  281 | 
  282 |         try {
  283 |             ResponseEntity<Map> response = restTemplate.exchange(url, HttpMethod.GET, entity, Map.class);
  284 | 
  285 |             if (response.getBody() != null) {
  286 |                 return response.getBody();
  287 |             } else {
  288 |                 throw new RuntimeException("ì‚¬ìš©ì í”„ë¡œí•„ì„ ê°€ì ¸ì˜¤ì§€ ëª»í–ˆìŠµë‹ˆë‹¤.");
  289 |             }
  290 |         } catch (Exception e) {
  291 |             log.error("Error while requesting user profile: ", e);
  292 |             throw e;
  293 |         }
  294 |     }
  295 | 
  296 |     @Transactional
  297 |     public users saveOrUpdateOauth2User(String provider, String oauthId, Map<String, Object> userProfile) {
  298 |         Optional<users> optionalUser = usersRepository.findByProviderAndProviderId(provider, oauthId);
  299 |         users user;
  300 |         if (optionalUser.isPresent()) {
  301 |             user = optionalUser.get();
  302 |             log.info("user found for {}", optionalUser.get().getUserId());
  303 |             updateUserDetails(user, userProfile, provider);
  304 |         } else {
  305 |             log.info("user not found, creating new user");
  306 |             user = createUser(provider, userProfile);
  307 |         }
  308 |         return usersRepository.save(user);
  309 |     }
  310 | 
  311 | 
  312 |     private void updateUserDetails(users user, Map<String, Object> userProfile, String provider) {
  313 |         log.info("updateUserDetails í˜¸ì¶œ");
  314 | 
  315 |         String newName = null;
  316 |         String newNickname = null;
  317 |         String newProfileImage = null;
  318 |         String newGender = null;
  319 |         String newPhone = null;
  320 |         String newBirthDate = null;
  321 |         String newEmail = null;
  322 | 
  323 |         String defaultString = "";
  324 |         String defaultGender = "N/A";
  325 |         String defaultPhone = "000-0000-0000";
  326 | 
  327 |         switch (provider) {
  328 |             case "kakao":
  329 |                 Map<String, Object> properties = (Map<String, Object>) userProfile.get("properties");
  330 |                 newNickname = (String) properties.get("nickname");
  331 |                 newProfileImage = (String) properties.get("profile_image");
  332 |                 Map<String, Object> kakaoAccount = (Map<String, Object>) userProfile.get("kakao_account");
  333 |                 newEmail = (String) kakaoAccount.get("email");
  334 |                 break;
  335 |             case "naver":
  336 |                 Map<String, Object> response = (Map<String, Object>) userProfile.get("response");
  337 |                 newName = (String) response.get("name");
  338 |                 newNickname = (String) response.get("nickname");
  339 |                 newProfileImage = (String) response.get("profile_image");
  340 |                 newEmail = (String) response.get("email");
  341 |                 newGender = (String) response.get("gender");
  342 |                 newPhone = (String) response.get("mobile_e164");
  343 |                 newBirthDate = (String) response.get("birthday");
  344 |                 break;
  345 |             case "google":
  346 |                 newName = (String) userProfile.get("name");
  347 |                 newProfileImage = (String) userProfile.get("picture");
  348 |                 newEmail = (String) userProfile.get("email");
  349 |                 newGender = defaultGender;
  350 |                 newPhone = defaultPhone;
  351 |                 newBirthDate = defaultString;
  352 |                 break;
  353 |         }
  354 | 
  355 |         if (newName != null && !newName.equals(user.getUserName())) {
  356 |             user.setUserName(newName);
  357 |         }
  358 | 
  359 |         if (newNickname != null && !newNickname.equals(user.getNickname())) {
  360 |             user.setNickname(newNickname);
  361 |         }
  362 | 
  363 |         if (newProfileImage != null && !newProfileImage.equals(user.getProfile())) {
  364 |             user.setProfile(newProfileImage);
  365 |         }
  366 | 
  367 |         if (newGender != null && !newGender.equals(user.getGender())) {
  368 |             user.setGender(newGender);
  369 |         }
  370 | 
  371 |         if (newPhone != null && !newPhone.equals(user.getPhone())) {
  372 |             user.setPhone(newPhone);
  373 |         }
  374 | 
  375 |         if (newBirthDate != null && !newBirthDate.equals(user.getBirthDate())) {
  376 |             user.setBirthDate(parseBirthday(newBirthDate));
  377 |         }
  378 | 
  379 |         if (newEmail != null && !newEmail.equals(user.getEmail())) {
  380 |             user.setEmail(newEmail);
  381 |         }
  382 |     }
  383 | 
  384 |     private users createUser(String provider, Map<String, Object> userProfile) {
  385 | 
  386 |         log.info("createUser í˜¸ì¶œ");
  387 | 
  388 |         String randomPassword = generateRandomString(13);
  389 |         String randomUserId = generateRandomString(13);
  390 | 
  391 |         String name = null;
  392 |         String nickname = null;
  393 |         String profileImage = null;
  394 |         String email = null;
  395 |         String providerId = null;
  396 |         String gender = null;
  397 |         String phone = null;
  398 |         String birthDate = null;
  399 | 
  400 |         String defaultString = "";
  401 |         String defaultGender = "N/A"; // Example default gender
  402 |         String defaultPhone = "000-0000-0000"; // Example default phone number
  403 | 
  404 | 
  405 |         log.info("provider [{}] ì˜ userProfile : {}", provider, userProfile);
  406 | 
  407 |         switch (provider) {
  408 |             case "kakao":
  409 |                 Map<String, Object> properties = (Map<String, Object>) userProfile.get("properties");
  410 |                 log.info("createUser [kakao] properties : {}", properties);
  411 |                 providerId = String.valueOf(userProfile.get("id"));
  412 |                 nickname = (String) properties.get("nickname");
  413 |                 profileImage = (String) properties.get("profile_image");
  414 |                 Map<String, Object> kakaoAccount = (Map<String, Object>) userProfile.get("kakao_account");
  415 |                 email = (String) kakaoAccount.get("email");
  416 |                 break;
  417 |             case "naver":
  418 |                 Map<String, Object> response = (Map<String, Object>) userProfile.get("response");
  419 |                 log.info("createUser [naver] response : {}", response);
  420 |                 providerId = (String) response.get("id");
  421 |                 name = (String) response.get("name");
  422 |                 nickname = (String) response.get("nickname");
  423 |                 profileImage = (String) response.get("profile_image");
  424 |                 email = (String) response.get("email");
  425 |                 gender = (String) response.get("gender");
  426 |                 phone = (String) response.get("mobile_e164");
  427 |                 birthDate = (String) response.get("birthday");
  428 |                 break;
  429 |             case "google":
  430 |                 log.info("createUser [google] userProfile : {}", userProfile);
  431 |                 providerId = (String) userProfile.get("sub"); // Google uses "sub" for user ID
  432 |                 name = (String) userProfile.get("name");
  433 |                 profileImage = (String) userProfile.get("picture");
  434 |                 email = (String) userProfile.get("email");
  435 |                 gender = defaultGender; // Google does not provide gender directly
  436 |                 phone = defaultPhone; // Google does not provide phone directly
  437 |                 birthDate = defaultString; // Google does not provide birthdate directly
  438 |                 break;
  439 |         }
  440 | 
  441 |         return users.builder()
  442 |                 .userId(randomUserId)
  443 |                 .userPw(randomPassword)
  444 |                 .userName(name != null ? name : defaultString)
  445 |                 .nickname(nickname != null ? nickname : defaultString)
  446 |                 .email(email != null ? email : defaultString)
  447 |                 .profile(profileImage != null ? profileImage : defaultString)
  448 |                 .gender(gender != null ? gender : defaultGender)
  449 |                 .phone(phone != null ? phone : defaultPhone)
  450 |                 .birthDate(birthDate != null ? parseBirthday(birthDate) : null)
  451 |                 .provider(provider)
  452 |                 .providerId(providerId != null ? providerId : "")
  453 |                 .role(Role.USER)
  454 |                 .build();
  455 |     }
  456 | 
  457 |     @Transactional
  458 |     public ResponseEntity<?> handleOauth2Login(Map<String, String> requestBody, HttpServletResponse response, String provider) {
  459 |         log.info("current : handleOauth2Login{}", provider);
  460 | 
  461 |         String tempCode = requestBody.get("tempCode");
  462 | 
  463 |         if (tempCode == null) {
  464 |             log.error("there is no tempCode needed for {} login", provider);
  465 |             return ResponseEntity.status(HttpStatus.BAD_REQUEST).body("there is no tempCode needed for " + provider + " login");
  466 |         }
  467 | 
  468 |         try {
  469 |             Map<String, String> tokens;
  470 |             Map<String, Object> userProfile;
  471 | 
  472 |             switch (provider) {
  473 |                 case "kakao":
  474 |                     tokens = getKakaoTokens(tempCode);
  475 |                     userProfile = getKakaoUserProfile(tokens.get("access_token"));
  476 |                     break;
  477 |                 case "naver":
  478 |                     String state = requestBody.get("state");
  479 |                     if (state == null) {
  480 |                         log.error("there is no state needed for naver login");
  481 |                         return ResponseEntity.status(HttpStatus.BAD_REQUEST).body("there is no state for naver login");
  482 |                     }
  483 |                     tokens = getNaverTokens(tempCode, state);
  484 |                     userProfile = getNaverUserProfile(tokens.get("access_token"));
  485 |                     log.info("Naver user profile: {}", userProfile); // Log the entire user profile
  486 |                     break;
  487 |                 case "google":
  488 |                     tokens = getGoogleTokens(tempCode);
  489 |                     userProfile = getGoogleUserProfile(tokens.get("access_token"));
  490 |                     break;
  491 |                 default:
  492 |                     throw new IllegalArgumentException("Unsupported provider: " + provider);
  493 |             }
  494 | 
  495 |             String snsAccessToken = tokens.get("access_token");
  496 |             String refreshToken = tokens.get("refresh_token");
  497 | 
  498 |             if (snsAccessToken == null || refreshToken == null) {
  499 |                 log.error("access token or refresh token does not exist");
  500 |                 return ResponseEntity.status(HttpStatus.NO_CONTENT).body("access token or refresh token does not exist");
  501 |             }
  502 | 
  503 |             if (userProfile == null) {
  504 |                 log.error("userProfile does not exist");
  505 |                 return ResponseEntity.status(HttpStatus.NOT_FOUND).body("user info does not exist");
  506 |             }
  507 | 
  508 |             // extract userId based on provider
  509 |             String oauthId = switch (provider) {
  510 |                 case "naver" -> ((Map<String, Object>) userProfile.get("response")).get("id").toString();
  511 |                 case "kakao" -> userProfile.get("id").toString();
  512 |                 case "google" -> userProfile.get("sub").toString();
  513 |                 default -> throw new IllegalArgumentException("Unsupported provider: " + provider);
  514 |             };
  515 | 
  516 |             if (oauthId == null) {
  517 |                 log.error("idë¥¼ íŒŒì‹±í•˜ëŠ”ë° ë¬¸ì œê°€ ìƒê¸´ ê²ƒ ê°™ìŠµë‹ˆë‹¤ ã… ã… ");
  518 |             }
  519 | 
  520 |             // Redisì— refresh token ì €ì¥
  521 |             redisService.saveRToken(oauthId, provider, refreshToken);
  522 | 
  523 |             // Oauth2 ì‚¬ìš©ì í™•ì¸ í›„ ì €ì¥ ë˜ëŠ” ì—…ë°ì´íŠ¸ í•˜ê¸°
  524 |             users user = saveOrUpdateOauth2User(provider, oauthId, userProfile);
  525 | 
  526 |             // ì„œë²„ ìì²´ access_token ìƒì„±
  527 |             tokenDto accessToken = jwtUtility.buildToken(user.getUserId(), user.getNickname(), Collections.singletonList(new SimpleGrantedAuthority(user.getRole().name())));
  528 | 
  529 |             loginResponse(response, accessToken.getAccessToken(), refreshToken, provider);
  530 | 
  531 |             //return ResponseEntity.ok(userProfile);
  532 |             return ResponseEntity.ok(Map.of(
  533 |                     "access_token", accessToken.getAccessToken(),
  534 |                     "userProfile", userProfile
  535 |             ));
  536 | 
  537 |         } catch (HttpClientErrorException e){
  538 |             if (e.getStatusCode() == HttpStatus.BAD_REQUEST && e.getResponseBodyAsString().contains("invalid_grant")) {
  539 |                 log.error("{} ë¡œê·¸ì¸ ì‹¤íŒ¨ - ì¬ ì‚¬ìš©ëœ ì¸ì¦ ì½”ë“œ ì…ë‹ˆë‹¤. ", provider);
  540 |                 return ResponseEntity.status(HttpStatus.BAD_REQUEST).body("ì¬ì‚¬ìš©ëœ ì¸ì¦ ì½”ë“œì…ë‹ˆë‹¤.");
  541 |             }
  542 |             log.error("{} ë¡œê·¸ì¸ ì‹¤íŒ¨!", provider, e);
  543 |             return ResponseEntity.status(HttpStatus.INTERNAL_SERVER_ERROR).body(provider + "ë¡œê·¸ì¸ ì‹¤íŒ¨!");
  544 |         } catch (Exception e) {
  545 |             log.error("{} ë¡œê·¸ì¸ ì‹¤íŒ¨! ", provider, e);
  546 |             return ResponseEntity.status(HttpStatus.INTERNAL_SERVER_ERROR).body(provider + " ë¡œê·¸ì¸ ì‹¤íŒ¨!");
  547 |         }
  548 |     }
  549 | 
  550 | 
  551 |     private void loginResponse(HttpServletResponse response, String accessToken, String refreshToken, String provider) {
  552 |         Cookie newCookie = new Cookie(provider + "_refreshToken", refreshToken);
  553 |         newCookie.setHttpOnly(true);
  554 |         newCookie.setDomain(domain);
  555 |         newCookie.setPath("/");
  556 |         response.addCookie(newCookie);
  557 | 
  558 |         response.addHeader(SecurityConstants.TOKEN_HEADER, SecurityConstants.TOKEN_PREFIX + accessToken);
  559 |     }
  560 | 
  561 | 
  562 |     private Date parseBirthday(String birthday) {
  563 |         if (birthday != null && birthday.length() == 5) {
  564 |             try {
  565 |                 SimpleDateFormat sdf = new SimpleDateFormat("MM-dd");
  566 |                 Date date = sdf.parse(birthday);
  567 |                 return date;
  568 |             } catch (ParseException e) {
  569 |                 log.error("Error parsing birthday: ", e);
  570 |             }
  571 |         }
  572 |         return null; // Implement proper parsing if different format
  573 |     }
  574 | 
  575 | 
  576 |     private String generateRandomString(int length) {
  577 |         final String characters = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789";
  578 |         Random random = new SecureRandom();
  579 |         StringBuilder sb = new StringBuilder(length);
  580 | 
  581 |         for (int i = 0; i < length; i++) {
  582 |             sb.append(characters.charAt(random.nextInt(characters.length())));
  583 |         }
  584 | 
  585 |         return sb.toString();
  586 |     }
  587 | }

#--------------------------------------------------------------------------------


# File: backend/src/main/java/com/authentication/auth/service/smtp/emailService.java
#=============================================================================

    1 | package com.career_block.auth.service.smtp;
    2 | 
    3 | import lombok.RequiredArgsConstructor;
    4 | import lombok.extern.slf4j.Slf4j;
    5 | import org.springframework.beans.factory.annotation.Value;
    6 | import org.springframework.mail.javamail.JavaMailSender;
    7 | import org.springframework.mail.javamail.MimeMessageHelper;
    8 | import org.springframework.stereotype.Service;
    9 | import org.springframework.transaction.annotation.Transactional;
   10 | 
   11 | import com.authentication.auth.DTO.smtp.customEmailRequest;
   12 | import com.authentication.auth.DTO.smtp.customEmailToAllRequest;
   13 | import com.authentication.auth.repository.usersRepository;
   14 | 
   15 | import javax.mail.MessagingException;
   16 | import javax.mail.internet.MimeMessage;
   17 | import java.util.UUID;
   18 | 
   19 | @Slf4j
   20 | @Service
   21 | @RequiredArgsConstructor
   22 | public class emailService {
   23 | 
   24 |     @Value("${server.email.sender}")
   25 |     private String sender_email;
   26 |     private final usersRepository usersRepository;
   27 |     private final JavaMailSender mailSender;
   28 | 
   29 |     private String randomNum() {
   30 |         String rand = UUID.randomUUID().toString().replace("-", "");
   31 |         String result = "";
   32 |         for (int i = 0; i < 8; i++){
   33 |             result += rand.charAt(i);
   34 |         }
   35 |         return result;
   36 |     }
   37 | 
   38 | 
   39 |     public String joinEmail(String email){
   40 |         String rand = randomNum();
   41 |         String from_email = sender_email;
   42 |         String to_email = email;
   43 |         String title = "íšŒì› ê°€ì… ì¸ì¦ ì´ë©”ì¼ ì…ë‹ˆë‹¤.";
   44 | 
   45 |         // HTML ì´ë©”ì¼ ì»¨í…ì¸ 
   46 |         String content =
   47 |                 "<div style=\"font-family: Arial, sans-serif; max-width: 600px; margin: 0 auto; padding: 30px; border: 1px solid #e0e0e0; border-radius: 8px; background-color: #ffffff; box-shadow: 0 4px 8px rgba(0, 0, 0, 0.05);\">\n" +
   48 |                         "    <h2 style=\"color: #4c5baf; text-align: center; margin-bottom: 20px;\">\uD83C\uDF89 Career Block ì— ì˜¤ì‹  ê²ƒì„ í™˜ì˜í•©ë‹ˆë‹¤!</h2>\n" +
   49 |                         "\n" +
   50 |                         "    <p style=\"font-size: 16px; color: #333333; line-height: 1.6; margin-bottom: 20px;\">\n" +
   51 |                         "        ê°€ì…í•´ì£¼ì…”ì„œ ì§„ì‹¬ìœ¼ë¡œ ê°ì‚¬í•©ë‹ˆë‹¤! ì•„ë˜ì˜ ì´ë©”ì¼ ì¸ì¦ ì½”ë“œë¥¼ ì‚¬ìš©í•˜ì—¬ ê°€ì…ì„ ì™„ë£Œí•´ì£¼ì„¸ìš”.\n" +
   52 |                         "    </p>\n" +
   53 |                         "\n" +
   54 |                         "    <div style=\"text-align: center; margin: 30px 0;\">\n" +
   55 |                         "        <span style=\"display: inline-block; font-size: 28px; font-weight: bold; color: #4c5baf; padding: 15px 30px; border: 2px dashed #4c5baf; border-radius: 5px; background-color: #f0f4ff;\">\n" +
   56 |                         "            " + rand + "\n" +
   57 |                         "        </span>\n" +
   58 |                         "    </div>\n" +
   59 |                         "\n" +
   60 |                         "    <p style=\"font-size: 16px; color: #333333; line-height: 1.6;\">\n" +
   61 |                         "        ìœ„ ì½”ë“œë¥¼ ì¸ì¦ í˜ì´ì§€ì— ì…ë ¥í•˜ì—¬ ê°€ì…ì„ ì™„ë£Œí•´ì£¼ì„¸ìš”. ì´ ì½”ë“œì˜ ìœ íš¨ ì‹œê°„ì€ 30ë¶„ ì…ë‹ˆë‹¤.\n" +
   62 |                         "    </p>\n" +
   63 |                         "\n" +
   64 |                         "    <p style=\"font-size: 14px; color: #666666; line-height: 1.6; margin-top: 30px;\">\n" +
   65 |                         "        ë§Œì•½ Career Block ê°€ì…ì„ ì‹œë„í•˜ì§€ ì•Šì•˜ë‹¤ë©´, ì´ ë©”ì‹œì§€ë¥¼ ë¬´ì‹œí•´ ì£¼ì„¸ìš”.\n" +
   66 |                         "    </p>\n" +
   67 |                         "\n" +
   68 |                         "    <hr style=\"border-top: 1px solid #e0e0e0; margin-top: 40px; margin-bottom: 20px;\">\n" +
   69 |                         "\n" +
   70 |                         "    <p style=\"text-align: center; font-size: 12px; color: #999999;\">\n" +
   71 |                         "        Â© 2024 Career Block. All rights reserved.\n" +
   72 |                         "    </p>\n" +
   73 |                         "</div>\n";
   74 | 
   75 |         mailSend(from_email, to_email, title, content);
   76 |         return rand;
   77 |     }
   78 | 
   79 | 
   80 |     public String changePwEmail(String email){
   81 |         String rand = randomNum();
   82 |         String from_email = sender_email;
   83 |         String to_email = email;
   84 |         String title = "ë¹„ë°€ë²ˆí˜¸ ë³€ê²½ ì´ë©”ì¼ì…ë‹ˆë‹¤.";
   85 |         String content =
   86 |                 "<!DOCTYPE html>" +
   87 |                         "<html>" +
   88 |                         "    <head>" +
   89 |                         "        <meta charset='UTF-8'>" +
   90 |                         "        <title>ë¹„ë°€ë²ˆí˜¸ ë³€ê²½ ì•ˆë‚´</title>" +
   91 |                         "        <style>" +
   92 |                         "            body { font-family: Arial, sans-serif; margin: 0; padding: 20px; background-color: #f6f6f6; }" +
   93 |                         "            .container { background-color: #ffffff; padding: 40px; border-radius: 10px; box-shadow: 0 2px 4px rgba(0, 0, 0, 0.1); }" +
   94 |                         "            h1 { color: #333333; }" +
   95 |                         "            p { color: #666666; }" +
   96 |                         "            .button { display: inline-block; padding: 10px 20px; color: #ffffff; background-color: #007bff; text-decoration: none; border-radius: 5px; }" +
   97 |                         "        </style>" +
   98 |                         "    </head>" +
   99 |                         "    <body>" +
  100 |                         "        <div class='container'>" +
  101 |                         "            <h1>ë¹„ë°€ë²ˆí˜¸ ë³€ê²½ ì•ˆë‚´</h1>" +
  102 |                         "            <p>ë¹„ë°€ë²ˆí˜¸ë¥¼ ìŠì–´ë²„ë¦¬ì…¨êµ°ìš”!</p>" +
  103 |                         "            <p>ì•„ë˜ì˜ ì„ì‹œ ë¹„ë°€ë²ˆí˜¸ë¥¼ ì‚¬ìš©í•˜ì—¬ ë¹„ë°€ë²ˆí˜¸ë¥¼ ë³€ê²½í•˜ì„¸ìš”:</p>" +
  104 |                         "            <h2>" + rand + "</h2>" +
  105 |                         "            <p><a href='gcp.nodove.com' class='button'>ë¹„ë°€ë²ˆí˜¸ ë³€ê²½í•˜ê¸°</a></p>" +
  106 |                         "        </div>" +
  107 |                         "    </body>" +
  108 |                         "</html>";
  109 |         mailSend(from_email, to_email, title, content);
  110 |         return rand;
  111 |     }
  112 | 
  113 | 
  114 | 
  115 | 
  116 |     public void mailSend(String from_email, String to_email, String title, String content) {
  117 |         MimeMessage message = mailSender.createMimeMessage();
  118 |         try {
  119 |             MimeMessageHelper helper = new MimeMessageHelper(message, true, "utf-8");
  120 |             helper.setFrom(from_email);
  121 |             helper.setTo(to_email);
  122 |             helper.setSubject(title);
  123 |             helper.setText(content, true);
  124 |             mailSender.send(message);
  125 | 
  126 |         } catch(MessagingException e){
  127 |             log.error("messagingException", e);
  128 |         }
  129 |     }
  130 | 
  131 |     @Transactional
  132 |     public void sendCustomEmail(customEmailRequest request) {
  133 |         try {
  134 |             String from_email = sender_email;
  135 |             String to_email = request.getEmail();
  136 |             String title = request.getTitle();
  137 |             String content = request.getContent();
  138 |             mailSend(from_email, to_email, title, content);
  139 |         } catch (Exception e) {
  140 |             log.error("message send Exception : ", e);
  141 |         }
  142 |     }
  143 | 
  144 |     @Transactional
  145 |     public void sendCustomEmailToAll(customEmailToAllRequest request) {
  146 | 
  147 |     }
  148 | 
  149 |     public boolean checkIsExistEmail(String userEmail){
  150 |         return usersRepository.existsByEmail(userEmail);
  151 |     }
  152 | 
  153 | }

#--------------------------------------------------------------------------------


# File: backend/src/main/java/com/authentication/auth/service/security/principalDetailService.java
#=============================================================================

    1 | package com.career_block.auth.service.security;
    2 | 
    3 | import lombok.RequiredArgsConstructor;
    4 | import lombok.extern.slf4j.Slf4j;
    5 | import org.springframework.security.core.userdetails.UserDetails;
    6 | import org.springframework.security.core.userdetails.UserDetailsService;
    7 | import org.springframework.security.core.userdetails.UsernameNotFoundException;
    8 | import org.springframework.stereotype.Service;
    9 | 
   10 | import com.authentication.auth.DTO.token.principalDetails;
   11 | import com.authentication.auth.domain.users;
   12 | import com.authentication.auth.repository.usersRepository;
   13 | 
   14 | @Slf4j
   15 | @Service
   16 | @RequiredArgsConstructor
   17 | public class principalDetailService implements UserDetailsService {
   18 | 
   19 |     private final usersRepository repository;
   20 | 
   21 |     @Override
   22 |     public UserDetails loadUserByUsername(String username) throws UsernameNotFoundException {
   23 |         users user = repository.findByUserId(username);
   24 |         return new principalDetails(user);
   25 |     }
   26 | }

#--------------------------------------------------------------------------------


# File: backend/src/main/java/com/authentication/auth/service/token/tokenService.java
#=============================================================================

    1 | package com.career_block.auth.service.token;
    2 | 
    3 | import jakarta.servlet.http.HttpServletRequest;
    4 | import jakarta.servlet.http.HttpServletResponse;
    5 | import lombok.RequiredArgsConstructor;
    6 | import lombok.extern.slf4j.Slf4j;
    7 | import org.springframework.http.HttpStatus;
    8 | import org.springframework.http.ResponseEntity;
    9 | import org.springframework.stereotype.Service;
   10 | import org.springframework.transaction.annotation.Transactional;
   11 | 
   12 | import com.authentication.auth.DTO.token.tokenRefreshRequest;
   13 | import com.authentication.auth.configuration.token.jwtUtility;
   14 | import com.authentication.auth.service.redis.redisService;
   15 | 
   16 | import java.io.IOException;
   17 | 
   18 | @Slf4j
   19 | @Service
   20 | @RequiredArgsConstructor
   21 | public class tokenService {
   22 | 
   23 | 
   24 |     private final jwtUtility jwtUtility;
   25 |     private final redisService redisService;
   26 | 
   27 |     @Transactional
   28 |     public ResponseEntity<?> refreshToken(HttpServletRequest httpRequest, HttpServletResponse httpResponse, tokenRefreshRequest request) throws IOException {
   29 | 
   30 |         String expiredToken = request.getExpiredToken();
   31 |         String provider = request.getProvider();
   32 | 
   33 |         if (jwtUtility.validateJWT(expiredToken)) {
   34 |             // token ê°±ì‹ 
   35 |             String newToken = jwtUtility.refreshToken(expiredToken);
   36 | 
   37 |             // Redisì— ê°±ì‹ ëœ í† í° ì €ì¥
   38 |             String userId = jwtUtility.getUserIdFromToken(newToken);
   39 | 
   40 |             String RToken = jwtUtility.checkCookie(httpRequest, httpResponse, provider);
   41 |             if(!redisService.isRTokenExist(userId, provider, RToken)){
   42 |                 return ResponseEntity.status(HttpStatus.NOT_ACCEPTABLE).body("There is no refresh token in REDIS");
   43 |             }
   44 | 
   45 |             return ResponseEntity.status(HttpStatus.OK).body(newToken);
   46 |         } else {
   47 |             return ResponseEntity.status(HttpStatus.NOT_ACCEPTABLE).body("not a valid token");
   48 |         }
   49 |     }
   50 | }

#--------------------------------------------------------------------------------


# File: backend/src/main/java/com/authentication/auth/service/redis/redisService.java
#=============================================================================

    1 | package com.career_block.auth.service.redis;
    2 | 
    3 | import lombok.RequiredArgsConstructor;
    4 | import lombok.extern.slf4j.Slf4j;
    5 | import org.springframework.beans.factory.annotation.Value;
    6 | import org.springframework.data.redis.core.RedisTemplate;
    7 | import org.springframework.stereotype.Component;
    8 | import org.springframework.transaction.annotation.Transactional;
    9 | import org.springframework.web.servlet.mvc.method.annotation.SseEmitter;
   10 | 
   11 | import java.util.Collections;
   12 | import java.util.List;
   13 | import java.util.Objects;
   14 | import java.util.Set;
   15 | import java.util.concurrent.TimeUnit;
   16 | 
   17 | @Slf4j
   18 | @RequiredArgsConstructor
   19 | @Component
   20 | public class redisService {
   21 | 
   22 |     @Value("${REFRESH_TOKEN_VALIDITY}")
   23 |     private long refreshExpire;
   24 | 
   25 |     @Value("${ACCESS_TOKEN_VALIDITY}")
   26 |     private long accessExpire;
   27 | 
   28 |     private final RedisTemplate<String, String> redisTemplate;
   29 | 
   30 | 
   31 |     private String RefreshTokenToRedisKey(String userId, String provider, String RToken) {
   32 |         if (userId == null || provider == null || RToken == null ||
   33 |                 userId.isEmpty() || provider.isEmpty() || RToken.isEmpty()) {
   34 |             throw new RuntimeException("error while convert Refresh Token into REDIS_KEY..");
   35 |         }
   36 |         return provider + "_RToken_" + userId;
   37 |     }
   38 | 
   39 |     private String AccessTokenToRedisKey(String RToken) {
   40 |         if (RToken == null || RToken.isEmpty()){
   41 |             throw new RuntimeException("error while convert access Token into REDIS_KEY..");
   42 |         }
   43 |         return "_accessToken_" + RToken.substring(10);
   44 |     }
   45 | 
   46 |     @Transactional
   47 |     public boolean saveRToken(String userId, String provider, String RToken) {
   48 |         String REDIS_KEY = RefreshTokenToRedisKey(userId, provider, RToken);
   49 |         try {
   50 |             redisTemplate.opsForValue().set(REDIS_KEY, RToken, refreshExpire, TimeUnit.SECONDS);
   51 |             log.info("Redis RToken save success for provider: {}", provider);
   52 |             return true;
   53 |         } catch (Exception e) {
   54 |             log.error("Redis has failed to save Refresh Token for provider {} and for userId {}", provider, userId, e);
   55 |             return false;
   56 |         }
   57 |     }
   58 | 
   59 |     @Transactional
   60 |     public boolean saveAccessToken(String RToken, String accessToken, String userId) {
   61 |         String REDIS_KEY = AccessTokenToRedisKey(RToken);
   62 |         try {
   63 |             redisTemplate.opsForValue().set(REDIS_KEY, accessToken, accessExpire, TimeUnit.SECONDS);
   64 |             return true;
   65 |         } catch (Exception e) {
   66 |             log.error("Redis has failed to save Access Token for userId {}", userId);
   67 |             return false;
   68 |         }
   69 |     }
   70 | 
   71 |     @Transactional
   72 |     public String getAccessToken(String RToken) {
   73 |         String REDIS_KEY = AccessTokenToRedisKey(RToken);
   74 |         try {
   75 |             String accessToken = redisTemplate.opsForValue().get(REDIS_KEY);
   76 | 
   77 |             if (accessToken == null) {
   78 |                 log.warn("No access Token INFO");
   79 |                 return null;
   80 |             }
   81 | 
   82 |             return accessToken;
   83 |         } catch (Exception e) {
   84 |             log.error("Failed to get AccessToken INFO from REDIS");
   85 |             return null;
   86 |         }
   87 |     }
   88 | 
   89 |     @Transactional
   90 |     public boolean isRTokenExist(String userId, String provider, String RToken) {
   91 |         String REDIS_KEY = RefreshTokenToRedisKey(userId, provider, RToken);
   92 |         try {
   93 |             Boolean exists = redisTemplate.hasKey(REDIS_KEY);
   94 |             return exists != null && exists;
   95 |         } catch (Exception e) {
   96 |             log.error("REDIS key searching failed for provider: {}", provider, e);
   97 |             return false;
   98 |         }
   99 |     }
  100 | 
  101 | 
  102 |     @Transactional
  103 |     public boolean deleteRToken(String userId, String provider, String RToken) {
  104 |         String REDIS_KEY = RefreshTokenToRedisKey(userId, provider, RToken);
  105 |         try {
  106 |             Boolean removed = redisTemplate.delete(REDIS_KEY);
  107 |             return removed != null && removed;
  108 |         } catch (Exception e) {
  109 |             log.error("Failed to delete RToken for provider: {}", provider, e);
  110 |             return false;
  111 |         }
  112 |     }
  113 | 
  114 | 
  115 |     @Transactional
  116 |     public List<String> getAllRTokens(String userId, String provider) {
  117 |         String pattern = provider + "_RToken_" + userId + "_";
  118 |         Set<String> keys = redisTemplate.keys(pattern);
  119 |         if (keys == null || keys.isEmpty()){
  120 |             return Collections.emptyList();
  121 |         }
  122 |         return redisTemplate.opsForValue().multiGet(keys);
  123 |     }
  124 | 
  125 | 
  126 |     @Transactional
  127 |     public boolean changeRToken(String userId, String provider, String RToken, String newRToken) {
  128 |         try {
  129 |             deleteRToken(userId, provider, RToken);
  130 |             saveRToken(userId, provider, newRToken);
  131 |             log.info("{}'s RToken has been changed for provider: {}", userId, provider);
  132 |             return true;
  133 |         } catch (Exception e) {
  134 |             log.error("Failed to change RToken for provider: {}", provider, e);
  135 |             return false;
  136 |         }
  137 |     }
  138 | 
  139 | 
  140 |     @Transactional
  141 |     public boolean saveEmailCode(String email, String code) {
  142 |         if (email == null || email.isEmpty() || code == null || code.isEmpty()){
  143 |             log.error("essential parameter or parameters is null");
  144 |             return false;
  145 |         }
  146 |         try {
  147 |             redisTemplate.opsForValue().set(email, code, 1800, TimeUnit.SECONDS);
  148 |             return true;
  149 |         } catch (Exception e) {
  150 |             log.error("Failed to save email code for email: {}", email);
  151 |             return false;
  152 |         }
  153 |     }
  154 | 
  155 | 
  156 |     @Transactional(readOnly = true)
  157 |     public boolean checkEmailCode(String email, String code) {
  158 |         if (email == null || email.isEmpty() || code == null || code.isEmpty()){
  159 |             log.error("essential parameter or parameters is null");
  160 |             return false;
  161 |         }
  162 |         try {
  163 |             return (Objects.equals(code, redisTemplate.opsForValue().get(email)));
  164 |         } catch (Exception e) {
  165 |             log.error("Failed to check Email Code for email : {}", email);
  166 |             return false;
  167 |         }
  168 |     }
  169 | 
  170 |     @Transactional
  171 |     public boolean findRToken(String userId, String provider, String RToken) {
  172 |         try {
  173 |             String key = RefreshTokenToRedisKey(userId, provider, RToken);
  174 |             return Boolean.TRUE.equals(redisTemplate.opsForSet().isMember(key, RToken));
  175 |         } catch (Exception e) {
  176 |             log.error("redis key search failed", e);
  177 |             return false;
  178 |         }
  179 |     }
  180 | 
  181 | 
  182 | }

#--------------------------------------------------------------------------------


# File: backend/build.gradle
#=============================================================================

    1 | plugins {
    2 | 	id 'java'
    3 | 	id 'org.springframework.boot' version '3.2.4'
    4 | 	id 'io.spring.dependency-management' version '1.1.4'
    5 | }
    6 | 
    7 | group = 'com.authentication'
    8 | version = '0.0.1-SNAPSHOT'
    9 | 
   10 | java {
   11 | 	toolchain {
   12 | 		languageVersion = JavaLanguageVersion.of(21)
   13 | 	}
   14 | }
   15 | 
   16 | configurations {
   17 | 	compileOnly {
   18 | 		extendsFrom annotationProcessor
   19 | 	}
   20 | }
   21 | 
   22 | repositories {
   23 | 	mavenCentral()
   24 | }
   25 | 
   26 | dependencies {
   27 | 	implementation 'org.springframework.boot:spring-boot-starter-data-jpa'
   28 | 	implementation 'org.springframework.boot:spring-boot-starter-security'
   29 | 	implementation 'org.springframework.boot:spring-boot-starter-web'
   30 | 	implementation 'org.apache.commons:commons-lang3:3.12.0'
   31 | 	implementation 'org.springframework.boot:spring-boot-starter-data-redis'
   32 | 	implementation group: 'commons-io', name: 'commons-io', version: '2.15.1'
   33 | 	implementation 'org.springframework.boot:spring-boot-starter-validation'
   34 | 	implementation 'javax.mail:mail:1.4.7'
   35 | 	implementation 'org.springframework:spring-context-support:5.3.9'
   36 | 	implementation 'org.springdoc:springdoc-openapi-starter-webmvc-ui:2.2.0'
   37 | 	compileOnly group: 'io.jsonwebtoken', name: 'jjwt-api', version: '0.11.2'
   38 | 	runtimeOnly group: 'io.jsonwebtoken', name: 'jjwt-impl', version: '0.11.2'
   39 | 	runtimeOnly group: 'io.jsonwebtoken', name: 'jjwt-jackson', version: '0.11.2'
   40 | 	compileOnly 'org.projectlombok:lombok'
   41 | 	runtimeOnly 'org.mariadb.jdbc:mariadb-java-client'
   42 | 	annotationProcessor 'org.projectlombok:lombok'
   43 | 	testImplementation 'org.springframework.boot:spring-boot-starter-test'
   44 | 	testImplementation 'org.springframework.security:spring-security-test'
   45 | 	implementation 'com.github.ulisesbocchio:jasypt-spring-boot-starter:3.0.5'
   46 | 	implementation 'org.springframework.boot:spring-boot-starter-oauth2-client:3.3.0'
   47 | 	implementation 'org.apache.commons:commons-text:1.3'
   48 | 	implementation 'org.springframework.boot:spring-boot-starter-data-elasticsearch'
   49 | 	implementation 'org.springframework.boot:spring-boot-starter-data-mongodb'
   50 | 	implementation 'com.corundumstudio.socketio:netty-socketio:2.0.3'
   51 | }
   52 | 
   53 | tasks.named('test') {
   54 | 	useJUnitPlatform()
   55 | }

#--------------------------------------------------------------------------------


# File: .gitignore
#=============================================================================

    1 | HELP.md
    2 | .gradle
    3 | build/
    4 | !gradle/wrapper/gradle-wrapper.jar
    5 | !**/src/main/**/build/
    6 | !**/src/test/**/build/
    7 | 
    8 | ### STS ###
    9 | .apt_generated
   10 | .classpath
   11 | .factorypath
   12 | .project
   13 | .settings
   14 | .springBeans
   15 | .sts4-cache
   16 | bin/
   17 | !**/src/main/**/bin/
   18 | !**/src/test/**/bin/
   19 | 
   20 | ### IntelliJ IDEA ###
   21 | .idea
   22 | *.iws
   23 | *.iml
   24 | *.ipr
   25 | out/
   26 | !**/src/main/**/out/
   27 | !**/src/test/**/out/
   28 | 
   29 | ### NetBeans ###
   30 | /nbproject/private/
   31 | /nbbuild/
   32 | /dist/
   33 | /nbdist/
   34 | /.nb-gradle/
   35 | 
   36 | ### VS Code ###
   37 | .vscode/

#--------------------------------------------------------------------------------


# File: file_concat/main.go
#=============================================================================

    1 | package main
    2 | 
    3 | import (
    4 | 	"bufio"
    5 | 	"flag"
    6 | 	"fmt"
    7 | 	"io"
    8 | 	"os"
    9 | 	"path/filepath"
   10 | 	"strings"
   11 | )
   12 | 
   13 | func main() {
   14 | 	// ëª…ë ¹ì¤„ í”Œë˜ê·¸ ì •ì˜
   15 | 	var (
   16 | 		startDir   = flag.String("d", ".", "ê²€ìƒ‰ ì‹œì‘ ë””ë ‰í† ë¦¬ ì§€ì • (ê¸°ë³¸ê°’: í˜„ì¬ ë””ë ‰í† ë¦¬)")
   17 | 		outputFile = flag.String("o", "merged_source_files.txt", "ì¶œë ¥ íŒŒì¼ ì§€ì • (ê¸°ë³¸ê°’: merged_source_files.txt)")
   18 | 		helpFlag   = flag.Bool("h", false, "ë„ì›€ë§ í‘œì‹œ")
   19 | 	)
   20 | 
   21 | 	// ê¸´ í˜•ì‹ì˜ í”Œë˜ê·¸ ë³„ì¹­ ì¶”ê°€
   22 | 	flag.StringVar(startDir, "directory", ".", "ê²€ìƒ‰ ì‹œì‘ ë””ë ‰í† ë¦¬ ì§€ì • (ê¸°ë³¸ê°’: í˜„ì¬ ë””ë ‰í† ë¦¬)")
   23 | 	flag.StringVar(outputFile, "output", "merged_source_files.txt", "ì¶œë ¥ íŒŒì¼ ì§€ì • (ê¸°ë³¸ê°’: merged_source_files.txt)")
   24 | 	flag.BoolVar(helpFlag, "help", false, "ë„ì›€ë§ í‘œì‹œ")
   25 | 
   26 | 	// ì‚¬ìš©ë²• ë©”ì‹œì§€ ì„¤ì •
   27 | 	flag.Usage = func() {
   28 | 		fmt.Fprintf(os.Stderr, "ì‚¬ìš©ë²•: %s [ì˜µì…˜]\n", os.Args[0])
   29 | 		fmt.Fprintln(os.Stderr, "ì˜µì…˜:")
   30 | 		fmt.Fprintln(os.Stderr, "  -d, --directory DIR  ê²€ìƒ‰ ì‹œì‘ ë””ë ‰í† ë¦¬ ì§€ì • (ê¸°ë³¸ê°’: í˜„ì¬ ë””ë ‰í† ë¦¬)")
   31 | 		fmt.Fprintln(os.Stderr, "  -o, --output FILE    ì¶œë ¥ íŒŒì¼ ì§€ì • (ê¸°ë³¸ê°’: merged_source_files.txt)")
   32 | 		fmt.Fprintln(os.Stderr, "  -h, --help           ë„ì›€ë§ í‘œì‹œ")
   33 | 	}
   34 | 
   35 | 	// í”Œë˜ê·¸ íŒŒì‹±
   36 | 	flag.Parse()
   37 | 
   38 | 	// ë„ì›€ë§ í‘œì‹œ
   39 | 	if *helpFlag {
   40 | 		flag.Usage()
   41 | 		os.Exit(0)
   42 | 	}
   43 | 
   44 | 	// ì‹œì‘ ë””ë ‰í† ë¦¬ ìœ íš¨ì„± ê²€ì‚¬
   45 | 	dirInfo, err := os.Stat(*startDir)
   46 | 	if err != nil || !dirInfo.IsDir() {
   47 | 		fmt.Fprintf(os.Stderr, "ì˜¤ë¥˜: ë””ë ‰í† ë¦¬ '%s'ê°€ ì¡´ì¬í•˜ì§€ ì•ŠìŠµë‹ˆë‹¤.\n", *startDir)
   48 | 		os.Exit(1)
   49 | 	}
   50 | 
   51 | 	// ì¶œë ¥ íŒŒì¼ ìƒì„±
   52 | 	outFile, err := os.Create(*outputFile)
   53 | 	if err != nil {
   54 | 		fmt.Fprintf(os.Stderr, "ì˜¤ë¥˜: ì¶œë ¥ íŒŒì¼ '%s'ì„ ìƒì„±í•  ìˆ˜ ì—†ìŠµë‹ˆë‹¤: %v\n", *outputFile, err)
   55 | 		os.Exit(1)
   56 | 	}
   57 | 	defer outFile.Close()
   58 | 
   59 | 	// ë²„í¼ ë¼ì´í„° ìƒì„± (ì„±ëŠ¥ í–¥ìƒ)
   60 | 	writer := bufio.NewWriter(outFile)
   61 | 	defer writer.Flush()
   62 | 
   63 | 	fmt.Printf("ë””ë ‰í† ë¦¬ '%s'ì—ì„œ .h ë° .cpp íŒŒì¼ì„ ê²€ìƒ‰í•˜ì—¬ '%s'ì— ë³‘í•©í•©ë‹ˆë‹¤...\n", *startDir, *outputFile)
   64 | 
   65 | 	// íŒŒì¼ ì¹´ìš´í„° ì´ˆê¸°í™”
   66 | 	fileCount := 0
   67 | 
   68 | 	// ë””ë ‰í† ë¦¬ íƒìƒ‰ ë° íŒŒì¼ ì²˜ë¦¬
   69 | 	err = filepath.Walk(*startDir, func(path string, info os.FileInfo, err error) error {
   70 | 		if err != nil {
   71 | 			fmt.Fprintf(os.Stderr, "ë””ë ‰í† ë¦¬ íƒìƒ‰ ì¤‘ ì˜¤ë¥˜ ë°œìƒ: %v\n", err)
   72 | 			return err
   73 | 		}
   74 | 
   75 | 		// íŒŒì¼ì´ë©° í™•ì¥ìê°€ .h ë˜ëŠ” .cppì¸ ê²½ìš°ì—ë§Œ ì²˜ë¦¬
   76 | 		if !info.IsDir() && (strings.HasSuffix(path, ".h") || strings.HasSuffix(path, ".cpp")) {
   77 | 			fileCount++
   78 | 
   79 | 			// ì§„í–‰ ìƒí™© í‘œì‹œ
   80 | 			fmt.Printf("ì²˜ë¦¬ ì¤‘: %s\n", path)
   81 | 
   82 | 			// íŒŒì¼ êµ¬ë¶„ì ì¶”ê°€
   83 | 			fmt.Fprintf(writer, "\n\n===== %s =====\n\n", path)
   84 | 
   85 | 			// íŒŒì¼ ë‚´ìš©ì„ ê²°ê³¼ íŒŒì¼ì— ì¶”ê°€
   86 | 			if err := appendFileContent(path, writer); err != nil {
   87 | 				fmt.Fprintf(os.Stderr, "íŒŒì¼ '%s' ì²˜ë¦¬ ì¤‘ ì˜¤ë¥˜ ë°œìƒ: %v\n", path, err)
   88 | 				// ì˜¤ë¥˜ê°€ ìˆë”ë¼ë„ ê³„ì† ì§„í–‰
   89 | 			}
   90 | 		}
   91 | 		return nil
   92 | 	})
   93 | 
   94 | 	if err != nil {
   95 | 		fmt.Fprintf(os.Stderr, "íŒŒì¼ íƒìƒ‰ ì¤‘ ì˜¤ë¥˜ ë°œìƒ: %v\n", err)
   96 | 		os.Exit(1)
   97 | 	}
   98 | 
   99 | 	fmt.Printf("ì™„ë£Œ: %dê°œì˜ íŒŒì¼ì´ '%s'ì— ë³‘í•©ë˜ì—ˆìŠµë‹ˆë‹¤.\n", fileCount, *outputFile)
  100 | }
  101 | 
  102 | // appendFileContent í•¨ìˆ˜ëŠ” ì†ŒìŠ¤ íŒŒì¼ì˜ ë‚´ìš©ì„ writerì— ì¶”ê°€í•©ë‹ˆë‹¤.
  103 | func appendFileContent(filepath string, writer *bufio.Writer) error {
  104 | 	srcFile, err := os.Open(filepath)
  105 | 	if err != nil {
  106 | 		return fmt.Errorf("íŒŒì¼ ì—´ê¸° ì˜¤ë¥˜: %w", err)
  107 | 	}
  108 | 	defer srcFile.Close()
  109 | 
  110 | 	// ë²„í¼ ë¦¬ë” ìƒì„± (ì„±ëŠ¥ í–¥ìƒ)
  111 | 	reader := bufio.NewReader(srcFile)
  112 | 
  113 | 	// íŒŒì¼ ë‚´ìš©ì„ ê²°ê³¼ íŒŒì¼ì— ë³µì‚¬
  114 | 	_, err = io.Copy(writer, reader)
  115 | 	if err != nil {
  116 | 		return fmt.Errorf("íŒŒì¼ ë³µì‚¬ ì˜¤ë¥˜: %w", err)
  117 | 	}
  118 | 
  119 | 	return nil
  120 | }

#--------------------------------------------------------------------------------

[0;32mIncluded content from 103 essential file(s).[0m

========================================
End of Report
========================================
