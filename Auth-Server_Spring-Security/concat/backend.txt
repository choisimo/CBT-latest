// 파일: backend/src/main/java/com/authentication/auth/AuthApplication.java
package com.authentication.auth;

import jakarta.annotation.PostConstruct;
import org.springframework.boot.SpringApplication;
import org.springframework.boot.autoconfigure.SpringBootApplication;
import org.springframework.data.mongodb.repository.config.EnableMongoRepositories;

import java.util.TimeZone;

@SpringBootApplication
@EnableMongoRepositories
public class AuthApplication {

	public static void main(String[] args) {
		SpringApplication.run(AuthApplication.class, args);
	}


	@PostConstruct
	void set_time_zone() {
		TimeZone.setDefault(TimeZone.getTimeZone("Asia/Seoul"));
	}
}


// ===================================

// 파일: backend/src/main/java/com/authentication/auth/config/SecurityFilterConfig.java
/**
 * 보안 필터 설정 클래스
 * 필터의 등록 및 순서 설정을 담당
 */
    /**
     * 인증 필터 등록
     */
    /**
     * 권한 필터 등록
     */
package com.authentication.auth.config;

import com.authentication.auth.filter.AuthenticationFilter;
import com.authentication.auth.filter.AuthorizationFilter;
import com.authentication.auth.filter.SnsRequestFilter;
import lombok.RequiredArgsConstructor;
import org.springframework.boot.web.servlet.FilterRegistrationBean;
import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;

/**
 * 보안 필터 설정 클래스
 * 필터의 등록 및 순서 설정을 담당
 */
@Configuration
@RequiredArgsConstructor
public class SecurityFilterConfig {

    private final AuthenticationFilter authenticationFilter;
    private final AuthorizationFilter authorizationFilter;
    private final SnsRequestFilter snsRequestFilter;

    /**
     * 인증 필터 등록
     */
    @Bean
    public FilterRegistrationBean<AuthenticationFilter> authenticationFilterRegistration() {
        FilterRegistrationBean<AuthenticationFilter> registrationBean = new FilterRegistrationBean<>();
        registrationBean.setFilter(authenticationFilter);
        registrationBean.addUrlPatterns("/*");
        registrationBean.setOrder(authenticationFilter.getOrder());
        registrationBean.setName("authenticationFilter");
        return registrationBean;
    }

    /**
     * 권한 필터 등록
     */
    @Bean
    public FilterRegistrationBean<AuthorizationFilter> authorizationFilterRegistration() {
        FilterRegistrationBean<AuthorizationFilter> registrationBean = new FilterRegistrationBean<>();
        registrationBean.setFilter(authorizationFilter);
        registrationBean.addUrlPatterns("/*");
        registrationBean.setOrder(authorizationFilter.getOrder());
        registrationBean.setName("authorizationFilter");
        return registrationBean;
    }

    /**
     * SNS 요청 필터 등록
     */
    @Bean
    public FilterRegistrationBean<SnsRequestFilter> snsRequestFilterRegistration() {
        FilterRegistrationBean<SnsRequestFilter> registrationBean = new FilterRegistrationBean<>();
        registrationBean.setFilter(snsRequestFilter);
        registrationBean.addUrlPatterns("/*");
        registrationBean.setOrder(snsRequestFilter.getOrder());
        registrationBean.setName("snsRequestFilter");
        return registrationBean;
    }
}


// ===================================

// 파일: backend/src/main/java/com/authentication/auth/configuration/redis/redisConfig.java
package com.authentication.auth.configuration.redis;

import org.springframework.beans.factory.annotation.Value;
import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;
import org.springframework.data.redis.connection.RedisConnectionFactory;
import org.springframework.data.redis.connection.RedisStandaloneConfiguration;
import org.springframework.data.redis.connection.lettuce.LettuceConnectionFactory;
import org.springframework.data.redis.core.RedisTemplate;
import org.springframework.data.redis.serializer.StringRedisSerializer;

@Configuration
public class redisConfig {

    @Value("${spring.data.redis.host}")
    private String host;

    @Value("${spring.data.redis.port}")
    private int port;

    @Value("${spring.data.redis.password}")
    private String password;


    @Bean
    public RedisConnectionFactory redisConnectionFactory() {
        RedisStandaloneConfiguration redisStandaloneConfiguration = new RedisStandaloneConfiguration();
        redisStandaloneConfiguration.setHostName(host);
        redisStandaloneConfiguration.setPort(port);
        redisStandaloneConfiguration.setPassword(password);
        return new LettuceConnectionFactory(redisStandaloneConfiguration);
    }


    @Bean
    public RedisTemplate<?, ?> redisTemplate() {
        RedisTemplate<?, ?> redisTemplate = new RedisTemplate<>();
        redisTemplate.setKeySerializer(new StringRedisSerializer());
        redisTemplate.setValueSerializer(new StringRedisSerializer());
        redisTemplate.setConnectionFactory(redisConnectionFactory());
        return redisTemplate;
    }
}


// ===================================

// 파일: backend/src/main/java/com/authentication/auth/configuration/resource/webMvcConfig.java
package com.authentication.auth.configuration.resource;

import org.springframework.context.annotation.Configuration;

@Configuration
public class webMvcConfig {


}


// ===================================

// 파일: backend/src/main/java/com/authentication/auth/configuration/SecurityConfig.java
/**
 * @Author: choisimo
 * @Date: 2025-05-05
 * @Description: Spring Security 구성 클래스
 * @Details: 보안 필터 체인 및 인증/인가 설정을 관리
 */
                .requestMatchers("/auth/**", "/login", "/signup", "/public/**").permitAll()
                .anyRequest().authenticated();
        
        // 플러그형 필터 등록
package com.authentication.auth.configuration;

import com.authentication.auth.filter.filterRegistry;
import lombok.RequiredArgsConstructor;
import lombok.extern.slf4j.Slf4j;
import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;
import org.springframework.security.config.annotation.web.builders.HttpSecurity;
import org.springframework.security.config.annotation.web.configuration.EnableWebSecurity;
import org.springframework.security.config.http.SessionCreationPolicy;
import org.springframework.security.web.SecurityFilterChain;

/**
 * @Author: choisimo
 * @Date: 2025-05-05
 * @Description: Spring Security 구성 클래스
 * @Details: 보안 필터 체인 및 인증/인가 설정을 관리
 */
@Configuration
@EnableWebSecurity
@RequiredArgsConstructor
@Slf4j
public class SecurityConfig {

    private final filterRegistry filterRegistry;
    
    @Bean
    public SecurityFilterChain securityFilterChain(HttpSecurity http) throws Exception {
        log.info("보안 필터 체인 구성 중...");
        
        http
            .csrf().disable()
            .formLogin().disable()
            .httpBasic().disable()
            .sessionManagement().sessionCreationPolicy(SessionCreationPolicy.STATELESS)
            .and()
            .authorizeHttpRequests()
                .requestMatchers("/auth/**", "/login", "/signup", "/public/**").permitAll()
                .anyRequest().authenticated();
        
        // 플러그형 필터 등록
        filterRegistry.configureFilters(http);
        
        return http.build();
    }
}


// ===================================

// 파일: backend/src/main/java/com/authentication/auth/configuration/security/corsConfig.java
        source.registerCorsConfiguration("/**", corsConfiguration);
        return source;
    }
}
package com.authentication.auth.configuration.security;

import org.springframework.beans.factory.annotation.Value;
import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;
import org.springframework.web.cors.CorsConfiguration;
import org.springframework.web.cors.CorsConfigurationSource;
import org.springframework.web.cors.UrlBasedCorsConfigurationSource;

import java.util.Arrays;
import java.util.List;

@Configuration
public class corsConfig {

    @Value("${site.domain}")
    private String siteDomain;
    @Value("${server.cookie.domain}")
    private String rootDomain;

    @Bean
    public CorsConfigurationSource corsConfigurationSource() {
        CorsConfiguration corsConfiguration = new CorsConfiguration();
        corsConfiguration.setAllowedOrigins(List.of(
                        "http://localhost:3000",
                        "http://127.0.0.1:3000",
                        "https://" + rootDomain,
                        "https://" + siteDomain,
                        "http://192.168.0.44",
                        "http://192.168.0.44:3000"
                ));
        corsConfiguration.setAllowedMethods(Arrays.asList("GET", "POST", "OPTIONS", "PATCH", "DELETE", "UPDATE"));
        corsConfiguration.setAllowedHeaders(Arrays.asList("Content-Type", "Authorization", "provider"));
        corsConfiguration.setAllowCredentials(true);

        UrlBasedCorsConfigurationSource source = new UrlBasedCorsConfigurationSource();
        source.registerCorsConfiguration("/**", corsConfiguration);
        return source;
    }
}


// ===================================

// 파일: backend/src/main/java/com/authentication/auth/configuration/security/publicAPI.java
package com.authentication.auth.configuration.security;

import jakarta.servlet.http.HttpServletRequest;
import lombok.Data;
import lombok.extern.slf4j.Slf4j;
import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;
import org.springframework.stereotype.Service;

import java.util.ArrayList;
import java.util.Arrays;
import java.util.List;


@Slf4j
@Data
@Service
public class publicAPI {

    private final List<String> apiEndPoints = Arrays.asList(
            "/login", "/public", "/api/public", "/errorPage", "/notExist", "/unauthorized", "/swagger-ui.html", "/v2/api-docs", "/swagger-resources", "/webjars", "/swagger-resources/configuration/ui", "/swagger-resources/configuration/security"
            ,"/oauth2/authorization/google", "/oauth2/authorization/google", "/oauth2/authorization/facebook", "/oauth2/authorization/github", "/oauth2/authorization/linkedin", "/oauth2/authorization/instagram", "/oauth2/authorization/twitter", "/oauth2/authorization/yahoo", "/oauth2/authorization/spotify", "/oauth2/authorization/amazon", "/oauth2/authorization/microsoft", "/oauth2/authorization/okta", "/oauth2/authorization/slack"
            ,"/oauth2/callback/google", "/oauth2/callback/google", "/oauth2/callback/facebook", "/oauth2/callback/github", "/oauth2/callback/linkedin", "/oauth2/callback/instagram", "/oauth2/callback/twitter", "/oauth2/callback/yahoo", "/oauth2/callback/spotify", "/oauth2/callback/amazon", "/oauth2/callback/microsoft", "/oauth2/callback/okta", "/oauth2/callback/slack",
            "/user/login", "/user/register", "/user/verify", "/user/forgetPassword", "/user/resetPassword", "/user/verifyResetPassword", "/user/verifyEmail", "/user/resendVerificationEmail"
    );

    public boolean checkRequestAPI(HttpServletRequest request){

    String requestURI = request.getRequestURI();
        log.info("Request URI: {}", requestURI); // log the request URI
        return (apiEndPoints.contains(requestURI));
    }
}


// ===================================

// 파일: backend/src/main/java/com/authentication/auth/configuration/security/SecurityConfig.java
                    .requestMatchers("/api/public/**").permitAll()
                    .requestMatchers(userRestrict).hasAnyAuthority("ADMIN", "USER", "COMPANY")
                    .requestMatchers(adminRestrict).hasAnyAuthority("ADMIN")
                    .requestMatchers(companyRestrict).hasAnyAuthority("COMPANY", "ADMIN")
                    .requestMatchers(oauth2Restrict).permitAll()
                    .anyRequest().permitAll();
        });
package com.authentication.auth.configuration.security;

import com.fasterxml.jackson.databind.ObjectMapper;
import lombok.RequiredArgsConstructor;
import lombok.extern.slf4j.Slf4j;
import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;
import org.springframework.security.authentication.AuthenticationManager;
import org.springframework.security.config.annotation.authentication.configuration.AuthenticationConfiguration;
import org.springframework.security.config.annotation.web.builders.HttpSecurity;
import org.springframework.security.config.annotation.web.configuration.EnableWebSecurity;
import org.springframework.security.config.annotation.web.configurers.AbstractHttpConfigurer;
import org.springframework.security.config.http.SessionCreationPolicy;
import org.springframework.security.crypto.bcrypt.BCryptPasswordEncoder;
import org.springframework.security.web.SecurityFilterChain;
import org.springframework.security.web.authentication.UsernamePasswordAuthenticationFilter;
import org.springframework.web.cors.CorsConfigurationSource;

@Slf4j
@Configuration
@EnableWebSecurity
@RequiredArgsConstructor
public class SecurityConfig {

    private final FilterRegistry filterRegistry; 

    @Bean
    public SecurityFilterChain filterChain(HttpSecurity http) throws Exception {
        // cors
        http.cors(cors -> cors.configurationSource(corsConfigurationSource));
        // 폼 로그인 비활성화
        http.formLogin(AbstractHttpConfigurer::disable);
        // Cross-Site Request Forgery 공격 방어 비활성화
        http.csrf(AbstractHttpConfigurer::disable);
        // HTTP 기본 인증 비활성화
        http.httpBasic(AbstractHttpConfigurer::disable);
        // session 기반 로그인 비활성화
        http.sessionManagement(management ->
                management.sessionCreationPolicy(SessionCreationPolicy.STATELESS));

        //filter
        filterRegistry.registerFilters(http);

        // authorization
        http.authorizeHttpRequests((authorize) -> {
            authorize
                    .requestMatchers(PathRequest.toStaticResources().atCommonLocations()).permitAll()
                    .requestMatchers("/api/public/**").permitAll()
                    .requestMatchers(userRestrict).hasAnyAuthority("ADMIN", "USER", "COMPANY")
                    .requestMatchers(adminRestrict).hasAnyAuthority("ADMIN")
                    .requestMatchers(companyRestrict).hasAnyAuthority("COMPANY", "ADMIN")
                    .requestMatchers(oauth2Restrict).permitAll()
                    .anyRequest().permitAll();
        });



        http.formLogin(formLogin -> formLogin
                .loginPage("/login").defaultSuccessUrl("/"));

        // 사용자 정보 서비스 및 암호화 설정
        http.userDetailsService(principalDetailService);

        // OAUTH 로그인 설정
        //http.oauth2Login(login -> login.loginPage("/login"));

        return http.build();
    }


    @Bean
    public BCryptPasswordEncoder passwordEncoder() {
        return new BCryptPasswordEncoder();
    }

    @Bean
    public ObjectMapper objectMapper() {
        return new ObjectMapper();
    }

}


// ===================================

// 파일: backend/src/main/java/com/authentication/auth/configuration/smtp/smtpConfig.java
package com.career_block.auth.configuration.smtp;

import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;
import org.springframework.mail.javamail.JavaMailSender;
import org.springframework.mail.javamail.JavaMailSenderImpl;

import java.util.Properties;

@Configuration
public class smtpConfig {

    @Bean
    public JavaMailSender mailSender() {
        JavaMailSenderImpl mailSender = new JavaMailSenderImpl();
        mailSender.setHost("smtp.gmail.com");
        mailSender.setPort(587);
        mailSender.setUsername("careernoteproject@gmail.com");
        mailSender.setPassword("akzm ifxr ahou copf");

        Properties javaMailProperties = new Properties();
        javaMailProperties.put("mail.transport.protocol", "smtp");
        javaMailProperties.put("mail.smtp.auth", "true");
        javaMailProperties.put("mail.smtp.socketFactory.class", "javax.net.ssl.SSLSocketFactory");
        javaMailProperties.put("mail.smtp.starttls.enable", "true");
        javaMailProperties.put("mail.debug", "true");//디버깅 정보 출력
        javaMailProperties.put("mail.smtp.ssl.trust", "smtp.gmail.com");//smtp 서버의 ssl 인증서를 신뢰
        javaMailProperties.put("mail.smtp.ssl.protocols", "TLSv1.2");//사용할 ssl 프로토콜 버젼
        mailSender.setJavaMailProperties(javaMailProperties);
        return mailSender;
    }
}


// ===================================

// 파일: backend/src/main/java/com/authentication/auth/configuration/token/jwtUtility.java
package com.authentication.auth.configuration.token;

import com.authentication.auth.DTO.token.TokenDto;
import io.jsonwebtoken.*;
import io.jsonwebtoken.security.Keys;
import jakarta.servlet.http.Cookie;
import jakarta.servlet.http.HttpServletRequest;
import jakarta.servlet.http.HttpServletResponse;
import lombok.extern.slf4j.Slf4j;
import org.springframework.beans.factory.annotation.Value;
import org.springframework.context.annotation.Bean;
import org.springframework.security.authentication.UsernamePasswordAuthenticationToken;
import org.springframework.security.core.GrantedAuthority;
import org.springframework.security.core.userdetails.UserDetails;
import org.springframework.stereotype.Component;
import org.springframework.transaction.annotation.Transactional;
import org.springframework.web.client.RestTemplate;

import java.io.IOException;
import java.io.PrintWriter;
import java.security.Key;
import java.time.Instant;
import java.util.*;

@Slf4j
@Component
public class jwtUtility {

    


    public jwtUtility(
            @Value("${jwt.secret-key}") String secretKey,
            @Value("${jwt.secret-key2}") String secretKey2,
            @Value("${ACCESS_TOKEN_VALIDITY}") Long ACCESS_TOKEN_VALIDITY,
            @Value("${REFRESH_TOKEN_VALIDITY}") Long REFRESH_TOKEN_VALIDITY){
        this.key = Keys.hmacShaKeyFor(secretKey.getBytes());
        this.key2 = Keys.hmacShaKeyFor(secretKey2.getBytes());
        this.ACCESS_TOKEN_VALIDITY = ACCESS_TOKEN_VALIDITY;
        this.REFRESH_TOKEN_VALIDITY = REFRESH_TOKEN_VALIDITY;
    }


    public TokenDto buildToken(String userId, String nickname, Collection<? extends GrantedAuthority> role) {
        Claims claims = createClaims(userId, nickname, role);

        // 토큰 만료 시간 설정
        Instant now = Instant.now();
        Instant validity = now.plusSeconds(ACCESS_TOKEN_VALIDITY);
        Instant validity2 = now.plusSeconds(REFRESH_TOKEN_VALIDITY);

        // 액세스 토큰 생성
        String accessToken = buildToken(claims, now, validity, key, SecurityConstants.TOKEN_TYPE);
        // 리프레시 토큰 생성
        String refreshToken = buildToken(Jwts.claims(), now, validity2, key2, SecurityConstants.TOKEN_TYPE2);

        return TokenDto.builder()

        return tokenDto.builder()
                .refreshToken(refreshToken)
                .accessToken(accessToken)
                .build();
    }
/* <<<<<<<<<<  2f21aafa-d159-41a6-892b-76ef4b9b83f8  >>>>>>>>>>> */

    // 클레임 생성 유틸리티 메서드
    private Claims createClaims(String userId, String nickname, Collection<? extends GrantedAuthority> role) {
        Claims claims = Jwts.claims();
        claims.put("userId", userId);
        claims.put("nickname", nickname);
        claims.put("role", role);
        return claims;
    }

    // 토큰 생성 유틸리티 메서드
    private String buildToken(Claims claims, Instant issuedAt, Instant expiry, Key signingKey, String type) {
        return Jwts.builder()
                .setClaims(claims)
                .setIssuedAt(Date.from(issuedAt))
                .setExpiration(Date.from(expiry))
                .signWith(signingKey, SignatureAlgorithm.HS512)
                .claim("type", type)
                .compact();
    }

    public UsernamePasswordAuthenticationToken getAuthentication(String JWT){
        try {
            Jws<Claims> parsedToken = Jwts.parserBuilder()
                    .setSigningKey(key)
                    .build()
                    .parseClaimsJws(JWT);

            log.info("parsedToken : " + parsedToken);
            users user = new users();

            List<LinkedHashMap<String, String>> roleList =
                    (List<LinkedHashMap<String, String>>) parsedToken.getBody().get("role");

            Role role = Role .valueOf(roleList.get(0).get("authority"));
            log.info("role : {}", role.toString());
            user = user.builder()
                    .userId((String) parsedToken.getBody().get("userId"))
                    .role(role)
                    .build();

            UserDetails userDetails = new principalDetails(user);


            log.info(userDetails.getUsername());
            log.info(userDetails.getAuthorities().toString());

            Collection<? extends GrantedAuthority> authorities = userDetails.getAuthorities();
            return new UsernamePasswordAuthenticationToken(userDetails, null, authorities);
        } catch (Exception e){
            log.error("authentication 과정에서 Exception 발생! " + e.getMessage());
            return null;
        }
    }

    public boolean validateJWT(String JWT) {
        try {
            Jws<Claims> parsedToken = Jwts.parserBuilder()
                    .setSigningKey(key)
                    .build()
                    .parseClaimsJws(JWT);

            log.info("JWT 유효성 검증 통과 - 만료일: {}", parsedToken.getBody().getExpiration());
            return !parsedToken.getBody().getExpiration().before(new Date());
        } catch (ExpiredJwtException e) {
            log.error("JWT 만료 - {}", e.getMessage());
            return false;
        } catch (UnsupportedJwtException e) {
            log.error("지원되지 않는 JWT - {}", e.getMessage());
            return false;
        } catch (MalformedJwtException e) {
            log.error("잘못된 형식의 JWT - {}", e.getMessage());
            return false;
        } catch (JwtException e) {
            log.error("JWT 예외 발생 - {}", e.getMessage());
            return false;
        } catch (Exception e) {
            log.error("JWT 처리 중 일반 예외 발생 - {}", e.getMessage());
            return false;
        }

    }

    public boolean validateRefreshJWT(String refreshJWT) {
        try{
            Jws<Claims> parsedRefreshToken = Jwts.parserBuilder()
                    .setSigningKey(key2)
                    .build()
                    .parseClaimsJws(refreshJWT);
            return !parsedRefreshToken.getBody().getExpiration().before(new Date());
        } catch(ExpiredJwtException e){
            log.error("refresh token expired");
            return false;
        } catch (JwtException e){
            log.error("refresh token tampered");
            return false;
        } catch(NullPointerException e){
            log.error("refresh token is null");
            return false;
        } catch (Exception e){
            log.error("refresh token error");
            return false;
        }
    }



    public Map<String, Object> getClaimsFromAccessToken(String JWT) {
        try {
            Jws<Claims> parsedToken = Jwts.parserBuilder()
                    .setSigningKey(key)
                    .build()
                    .parseClaimsJws(JWT);

            Claims claims = parsedToken.getBody();

            Map<String, Object> claimMap = new HashMap<>();
            claimMap.put("userId", claims.get("userId"));
            claimMap.put("nickname", claims.get("nickname"));
            claimMap.put("role", claims.get("role"));
            return claimMap;
        } catch (ExpiredJwtException e) {
            log.error("| jwt utils | expired Token!");
            Map<String, Object> claimMap = new HashMap<>();
            claimMap.put("userId", e.getClaims().get("userId"));
            claimMap.put("nickname", e.getClaims().get("nickname"));
            claimMap.put("role", e.getClaims().get("role"));
            return claimMap;
        } catch (JwtException e) {
            throw new RuntimeException("token error");
        }
    }


    // 기존 토큰을 기반으로 새로운 토큰을 발급하는 메서드
    public String refreshToken(String expiredToken) {
        Claims claims; Instant now = Instant.now();Instant newExpiry = now.plusSeconds(ACCESS_TOKEN_VALIDITY);
        try {
            claims = extractClaims(expiredToken);
        } catch (ExpiredJwtException e) {
            claims = e.getClaims();
        } catch (JwtException e) {
            throw new RuntimeException("token error");
        }
        return buildToken(claims, now, newExpiry, key, SecurityConstants.TOKEN_TYPE);
    }


    public String getUserIdFromToken(String token) {
        if (token == null) {
            throw new IllegalArgumentException("Token is null");
        }

        Claims getClaims = this.extractClaims(token);
        return getClaims.get("userId", String.class);  // userId를 String으로 반환
    }


    // access 토큰에서 Claims 를 추출하는 유틸리티 메서드
    public Claims extractClaims(String token) {
        return Jwts.parserBuilder()
                .setSigningKey(key)
                .build()
                .parseClaimsJws(token)
                .getBody();
    }

    public String checkSnsCookie(HttpServletRequest request, HttpServletResponse response) throws IOException {
        String providerHeader = request.getHeader("provider"); // SNS 정보 제공자 추가하기
        Cookie[] cookies = request.getCookies();
        String RToken = null;
        if (cookies != null) {
            for (Cookie cookie : cookies) {
                if (cookie.getName().equals(providerHeader + "_refreshToken")) {
                    RToken = cookie.getValue();
                    break;
                }
            }
        }
        if (RToken == null) {
            sendResponseStatus(response, HttpServletResponse.SC_UNAUTHORIZED, "there's no refreshToken");
        }
        return RToken;
    }

    private void sendResponseStatus(HttpServletResponse response, int status, String message)
            throws IOException{
        response.setStatus(status);
        PrintWriter writer = response.getWriter();
        response.setContentType("application/json");
        response.setCharacterEncoding("UTF-8");
        writer.print("{\"message\":\"" + message + "\"}");
        writer.flush();
    }


    @Transactional
    public String checkCookie(HttpServletRequest request, HttpServletResponse response, String provider) throws IOException {
        Cookie[] cookies = request.getCookies();
        String RToken = null;

        if (cookies == null) {
            sendResponseStatus(response, HttpServletResponse.SC_UNAUTHORIZED, "there's no cookies");
            return null;
        }

        if (!"server".equals(provider)) {
            for (Cookie cookie : cookies) {
                if (cookie.getName().equals(provider + "_refreshToken")) {
                    RToken = cookie.getValue();
                    break;
                }
            }
        } else {
            for (Cookie cookie : cookies) {
                if (cookie.getName().equals("refreshToken")) {
                    RToken = cookie.getValue();
                    break;
                }
            }
        }

        if (RToken == null) {
            sendResponseStatus(response, HttpServletResponse.SC_UNAUTHORIZED, "there's no refreshToken");
        }

        return RToken;
    }


    @Bean
    public RestTemplate restTemplate() {
        return new RestTemplate();
    }

}


// ===================================

// 파일: backend/src/main/java/com/authentication/auth/controller/auth/AuthController.java
package com.career_block.auth.controller.auth;

import org.springframework.http.ResponseEntity;
import org.springframework.web.bind.annotation.GetMapping;
import org.springframework.web.bind.annotation.RestController;

@RestController
public class AuthController {

    @GetMapping("/auth_check")
    public ResponseEntity<String> authCheck() {
        return ResponseEntity.ok("Authorized");
    }
}


// ===================================

// 파일: backend/src/main/java/com/authentication/auth/controller/auth/oauth2Controller.java
package com.career_block.auth.controller.auth;

import jakarta.servlet.http.HttpServletResponse;
import lombok.RequiredArgsConstructor;
import lombok.extern.slf4j.Slf4j;
import org.springframework.http.ResponseEntity;
import org.springframework.web.bind.annotation.PostMapping;
import org.springframework.web.bind.annotation.RequestBody;
import org.springframework.web.bind.annotation.RequestMapping;
import org.springframework.web.bind.annotation.RestController;

import com.authentication.auth.configuration.token.jwtUtility;
import com.authentication.auth.service.oauth2.oauth2Service;
import com.authentication.auth.service.redis.redisService;

import java.util.Map;
import java.util.UUID;

@Slf4j
@RestController
@RequiredArgsConstructor
@RequestMapping("/oauth2")
public class oauth2Controller {

    //하핫.. 너는 서비스다...
    private final oauth2Service  oauth2Service;
    private final redisService  redisService;
    private final jwtUtility jwtUtility;


    @PostMapping("/callback/kakao")
    public ResponseEntity<?> oauth2KakaoLogin(@RequestBody Map<String, String> requestBody, HttpServletResponse response) {
        log.info("/oauth2/callback/kakao");
        return oauth2Service.handleOauth2Login(requestBody, response, "kakao");
    }
    @PostMapping("/callback/naver")
    public ResponseEntity<?> oauth2NaverLogin(@RequestBody Map<String, String> requestBody, HttpServletResponse response) {
        log.info("/oauth2/callback/naver");
        String state = UUID.randomUUID().toString();
        return oauth2Service.handleOauth2Login(requestBody, response, "naver");
    }
    @PostMapping("/callback/google")
    public ResponseEntity<?> oauth2GoogleLogin(@RequestBody Map<String, String> requestBody, HttpServletResponse response) {
        log.info("/oauth2/callback/google");
        log.info("tempCode for google from client server : {}", requestBody.get("tempCode"));
        return oauth2Service.handleOauth2Login(requestBody, response, "google");
    }

}


// ===================================

// 파일: backend/src/main/java/com/authentication/auth/controller/auth/tokenController.java
package com.career_block.auth.controller.auth;

import io.swagger.v3.oas.annotations.Operation;
import io.swagger.v3.oas.annotations.responses.ApiResponse;
import io.swagger.v3.oas.annotations.responses.ApiResponses;
import jakarta.servlet.http.HttpServletRequest;
import jakarta.servlet.http.HttpServletResponse;
import lombok.extern.slf4j.Slf4j;
import org.springframework.http.HttpStatus;
import org.springframework.http.ResponseEntity;
import org.springframework.web.bind.annotation.PostMapping;
import org.springframework.web.bind.annotation.RequestBody;
import org.springframework.web.bind.annotation.RequestMapping;
import org.springframework.web.bind.annotation.RestController;

import com.authentication.auth.DTO.token.tokenRefreshRequest;
import com.authentication.auth.configuration.token.jwtUtility;
import com.authentication.auth.service.redis.redisService;
import com.authentication.auth.service.token.tokenService;

import java.io.IOException;

@Slf4j
@RestController
@RequestMapping("/auth")
public class tokenController {

    private final jwtUtility jwtUtility;
    private final redisService redisService;
    private final tokenService  tokenService;

    public tokenController(jwtUtility jwtUtility, redisService redisService, tokenService tokenService){
        this.jwtUtility = jwtUtility;
        this.redisService = redisService;
        this.tokenService = tokenService;
    }

    @Operation(summary = "Refresh JWT Token", description = "Refreshes the expired JWT token and returns a new token if valid.")
    @ApiResponses(value = {
            @ApiResponse(responseCode = "200", description = "Token refreshed successfully, new token returned."),
            @ApiResponse(responseCode = "406", description = "Not acceptable, invalid token or no refresh token in Redis."),
            @ApiResponse(responseCode = "401", description = "Unauthorized, refresh token not found in cookies."),
    })
    @PostMapping("/api/protected/refresh")
    public ResponseEntity<?> refreshToken(HttpServletRequest httpRequest, HttpServletResponse httpResponse, @RequestBody tokenRefreshRequest request) throws IOException {

        if (request == null || request.getExpiredToken() == null || request.getProvider() == null) {
            return ResponseEntity.status(HttpStatus.NOT_ACCEPTABLE).build();
        }

        return tokenService.refreshToken(httpRequest, httpResponse, request);
    }
}


// ===================================

// 파일: backend/src/main/java/com/authentication/auth/controller/emailController.java
package com.career_block.auth.controller;


import io.swagger.v3.oas.annotations.Operation;
import io.swagger.v3.oas.annotations.media.Content;
import io.swagger.v3.oas.annotations.responses.ApiResponse;
import io.swagger.v3.oas.annotations.responses.ApiResponses;
import io.swagger.v3.oas.annotations.tags.Tag;
import jakarta.validation.Valid;
import lombok.RequiredArgsConstructor;
import lombok.extern.slf4j.Slf4j;
import org.springframework.http.HttpStatus;
import org.springframework.http.ResponseEntity;
import org.springframework.security.core.annotation.AuthenticationPrincipal;
import org.springframework.web.bind.annotation.*;

import com.authentication.auth.DTO.smtp.customEmailRequest;
import com.authentication.auth.DTO.smtp.emailCheckDto;
import com.authentication.auth.DTO.smtp.emailFindById;
import com.authentication.auth.DTO.smtp.emailRequest;
import com.authentication.auth.DTO.token.principalDetails;
import com.authentication.auth.service.redis.redisService;
import com.authentication.auth.service.smtp.emailService;
import com.authentication.auth.service.users.userService;

@Slf4j
@Tag(name="email 관련", description = "email")
@RestController
@RequiredArgsConstructor
@RequestMapping("/api")
public class emailController {

    private final emailService service;
    private final userService  userService;
    private final redisService  redisService;

    @Operation(summary="이메일 보내기", description = "이메일 코드 전송 관련")
    @ApiResponses(value = {
            @ApiResponse(responseCode = "200", description = "이메일 전송 성공", content = @Content(mediaType = "application/json")),
            @ApiResponse(responseCode = "500", description = "이메일 전송 실패", content = @Content(mediaType = "application/json"))
    })
    @PostMapping("/public/emailSend")
    public ResponseEntity<?> emailSend(@RequestBody @Valid emailRequest request) {
        try {
            if(service.checkIsExistEmail(request.getEmail()))
            {
                return ResponseEntity.status(HttpStatus.BAD_REQUEST).body("user with this email already exist");
            }
            String code = service.joinEmail(request.getEmail());
            this.redisService.saveEmailCode(request.getEmail(), code);
            return ResponseEntity.status(HttpStatus.OK).body("A temporary code has been sent to your email");
        } catch (Exception e) {
            return ResponseEntity.status(HttpStatus.INTERNAL_SERVER_ERROR).body("email sent failed");
        }
    }


    @Operation(summary="커스텀 이메일 보내기", description = "커스텀 이메일 전송 관련")
    @ApiResponses(value = {
            @ApiResponse(responseCode = "200", description = "이메일 전송 성공", content = @Content(mediaType = "application/json")),
            @ApiResponse(responseCode = "500", description = "이메일 전송 실패", content = @Content(mediaType = "application/json"))
    })
    @PostMapping("/api/private/customEmailSend")
    public ResponseEntity<?> customEmailSend(@RequestBody @Valid customEmailRequest request) {
        try {
            if (request.getEmail() == null) {
                return ResponseEntity.status(HttpStatus.BAD_REQUEST).body("email is blank");
            }
            if (request.getContent() == null){
                return ResponseEntity.status(HttpStatus.BAD_REQUEST).body("there's no content in the request");
            }
            service.sendCustomEmail(request);
            return ResponseEntity.status(HttpStatus.OK).body("custom email send success");
        } catch (Exception e) {
            return ResponseEntity.status(HttpStatus.INTERNAL_SERVER_ERROR).body("email sent failed");
        }
    }


    @Operation(summary = "이메일 코드 확인", description = "이메일로 전송된 코드를 확인합니다")
    @ApiResponses(value = {
            @ApiResponse(responseCode = "202", description = "이메일 코드 유효", content = @Content(mediaType = "application/json")),
            @ApiResponse(responseCode = "401", description = "이메일 코드 무효", content = @Content(mediaType = "application/json"))
    })
    @PostMapping("/public/emailCheck")
    public ResponseEntity<?> emailCodeCheck(@RequestBody @Valid emailCheckDto checkdto) {
        boolean isValid = redisService.checkEmailCode(checkdto.getEmail(), checkdto.getCode());
        if (isValid) {
            return ResponseEntity.status(HttpStatus.ACCEPTED).body("email code is valid");
        } else {
            return ResponseEntity.status(HttpStatus.UNAUTHORIZED).body("email code is invalid");
        }
    }

    @Operation(summary = "임시 비밀번호 이메일 전송", description = "인증된 사용자에게 임시 비밀번호를 이메일로 전송합니다")
    @ApiResponses(value = {
            @ApiResponse(responseCode = "200", description = "임시 비밀번호 전송 성공", content = @Content(mediaType = "application/json")),
            @ApiResponse(responseCode = "500", description = "임시 비밀번호 전송 실패", content = @Content(mediaType = "application/json"))
    })
    @PostMapping("/protected/sendEmailPassword")
    public ResponseEntity<?> emailSendPassword(@AuthenticationPrincipal principalDetails principalDetails) {
        try {
            String userId = principalDetails.getUserId();
            String email = userService.getEmailByUserId(userId);
            String temporalPassword = service.changePwEmail(email);
            userService.UpdateUserPassword(userId, temporalPassword);
            return ResponseEntity.status(HttpStatus.OK).body("A temporary password has been sent to your email");
        } catch (Exception e) {
            return ResponseEntity.status(HttpStatus.INTERNAL_SERVER_ERROR).body("error occurred while sending an temporary password");
        }
    }

    @Operation(summary = "이메일로 비밀번호 찾기", description = "사용자 ID를 통해 이메일로 임시 비밀번호를 전송합니다")
    @ApiResponses(value = {
            @ApiResponse(responseCode = "200", description = "임시 비밀번호 전송 성공", content = @Content(mediaType = "application/json")),
            @ApiResponse(responseCode = "500", description = "임시 비밀번호 전송 실패", content = @Content(mediaType = "application/json"))
    })
    @GetMapping("/public/findPassWithEmail")
    public ResponseEntity<?> findPassWithEmail(@RequestBody emailFindById emailFindById) {
        try {
            String email = userService.getEmailByUserId(emailFindById.getUserId());
            String temporalPassword = service.changePwEmail(email);
            userService.UpdateUserPassword(emailFindById.getUserId(), temporalPassword);
            return ResponseEntity.status(HttpStatus.OK).body("A temporary password has been sent to your email");
        } catch (Exception e) {
            log.error("Error find Password with Email sent", e);
            return ResponseEntity.status(HttpStatus.INTERNAL_SERVER_ERROR).body("error occurred while sending an temporary password");
        }
    }


}


// ===================================

// 파일: backend/src/main/java/com/authentication/auth/controller/errorController.java
/*

package com.career_block.auth.controller;

import jakarta.servlet.http.HttpServlet;
import jakarta.servlet.http.HttpServletRequest;
import org.springframework.boot.web.servlet.error.ErrorController;
import org.springframework.stereotype.Controller;
import org.springframework.ui.Model;
import org.springframework.web.bind.annotation.GetMapping;
import org.springframework.web.bind.annotation.RequestMapping;
import org.springframework.web.bind.annotation.RestController;


@Controller
public class errorController implements ErrorController {

    @RequestMapping("/errorPage")
    public String handleError(HttpServletRequest request, Model model) {
        Object status = request.getAttribute("javax.servlet.error.status_code");

        if (status != null) {
            int statusCode = Integer.parseInt(status.toString());
            model.addAttribute("statusCode", statusCode);

            if (statusCode == 404) {
                return "notExist";  // src/main/resources/templates/notExist.html 템플릿 반환
            } else if (statusCode == 401) {
                return "unauthorized"; // src/main/resources/templates/unauthorized.html 템플릿 반환
            }
        }

        return "error"; // 다른 오류에는 기본 에러 페이지 반환 (src/main/resources/templates/error.html)

}
*/


// ===================================

// 파일: backend/src/main/java/com/authentication/auth/controller/sseController.java
    /**
     * 클라이언트가 SSE 스트림에 구독하기 위한 엔드포인트
     * 예: GET /sse/subscribe/{userId}
     *
     * @param userId 사용자의 고유 ID
     * @return SseEmitter 객체
     */
    /**
     * 더미 데이터를 특정 사용자에게 전송하는 엔드포인트
     * 예: POST /sse/dummyData/{user_id}
package com.career_block.auth.controller;

import io.swagger.v3.oas.annotations.Operation;
import io.swagger.v3.oas.annotations.media.Content;
import io.swagger.v3.oas.annotations.responses.ApiResponse;
import io.swagger.v3.oas.annotations.responses.ApiResponses;
import lombok.RequiredArgsConstructor;
import lombok.extern.slf4j.Slf4j;
import org.springframework.http.HttpStatus;
import org.springframework.http.MediaType;
import org.springframework.http.ResponseEntity;
import org.springframework.security.core.annotation.AuthenticationPrincipal;
import org.springframework.web.bind.annotation.*;
import org.springframework.web.servlet.mvc.method.annotation.SseEmitter;

import com.authentication.auth.DTO.token.principalDetails;
import com.authentication.auth.service.sse.sseService;

import java.util.Map;

@Slf4j
@RestController
@RequiredArgsConstructor
@RequestMapping("/api")
public class sseController {

    private final sseService sseService;


    /**
     * 클라이언트가 SSE 스트림에 구독하기 위한 엔드포인트
     * 예: GET /sse/subscribe/{userId}
     *
     * @param userId 사용자의 고유 ID
     * @return SseEmitter 객체
     */
    @Operation(summary = "SSE 구독", description = "서버에서 SSE 이벤트를 구독합니다.")
    @ApiResponses(value = {
            @ApiResponse(responseCode = "200", description = "구독 성공", content = @Content(mediaType = "application/json")),
            @ApiResponse(responseCode = "401", description = "인증 실패", content = @Content(mediaType = "application/json")),
            @ApiResponse(responseCode = "500", description = "서버 오류", content = @Content(mediaType = "application/json"))
    })
    @GetMapping(value = "/protected/sse/subscribe", produces = MediaType.TEXT_EVENT_STREAM_VALUE)
    public ResponseEntity<SseEmitter> subscribeSse(@AuthenticationPrincipal principalDetails principalDetails,
                                                   @RequestHeader(value = "Last-Event-ID", required = false, defaultValue = "") String lastEventId) {
        SseEmitter emitter = new SseEmitter(30 * 60 * 1000L);

        String userId = principalDetails.getUserId();
        boolean saved = sseService.saveSseEmitter(userId, emitter);
        if (!saved) {
            log.error("Failed to save SseEmitter for userId : {}", userId);
            emitter.completeWithError(new IllegalStateException("Failed to save SseEmitter for userId : " + userId));
        }

        // Initial Data 전송
        try {
            emitter.send(SseEmitter.event()
                    .name("INIT")
                    .data("Subscription successful"));
        } catch (Exception e) {
            log.error("Error sending initial event to userId : {}", userId, e);
            sseService.removeEmitter(userId, emitter);
            emitter.completeWithError(e);
        }

        return ResponseEntity.status(HttpStatus.OK).body(emitter);
    }



    /**
     * 더미 데이터를 특정 사용자에게 전송하는 엔드포인트
     * 예: POST /sse/dummyData/{user_id}
     *
     * @param principalDetails 인증된 사용자 정보
     * @param userId 대상 사용자의 ID
     * @param payload 전송할 데이터
     * @return ResponseEntity
     */
    @Operation(summary = "더미 데이터 전송", description = "특정 사용자에게 더미 데이터를 전송합니다.")
    @ApiResponses(value = {
            @ApiResponse(responseCode = "200", description = "데이터 전송 성공", content = @Content(mediaType = "application/json")),
            @ApiResponse(responseCode = "400", description = "잘못된 요청", content = @Content(mediaType = "application/json")),
            @ApiResponse(responseCode = "401", description = "인증 실패", content = @Content(mediaType = "application/json")),
            @ApiResponse(responseCode = "500", description = "서버 오류", content = @Content(mediaType = "application/json"))
    })
    @PostMapping("/public/dummyData/{user_id}")
    public ResponseEntity<?> sseDummyData(@AuthenticationPrincipal principalDetails principalDetails,
                                          @PathVariable("user_id") String userId,
                                          @RequestBody Map<String, String> payload){
        String message = payload.get("message");
        if (message == null || message.isEmpty()){
            return ResponseEntity.status(HttpStatus.BAD_REQUEST).body("Message is required");
        }

        sseService.sendEventToUser(userId, message);
        return ResponseEntity.ok().build();
    }


}


// ===================================

// 파일: backend/src/main/java/com/authentication/auth/controller/usersController.java
package com.career_block.auth.controller;

import io.swagger.v3.oas.annotations.Operation;
import io.swagger.v3.oas.annotations.media.Content;
import io.swagger.v3.oas.annotations.responses.ApiResponse;
import io.swagger.v3.oas.annotations.responses.ApiResponses;
import io.swagger.v3.oas.annotations.tags.Tag;
import jakarta.servlet.http.Cookie;
import jakarta.servlet.http.HttpServletRequest;
import jakarta.servlet.http.HttpServletResponse;
import lombok.RequiredArgsConstructor;
import lombok.extern.slf4j.Slf4j;
import org.apache.commons.io.FilenameUtils;
import org.springframework.beans.factory.annotation.Value;
import org.springframework.http.HttpStatus;
import org.springframework.http.ResponseEntity;
import org.springframework.web.bind.annotation.*;
import org.springframework.web.multipart.MultipartFile;

import com.authentication.auth.DTO.token.tokenDto;
import com.authentication.auth.DTO.users.joinRequest;
import com.authentication.auth.configuration.token.jwtUtility;
import com.authentication.auth.others.constants.SecurityConstants;
import com.authentication.auth.service.redis.redisService;
import com.authentication.auth.service.smtp.emailService;
import com.authentication.auth.service.users.userService;

import java.io.File;
import java.io.IOException;
import java.nio.file.Files;
import java.util.*;

@Slf4j
@RestController
@RequiredArgsConstructor
@RequestMapping("/api")
@Tag(name = "User Management", description = "유저 관리 API")
public class usersController {

    @Value("${file.profile-path}")
    private String profilePath;
    @Value("${file.server}")
    private String fileServer;
    @Value("${site.domain}")
    private String domain;
    private final userService userService;
    private final emailService emailService;
    private final redisService redisService;
    private final jwtUtility jwtUtility;

    @Operation(summary = "회원 가입", description = "새로운 유저를 등록합니다.")
    @ApiResponses(value = {
            @ApiResponse(responseCode = "200", description = "회원 가입 성공", content = @Content(mediaType = "application/json")),
            @ApiResponse(responseCode = "500", description = "회원 가입 실패", content = @Content(mediaType = "application/json"))
    })
    @PostMapping("/public/join")
    public ResponseEntity<?> join(@RequestBody joinRequest request) throws Exception {
        if (!redisService.checkEmailCode(request.getEmail(), request.getCode()))
            return ResponseEntity.status(HttpStatus.BAD_REQUEST).body("Email validation is not accessed");
        ResponseEntity<?> save = userService.join(request);
        if (save.getStatusCode() == HttpStatus.CONFLICT)
            return ResponseEntity.status(HttpStatus.CONFLICT).body("already exist userId or nickname");
        if (save.getStatusCode() == HttpStatus.OK) {
            return ResponseEntity.status(HttpStatus.OK).body("join successfully");
        } else {
            return ResponseEntity.status(HttpStatus.INTERNAL_SERVER_ERROR).body("join save failed");
        }
    }

    @Operation(summary = "프로필 업로드", description = "유저 프로필 이미지를 업로드합니다.")
    @ApiResponses(value = {
            @ApiResponse(responseCode = "200", description = "프로필 업로드 성공", content = @Content(mediaType = "application/json")),
            @ApiResponse(responseCode = "400", description = "잘못된 파일 이름 또는 확장자", content = @Content(mediaType = "application/json")),
            @ApiResponse(responseCode = "500", description = "서버 오류", content = @Content(mediaType = "application/json"))
    })
    @PostMapping("/public/profileUpload")
    public ResponseEntity<?> fileUpload(@RequestParam("profile") MultipartFile[] files) {
        Map<String, String> response = new HashMap<>();
        for (MultipartFile file : files) {
            try {
                String originName = file.getOriginalFilename();
                if (originName == null || originName.contains("..")) {
                    log.error("invalid file name : " + originName);
                    return ResponseEntity.status(HttpStatus.BAD_REQUEST).body("invalid file name : " + originName);
                }

                String originNameOnly = FilenameUtils.getBaseName(originName);
                String extension = FilenameUtils.getExtension(originName);
                if (!isValidExtension(extension)) {
                    log.error("invalid file extension : " + extension);
                    return ResponseEntity.status(HttpStatus.BAD_REQUEST).body("invalid file extension : " + extension);
                }

                String fileName = UUID.randomUUID().toString() + "_" + originNameOnly + "." + extension;

                File directory = new File(profilePath);
                if (!directory.exists()) {
                    directory.mkdirs();
                }
                File targetFile = new File(profilePath, fileName);
                file.transferTo(targetFile);

                log.info("Saving file to {}", targetFile.getAbsolutePath());

                if (!isValidFileContent(targetFile, extension)) {
                    targetFile.delete();
                    log.error("invalid file content");
                    return ResponseEntity.status(HttpStatus.BAD_REQUEST).body("invalid file content");
                }

                log.info("saving file dir to {}", targetFile.getAbsolutePath());

                response.put("fileName", fileServer + "/attach/profile/" + fileName);

            } catch (IOException e) {
                log.error("프로필 파일 업로드 중 오류 발생!", e);
                return ResponseEntity.status(HttpStatus.INTERNAL_SERVER_ERROR).body("profile upload error");
            }
        }
        return ResponseEntity.status(HttpStatus.OK).body(response);
    }


    private boolean isValidExtension(String extension) {
        List<String> allowedExtensions = Arrays.asList("jpg", "jpeg", "png", "gif", "bmp", "webp", "svg", "tiff");
        return allowedExtensions.contains(extension);
    }

    private boolean isValidFileContent(File file, String extension) {
        try {
            String mimeType = Files.probeContentType(file.toPath());
            List<String> allowedMimeTypes = Arrays.asList(
                    "image/jpeg", "image/png", "image/gif", "image/bmp", "image/webp", "image/svg+xml", "image/tiff"
            );
            return allowedMimeTypes.contains(mimeType);
        } catch (IOException e) {
            log.error("파일 내용 검증 중 오류 발생", e);
            return false;
        }
    }

    @Operation(summary = "아이디 중복 체크", description = "아이디의 중복 여부를 체크합니다.")
    @ApiResponses(value = {
            @ApiResponse(responseCode = "200", description = "중복 체크 성공", content = @Content(mediaType = "application/json"))
    })
    @PostMapping("/public/check/userId/IsDuplicate")
    public boolean checkUserIdIsDuplicate(@RequestBody HashMap<String, String> user) {
        log.info("/check/userId/IsDuplicate : {}", user.get("userId"));
        return userService.checkUserIdIsDuplicate(user.get("userId"));
    }

    @Operation(summary = "닉네임 중복 체크", description = "닉네임의 중복 여부를 체크합니다.")
    @ApiResponses(value = {
            @ApiResponse(responseCode = "200", description = "중복 체크 성공", content = @Content(mediaType = "application/json"))
    })
    @PostMapping("/public/check/nickname/IsDuplicate")
    public boolean checkNickNameDuplicate(@RequestBody HashMap<String, String> user) {
        log.info("/check/nickname/IsDuplicate : {}", user.get("nickname"));
        return userService.checkNickNameIsDuplicate(user.get("nickname"));
    }

    @PostMapping("/public/clean/userTokenCookie")
    public ResponseEntity<?> cleanUserTokenCookie(HttpServletRequest request, HttpServletResponse response) {
        String cookieName = "refreshToken";
        Cookie[] cookies = request.getCookies();
        if (cookies != null) {
            for (Cookie cookie : cookies) {
                if (cookieName.equals(cookie.getName())) {
                    cookie.setMaxAge(0);
                    cookie.setPath("/");
                    cookie.setHttpOnly(true);
                    response.addCookie(cookie);
                }
            }
        }
        return ResponseEntity.ok().body("refreshToken deleted");
    }

    private void sendFrontNewCookie(HttpServletResponse response, int status, tokenDto tokendto) {
        response.setStatus(status);
        response.addHeader(SecurityConstants.TOKEN_HEADER, SecurityConstants.TOKEN_PREFIX + tokendto.getAccessToken());
        Cookie refreshTokenCookie = new Cookie("refreshToken", tokendto.getRefreshToken());
        refreshTokenCookie.setHttpOnly(true);
        refreshTokenCookie.setDomain(domain);
        refreshTokenCookie.setPath("/");
        response.addCookie(refreshTokenCookie);
    }

    private String getRefreshTokenFromCookie(HttpServletRequest request) {
        // cookie 배열 가지고 오기
        Cookie[] cookies = request.getCookies();

        if (cookies != null) {
            for (Cookie cookie : cookies) {
                if ("refreshToken".equals(cookie.getName())) {
                    return cookie.getValue();
                }
            }
        }
        log.error("[getRefreshTokenFromCookie] cookie 에서 refreshToken 찾기 실패");
        return null;
    }

    private boolean RedisMatchRToken(String userId, String RToken) {
        return redisService.findRToken(userId, "server", RToken);
    }
}


// ===================================

// 파일: backend/src/main/java/com/authentication/auth/domain/AuthProvider.java
@Entity
@Table(name = "Auth_Provider")
@Data
@NoArgsConstructor
@AllArgsConstructor
public class AuthProvider {
    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    private Integer id;
    
    @Column(name = "provider_name", nullable = false, length = 50)
    private String providerName = "SERVER";
    
    private String description;
    
    @Column(name = "is_active")
    private Boolean isActive = true;
    
    @OneToMany(mappedBy = "authProvider", cascade = CascadeType.ALL)
    private List<UserAuthentication> userAuthentications = new ArrayList<>();
}


// ===================================

// 파일: backend/src/main/java/com/authentication/auth/domain/DiaryAnswer.java
package com.authentication.auth.domain;

import jakarta.persistence.*;
import lombok.AllArgsConstructor;
import lombok.Data;
import lombok.NoArgsConstructor;

import java.time.LocalDateTime;

@Entity
@Table(name = "Diary_Answer")
@Data
@NoArgsConstructor
@AllArgsConstructor
public class DiaryAnswer {

    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    private Long id;

    @OneToOne(fetch = FetchType.LAZY)
    @JoinColumn(name = "diary_id", nullable = false)
    private Diary diary;

    @Column(name = "created_at")
    private LocalDateTime createdAt;

    @Column(name = "updated_at")
    private LocalDateTime updatedAt;

    @Column(name = "emotion_detection")
    private String emotionDetection;

    @Column(name = "automatic_thought")
    private String automaticThought;

    @Column(name = "prompt_for_change")
    private String promptForChange;

    @Column(name = "alternative_thought")
    private String alternativeThought;

    @Enumerated(EnumType.STRING)
    @Column(nullable = false)
    private EmotionStatus status = EmotionStatus.NEUTRAL;

    public enum EmotionStatus {
        POSITIVE, NEGATIVE, NEUTRAL
    }
}


// ===================================

// 파일: backend/src/main/java/com/authentication/auth/domain/Diary.java
package com.authentication.auth.domain;

import jakarta.persistence.*;
import lombok.AllArgsConstructor;
import lombok.Data;
import lombok.NoArgsConstructor;

import java.time.LocalDateTime;

@Entity
@Table(name = "Diary")
@Data
@NoArgsConstructor
@AllArgsConstructor
public class Diary {

    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    private Long id;

    @ManyToOne(fetch = FetchType.LAZY)
    @JoinColumn(name = "user_id", nullable = false)
    private User user;

    @Column(name = "created_at")
    private LocalDateTime createdAt;

    @Column(name = "updated_at")
    private LocalDateTime updatedAt;

    private String title;

    @Column(nullable = false)
    private String content;

    @Column(name = "alternative_thought")
    private String alternativeThought;

    @OneToOne(mappedBy = "diary", cascade = CascadeType.ALL, orphanRemoval = true)
    private DiaryAnswer diaryAnswer;

    @PrePersist
    protected void onCreate() {
        createdAt = LocalDateTime.now();
        updatedAt = LocalDateTime.now();
    }

    @PreUpdate
    protected void onUpdate() {
        updatedAt = LocalDateTime.now();
    }
}


// ===================================

// 파일: backend/src/main/java/com/authentication/auth/domain/SettingsOption.java
package com.authentication.auth.domain;

import java.util.ArrayList;
import java.util.List;
import jakarta.persistence.*;
import lombok.AllArgsConstructor;
import lombok.Data;
import lombok.NoArgsConstructor;

@Entity
@Table(name = "Settings_option")
@Data
@NoArgsConstructor
@AllArgsConstructor
public class SettingsOption {
    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    private Integer id;
    
    @Column(name = "setting_key", nullable = false, unique = true, length = 50)
    private String settingKey;
    
    @Column(name = "default_value", nullable = false)
    private String defaultValue;
    
    @Enumerated(EnumType.STRING)
    @Column(name = "data_type", nullable = false)
    private DataType dataType;
    
    private String description;
    
    @Column(name = "is_user_editable")
    private Boolean isUserEditable = true;
    
    @OneToMany(mappedBy = "settingsOption", cascade = CascadeType.ALL)
    private List<UserCustomSetting> userCustomSettings = new ArrayList<>();
    
    public enum DataType {
        STRING, NUMBER, BOOLEAN, JSON
    }
}


// ===================================

// 파일: backend/src/main/java/com/authentication/auth/domain/UserAuthentication.java
@Entity
@Table(name = "User_Authentication", uniqueConstraints = {
    @UniqueConstraint(columnNames = {"auth_provider_id", "social_id"})
})
@Data
@NoArgsConstructor
@AllArgsConstructor
public class UserAuthentication {
    @EmbeddedId
    private UserAuthenticationId id;
    
    @ManyToOne(fetch = FetchType.LAZY)
    @MapsId("userId")
    @JoinColumn(name = "user_id")
    private User user;
    
    @ManyToOne(fetch = FetchType.LAZY)
    @MapsId("authProviderId")
    @JoinColumn(name = "auth_provider_id")
    private AuthProvider authProvider;
    
    @Column(name = "social_id", nullable = false)
    private String socialId;
    
    private String email;
    
    @Column(name = "created_at")
    private LocalDateTime createdAt;
    
    @Column(name = "updated_at")
    private LocalDateTime updatedAt;
}

@Embeddable
@Data
@NoArgsConstructor
@AllArgsConstructor
public class UserAuthenticationId implements Serializable {
    @Column(name = "user_id")
    private Long userId;
    
    @Column(name = "auth_provider_id")
    private Integer authProviderId;
    
    @Column(name = "social_id")
    private String socialId;
}


// ===================================

// 파일: backend/src/main/java/com/authentication/auth/domain/UserCustomSetting.java
package com.authentication.auth.domain;

@Entity
@Table(name = "User_custom_setting")
@Data
@NoArgsConstructor
@AllArgsConstructor
public class UserCustomSetting {
    @EmbeddedId
    private UserCustomSettingId id;
    
    @ManyToOne(fetch = FetchType.LAZY)
    @MapsId("userId")
    @JoinColumn(name = "user_id")
    private User user;
    
    @ManyToOne(fetch = FetchType.LAZY)
    @MapsId("settingId")
    @JoinColumn(name = "setting_id")
    private SettingsOption settingsOption;
    
    @Column(name = "override_value", nullable = false)
    private String overrideValue;
    
    @Column(name = "created_at")
    private LocalDateTime createdAt;
    
    @Column(name = "updated_at")
    private LocalDateTime updatedAt;
}

@Embeddable
@Data
@NoArgsConstructor
@AllArgsConstructor
public class UserCustomSettingId implements Serializable {
    @Column(name = "user_id")
    private Long userId;
    
    @Column(name = "setting_id")
    private Integer settingId;
}


// ===================================

// 파일: backend/src/main/java/com/authentication/auth/domain/User.java
    /**
     * 사용자 상태를 나타내는 열거형
     * schema.sql의 enum('active','waiting','blocked','suspend','delete') 값과 일치
     */
package com.authentication.auth.domain;

import jakarta.persistence.*;
import lombok.AllArgsConstructor;
import lombok.Data;
import lombok.NoArgsConstructor;
import java.time.LocalDateTime;
import java.util.ArrayList;
import java.util.List;

@Entity
@Table(name = "Users")
@Data
@NoArgsConstructor
@AllArgsConstructor
public class User {
    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    private Long id;

    @Column(nullable = false)
    private String password;

    @Column(name = "created_at")
    private LocalDateTime createdAt;

    @Column(name = "updated_at")
    private LocalDateTime updatedAt;

    @Column(name = "user_name", nullable = false, length = 30)
    private String userName;

    @Enumerated(EnumType.STRING)
    @Column(name = "user_role", nullable = false)
    private UserRole userRole = UserRole.USER;

    @Column(name = "is_premium")
    private Boolean isPremium = false;

    @Column(name = "last_login")
    private LocalDateTime lastLogin;

    @Enumerated(EnumType.STRING)
    @Column(name = "is_active", nullable = false)
    private UserStatus isActive = UserStatus.WAITING;

    @OneToMany(mappedBy = "user")
    private List<Diary> diaries = new ArrayList<>();

    @PrePersist
    protected void onCreate() {
        createdAt = LocalDateTime.now();
        updatedAt = LocalDateTime.now();
    }

    @PreUpdate
    protected void onUpdate() {
        updatedAt = LocalDateTime.now();
    }

    public enum UserRole {
        USER, ADMIN
    }

    /**
     * 사용자 상태를 나타내는 열거형
     * schema.sql의 enum('active','waiting','blocked','suspend','delete') 값과 일치
     */
    public enum UserStatus {
        // DB 스키마의 값과 일치시키기 위해 소문자로 정의
        // JPA에서는 UPPERCASE로 변환하므로 @Enumerated(EnumType.STRING) 사용 시 주의 필요
        ACTIVE("active"), 
        WAITING("waiting"), 
        BLOCKED("blocked"), 
        SUSPEND("suspend"), 
        DELETE("delete");
        
        private final String value;
        
        UserStatus(String value) {
            this.value = value;
        }
        
        public String getValue() {
            return value;
        }
        
        @Override
        public String toString() {
            return value;
        }
    }
}


// ===================================

// 파일: backend/src/main/java/com/authentication/auth/DTO/smtp/customEmailRequest.java
package com.career_block.auth.DTO.smtp;

import lombok.Data;

@Data
public class customEmailRequest {
    private String email;
    private String content;
    private String title;
}


// ===================================

// 파일: backend/src/main/java/com/authentication/auth/DTO/smtp/customEmailToAllRequest.java
package com.career_block.auth.DTO.smtp;

import lombok.Data;

@Data
public class customEmailToAllRequest {
    private String title;
    private String content;
}


// ===================================

// 파일: backend/src/main/java/com/authentication/auth/DTO/smtp/emailCheckDto.java
package com.career_block.auth.DTO.smtp;

import jakarta.validation.constraints.Email;
import jakarta.validation.constraints.NotBlank;
import lombok.Getter;

@Getter
public class emailCheckDto {
    @Email
    @NotBlank
    private String email;
    @NotBlank
    private String code;
}


// ===================================

// 파일: backend/src/main/java/com/authentication/auth/DTO/smtp/emailFindById.java
package com.career_block.auth.DTO.smtp;

import jakarta.validation.constraints.NotBlank;
import lombok.Data;

@Data
public class emailFindById {
    @NotBlank
    private String userId;
}


// ===================================

// 파일: backend/src/main/java/com/authentication/auth/DTO/smtp/emailRequest.java
package com.career_block.auth.DTO.smtp;

import jakarta.validation.constraints.Email;
import jakarta.validation.constraints.NotBlank;
import lombok.Data;

@Data
public class emailRequest {
    @Email
    @NotBlank
    private String email;
}


// ===================================

// 파일: backend/src/main/java/com/authentication/auth/DTO/token/principalDetails.java
package com.career_block.auth.DTO.token;

import lombok.RequiredArgsConstructor;
import lombok.extern.slf4j.Slf4j;
import org.springframework.security.core.GrantedAuthority;
import org.springframework.security.core.authority.SimpleGrantedAuthority;
import org.springframework.security.core.userdetails.UserDetails;

import com.authentication.auth.domain.users;

import java.util.Collection;
import java.util.Collections;

@Slf4j
@RequiredArgsConstructor
public class principalDetails implements UserDetails{

    private final users user;

    @Override
    public Collection<? extends GrantedAuthority> getAuthorities() {
        return Collections.singletonList(new SimpleGrantedAuthority(user.getRole().name()));
    }
    @Override
    public String getPassword() {
        return user.getUserPw();
    }
    @Override
    public String getUsername() {
        return user.getUserName();
    }
    @Override
    public boolean isAccountNonExpired() {
        return true;
    }
    @Override
    public boolean isAccountNonLocked() {
        return true;
    }
    @Override
    public boolean isCredentialsNonExpired() {
        return true;
    }
    @Override
    public boolean isEnabled() {
        return true;
    }
    public String getNickname(){
        return user.getNickname();
    }
    public String getUserId(){
        return user.getUserId();
    }

}


// ===================================

// 파일: backend/src/main/java/com/authentication/auth/DTO/token/TokenDto.java
/**
 * @Author : choisimo
 * @Date : 2025.05.08
 * @Description : Token Data Transfer Object
 * @Detail : accessToken, refreshToken
 * @Refactor : change class type to record type
 * */
/**
 * class TokenDto {
 *     String accessToken;
package com.authentication.auth.DTO.token;


/**
 * @Author : choisimo
 * @Date : 2025.05.08
 * @Description : Token Data Transfer Object
 * @Detail : accessToken, refreshToken
 * @Refactor : change class type to record type
 * */

public record TokenDto(String accessToken, String refreshToken) {}

// same as
/**
 * class TokenDto {
 *     String accessToken;
 *     String refreshToken;
 *
 *     public TokenDto(String accessToken, String refreshToken) {
 *         this.accessToken = accessToken;
 *         this.refreshToken = refreshToken;
 *     }
 *
 *     public String getAccessToken() {
 *         return accessToken;
 *     }
 *
 *     public void setAccessToken(String accessToken) {
 *         this.accessToken = accessToken;
 *     }
 *
 *     public String getRefreshToken() {
 *         return refreshToken;
 *     }
 *
 *     public void setRefreshToken(String refreshToken) {
 *         this.refreshToken = refreshToken;
 *     }
 *
 *     public String toString() {
 *         return "TokenDto [accessToken=" + accessToken + ", refreshToken=" + refreshToken + "]";
 *     }
 *
 *     public int hashCode() {
 *
 *     }
 * }
 *
 * */


// ===================================

// 파일: backend/src/main/java/com/authentication/auth/DTO/token/tokenRefreshRequest.java
package com.career_block.auth.DTO.token;

import lombok.Data;

@Data
public class tokenRefreshRequest {
    private String expiredToken;
    private String provider;
}


// ===================================

// 파일: backend/src/main/java/com/authentication/auth/DTO/users/JoinRequest.java
/**
 * @author: nodove
 * 기존 class -> record 으로 변경 
 * record 매개변수에 직접 @NotBlank 추가
 * 
 * */
package com.authentication.auth.DTO.users;

import com.authentication.auth.domain.User;
import com.fasterxml.jackson.annotation.JsonProperty;
import jakarta.validation.constraints.NotBlank;

import java.util.Date;

/**
 * @author: nodove
 * 기존 class -> record 으로 변경 
 * record 매개변수에 직접 @NotBlank 추가
 * 
 * */
public record JoinRequest(
    @NotBlank String userId,
    @NotBlank String userPw,
    @NotBlank String userName,
    @NotBlank String nickname,
    @NotBlank String phone,
    String email,
    User.UserRole role,
    Date birthDate,
    @NotBlank String gender,
    @JsonProperty("isPrivate") boolean isPrivate,
    String profile,
    String code
) {
    // default 프로필 이미지를 위한 정적 팩토리 메서드 -> 불필요한 객체 생성 방지(생성자 활용, immutable) 목적
    public static JoinRequest of(String userId, String userPw, String userName, String nickname, 
                              String phone, String email, User.UserRole role, Date birthDate, 
                              String gender, boolean isPrivate, String code) {
        return new JoinRequest(userId, userPw, userName, nickname, phone, email, role, 
                            birthDate, gender, isPrivate, "https://zrr.kr/iPHf", code);
    }

    // 사용자 엔티티로 변환하는 메서드
    public User toEntity() {
        return User.builder()
                .userId(this.userId)
                .userPw(this.userPw)
                .userName(this.userName)
                .nickname(this.nickname)
                .phone(this.phone)
                .email(this.email)
                .role(this.role)
                .birthDate(this.birthDate)
                .gender(this.gender)
                .isPrivate(this.isPrivate)
                .profile(this.profile)
                .build();
    }
}


// ===================================

// 파일: backend/src/main/java/com/authentication/auth/DTO/users/loginRequest.java
package com.authentication.auth.DTO.users;

import lombok.Data;

public record LoginRequest(String userId, String password) {}


// ===================================

// 파일: backend/src/main/java/com/authentication/auth/DTO/users/userStat.java
package com.career_block.auth.DTO.users;

import jakarta.validation.constraints.NotBlank;
import lombok.Builder;
import lombok.Data;

import java.time.LocalDateTime;
import java.util.Date;
import java.util.List;

import com.authentication.auth.domain.Role;

@Data
@Builder
public class userStat {
    @NotBlank
    private String userId;
    @NotBlank
    private String nickname;
    private Role role;
    private Date birthDate;
    //private String gender;
    private boolean isPrivate;
    private String profile;
    private List<String> hashtags;
    private List<String> certifications;
    private List<String> groups;
    private LocalDateTime userActivites;
}


// ===================================

// 파일: backend/src/main/java/com/authentication/auth/filter/AbstractAuthenticationFilter.java
/**
 * @Author: choisimo
 * @Date: 2025-05-05
 * @Description: 인증 필터 추상 클래스
 * @Details: 사용자 로그인 요청을 처리하고 JWT 토큰을 생성하는 필터의 기본 구조 정의
 * 
 * 추상(abstract) 클래스 vs 구체적 구현 클래스 차이점:
 * 1. 추상 클래스: 
 *    - 불완전한 설계를 제공하며 상속을 통해 구체적 구현을 강제합니다.
 *    - 자식 클래스가 반드시 구현해야 하는 메소드를 정의할 수 있습니다.
package com.authentication.auth.filter;

import com.authentication.auth.configuration.token.JwtUtility;
import com.authentication.auth.service.RedisService;
import com.fasterxml.jackson.databind.ObjectMapper;
import jakarta.servlet.Filter;
import jakarta.servlet.FilterChain;
import jakarta.servlet.ServletException;
import jakarta.servlet.http.HttpServletRequest;
import jakarta.servlet.http.HttpServletResponse;
import lombok.RequiredArgsConstructor;
import lombok.extern.slf4j.Slf4j;
import org.springframework.security.authentication.AuthenticationManager;
import org.springframework.security.authentication.UsernamePasswordAuthenticationToken;
import org.springframework.security.config.annotation.web.builders.HttpSecurity;
import org.springframework.security.core.Authentication;
import org.springframework.security.core.AuthenticationException;
import org.springframework.security.web.authentication.UsernamePasswordAuthenticationFilter;
import org.springframework.stereotype.Component;

import java.io.IOException;

/**
 * @Author: choisimo
 * @Date: 2025-05-05
 * @Description: 인증 필터 추상 클래스
 * @Details: 사용자 로그인 요청을 처리하고 JWT 토큰을 생성하는 필터의 기본 구조 정의
 * 
 * 추상(abstract) 클래스 vs 구체적 구현 클래스 차이점:
 * 1. 추상 클래스: 
 *    - 불완전한 설계를 제공하며 상속을 통해 구체적 구현을 강제합니다.
 *    - 자식 클래스가 반드시 구현해야 하는 메소드를 정의할 수 있습니다.
 *    - 공통 기능을 제공하면서 확장성을 보장합니다.
 *    - 이 방식은 프레임워크나 라이브러리를 설계할 때 유용합니다.
 *    
 * 2. 구체적 구현 클래스: 
 *    - 직접 인스턴스화 가능하고 모든 메소드가 구현되어 있습니다.
 *    - 특정한 비즈니스 로직에 맞게 최적화되어 있습니다.
 *    - 상속보다는 특정 인터페이스 구현에 중점을 둡니다.
 *    - 이 방식은 실제 애플리케이션 로직을 구현할 때 적합합니다.
 *    
 * 접근 제한자 사용:
 * - private: 클래스 내부에서만 접근 가능한 필드들(authenticationManager 등)은 캡슐화를 위해 사용
 * - protected: 상속 관계에서 자식 클래스에게 접근을 허용하기 위해 일부 메소드에 사용
 * - public: 외부에서 호출 가능한 API를 제공하기 위해 사용
 */
@Slf4j
@Component
@RequiredArgsConstructor
public abstract class AbstractAuthenticationFilter extends UsernamePasswordAuthenticationFilter implements PluggableFilter {
    
    private final AuthenticationManager authenticationManager;
    private final JwtUtility jwtUtility;
    private final ObjectMapper objectMapper;
    private final RedisService redisService;
    private final String domain;
    private final String cookieDomain;
    
    /**
     * 추상 클래스 구현에서는 공통된 인증 로직을 제공합니다.
     * 이 메소드는 public으로 선언되어 Spring Security 필터 체인에서 직접 호출될 수 있습니다.
     * 
     * 반면 구체적 구현 클래스에서는 doFilterInternal 메소드를 활용해 더 세부적인 인증 로직을 구현합니다.
     * 이 방식은 JWT 토큰 검증과 같은 특정 인증 방식에 최적화되어 있습니다.
     */
    @Override
    public Authentication attemptAuthentication(HttpServletRequest request, HttpServletResponse response) throws AuthenticationException {
        log.info("인증 시도");
        try {
            // 사용자 인증 로직
            // 로그인 요청에서 사용자 이름과 비밀번호 추출
            // 인증 관리자를 통해 인증 시도
            return authenticationManager.authenticate(
                    new UsernamePasswordAuthenticationToken(request.getParameter("username"), request.getParameter("password"))
            );
        } catch (Exception e) {
            log.error("인증 시도 중 오류 발생: ", e);
            throw new AuthenticationException("인증 실패") {};
        }
    }
package com.authentication.auth.filter;

import com.authentication.auth.configuration.token.JwtUtility;
import com.authentication.auth.service.RedisService;
import com.fasterxml.jackson.databind.ObjectMapper;
import jakarta.servlet.FilterChain;
import jakarta.servlet.ServletException;
import jakarta.servlet.http.HttpServletRequest;
import jakarta.servlet.http.HttpServletResponse;
import lombok.extern.slf4j.Slf4j;
import org.springframework.security.authentication.AuthenticationManager;
import org.springframework.security.authentication.UsernamePasswordAuthenticationToken;
import org.springframework.security.core.Authentication;
import org.springframework.security.core.AuthenticationException;
import org.springframework.security.web.authentication.UsernamePasswordAuthenticationFilter;

import java.io.IOException;
import java.util.Map;

/**
 * @Author: choisimo
 * @Date: 2025-05-05
 * @Description: 추상 인증 필터
 * @Details: 인증 처리를 위한 기본 기능을 제공하는 추상 필터 클래스
 */
@Slf4j
public abstract class AbstractAuthenticationFilter extends UsernamePasswordAuthenticationFilter implements PluggableFilter {
    
    protected final AuthenticationManager authenticationManager;
    protected final JwtUtility jwtUtility;
    protected final ObjectMapper objectMapper;
    protected final RedisService redisService;
    protected final String domain;
    protected final String cookieDomain;
    
    protected AbstractAuthenticationFilter(
            AuthenticationManager authenticationManager,
            JwtUtility jwtUtility,
            ObjectMapper objectMapper,
            RedisService redisService,
            String domain,
            String cookieDomain) {
        this.authenticationManager = authenticationManager;
        this.jwtUtility = jwtUtility;
        this.objectMapper = objectMapper;
        this.redisService = redisService;
        this.domain = domain;
        this.cookieDomain = cookieDomain;
        
        setAuthenticationManager(authenticationManager);
    }
    
    @Override
    public Authentication attemptAuthentication(HttpServletRequest request, HttpServletResponse response) 
            throws AuthenticationException {
        try {
            // 요청 본문에서 사용자 정보 파싱
            Map<String, String> credentials = objectMapper.readValue(
                    request.getInputStream(), Map.class);
            
            String username = credentials.get("username");
            String password = credentials.get("password");
            
            log.debug("사용자 로그인 시도: {}", username);
            
            // 인증 토큰 생성 및 인증 요청
            UsernamePasswordAuthenticationToken authToken = 
                    new UsernamePasswordAuthenticationToken(username, password);
            
            return authenticationManager.authenticate(authToken);
        } catch (IOException e) {
            log.error("인증 요청 처리 중 오류 발생", e);
            throw new RuntimeException("인증 요청을 처리할 수 없습니다", e);
        }
    }
    
    @Override
    public String getFilterId() {
        return this.getClass().getSimpleName();
    }
}
    @Override
    protected void successfulAuthentication(HttpServletRequest request, HttpServletResponse response,
                                           FilterChain chain, Authentication authResult) throws IOException, ServletException {
        log.info("인증 성공");
        // JWT 토큰 생성 및 응답에 추가
        // SecurityContext에 인증 정보 설정
    }


// ===================================

// 파일: backend/src/main/java/com/authentication/auth/filter/AbstractSecurityFilter.java
/**
 * 모든 보안 필터의 기본 추상 클래스
 * 필터 실행 흐름 제어 및 공통 기능 제공
 */
    /**
     * 필터의 주요 비즈니스 로직 구현
     */
    /**
     * @Author: choisimo
     * @Date: 2025-05-05
package com.authentication.auth.filter;

import jakarta.servlet.Filter;
import jakarta.servlet.FilterChain;
import jakarta.servlet.ServletException;
import jakarta.servlet.ServletRequest;
import jakarta.servlet.ServletResponse;
import jakarta.servlet.http.HttpServletRequest;
import jakarta.servlet.http.HttpServletResponse;
import lombok.extern.slf4j.Slf4j;

import java.io.IOException;

/**
 * 모든 보안 필터의 기본 추상 클래스
 * 필터 실행 흐름 제어 및 공통 기능 제공
 */
@Slf4j
public abstract class AbstractSecurityFilter implements Filter {

    private final SecurityFilterOrder filterOrder;

    protected AbstractSecurityFilter(SecurityFilterOrder filterOrder) {
        this.filterOrder = filterOrder;
    }

    @Override
    public void doFilter(ServletRequest request, ServletResponse response, FilterChain chain)
            throws IOException, ServletException {
        
        HttpServletRequest httpRequest = (HttpServletRequest) request;
        HttpServletResponse httpResponse = (HttpServletResponse) response;
        
        // 필터 건너뛰기 여부 확인
        if (shouldNotFilter(httpRequest)) {
            chain.doFilter(request, response);
            return;
        }
        
        try {
            log.debug("필터 시작: {}", filterOrder.name());
            doFilterInternal(httpRequest, httpResponse, chain);
            log.debug("필터 종료: {}", filterOrder.name());
        } catch (Exception e) {
            log.error("필터 실행 중 오류 발생: {}", filterOrder.name(), e);
            handleFilterException(httpRequest, httpResponse, e);
        }
    }
    
    /**
     * 필터의 주요 비즈니스 로직 구현
     */
    protected abstract void doFilterInternal(HttpServletRequest request, HttpServletResponse response, 
                                           FilterChain chain) throws IOException, ServletException;
    
    package com.authentication.auth.filter;
    
    import jakarta.servlet.Filter;
    import jakarta.servlet.FilterChain;
    import jakarta.servlet.ServletException;
    import jakarta.servlet.ServletRequest;
    import jakarta.servlet.ServletResponse;
    import jakarta.servlet.http.HttpServletRequest;
    import jakarta.servlet.http.HttpServletResponse;
    import lombok.extern.slf4j.Slf4j;
    import org.springframework.web.filter.OncePerRequestFilter;
    
    import java.io.IOException;
    
    /**
     * @Author: choisimo
     * @Date: 2025-05-05
     * @Description: 추상 보안 필터
     * @Details: 모든 보안 필터의 기본 구현을 제공하는 추상 클래스
     */
    @Slf4j
    public abstract class AbstractSecurityFilter extends OncePerRequestFilter implements PluggableFilter {
    
        // 필터 실행 순서
        private final SecurityFilterOrder securityFilterOrder;
    
        /**
         * 생성자
         * @param securityFilterOrder 필터 실행 순서
         */
        protected AbstractSecurityFilter(SecurityFilterOrder securityFilterOrder) {
            this.securityFilterOrder = securityFilterOrder;
        }
    
        @Override
        public final void doFilter(ServletRequest request, ServletResponse response, FilterChain chain)
                throws IOException, ServletException {
            doFilter((HttpServletRequest) request, (HttpServletResponse) response, chain);
        }
    
        /**
         * HTTP 요청에 대한 필터 처리
         * @param request HTTP 요청
         * @param response HTTP 응답
         * @param chain 필터 체인
         * @throws IOException IO 예외 발생 시
         * @throws ServletException 서블릿 예외 발생 시
         */
        private void doFilter(HttpServletRequest request, HttpServletResponse response, FilterChain chain)
                throws IOException, ServletException {
            super.doFilter(request, response, chain);
        }
    
        @Override
        protected final boolean shouldNotFilter(HttpServletRequest request) throws ServletException {
            String path = request.getRequestURI();
            boolean shouldNotFilter = shouldSkipFilter(request);
            
            if (shouldNotFilter) {
                log.trace("필터 건너뜀 ({}): {}", getFilterId(), path);
            } else {
                log.trace("필터 적용 ({}): {}", getFilterId(), path);
            }
            
            return shouldNotFilter;
        }
        
        /**
         * 필터 적용 여부 결정
         * @param request HTTP 요청
         * @return true인 경우 필터 실행 건너뜀
         */
        protected abstract boolean shouldSkipFilter(HttpServletRequest request);
    
        @Override
        public int getOrder() {
            return securityFilterOrder.getOrder();
        }
        
        @Override
        public String getFilterId() {
            return this.getClass().getSimpleName();
        }
    }
    
    /**
     * 필터 예외 처리 메서드
     */
    protected void handleFilterException(HttpServletRequest request, HttpServletResponse response, Exception e) 
            throws IOException, ServletException {
        // 기본 구현에서는 예외를 전파
        // 필요시 하위 클래스에서 재정의
        if (e instanceof IOException) {
            throw (IOException) e;
        } else if (e instanceof ServletException) {
            throw (ServletException) e;
        } else {
            throw new ServletException("필터 처리 중 오류 발생", e);
        }
    }
    
    /**
     * 필터 순서 반환
     */
    public int getOrder() {
        return filterOrder.getOrder();
    }
}


// ===================================

// 파일: backend/src/main/java/com/authentication/auth/filter/ApiChecker.java
/**
 * 필터 적용 여부를 결정하는 API 요청 검사 클래스
 */
    /**
     * 요청이 필터를 적용하지 않아도 되는지 검사
     * @param request HTTP 요청
     * @return true일 경우 필터 적용 제외
     */
package com.authentication.auth.filter;

import jakarta.servlet.http.HttpServletRequest;
import lombok.extern.slf4j.Slf4j;
import org.springframework.stereotype.Component;

import java.util.Arrays;
import java.util.List;

/**
 * 필터 적용 여부를 결정하는 API 요청 검사 클래스
 */
@Slf4j
@Component
public class ApiChecker {

    // 인증 필터를 적용하지 않을 공개 경로 목록
    private final List<String> PUBLIC_PATHS = Arrays.asList(
        "/api/auth/login",
        "/api/auth/register",
        "/api/auth/refresh",
        "/swagger-ui",
        "/v3/api-docs",
        "/h2-console",
        "/error",
        "/favicon.ico"
    );

    /**
     * 요청이 필터를 적용하지 않아도 되는지 검사
     * @param request HTTP 요청
     * @return true일 경우 필터 적용 제외
     */
    public boolean checkRequestAPI(HttpServletRequest request) {
        String requestURI = request.getRequestURI();
        
        // 허용된 경로인지 확인
        for (String path : PUBLIC_PATHS) {
            if (requestURI.startsWith(path)) {
                log.debug("필터 적용 제외 경로: {}", requestURI);
                return true;
            }
        }
        
        // OPTIONS 메서드는 필터링 제외 (CORS preflight 요청)
        if ("OPTIONS".equalsIgnoreCase(request.getMethod())) {
            return true;
        }
        
        return false;
    }
}


// ===================================

// 파일: backend/src/main/java/com/authentication/auth/filter/authenticationFilter.java
/**
 * @Author: choisimo
 * @Date: 2025-05-05
 * @Description: JWT 인증 필터
 * @Details: 사용자 로그인 요청을 처리하고, 인증 성공 시 JWT 토큰을 발급하는 필터
 * @Usage: Spring Security 필터 체인에 등록하여 사용
 */
    /**
     * 인증 필터 생성자
     * @param authenticationManager Spring Security 인증 관리자
package com.career_block.auth.filter;

import com.authentication.auth.DTO.token.principalDetails;
import com.authentication.auth.DTO.token.tokenDto;
import com.authentication.auth.DTO.users.loginRequest;
import com.authentication.auth.configuration.token.jwtUtility;
import com.authentication.auth.others.constants.SecurityConstants;
import com.authentication.auth.service.redis.redisService;
import com.fasterxml.jackson.databind.ObjectMapper;
import jakarta.servlet.FilterChain;
import jakarta.servlet.http.Cookie;
import jakarta.servlet.http.HttpServletRequest;
import jakarta.servlet.http.HttpServletResponse;
import lombok.extern.slf4j.Slf4j;
import org.springframework.http.HttpStatus;
package com.authentication.auth.filter;

import com.authentication.auth.domain.User;
import com.authentication.auth.service.redis.RedisService;
import com.authentication.auth.utility.JwtUtility;
import jakarta.servlet.ServletException;
import jakarta.servlet.ServletRequest;
import jakarta.servlet.ServletResponse;
import org.springframework.http.MediaType;
import org.springframework.security.authentication.AuthenticationManager;
import org.springframework.security.authentication.BadCredentialsException;
import org.springframework.security.authentication.UsernamePasswordAuthenticationToken;
import org.springframework.security.core.Authentication;
import org.springframework.security.core.AuthenticationException;
import org.springframework.security.core.userdetails.UserDetails;
import org.springframework.security.web.authentication.UsernamePasswordAuthenticationFilter;
import org.springframework.security.web.util.matcher.AntPathRequestMatcher;

import java.io.IOException;
import java.time.LocalDateTime;
import java.util.HashMap;
import java.util.Map;
import java.util.Objects;
import java.util.UUID;

/**
 * @Author: choisimo
 * @Date: 2025-05-05
 * @Description: JWT 인증 필터
 * @Details: 사용자 로그인 요청을 처리하고, 인증 성공 시 JWT 토큰을 발급하는 필터
 * @Usage: Spring Security 필터 체인에 등록하여 사용
 */
@Slf4j
public class AuthenticationFilter extends UsernamePasswordAuthenticationFilter implements PluggableFilter {

    private final AuthenticationManager authenticationManager;
    private final JwtUtility jwtUtility;
    private final ObjectMapper objectMapper;
    private final RedisService redisService;
    private final String domain;
    private final String cookieDomain;

    /**
     * 인증 필터 생성자
     * @param authenticationManager Spring Security 인증 관리자
     * @param jwtUtility JWT 토큰 유틸리티
     * @param objectMapper JSON 변환용 객체 매퍼
     * @param redisService Redis 서비스 (토큰 저장용)
     * @param domain 애플리케이션 도메인
     * @param cookieDomain 쿠키에 사용할 도메인
     */
    public AuthenticationFilter(AuthenticationManager authenticationManager, JwtUtility jwtUtility, ObjectMapper objectMapper, RedisService redisService, String domain, String cookieDomain) {
        this.authenticationManager = authenticationManager;
        this.jwtUtility = jwtUtility;
        this.objectMapper = objectMapper;
        this.redisService = redisService;
        this.domain = domain;
        this.cookieDomain = cookieDomain;
        // 로그인 URL 설정 - POST /api/auth/login으로 변경
        setRequiresAuthenticationRequestMatcher(new AntPathRequestMatcher("/api/auth/login", "POST"));
    }

    /**
     * 사용자 인증 시도 메서드
     * 요청에서 사용자 자격 증명을 추출하고 인증을 시도합니다.
     * @param request HTTP 요청
     * @param response HTTP 응답
     * @return 인증 객체
     * @throws AuthenticationException 인증 예외
     */
    @Override
    public Authentication attemptAuthentication(HttpServletRequest request, HttpServletResponse response)
            throws AuthenticationException {
        log.info("인증 시도: {}", request.getRequestURI());
        
        try {
            // 요청 바디에서 사용자 자격 증명 추출
            Map<String, String> credentials = objectMapper.readValue(request.getInputStream(), Map.class);
            String username = credentials.get("username");
            String password = credentials.get("password");
            
            if (username == null || password == null) {
                throw new BadCredentialsException("사용자 이름 또는 비밀번호가 누락되었습니다.");
            }
            
            log.debug("사용자 인증 시도: {}", username);
            
            // 인증 토큰 생성 및 인증 시도
            UsernamePasswordAuthenticationToken authenticationToken = 
                new UsernamePasswordAuthenticationToken(username, password);
                
            return authenticationManager.authenticate(authenticationToken);
        } catch (IOException e) {
            log.error("인증 요청 처리 중 오류 발생: {}", e.getMessage());
            throw new BadCredentialsException("인증 요청을 처리할 수 없습니다.");
        }
    }

    /**
     * 인증 성공 처리 메서드
     * 인증 성공 시 JWT 토큰을 생성하고 클라이언트에게 제공합니다.
     * @param request HTTP 요청
     * @param response HTTP 응답
     * @param chain 필터 체인
     * @param authResult 인증 결과
     * @throws IOException IO 예외
     * @throws ServletException 서블릿 예외
     */
    @Override
    protected void successfulAuthentication(HttpServletRequest request, HttpServletResponse response,
                                           FilterChain chain, Authentication authResult) 
                                           throws IOException, ServletException {
        log.info("인증 성공 처리");
        
        UserDetails userDetails = (UserDetails) authResult.getPrincipal();
        String username = userDetails.getUsername();
        
        // 액세스 토큰 생성
        String accessToken = jwtUtility.generateAccessToken(username, userDetails.getAuthorities());
        
        // 리프레시 토큰 생성 및 Redis에 저장
        String refreshTokenId = UUID.randomUUID().toString();
        String refreshToken = jwtUtility.generateRefreshToken(username, refreshTokenId);
        
        // 사용자 ID 정보 추출
        User user = (User) userDetails;
        String userId = user.getId().toString();
        
        // Redis에 리프레시 토큰 저장 (사용자 ID와 함께)
        String redisKey = "JWT_RToken_" + userId + "_" + refreshTokenId;
        redisService.setValueWithExpiration(redisKey, refreshToken, jwtUtility.getRefreshTokenExpiration());
        
        // 액세스 토큰과 리프레시 토큰을 쿠키에 설정
        Cookie accessTokenCookie = createCookie("access_token", accessToken, jwtUtility.getAccessTokenExpiration() / 1000);
        Cookie refreshTokenCookie = createCookie("refresh_token", refreshToken, jwtUtility.getRefreshTokenExpiration() / 1000);
        
        response.addCookie(accessTokenCookie);
        response.addCookie(refreshTokenCookie);
        
        // 응답 데이터 구성
        Map<String, Object> responseData = new HashMap<>();
        responseData.put("status", "success");
        responseData.put("message", "로그인 성공");
        responseData.put("timestamp", LocalDateTime.now().toString());
        
        // JSON 응답 전송
        response.setContentType(MediaType.APPLICATION_JSON_VALUE);
        response.setStatus(HttpStatus.OK.value());
        objectMapper.writeValue(response.getWriter(), responseData);
        
        log.debug("사용자 {} 인증 완료, 토큰 발급 성공", username);
    }

    /**
     * 쿠키 생성 헬퍼 메서드
     * @param name 쿠키 이름
     * @param value 쿠키 값
     * @param maxAge 쿠키 만료 시간 (초)
     * @return 생성된 쿠키
     */
    private Cookie createCookie(String name, String value, long maxAge) {
        Cookie cookie = new Cookie(name, value);
        cookie.setHttpOnly(true);
        cookie.setSecure(true); // HTTPS에서만 전송
        cookie.setPath("/");
        cookie.setDomain(cookieDomain);
        cookie.setMaxAge((int) maxAge);
        return cookie;
    }

    /**
     * 인증 실패 처리 메서드
     * 인증 실패 시 적절한 오류 메시지를 클라이언트에게 제공합니다.
     * @param request HTTP 요청
     * @param response HTTP 응답
     * @param failed 인증 예외
     * @throws IOException IO 예외
     * @throws ServletException 서블릿 예외
     */
    @Override
    protected void unsuccessfulAuthentication(HttpServletRequest request, HttpServletResponse response,
                                             AuthenticationException failed) 
                                             throws IOException, ServletException {
        log.warn("인증 실패: {}", failed.getMessage());
        
        Map<String, Object> errorResponse = new HashMap<>();
        errorResponse.put("status", "error");
        errorResponse.put("message", "로그인 실패: 사용자 이름 또는 비밀번호가 올바르지 않습니다.");
        errorResponse.put("timestamp", LocalDateTime.now().toString());
        
        response.setContentType(MediaType.APPLICATION_JSON_VALUE);
        response.setStatus(HttpStatus.UNAUTHORIZED.value());
        objectMapper.writeValue(response.getWriter(), errorResponse);
    }

    /**
     * PluggableFilter 인터페이스 구현
     * 필터 설정 메서드
     */
    @Override
    public void configure(HttpSecurity http) throws Exception {
        http.addFilter(this);
    }

    /**
     * PluggableFilter 인터페이스 구현
     * 필터 순서 반환 메서드
     */
    @Override
    public int getOrder() {
        return 2; // 인증 필터는 우선순위가 비교적 높아야 함
    }

    /**
     * PluggableFilter 인터페이스 구현
     * 이 필터 이전에 적용될 필터 클래스 반환
     */
    @Override
    public Class<? extends Filter> getBeforeFilter() {
        return UsernamePasswordAuthenticationFilter.class;
    }

    /**
     * PluggableFilter 인터페이스 구현
     * 이 필터 이후에 적용될 필터 클래스 반환
     */
    @Override
    public Class<? extends Filter> getAfterFilter() {
        return null; // 현재 필터 이후에 특정 필터가 없음
    }

    /**
     * PluggableFilter 인터페이스 구현
     * 필터 체인 로직 실행 메서드
     */
    @Override
    public void doFilter(ServletRequest request, ServletResponse response, FilterChain chain) 
            throws IOException, ServletException {
        // 기본 필터 로직은 UsernamePasswordAuthenticationFilter에서 상속됨
        // 추가 필터 로직이 필요한 경우 여기에 구현
        super.doFilter(request, response, chain);
    }
}
            throws AuthenticationException {
        log.info("╔═══════════════════════════════════════════════════════════════╗");
        log.info("║                       Authentication Filter                   ║");
        log.info("╚═══════════════════════════════════════════════════════════════╝");
        if (request.getCookies() != null) log.debug("request.getCookies() is not null");//jwtutility.deleteHttpOnlyCookie(request, response);

        // JSON 요청에서 사용자 로그인 정보 읽기
        loginRequest loginRequest;
        try {
            log.info("get loginRequest");
            loginRequest = objectMapper.readValue(request.getInputStream(), loginRequest.class);
        } catch (IOException e) {
            throw new RuntimeException(e);
        }

        log.info("login, userId : {}",loginRequest.getUserId());

        UsernamePasswordAuthenticationToken authenticationToken =
                new UsernamePasswordAuthenticationToken(loginRequest.getUserId(), loginRequest.getPassword());

        log.info("login, authentication token created successfully");

        // 사용자 인증 시도
        Authentication authentication = null;
        try{
            authentication = authenticationManager.authenticate(authenticationToken);
        } catch (Exception e){
            log.error("authentication processing error", e);
        }

        if(!Objects.requireNonNull(authentication).isAuthenticated()){
            log.error("authentication failed");
            response.setStatus(401);
        }

        return authentication;
    }


    @Override
    protected void successfulAuthentication(HttpServletRequest request, HttpServletResponse response,
                                            FilterChain filterChain, Authentication authentication) throws  IOException{

        principalDetails principalDetails = (principalDetails) authentication.getPrincipal();
        tokenDto tokendto = jwtUtility.buildToken(principalDetails.getUserId(),
                principalDetails.getNickname(), principalDetails.getAuthorities());

        log.info("Authentication successful for userId : {}", principalDetails.getUserId());
        log.info("Authentication token dto created");

        boolean RTokenSave = redisService.saveRToken(principalDetails.getUserId(), "server", tokendto.getRefreshToken());
        boolean accessTokenSave = redisService.saveAccessToken(tokendto.getRefreshToken(), tokendto.getAccessToken(), principalDetails.getUserId());
        log.info("redis save result R : {}, A : {} for userId {}", RTokenSave, accessTokenSave, principalDetails.getUserId());
        if (accessTokenSave && RTokenSave && jwtUtility.validateRefreshJWT(tokendto.getRefreshToken())){

            loginResponse(response, tokendto);

            response.setContentType("application/json");
            response.setCharacterEncoding("UTF-8");
            response.setStatus(HttpStatus.OK.value());

            // JSON 형식으로 응답 생성 및 전송 (access_token)
            String jsonResponse = new ObjectMapper().writeValueAsString(Map.of(
                    "access_token", tokendto.getAccessToken()
            ));
            response.getWriter().write(jsonResponse);

        } else {
            log.error("REDIS token save failed return SERVER_INTERNAL_ERROR");
            response.setStatus(HttpStatus.INTERNAL_SERVER_ERROR.value());
        }
    }


    private void loginResponse(HttpServletResponse response, tokenDto tokendto){
        Cookie newCookie = new Cookie("refreshToken", tokendto.getRefreshToken());
        newCookie.setHttpOnly(true);
        newCookie.setDomain(cookieDomain);
        newCookie.setPath("/");
        response.addCookie(newCookie);
        response.addHeader(SecurityConstants.TOKEN_HEADER,
                SecurityConstants.TOKEN_PREFIX + tokendto.getAccessToken());
    }

}


// ===================================

// 파일: backend/src/main/java/com/authentication/auth/filter/AuthenticationFilter.java
/**
 * @Author: choisimo
 * @Date: 2025-05-05
 * @Description: 사용자 인증 필터
 * @Details: 사용자 로그인 요청을 처리하고 JWT 토큰을 생성하는 필터의 구체적인 구현
 *          유동적인 필터 조건 지원을 위해 개선됨
 */
    /**
     * 필터 초기화 및 레지스트리에 등록
     */
package com.authentication.auth.filter;

import com.authentication.auth.configuration.token.JwtUtility;
import com.authentication.auth.service.RedisService;
import com.fasterxml.jackson.databind.ObjectMapper;
import jakarta.servlet.Filter;
import jakarta.servlet.FilterChain;
import jakarta.servlet.ServletException;
import jakarta.servlet.http.Cookie;
import jakarta.servlet.http.HttpServletRequest;
import jakarta.servlet.http.HttpServletResponse;
import lombok.extern.slf4j.Slf4j;
import org.springframework.security.authentication.AuthenticationManager;
import org.springframework.security.authentication.UsernamePasswordAuthenticationToken;
import org.springframework.security.config.annotation.web.builders.HttpSecurity;
import org.springframework.security.core.Authentication;
import org.springframework.security.core.AuthenticationException;
import org.springframework.security.core.context.SecurityContextHolder;
import org.springframework.security.core.userdetails.UserDetails;
import org.springframework.stereotype.Component;

import java.io.IOException;
import java.util.HashMap;
package com.authentication.auth.filter;

import com.authentication.auth.configuration.token.JwtUtility;
import com.authentication.auth.service.RedisService;
import com.fasterxml.jackson.databind.ObjectMapper;
import jakarta.annotation.PostConstruct;
import jakarta.servlet.Filter;
import jakarta.servlet.FilterChain;
import jakarta.servlet.ServletException;
import jakarta.servlet.http.Cookie;
import jakarta.servlet.http.HttpServletRequest;
import jakarta.servlet.http.HttpServletResponse;
import lombok.extern.slf4j.Slf4j;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.http.HttpMethod;
import org.springframework.security.authentication.AuthenticationManager;
import org.springframework.security.authentication.UsernamePasswordAuthenticationToken;
import org.springframework.security.config.annotation.web.builders.HttpSecurity;
import org.springframework.security.core.Authentication;
import org.springframework.security.core.AuthenticationException;
import org.springframework.security.core.context.SecurityContextHolder;
import org.springframework.security.core.userdetails.UserDetails;
import org.springframework.stereotype.Component;

import java.io.IOException;
import java.util.HashMap;
import java.util.Map;

/**
 * @Author: choisimo
 * @Date: 2025-05-05
 * @Description: 사용자 인증 필터
 * @Details: 사용자 로그인 요청을 처리하고 JWT 토큰을 생성하는 필터의 구체적인 구현
 *          유동적인 필터 조건 지원을 위해 개선됨
 */
@Slf4j
@Component
public class AuthenticationFilter extends AbstractAuthenticationFilter {
    
    private final FilterRegistry filterRegistry;
    
    @Autowired
    public AuthenticationFilter(
            AuthenticationManager authenticationManager,
            JwtUtility jwtUtility,
            ObjectMapper objectMapper,
            RedisService redisService,
            String domain,
            String cookieDomain,
            FilterRegistry filterRegistry) {
        super(authenticationManager, jwtUtility, objectMapper, redisService, domain, cookieDomain);
        this.filterRegistry = filterRegistry;
        setFilterProcessesUrl("/api/auth/login"); // 로그인 URL 설정
    }
    
    /**
     * 필터 초기화 및 레지스트리에 등록
     */
    @PostConstruct
    public void init() {
        // 필터 레지스트리에 이 필터 등록
        filterRegistry.registerFilter(this);
        
        // 기본 필터 조건 설정 - 공개 API는 인증 필터 적용하지 않음
        PathPatternFilterCondition publicApiCondition = new PathPatternFilterCondition(
                "공개 API 경로 제외",
                "/api/public/**", 
                "/api/auth/register", 
                "/api/auth/refresh",
                "/swagger-ui/**", 
                "/v3/api-docs/**"
        );
        
        // 로그인 경로에는 POST 메소드만 허용하고 다른 메소드는 필터링
        PathPatternFilterCondition loginPathCondition = new PathPatternFilterCondition(
                "로그인 경로 메소드 제한",
                new HttpMethod[] {HttpMethod.GET, HttpMethod.PUT, HttpMethod.DELETE},
                "/api/auth/login"
        );
        
        // 필터 레지스트리에 조건 추가
        filterRegistry.addCondition(getFilterId(), publicApiCondition);
        filterRegistry.addCondition(getFilterId(), loginPathCondition);
    }

    @Override
    public Authentication attemptAuthentication(HttpServletRequest request, HttpServletResponse response) 
            throws AuthenticationException {
        // 필터 적용 여부 검사
        if (shouldNotFilter(request)) {
            log.debug("인증 필터 적용되지 않음: {}", request.getRequestURI());
            return null;
        }
        
        log.info("인증 시도: {}", request.getRequestURI());
        return super.attemptAuthentication(request, response);
    }

    @Override
    protected void successfulAuthentication(HttpServletRequest request, HttpServletResponse response,
                                           FilterChain chain, Authentication authResult) throws IOException, ServletException {
        log.info("로그인 성공: 토큰 생성 시작");
        
        UserDetails userDetails = (UserDetails) authResult.getPrincipal();
        String username = userDetails.getUsername();
        
        // 액세스 및 리프레시 토큰 생성
        String accessToken = jwtUtility.generateAccessToken(username);
        String refreshToken = jwtUtility.generateRefreshToken(username);
        
        // 리프레시 토큰을 Redis에 저장
        redisService.setData("RT:" + username, refreshToken, jwtUtility.getRefreshTokenExpirationTime());
        
        // 토큰을 쿠키에 저장
        Cookie accessTokenCookie = new Cookie("access_token", accessToken);
        accessTokenCookie.setHttpOnly(true);
        accessTokenCookie.setPath("/");
        accessTokenCookie.setDomain(cookieDomain);
        accessTokenCookie.setSecure(true);
        
        Cookie refreshTokenCookie = new Cookie("refresh_token", refreshToken);
        refreshTokenCookie.setHttpOnly(true);
        refreshTokenCookie.setPath("/");
        refreshTokenCookie.setDomain(cookieDomain);
        refreshTokenCookie.setSecure(true);
        
        response.addCookie(accessTokenCookie);
        response.addCookie(refreshTokenCookie);
        
        // 응답 본문에도 토큰 정보 포함
        Map<String, String> tokens = new HashMap<>();
        tokens.put("access_token", accessToken);
        tokens.put("refresh_token", refreshToken);
        tokens.put("username", username);
        
        response.setContentType("application/json");
        objectMapper.writeValue(response.getOutputStream(), tokens);
        
        // SecurityContext에 인증 정보 설정
        SecurityContextHolder.getContext().setAuthentication(authResult);
        
        log.info("로그인 성공: 토큰 생성 완료 및 쿠키 설정");
    }
    
    @Override
    protected void unsuccessfulAuthentication(HttpServletRequest request, HttpServletResponse response,
                                             AuthenticationException failed) throws IOException, ServletException {
        log.error("로그인 실패: {}", failed.getMessage());
        
        SecurityContextHolder.clearContext();
        
        response.setStatus(HttpServletResponse.SC_UNAUTHORIZED);
        response.setContentType("application/json");
        
        Map<String, String> error = new HashMap<>();
        error.put("error", "인증 실패");
        error.put("message", failed.getMessage());
        
        objectMapper.writeValue(response.getOutputStream(), error);
    }
    
    /**
     * 동적 필터 조건을 통해 필터 적용 여부 결정
     */
    protected boolean shouldNotFilter(HttpServletRequest request) {
        return filterRegistry.shouldNotFilter(getFilterId(), request);
    }
    
    @Override
    public void configure(HttpSecurity http) throws Exception {
        http.addFilterAt(this, AbstractAuthenticationFilter.class);
        log.debug("인증 필터 HttpSecurity에 구성됨");
    }
    
    @Override
    public int getOrder() {
        return SecurityFilterOrder.AUTHENTICATION_FILTER.getOrder();
    }
    
    @Override
    public Class<? extends Filter> getBeforeFilter() {
        return null; // 이 필터 이전에 실행되어야 하는 필터가 없음
    }
    
    @Override
    public Class<? extends Filter> getAfterFilter() {
        return JwtVerificationFilter.class; // JWT 검증 필터 이전에 실행
    }
    
    /**
     * 필터에 새로운 조건 추가
     * @param condition 추가할 필터 조건
     */
    public void addFilterCondition(FilterCondition condition) {
        filterRegistry.addCondition(getFilterId(), condition);
    }
    
    /**
     * 필터에서 조건 제거
     * @param condition 제거할 필터 조건
     * @return 제거 성공 여부
     */
    public boolean removeFilterCondition(FilterCondition condition) {
        return filterRegistry.removeCondition(getFilterId(), condition);
    }
}
            String cookieDomain,
            ApiChecker apiChecker) {
        super(authenticationManager, jwtUtility, objectMapper, redisService, domain, cookieDomain);
        this.apiChecker = apiChecker;
        setFilterProcessesUrl("/api/auth/login"); // 로그인 URL 설정
    }
    
    @Override
    public Authentication attemptAuthentication(HttpServletRequest request, HttpServletResponse response) 
            throws AuthenticationException {
        // 부모 클래스의 인증 메소드 호출
        return super.attemptAuthentication(request, response);
    }

    @Override
    protected void successfulAuthentication(HttpServletRequest request, HttpServletResponse response,
                                           FilterChain chain, Authentication authResult) throws IOException, ServletException {
        log.info("로그인 성공: 토큰 생성 시작");
        
        UserDetails userDetails = (UserDetails) authResult.getPrincipal();
        String username = userDetails.getUsername();
        
        // 액세스 및 리프레시 토큰 생성
        String accessToken = jwtUtility.generateAccessToken(username);
        String refreshToken = jwtUtility.generateRefreshToken(username);
        
        // 리프레시 토큰을 Redis에 저장
        redisService.setData("RT:" + username, refreshToken, jwtUtility.getRefreshTokenExpirationTime());
        
        // 토큰을 쿠키에 저장
        Cookie accessTokenCookie = new Cookie("access_token", accessToken);
        accessTokenCookie.setHttpOnly(true);
        accessTokenCookie.setPath("/");
        accessTokenCookie.setDomain(cookieDomain);
        accessTokenCookie.setSecure(true);
        
        Cookie refreshTokenCookie = new Cookie("refresh_token", refreshToken);
        refreshTokenCookie.setHttpOnly(true);
        refreshTokenCookie.setPath("/");
        refreshTokenCookie.setDomain(cookieDomain);
        refreshTokenCookie.setSecure(true);
        
        response.addCookie(accessTokenCookie);
        response.addCookie(refreshTokenCookie);
        
        // 응답 본문에도 토큰 정보 포함
        Map<String, String> tokens = new HashMap<>();
        tokens.put("access_token", accessToken);
        tokens.put("refresh_token", refreshToken);
        
        response.setContentType("application/json");
        objectMapper.writeValue(response.getOutputStream(), tokens);
        
        // SecurityContext에 인증 정보 설정
        SecurityContextHolder.getContext().setAuthentication(authResult);
        
        log.info("로그인 성공: 토큰 생성 완료 및 쿠키 설정");
    }
    
    @Override
    protected void unsuccessfulAuthentication(HttpServletRequest request, HttpServletResponse response,
                                             AuthenticationException failed) throws IOException, ServletException {
        log.error("로그인 실패: {}", failed.getMessage());
        
        SecurityContextHolder.clearContext();
        
        response.setStatus(HttpServletResponse.SC_UNAUTHORIZED);
        response.setContentType("application/json");
        
        Map<String, String> error = new HashMap<>();
        error.put("error", "인증 실패");
        error.put("message", failed.getMessage());
        
        objectMapper.writeValue(response.getOutputStream(), error);
    }
    
    @Override
    public void configure(HttpSecurity http) throws Exception {
        http.addFilterAt(this, AbstractAuthenticationFilter.class);
    }
    
    @Override
    public int getOrder() {
        return 100; // 기본 인증 필터 순서
    }
    
    @Override
    public Class<? extends Filter> getBeforeFilter() {
        return null; // 이 필터 이전에 실행되어야 하는 필터가 없음
    }
    
    @Override
    public Class<? extends Filter> getAfterFilter() {
        return JwtVerificationFilter.class; // JWT 검증 필터 이전에 실행
    }
}
    
    /**
     * extends와 implements 복수 사용에 관한 설명:
     * 
     * 1. 다중 상속 구조:
     *    - Java에서는 단일 상속만 가능합니다(extends는 한 클래스만 가능)
     *    - 하지만 복수의 인터페이스 구현(implements)은 가능합니다
     *    - 추상 클래스 예제에서는 UsernamePasswordAuthenticationFilter를 상속하면서
     *      PluggableFilter 인터페이스를 구현하는 방식을 사용했습니다
     * 
     * 2. 장점:
     *    - 상속(extends)을 통해 기존 클래스의 기능을 재사용
     *    - 인터페이스 구현(implements)을 통해 다양한 계약을 준수
     *    - 유연한 설계 가능: 하나의 클래스가 다양한 역할 수행 가능
     * 
     * 3. 단점:
     *    - 복잡한 상속 구조는 코드 이해를 어렵게 만들 수 있음
     *    - 다이아몬드 문제 발생 가능(상속 계층이 복잡할 때)
     *    - 상위 클래스 변경 시 하위 클래스에 영향
     * 
     * 4. 구체적 구현 클래스에서는:
     *    - AbstractSecurityFilter를 상속하는 더 단순한 구조 채택
     *    - 명확한 책임과 역할 분리로 유지보수성 향상
     */


// ===================================

// 파일: backend/src/main/java/com/authentication/auth/filter/authorizationFilter.java
/**
 * @Author: choisimo
 * @Date: 2025-05-05
 * @Description: 권한 부여 필터
 * @Details: JWT 토큰의 유효성을 검증하고 사용자 권한을 검사하는 필터
 */
    /**
     * 필터 초기화 및 레지스트리에 등록
     */
                "/api/public/**",
package com.authentication.auth.filter;
package com.authentication.auth.filter;

import com.authentication.auth.configuration.token.JwtUtility;
import com.fasterxml.jackson.databind.ObjectMapper;
import jakarta.annotation.PostConstruct;
import jakarta.servlet.Filter;
import jakarta.servlet.FilterChain;
import jakarta.servlet.ServletException;
import jakarta.servlet.http.HttpServletRequest;
import jakarta.servlet.http.HttpServletResponse;
import lombok.extern.slf4j.Slf4j;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.http.HttpMethod;
import org.springframework.http.MediaType;
import org.springframework.security.authentication.UsernamePasswordAuthenticationToken;
import org.springframework.security.config.annotation.web.builders.HttpSecurity;
import org.springframework.security.core.Authentication;
import org.springframework.security.core.authority.SimpleGrantedAuthority;
import org.springframework.security.core.context.SecurityContextHolder;
import org.springframework.stereotype.Component;

import java.io.IOException;
import java.util.Collections;
import java.util.HashMap;
import java.util.Map;
import java.util.Set;

/**
 * @Author: choisimo
 * @Date: 2025-05-05
 * @Description: 권한 부여 필터
 * @Details: JWT 토큰의 유효성을 검증하고 사용자 권한을 검사하는 필터
 */
@Slf4j
@Component
public class authorizationFilter extends AbstractSecurityFilter {

    private final JwtUtility jwtUtility;
    private final ObjectMapper objectMapper;
    private final FilterRegistry filterRegistry;
    private final Set<String> adminRoles = Set.of("ROLE_ADMIN", "ADMIN");

    @Autowired
    public authorizationFilter(
            JwtUtility jwtUtility,
            ObjectMapper objectMapper,
            FilterRegistry filterRegistry) {
        super(SecurityFilterOrder.AUTHORIZATION_FILTER);
        this.jwtUtility = jwtUtility;
        this.objectMapper = objectMapper;
        this.filterRegistry = filterRegistry;
    }

    /**
     * 필터 초기화 및 레지스트리에 등록
     */
    @PostConstruct
    public void init() {
        // 필터 레지스트리에 이 필터 등록
        filterRegistry.registerFilter(this);

        // 기본 필터 조건 설정 - 공개 API는 권한 필터 적용하지 않음
        PathPatternFilterCondition publicApiCondition = new PathPatternFilterCondition(
                "권한 확인 불필요 경로",
                "/api/public/**",
                "/api/auth/login",
                "/api/auth/register",
                "/api/auth/refresh",
                "/swagger-ui/**",
                "/v3/api-docs/**"
        );

        // 관리자 전용 API는 ADMIN 역할 필요
        PathPatternFilterCondition adminApiCondition = new PathPatternFilterCondition(
                "관리자 전용 API",
                "/api/admin/**"
        );

        // 필터 레지스트리에 조건 추가
        filterRegistry.addCondition(getFilterId(), publicApiCondition);
    }

    @Override
    protected void doFilterInternal(HttpServletRequest request, HttpServletResponse response, FilterChain chain)
            throws IOException, ServletException {
        
        String path = request.getRequestURI();
        log.debug("권한 부여 필터 실행: {}", path);
        
        try {
            // 토큰에서 인증 정보 추출
            String token = extractToken(request);
            
            if (token != null && jwtUtility.validateToken(token)) {
                String username = jwtUtility.getUsernameFromToken(token);
                Set<String> roles = jwtUtility.getRolesFromToken(token);
                
                // 관리자 전용 API 접근 제한
                if (path.startsWith("/api/admin") && !hasAdminRole(roles)) {
                    sendForbiddenResponse(response, "관리자 권한이 필요합니다.");
                    return;
                }
                
                // 인증 정보 설정
                Authentication authentication = createAuthentication(username, roles);
                SecurityContextHolder.getContext().setAuthentication(authentication);
                
                log.debug("사용자 '{}' 인증 성공, 권한: {}", username, roles);
            }
            
            chain.doFilter(request, response);
        } catch (Exception e) {
            log.error("권한 부여 필터 실행 중 오류 발생: {}", e.getMessage());
            sendErrorResponse(response, "인증 처리 중 오류가 발생했습니다: " + e.getMessage());
        } finally {
            // 이미 응답이 커밋되지 않은 경우에만 필터 체인 계속 진행
            if (!response.isCommitted()) {
                chain.doFilter(request, response);
            }
        }
    }

    /**
     * 요청에서 JWT 토큰 추출
     */
    private String extractToken(HttpServletRequest request) {
        String authHeader = request.getHeader("Authorization");
        
        if (authHeader != null && authHeader.startsWith("Bearer ")) {
            return authHeader.substring(7);
        }
        
        return null;
    }

    /**
     * 사용자가 관리자 권한을 가지고 있는지 확인
     */
    private boolean hasAdminRole(Set<String> roles) {
        return roles.stream().anyMatch(adminRoles::contains);
    }

    /**
     * 인증 객체 생성
     */
    private Authentication createAuthentication(String username, Set<String> roles) {
        Set<SimpleGrantedAuthority> authorities = roles.stream()
                .map(SimpleGrantedAuthority::new)
                .collect(Collections.toSet());
        
        return new UsernamePasswordAuthenticationToken(
                username, null, authorities);
    }

    /**
     * 권한 없음 응답 전송
     */
    private void sendForbiddenResponse(HttpServletResponse response, String message) throws IOException {
        response.setStatus(HttpServletResponse.SC_FORBIDDEN);
        response.setContentType(MediaType.APPLICATION_JSON_VALUE);
        
        Map<String, String> error = new HashMap<>();
        error.put("error", "접근 거부");
        error.put("message", message);
        
        objectMapper.writeValue(response.getOutputStream(), error);
    }

    /**
     * 오류 응답 전송
     */
    private void sendErrorResponse(HttpServletResponse response, String message) throws IOException {
        response.setStatus(HttpServletResponse.SC_UNAUTHORIZED);
        response.setContentType(MediaType.APPLICATION_JSON_VALUE);
        
        Map<String, String> error = new HashMap<>();
        error.put("error", "인증 오류");
        error.put("message", message);
        
        objectMapper.writeValue(response.getOutputStream(), error);
    }

    @Override
    protected boolean shouldSkipFilter(HttpServletRequest request) {
        return filterRegistry.shouldNotFilter(getFilterId(), request);
    }

    @Override
    public void configure(HttpSecurity http) throws Exception {
        http.addFilterAfter(this, JwtVerificationFilter.class);
        log.debug("권한 부여 필터 HttpSecurity에 구성됨");
    }

    @Override
    public Class<? extends Filter> getBeforeFilter() {
        return JwtVerificationFilter.class;
    }

    @Override
    public Class<? extends Filter> getAfterFilter() {
        return null;
    }

    /**
     * 필터에 새로운 조건 추가
     */
    public void addFilterCondition(FilterCondition condition) {
        filterRegistry.addCondition(getFilterId(), condition);
    }

    /**
     * 필터에서 조건 제거
     */
    public boolean removeFilterCondition(FilterCondition condition) {
        return filterRegistry.removeCondition(getFilterId(), condition);
    }
}
import com.authentication.auth.DTO.token.tokenDto;
import com.authentication.auth.DTO.users.loginRequest;
import com.authentication.auth.configuration.security.publicAPI;
import com.authentication.auth.configuration.token.jwtUtility;
import com.fasterxml.jackson.databind.ObjectMapper;
import jakarta.servlet.FilterChain;
import jakarta.servlet.ServletException;
import jakarta.servlet.http.Cookie;
import jakarta.servlet.http.HttpServletRequest;
import jakarta.servlet.http.HttpServletResponse;
import lombok.extern.slf4j.Slf4j;
import org.springframework.beans.factory.annotation.Value;
import org.springframework.security.core.Authentication;
import org.springframework.security.core.GrantedAuthority;
import org.springframework.security.core.context.SecurityContextHolder;
import org.springframework.web.filter.OncePerRequestFilter;

import java.io.IOException;
import java.io.PrintWriter;
import java.util.Collection;
import java.util.Collections;
import java.util.Map;
import java.util.Objects;

@Slf4j
public class authorizationFilter extends OncePerRequestFilter {

    @Value("${site.domain}")
    private String domain;

    @Value("${server.cookie.domain}")
    private String cookieDomain;

    @Value("${auth_proxy_header}")
    private String AuthorizedProxyHeader;


    private final jwtUtility  jwtUtility;
    private final redisService  redisService;
    private final ObjectMapper objectMapper;
    private final publicAPI apiChecker;
    public authorizationFilter(jwtUtility jwtUtility, redisService redisService, ObjectMapper objectMapper, publicAPI apiChecker) {
        this.jwtUtility = jwtUtility;
        this.redisService = redisService;
        this.objectMapper = objectMapper;
        this.apiChecker = apiChecker;
    }
    @Override
    protected boolean shouldNotFilter(HttpServletRequest request){
        // true 일 경우 filter 작동 skip.
        return apiChecker.checkRequestAPI(request);
    }


    @Override
    protected void doFilterInternal(HttpServletRequest request, HttpServletResponse response, FilterChain filterChain) throws ServletException, IOException {

        // Authorization Header 확인 : Bearer Token 확인
        String authorizationHeader = request.getHeader(SecurityConstants.TOKEN_HEADER);

        if (authorizationHeader == null || !authorizationHeader.startsWith("Bearer ")) {
            log.warn("Invalid or missing Authorization header. Skipping filter.");
            return;
        }

        log.info("╔═══════════════════════════════════════════════════════════════╗");
        log.info("║                       Authorization Filter                    ║");
        log.info("╚═══════════════════════════════════════════════════════════════╝");

        String RToken = null;
        if (requiresCookieCheck(request)) {
            RToken = checkCookie(request, response);

            if (RToken == null) {
                log.error("cookie 필요 request 에 쿠키가 없어 401 오류를 반환합니다");
                return;
            }
        }

        String provider = request.getHeader("provider");

        if (provider != null) {
            log.info("{} 의 토큰입니다.", provider);
        }

        if (!authorizationHeader.startsWith(SecurityConstants.TOKEN_PREFIX)){

            if (Objects.requireNonNull(RToken).isEmpty()) {
                log.warn("refresh token 없음 -> 임시로 검사 안함 [수정 필요]");
                filterChain.doFilter(request, response);
                return;
            }

            // RToken 으로 AccessToken 찾기
            String findAccessToken = redisService.getAccessToken(RToken);

            if(findAccessToken != null && !findAccessToken.isEmpty()){
                response.addHeader(SecurityConstants.TOKEN_HEADER,
                        SecurityConstants.TOKEN_PREFIX + findAccessToken);
            }

        }

        String JWT = null;
        if(authorizationHeader.startsWith(SecurityConstants.TOKEN_PREFIX)){
            JWT = authorizationHeader.split(" ")[1];
        }

        if(JWT == null) {
            filterChain.doFilter(request, response);
            return;
        }

        // 기존 JWT 검증 및 인증 처리
        // Authorized Token 생성 및 Response Header 에 추가
        if (jwtUtility.validateJWT(JWT)) {
            log.info("유효한 토큰입니다.");
            Authentication getAuth = authenticateUser(JWT);

            log.info("인증 정보 : {}", getAuth);
            // 인증 실패 처리
            if (getAuth != null && getAuth.isAuthenticated()) {
                // 인증 성공: 필터 체인으로 요청 전달
                response.setStatus(HttpServletResponse.SC_OK);
            } else {
                // 인증 실패: 상태와 메시지 반환
                sendResponseStatus(response, HttpServletResponse.SC_UNAUTHORIZED, "Authentication failed");
            }
            return;
        } else if (RToken == null) {
            log.error("there is no refreshToken in cookie");
            sendResponseStatus(response, HttpServletResponse.SC_UNAUTHORIZED, "no refresh token in cookie");
        } else if (jwtUtility.validateRefreshJWT(RToken)) {
            handleRefreshToken(request, response, filterChain, RToken, JWT);
        } else {
            sendResponseStatus(response, HttpServletResponse.SC_UNAUTHORIZED, "Invalid or expired JWT");
        }

        filterChain.doFilter(request, response);
    }

    private String checkCookie(HttpServletRequest request, HttpServletResponse response) throws IOException {
        Cookie[] cookies = request.getCookies();
        String RToken = null;
        if (cookies != null){
            for (Cookie cookie : cookies){
                if (cookie.getName().equals("refreshToken")){
                    RToken = cookie.getValue();
                    break;
                }
            }
        }
        if (RToken == null){
            sendResponseStatus(response, 403, "ㅠㅠㅠㅠㅠㅠㅠㅠㅠㅠㅠㅠㅠㅠㅠㅠㅠㅠㅠㅠㅠㅠㅠㅠㅠㅠㅠ");
        }
        return RToken;
    }


    private void sendResponseStatus(HttpServletResponse response, int status, String message)
            throws IOException{
        response.setStatus(status);
        PrintWriter writer = response.getWriter();
        response.setContentType("application/json");
        response.setCharacterEncoding("UTF-8");
        Map<String, String> responseBody = Collections.singletonMap("message", message);
        objectMapper.writeValue(response.getWriter(), responseBody);
    }

    private void sendFrontNewCookie(HttpServletResponse response, int status, tokenDto tokendto){
        response.setStatus(status);
        response.addHeader(SecurityConstants.TOKEN_HEADER, SecurityConstants.TOKEN_PREFIX + tokendto.getAccessToken());
        Cookie refreshTokenCookie = new Cookie("refreshToken", tokendto.getRefreshToken());
        refreshTokenCookie.setHttpOnly(true);
        refreshTokenCookie.setDomain(this.cookieDomain);
        refreshTokenCookie.setPath("/");
        response.addCookie(refreshTokenCookie);
    }

    private boolean RedisMatchRToken(String userId, String RToken){
        return redisService.findRToken(userId, "server", RToken);
    }


    private boolean requiresCookieCheck(HttpServletRequest request) {
        return !apiChecker.checkRequestAPI(request);
    }


    // JWT 토큰을 이용하여 사용자 인증 처리
    // Spring Security Context 에 인증 정보를 저장
    private Authentication authenticateUser(String JWT) {
        try {
            Authentication authentication = jwtUtility.getAuthentication(JWT);
            SecurityContextHolder.getContext().setAuthentication(authentication);
            return authentication;
        } catch (Exception e) {
            log.error("인증 실패");
            return null;
        }
    }

    private void handleRefreshToken(HttpServletRequest request, HttpServletResponse response, FilterChain filterChain, String RToken, String JWT) throws IOException, ServletException {
        Map<String, Object> pToken = jwtUtility.getClaimsFromAccessToken(JWT);
        String userId = (String) pToken.get("userId");

        if (RedisMatchRToken(userId, RToken)) {
            log.info("refresh token is exist in redis");
            tokenDto tokendto = jwtUtility.buildToken(userId, (String) pToken.get("nickname"), (Collection<? extends GrantedAuthority>) pToken.get("role"));

            if (redisService.changeRToken(userId, "server", RToken, tokendto.getRefreshToken())) {
                log.info("access token and refresh token have been changed");
                sendFrontNewCookie(response, HttpServletResponse.SC_CREATED, tokendto);
                authenticateUser(tokendto.getAccessToken());
                filterChain.doFilter(request, response);
            } else {
                log.error("refresh token change failed");
                sendResponseStatus(response, HttpServletResponse.SC_UNAUTHORIZED, "refresh token change failed");
            }
        } else {
            log.error("refresh token from redis does not exist");
            sendResponseStatus(response, HttpServletResponse.SC_UNAUTHORIZED, "refresh token from redis does not exist");
        }
    }

}


// ===================================

// 파일: backend/src/main/java/com/authentication/auth/filter/AuthorizationFilter.java
/**
 * @Author: choisimo
 * @Date: 2025-05-05
 * @Description: 인가 필터
 * @Details: 사용자의 권한에 따라 특정 리소스 접근 제어를 담당하는 필터
 */
            new AntPathRequestMatcher("/admin/**"),
            List.of("ROLE_ADMIN")
        );
        
package com.authentication.auth.filter;

import jakarta.servlet.FilterChain;
import jakarta.servlet.ServletException;
import jakarta.servlet.http.HttpServletRequest;
import jakarta.servlet.http.HttpServletResponse;
import lombok.RequiredArgsConstructor;
import lombok.extern.slf4j.Slf4j;
import org.springframework.security.access.AccessDeniedException;
import org.springframework.security.core.Authentication;
import org.springframework.security.core.GrantedAuthority;
import org.springframework.security.core.context.SecurityContextHolder;
import org.springframework.security.web.access.intercept.AuthorizationFilter;
import org.springframework.security.web.util.matcher.AntPathRequestMatcher;
import org.springframework.security.web.util.matcher.RequestMatcher;
import org.springframework.stereotype.Component;
import org.springframework.web.filter.OncePerRequestFilter;

import java.io.IOException;
import java.util.Collection;
import java.util.HashMap;
import java.util.List;
import java.util.Map;

/**
 * @Author: choisimo
 * @Date: 2025-05-05
 * @Description: 인가 필터
 * @Details: 사용자의 권한에 따라 특정 리소스 접근 제어를 담당하는 필터
 */
@Slf4j
@Component
@RequiredArgsConstructor
public class AuthorizationFilter extends OncePerRequestFilter implements PluggableFilter {

    // URL 패턴별 필요 권한 매핑
    private final Map<RequestMatcher, List<String>> urlAuthorizationMap = new HashMap<>();
    
    // 생성자에서 URL 패턴별 필요 권한 초기화
    public AuthorizationFilter() {
        // 예시: 관리자 전용 URL 패턴
        urlAuthorizationMap.put(
            new AntPathRequestMatcher("/admin/**"),
            List.of("ROLE_ADMIN")
        );
        
        // 예시: 사용자 및 관리자 접근 가능 URL 패턴
        urlAuthorizationMap.put(
            new AntPathRequestMatcher("/api/users/**"),
            List.of("ROLE_USER", "ROLE_ADMIN")
        );
    }

    @Override
    protected void doFilterInternal(HttpServletRequest request, HttpServletResponse response,
                                   FilterChain filterChain) throws ServletException, IOException {
        Authentication authentication = SecurityContextHolder.getContext().getAuthentication();
        
        // 인증 정보가 없거나 익명 사용자인 경우 바로 통과 (인증 필터에서 처리)
        if (authentication == null || !authentication.isAuthenticated()) {
            filterChain.doFilter(request, response);
            return;
        }
        
        // URL 패턴별 권한 확인
        for (Map.Entry<RequestMatcher, List<String>> entry : urlAuthorizationMap.entrySet()) {
            if (entry.getKey().matches(request)) {
                if (!hasAnyAuthority(authentication.getAuthorities(), entry.getValue())) {
                    log.warn("접근 권한 없음. 사용자: {}, URL: {}", authentication.getName(), request.getRequestURI());
                    throw new AccessDeniedException("접근 권한이 없습니다.");
                }
                break;
            }
        }
        
        // 권한 검사를 통과하면 다음 필터로 진행
        filterChain.doFilter(request, response);
    }
    
    // 사용자가 필요한 권한 중 하나라도 가지고 있는지 확인
    private boolean hasAnyAuthority(Collection<? extends GrantedAuthority> authorities, List<String> requiredAuthorities) {
        return authorities.stream()
                .map(GrantedAuthority::getAuthority)
                .anyMatch(requiredAuthorities::contains);
    }
    
    @Override
    public void configure(HttpSecurity http) throws Exception {
        http.addFilterAfter(this, JwtVerificationFilter.class);
    }

    @Override
    public int getOrder() {
        return 300; // JwtVerificationFilter 다음 순서
    }

    @Override
    public Class<? extends Filter> getBeforeFilter() {
        return JwtVerificationFilter.class;
    }

    @Override
    public Class<? extends Filter> getAfterFilter() {
        return null; // 이 필터 이후에 실행되어야 하는 특정 필터가 없음
    }
}


// ===================================

// 파일: backend/src/main/java/com/authentication/auth/filter/FilterCondition.java
/**
 * @Author: choisimo
 * @Date: 2025-05-05
 * @Description: 필터 조건 인터페이스
 * @Details: 필터 적용 조건을 정의하는 인터페이스
 */
    /**
     * 요청에 필터를 적용할지 여부를 결정
     * @param request HTTP 요청
     * @return true이면 필터를 적용하지 않음, false이면 필터 적용
package com.authentication.auth.filter;

import jakarta.servlet.http.HttpServletRequest;

/**
 * @Author: choisimo
 * @Date: 2025-05-05
 * @Description: 필터 조건 인터페이스
 * @Details: 필터 적용 조건을 정의하는 인터페이스
 */
public interface FilterCondition {
    
    /**
     * 요청에 필터를 적용할지 여부를 결정
     * @param request HTTP 요청
     * @return true이면 필터를 적용하지 않음, false이면 필터 적용
     */
    boolean shouldNotFilter(HttpServletRequest request);
    
    /**
     * 조건에 설명을 제공
     * @return 조건 설명
     */
    String getDescription();
}


// ===================================

// 파일: backend/src/main/java/com/authentication/auth/filter/filterRegistry.java
/**
 * @Author: choisimo
 * @Date: 2025-05-05
 * @Description: 필터 레지스트리 구성 클래스
 * @Details: 애플리케이션에서 사용할 보안 필터를 등록하고 관리합니다.
 */
    /**
     * JWT 검증 필터 빈 생성
     * @param jwtUtility JWT 유틸리티
     * @param redisService Redis 서비스
package com.authentication.auth.filter;
package com.authentication.auth.filter;

import com.authentication.auth.service.redis.RedisService;
import com.authentication.auth.utility.JwtUtility;
import com.fasterxml.jackson.databind.ObjectMapper;
import lombok.extern.slf4j.Slf4j;
import org.springframework.beans.factory.annotation.Value;
import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;
import org.springframework.security.authentication.AuthenticationManager;
import org.springframework.security.config.annotation.web.builders.HttpSecurity;
import org.springframework.security.core.userdetails.UserDetailsService;

import java.util.ArrayList;
import java.util.Arrays;
import java.util.List;

/**
 * @Author: choisimo
 * @Date: 2025-05-05
 * @Description: 필터 레지스트리 구성 클래스
 * @Details: 애플리케이션에서 사용할 보안 필터를 등록하고 관리합니다.
 */
@Slf4j
@Configuration
public class FilterRegistry {

    @Value("${application.domain:localhost}")
    private String domain;

    @Value("${application.cookie.domain:localhost}")
    private String cookieDomain;

    /**
     * JWT 검증 필터 빈 생성
     * @param jwtUtility JWT 유틸리티
     * @param redisService Redis 서비스
     * @param userDetailsService 사용자 세부 정보 서비스
     * @param objectMapper 객체 매퍼
     * @return 구성된 JWT 검증 필터
     */
    @Bean
    public JwtVerificationFilter jwtVerificationFilter(
            JwtUtility jwtUtility,
            RedisService redisService,
            UserDetailsService userDetailsService,
            ObjectMapper objectMapper) {
        
        List<String> excludePaths = Arrays.asList(
            "/api/auth/login",
            "/api/auth/register",
            "/api/auth/password/reset",
            "/api/health",
            "/swagger-ui/**",
            "/v3/api-docs/**",
            "/error"
        );
        
        log.info("JWT 검증 필터 등록. 제외 경로: {}", excludePaths);
        return new JwtVerificationFilter(jwtUtility, redisService, userDetailsService, objectMapper, excludePaths);
    }

    /**
     * 인증 필터 빈 생성
     * @param authenticationManager 인증 관리자
     * @param jwtUtility JWT 유틸리티
     * @param objectMapper 객체 매퍼
     * @param redisService Redis 서비스
     * @return 구성된 인증 필터
     */
    @Bean
    public AuthenticationFilter authenticationFilter(
            AuthenticationManager authenticationManager,
            JwtUtility jwtUtility,
            ObjectMapper objectMapper,
            RedisService redisService) {
        
        log.info("인증 필터 등록. 도메인: {}, 쿠키 도메인: {}", domain, cookieDomain);
        return new AuthenticationFilter(authenticationManager, jwtUtility, objectMapper, redisService, domain, cookieDomain);
    }

    /**
     * 모든 필터를 등록하여 보안 구성에 적용
     * @param http HTTP 보안 구성
     * @param filters 등록할 필터 목록
     * @throws Exception 보안 구성 예외
     */
    public void registerFilters(HttpSecurity http, List<PluggableFilter> filters) throws Exception {
        log.info("{} 필터 등록 중...", filters.size());
        
        // 필터를 order 기준으로 정렬
        filters.sort((f1, f2) -> Integer.compare(f1.getOrder(), f2.getOrder()));
        
        // 각 필터를 구성에 적용
        for (PluggableFilter filter : filters) {
            log.debug("필터 등록: {}, 순서: {}", filter.getClass().getSimpleName(), filter.getOrder());
            filter.configure(http);
        }
    }

    /**
     * 구성 가능한 모든 필터 수집
     * @param authenticationFilter 인증 필터
     * @param jwtVerificationFilter JWT 검증 필터
     * @return 구성 가능한 필터 목록
     */
    @Bean
    public List<PluggableFilter> pluggableFilters(
            AuthenticationFilter authenticationFilter,
            JwtVerificationFilter jwtVerificationFilter) {
        
        List<PluggableFilter> filters = new ArrayList<>();
        filters.add(jwtVerificationFilter);
        filters.add(authenticationFilter);
        
        log.info("총 {} 필터가 등록되었습니다.", filters.size());
        return filters;
    }
}
import java.util.ArrayList;
import java.util.Collections;
import java.util.HashMap;
import java.util.LinkedList;
import java.util.List;
import java.util.Map;
import java.util.Queue;

import org.springframework.security.config.annotation.web.builders.HttpSecurity;
import org.springframework.security.web.authentication.UsernamePasswordAuthenticationFilter;
import org.springframework.stereotype.Component;
import org.springframework.web.filter.GenericFilterBean;

import jakarta.servlet.FilterChain;
import jakarta.servlet.ServletException;
import jakarta.servlet.ServletRequest;
import jakarta.servlet.ServletResponse;
import jakarta.servlet.Filter;
import java.io.IOException;

/**
 * @Author : choisimo 
 * @Date : 2025-05-05
 * @Description : filterRegistry class
 * @Details : 등록된 필터들을 순서대로 등록하는 클래스 (order 기반)
 * @Usage : Spring Security 의 addFilterBefore, addFilterAfter, addFilter 메소드를 사용하여 필터를 등록할 때 사용
 */

@Component
@RequiredArgsConstructor
@Slf4j
public class filterRegistry {
    private final List<PluggableFilter> filters = new ArrayList<>();
    
    @Autowired
    public filterRegistry(List<PluggableFilter> pluggableFilters) {
        // 자동으로 모든 PluggableFilter 구현체를 주입받음
        this.filters.addAll(pluggableFilters);
        log.info("총 {} 개의 필터가 등록되었습니다.", filters.size());
    }

    public void addFilter(PluggableFilter filter) {
        filters.add(filter);
    }

    /**
     * 정렬된 필터를 Spring Security 필터 체인에 등록합니다.
     * 필터 순서는 위상 정렬 알고리즘을 통해 결정됩니다.
     * @param http HttpSecurity 구성 객체
     * @throws Exception 구성 중 발생할 수 있는 예외
     */
    public void configureFilters(HttpSecurity http) throws Exception {
        List<PluggableFilter> sortedFilters = topologicalSort();
        
        for (PluggableFilter filter : sortedFilters) {
            log.info("필터 등록: {}, 순서: {}", filter.getClass().getSimpleName(), filter.getOrder());
            filter.configure(http);
        }
    }
    
    /**
     * 필터 의존성을 기반으로 위상 정렬을 수행합니다.
     * @return 정렬된 필터 목록
     */
    private List<PluggableFilter> topologicalSort() {
        Map<Class<?>, PluggableFilter> filterMap = new HashMap<>();
        Map<PluggableFilter, List<PluggableFilter>> graph = new HashMap<>();
        Set<PluggableFilter> visited = new HashSet<>();
        List<PluggableFilter> result = new ArrayList<>();
        
        // 필터 맵 초기화
        for (PluggableFilter filter : filters) {
            filterMap.put(filter.getClass(), filter);
            graph.put(filter, new ArrayList<>());
        }
        
        // 그래프 구성
        for (PluggableFilter filter : filters) {
            // 이 필터 이전에 실행되어야 하는 필터
            Class<? extends Filter> beforeFilter = filter.getBeforeFilter();
            if (beforeFilter != null && filterMap.containsKey(beforeFilter)) {
                graph.get(filterMap.get(beforeFilter)).add(filter);
            }
            
            // 이 필터 이후에 실행되어야 하는 필터
            Class<? extends Filter> afterFilter = filter.getAfterFilter();
            if (afterFilter != null && filterMap.containsKey(afterFilter)) {
                graph.get(filter).add(filterMap.get(afterFilter));
            }
        }
        
        // DFS를 통한 위상 정렬
        for (PluggableFilter filter : filters) {
            if (!visited.contains(filter)) {
                dfs(filter, graph, visited, result);
            }
        }
        
        // 순서(Order) 기반 추가 정렬
        result.sort(Comparator.comparingInt(PluggableFilter::getOrder));
        
        return result;
    }
    
    /**
     * 깊이 우선 탐색을 통한 위상 정렬 수행
     */
    private void dfs(PluggableFilter filter, Map<PluggableFilter, List<PluggableFilter>> graph,
                     Set<PluggableFilter> visited, List<PluggableFilter> result) {
        visited.add(filter);
        
        for (PluggableFilter dependency : graph.get(filter)) {
            if (!visited.contains(dependency)) {
                dfs(dependency, graph, visited, result);
            }
        }
        
        result.add(filter);
    }
}
     */
    public void registerFilters(HttpSecurity http) throws Exception {
        List<PluggableFilter> sortedFilters = topologicalSort(filters);
        
        for (PluggableFilter filter : sortedFilters) {
            try {
                if (filter.getBeforeFilter() != null) {
                    // 지정된 필터 이전에 실행
                    http.addFilterBefore(
                        new FilterWrapper(filter), 
                        (Class<? extends Filter>) filter.getBeforeFilter()
                    );
                } else if (filter.getAfterFilter() != null) {
                    // 지정된 필터 이후에 실행
                    http.addFilterAfter(
                        new FilterWrapper(filter), 
                        (Class<? extends Filter>) filter.getAfterFilter()
                    );
                } else {
                    // 기본 순서로 실행 (UsernamePasswordAuthenticationFilter 위치)
                    http.addFilterBefore(new FilterWrapper(filter), UsernamePasswordAuthenticationFilter.class);
                }
            } catch (Exception e) {
                throw new RuntimeException("Filter registration failed: " + filter.getClass().getSimpleName(), e);
            }
        }
    }

    private List<PluggableFilter> topologicalSort(List<PluggableFilter> filters) {

        // 그래프 인접 리스트 생성
        Map<Class<?>, List<Class<?>>> adjacencyList = new HashMap<>();
        
        // 각 필터의 진입 차수 저장
        Map<Class<?>, Integer> inDegree = new HashMap<>();

        // 필터 클래스를 필터 인스턴스에 매핑
        Map<Class<?>, PluggableFilter> filterMap = new HashMap<>();    


        // 그래프와 진입 차수 초기화
        for (PluggableFilter filter : filters) {
            Class<?> filterClass = filter.getClass();
            adjacencyList.putIfAbsent(filterClass, new ArrayList<>());
            inDegree.putIfAbsent(filterClass, 0);
            filterMap.put(filterClass, filter);
        }

    // before/after 관계를 기반으로 그래프 구축
    for (PluggableFilter filter : filters) {
        Class<?> filterClass = filter.getClass();
        
        if (filter.getBeforeFilter() != null) {
            // A가 B 이전에 오면, A에서 B로 간선 추가
            adjacencyList.get(filterClass).add(filter.getBeforeFilter());
            inDegree.merge(filter.getBeforeFilter(), 1, Integer::sum);
        }
        
        if (filter.getAfterFilter() != null) {
            // A가 B 이후에 오면, B에서 A로 간선 추가
            adjacencyList.putIfAbsent(filter.getAfterFilter(), new ArrayList<>());
            adjacencyList.get(filter.getAfterFilter()).add(filterClass);
            inDegree.merge(filterClass, 1, Integer::sum);
        }
    }
    
    // 위상 정렬 수행
    return performKahnsAlgorithm(adjacencyList, inDegree, filterMap);
}

private List<PluggableFilter> performKahnsAlgorithm(
        Map<Class<?>, List<Class<?>>> adjacencyList,
        Map<Class<?>, Integer> inDegree,
        Map<Class<?>, PluggableFilter> filterMap) {
    
    List<PluggableFilter> sortedFilters = new ArrayList<>();
    Queue<Class<?>> queue = new LinkedList<>();
    
    // 진입 차수가 0인 노드(의존성이 없는 필터)부터 시작
    for (Map.Entry<Class<?>, Integer> entry : inDegree.entrySet()) {
        if (entry.getValue() == 0) {
            queue.add(entry.getKey());
        }
    }
    
    // 위상 정렬 순서대로 노드 처리
    while (!queue.isEmpty()) {
        Class<?> current = queue.poll();
        PluggableFilter filter = filterMap.get(current);
        
        if (filter != null) {
            sortedFilters.add(filter);
        }
        
        // 각 종속 필터의 진입 차수를 감소시키고 준비됐는지 확인
        for (Class<?> dependent : adjacencyList.getOrDefault(current, Collections.emptyList())) {
            inDegree.put(dependent, inDegree.get(dependent) - 1);
            if (inDegree.get(dependent) == 0) {
                queue.add(dependent);
            }
        }
    }
    
    // 종속성 그래프에 순환이 있는지 확인
    if (sortedFilters.size() != filterMap.size()) {
        throw new IllegalStateException("필터 간에 순환 의존성이 감지되었습니다");
    }
    
    return sortedFilters;
}

/**
 * 필터 어댑터 클래스
 * Spring Security Filter와 PluggableFilter 간의 호환성 제공
 */
private static class FilterWrapper extends GenericFilterBean {
    private final PluggableFilter delegate;

    public FilterWrapper(PluggableFilter delegate) {
        this.delegate = delegate;
    }

    @Override
    public void doFilter(
        ServletRequest request,
        ServletResponse response,
        FilterChain chain
    ) throws ServletException, IOException {
        delegate.doFilter(request, response, chain);
    }
}
}


// ===================================

// 파일: backend/src/main/java/com/authentication/auth/filter/FilterRegistry.java
/**
 * @Author: choisimo
 * @Date: 2025-05-05
 * @Description: 필터 레지스트리
 * @Details: 보안 필터 등록 및 관리를 위한 중앙 레지스트리
 */
    /**
     * 필터 등록
     * @param filter 등록할 필터
     */
package com.authentication.auth.filter;

import lombok.extern.slf4j.Slf4j;
import org.springframework.security.config.annotation.web.builders.HttpSecurity;
import org.springframework.stereotype.Component;

import java.util.*;
import java.util.concurrent.ConcurrentHashMap;
import java.util.concurrent.CopyOnWriteArrayList;

/**
 * @Author: choisimo
 * @Date: 2025-05-05
 * @Description: 필터 레지스트리
 * @Details: 보안 필터 등록 및 관리를 위한 중앙 레지스트리
 */
@Slf4j
@Component
public class FilterRegistry {

    // 필터 인스턴스 저장 맵 (필터 이름 -> 필터 인스턴스)
    private final Map<String, PluggableFilter> filterMap = new ConcurrentHashMap<>();
    
    // 필터 우선순위 순서대로 저장된 리스트
    private final List<PluggableFilter> orderedFilters = new CopyOnWriteArrayList<>();
    
    // 필터 조건 저장 맵 (필터 이름 -> 필터 조건 리스트)
    private final Map<String, List<FilterCondition>> filterConditions = new ConcurrentHashMap<>();

    /**
     * 필터 등록
     * @param filter 등록할 필터
     */
    public void registerFilter(PluggableFilter filter) {
        String filterName = filter.getClass().getSimpleName();
        filterMap.put(filterName, filter);
        
        // 우선순위에 따라 정렬된 위치에 필터 삽입
        insertFilterInOrder(filter);
        
        log.info("필터 등록 완료: {}, 우선순위: {}", filterName, filter.getOrder());
    }

    /**
     * 필터에 조건 추가
     * @param filterName 필터 이름
     * @param condition 필터 조건
     */
    public void addCondition(String filterName, FilterCondition condition) {
        filterConditions.computeIfAbsent(filterName, k -> new CopyOnWriteArrayList<>())
                        .add(condition);
        log.info("필터 '{}' 에 조건 추가: {}", filterName, condition.getDescription());
    }

    /**
     * 필터에 조건 제거
     * @param filterName 필터 이름
     * @param condition 제거할 조건
     * @return 제거 성공 여부
     */
    public boolean removeCondition(String filterName, FilterCondition condition) {
        List<FilterCondition> conditions = filterConditions.get(filterName);
        if (conditions != null) {
            boolean result = conditions.remove(condition);
            if (result) {
                log.info("필터 '{}' 에서 조건 제거: {}", filterName, condition.getDescription());
            }
            return result;
        }
        return false;
    }

    /**
     * 필터 제거
     * @param filterName 제거할 필터 이름
     * @return 제거된 필터, 없으면 null
     */
    public PluggableFilter unregisterFilter(String filterName) {
        PluggableFilter filter = filterMap.remove(filterName);
        if (filter != null) {
            orderedFilters.remove(filter);
            filterConditions.remove(filterName);
            log.info("필터 제거 완료: {}", filterName);
        }
        return filter;
    }

    /**
     * 특정 요청에 대해 필터를 적용해야 하는지 확인
     * @param filterName 필터 이름
     * @param request HTTP 요청
     * @return true면 필터를 적용하지 않음, false면 필터 적용
     */
    public boolean shouldNotFilter(String filterName, jakarta.servlet.http.HttpServletRequest request) {
        List<FilterCondition> conditions = filterConditions.get(filterName);
        if (conditions == null || conditions.isEmpty()) {
            return false; // 조건이 없으면 항상 필터 적용
        }
        
        // 어느 하나의 조건이라도 true를 반환하면 필터를 적용하지 않음 (OR 조건)
        return conditions.stream().anyMatch(condition -> condition.shouldNotFilter(request));
    }

    /**
     * 우선순위에 따라 정렬된 위치에 필터 삽입
     * @param filter 삽입할 필터
     */
    private void insertFilterInOrder(PluggableFilter filter) {
        // 기존 필터가 있으면 제거
        orderedFilters.remove(filter);
        
        // 새 필터의 순서
        int newFilterOrder = filter.getOrder();
        
        int insertIndex = 0;
        while (insertIndex < orderedFilters.size() && 
               orderedFilters.get(insertIndex).getOrder() <= newFilterOrder) {
            insertIndex++;
        }
        
        orderedFilters.add(insertIndex, filter);
    }

    /**
     * 등록된 모든 필터를 SecurityConfig에 등록
     * @param http HttpSecurity 객체
     * @throws Exception 설정 중 예외 발생 시
     */
    public void registerFilters(HttpSecurity http) throws Exception {
        for (PluggableFilter filter : orderedFilters) {
            filter.configure(http);
            log.debug("필터 구성 적용: {}", filter.getClass().getSimpleName());
        }
        log.info("총 {}개의 필터가 SecurityConfig에 등록됨", orderedFilters.size());
    }

    /**
     * 등록된 모든 필터 목록 반환
     * @return 필터 목록
     */
    public List<PluggableFilter> getRegisteredFilters() {
        return Collections.unmodifiableList(orderedFilters);
    }
    
    /**
     * 특정 필터 조회
     * @param filterName 필터 이름
     * @return 찾은 필터, 없으면 null
     */
    public PluggableFilter getFilter(String filterName) {
        return filterMap.get(filterName);
    }
}


// ===================================

// 파일: backend/src/main/java/com/authentication/auth/filter/JwtVerificationFilter.java
/**
 * @Author: choisimo
 * @Date: 2025-05-05
 * @Description: JWT 토큰 검증 필터
 * @Details: 요청에 포함된 JWT 토큰을 검증하고 사용자 인증 정보를 설정
 */
    /**
     * 필터 초기화 및 레지스트리에 등록
     */
                "/api/public/**",
package com.authentication.auth.filter;
package com.authentication.auth.filter;

import com.authentication.auth.configuration.token.JwtUtility;
import com.fasterxml.jackson.databind.ObjectMapper;
import jakarta.annotation.PostConstruct;
import jakarta.servlet.Filter;
import jakarta.servlet.FilterChain;
import jakarta.servlet.ServletException;
import jakarta.servlet.http.HttpServletRequest;
import jakarta.servlet.http.HttpServletResponse;
import lombok.extern.slf4j.Slf4j;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.http.MediaType;
import org.springframework.security.authentication.UsernamePasswordAuthenticationToken;
import org.springframework.security.config.annotation.web.builders.HttpSecurity;
import org.springframework.security.core.authority.SimpleGrantedAuthority;
import org.springframework.security.core.context.SecurityContextHolder;
import org.springframework.stereotype.Component;

import java.io.IOException;
import java.util.HashMap;
import java.util.Map;
import java.util.Set;
import java.util.stream.Collectors;

/**
 * @Author: choisimo
 * @Date: 2025-05-05
 * @Description: JWT 토큰 검증 필터
 * @Details: 요청에 포함된 JWT 토큰을 검증하고 사용자 인증 정보를 설정
 */
@Slf4j
@Component
public class JwtVerificationFilter extends AbstractSecurityFilter {

    private final JwtUtility jwtUtility;
    private final ObjectMapper objectMapper;
    private final FilterRegistry filterRegistry;

    @Autowired
    public JwtVerificationFilter(
            JwtUtility jwtUtility,
            ObjectMapper objectMapper,
            FilterRegistry filterRegistry) {
        super(SecurityFilterOrder.JWT_VERIFICATION_FILTER);
        this.jwtUtility = jwtUtility;
        this.objectMapper = objectMapper;
        this.filterRegistry = filterRegistry;
    }

    /**
     * 필터 초기화 및 레지스트리에 등록
     */
    @PostConstruct
    public void init() {
        // 필터 레지스트리에 이 필터 등록
        filterRegistry.registerFilter(this);

        // 기본 필터 조건 설정 - 공개 API는 JWT 검증 필터 적용하지 않음
        PathPatternFilterCondition publicApiCondition = new PathPatternFilterCondition(
                "JWT 검증 불필요 경로",
                "/api/public/**",
                "/api/auth/login",
                "/api/auth/register",
                "/api/auth/refresh",
                "/swagger-ui/**",
                "/v3/api-docs/**"
        );

        // 필터 레지스트리에 조건 추가
        filterRegistry.addCondition(getFilterId(), publicApiCondition);
    }

    @Override
    protected void doFilterInternal(HttpServletRequest request, HttpServletResponse response, FilterChain chain)
            throws IOException, ServletException {
        
        String path = request.getRequestURI();
        log.debug("JWT 검증 필터 실행: {}", path);
        
        try {
            String token = extractToken(request);
            
            if (token != null) {
                if (jwtUtility.validateToken(token)) {
                    String username = jwtUtility.getUsernameFromToken(token);
                    Set<String> roles = jwtUtility.getRolesFromToken(token);
                    
                    // 권한 설정
                    Set<SimpleGrantedAuthority> authorities = roles.stream()
                            .map(SimpleGrantedAuthority::new)
                            .collect(Collectors.toSet());
                    
                    UsernamePasswordAuthenticationToken authToken = 
                            new UsernamePasswordAuthenticationToken(username, null, authorities);
                    
                    SecurityContextHolder.getContext().setAuthentication(authToken);
                    log.debug("JWT 토큰 검증 성공: {}", username);
                } else {
                    log.warn("유효하지 않은 JWT 토큰");
                    sendErrorResponse(response, "유효하지 않은 토큰입니다.");
                    return;
                }
            } else {
                log.debug("JWT 토큰이 없음");
            }
            
            chain.doFilter(request, response);
        } catch (Exception e) {
            log.error("JWT 검증 중 오류 발생: {}", e.getMessage());
            SecurityContextHolder.clearContext();
            sendErrorResponse(response, "토큰 검증 중 오류가 발생했습니다: " + e.getMessage());
        }
    }

    /**
     * 요청에서 JWT 토큰 추출
     */
    private String extractToken(HttpServletRequest request) {
        String authHeader = request.getHeader("Authorization");
        
        if (authHeader != null && authHeader.startsWith("Bearer ")) {
            return authHeader.substring(7);
        }
        
        return null;
    }

    /**
     * 오류 응답 전송
     */
    private void sendErrorResponse(HttpServletResponse response, String message) throws IOException {
        response.setStatus(HttpServletResponse.SC_UNAUTHORIZED);
        response.setContentType(MediaType.APPLICATION_JSON_VALUE);
        
        Map<String, String> error = new HashMap<>();
        error.put("error", "인증 오류");
        error.put("message", message);
        
        objectMapper.writeValue(response.getOutputStream(), error);
    }

    @Override
    protected boolean shouldSkipFilter(HttpServletRequest request) {
        return filterRegistry.shouldNotFilter(getFilterId(), request);
    }

    @Override
    public void configure(HttpSecurity http) throws Exception {
        http.addFilterAfter(this, AuthenticationFilter.class);
        log.debug("JWT 검증 필터 HttpSecurity에 구성됨");
    }

    @Override
    public Class<? extends Filter> getBeforeFilter() {
        return AuthenticationFilter.class;
    }

    @Override
    public Class<? extends Filter> getAfterFilter() {
        return authorizationFilter.class;
    }
}
import com.authentication.auth.service.redis.RedisService;
import com.authentication.auth.utility.JwtUtility;
import com.fasterxml.jackson.databind.ObjectMapper;
import io.jsonwebtoken.Claims;
import io.jsonwebtoken.ExpiredJwtException;
import io.jsonwebtoken.JwtException;
import jakarta.servlet.FilterChain;
import jakarta.servlet.ServletException;
import jakarta.servlet.ServletRequest;
import jakarta.servlet.ServletResponse;
import jakarta.servlet.http.Cookie;
import jakarta.servlet.http.HttpServletRequest;
import jakarta.servlet.http.HttpServletResponse;
import lombok.RequiredArgsConstructor;
import lombok.extern.slf4j.Slf4j;
import org.springframework.http.HttpHeaders;
import org.springframework.http.HttpStatus;
import org.springframework.http.MediaType;
import org.springframework.security.authentication.UsernamePasswordAuthenticationToken;
import org.springframework.security.core.authority.SimpleGrantedAuthority;
import org.springframework.security.core.context.SecurityContextHolder;
import org.springframework.security.core.userdetails.UserDetailsService;
import org.springframework.security.web.authentication.WebAuthenticationDetailsSource;
import org.springframework.security.web.util.matcher.AntPathRequestMatcher;
import org.springframework.security.web.util.matcher.OrRequestMatcher;
import org.springframework.security.web.util.matcher.RequestMatcher;
import org.springframework.web.filter.OncePerRequestFilter;

import javax.security.auth.login.CredentialExpiredException;
import java.io.IOException;
import java.time.LocalDateTime;
import java.util.*;
import java.util.stream.Collectors;

/**
 * @Author: choisimo
 * @Date: 2025-05-05
 * @Description: JWT 토큰 검증 필터
 * @Details: 요청에서 JWT 토큰을 추출하고 유효성을 검사하는 필터
 * @Usage: Spring Security 필터 체인에 등록하여 사용
 */
@Slf4j
@RequiredArgsConstructor
public class JwtVerificationFilter extends OncePerRequestFilter implements PluggableFilter {
    
    private final JwtUtility jwtUtility;
    private final RedisService redisService;
    private final UserDetailsService userDetailsService;
    private final ObjectMapper objectMapper;
    private final RequestMatcher excludePathMatcher;

    /**
     * JWT 검증 필터 생성자
     * @param jwtUtility JWT 토큰 유틸리티
     * @param redisService Redis 서비스
     * @param userDetailsService 사용자 세부정보 서비스
     * @param objectMapper JSON 변환용 객체 매퍼
     * @param excludePaths 필터 적용을 제외할 경로 목록
     */
    public JwtVerificationFilter(JwtUtility jwtUtility, RedisService redisService, 
                                UserDetailsService userDetailsService, ObjectMapper objectMapper,
                                List<String> excludePaths) {
        this.jwtUtility = jwtUtility;
        this.redisService = redisService;
        this.userDetailsService = userDetailsService;
        this.objectMapper = objectMapper;
        
        // 제외 경로 패턴 매처 설정
        List<RequestMatcher> matchers = excludePaths.stream()
                .map(path -> new AntPathRequestMatcher(path))
                .collect(Collectors.toList());
        this.excludePathMatcher = new OrRequestMatcher(matchers.toArray(new RequestMatcher[0]));
    }

    /**
     * 필터 적용 여부 결정 메서드
     * 특정 경로는 JWT 검증에서 제외
     * @param request 현재 요청
     * @return 필터 적용 여부
     */
    @Override
    protected boolean shouldNotFilter(HttpServletRequest request) {
        return excludePathMatcher.matches(request);
    }
        
        @Override
        public void configure(HttpSecurity http) throws Exception {
            http.addFilterBefore(this, AuthorizationFilter.class);
        }
    
        @Override
        public int getOrder() {
            return 200; // AuthenticationFilter 다음 순서
        }
    
        @Override
        public Class<? extends Filter> getBeforeFilter() {
            return AuthenticationFilter.class;
        }
    
        @Override
        public Class<? extends Filter> getAfterFilter() {
            return AuthorizationFilter.class;
        }

    /**
     * JWT 토큰 검증 및 인증 처리 메서드
     * @param request 요청
     * @param response 응답
     * @param filterChain 필터 체인
     * @throws ServletException 서블릿 예외
     * @throws IOException IO 예외
     */
    @Override
    protected void doFilterInternal(HttpServletRequest request, HttpServletResponse response, FilterChain filterChain)
            throws ServletException, IOException {
        
        log.debug("JWT 검증 필터 시작: {}", request.getRequestURI());
        
        try {
            // 토큰 추출
            String token = extractToken(request);
            
            if (token == null) {
                log.debug("토큰이 없음, 인증 생략");
                filterChain.doFilter(request, response);
                return;
            }
            
            // 토큰 유효성 검증
            if (jwtUtility.validateToken(token)) {
                // 토큰에서 사용자 정보 추출
                Claims claims = jwtUtility.getClaims(token);
                String username = claims.getSubject();
                
                // 블랙리스트 확인 (로그아웃된 토큰인지)
                String tokenId = claims.getId();
                if (tokenId != null && redisService.hasKey("JWT_Blacklist_" + tokenId)) {
                    throw new CredentialExpiredException("로그아웃된 토큰입니다.");
                }
                
                // 사용자 권한 추출
                List<String> authorities = claims.get("authorities", List.class);
                List<SimpleGrantedAuthority> grantedAuthorities = null;
                
                if (authorities != null) {
                    grantedAuthorities = authorities.stream()
                            .map(SimpleGrantedAuthority::new)
                            .collect(Collectors.toList());
                }
                
                // 인증 객체 생성 및 설정
                UsernamePasswordAuthenticationToken authentication = 
                        new UsernamePasswordAuthenticationToken(username, null, grantedAuthorities);
                authentication.setDetails(new WebAuthenticationDetailsSource().buildDetails(request));
                
                // 보안 컨텍스트에 인증 객체 설정
                SecurityContextHolder.getContext().setAuthentication(authentication);
                log.debug("사용자 {} 인증 완료", username);
            }
            
            // 필터 체인 계속 진행
            filterChain.doFilter(request, response);
            
        } catch (ExpiredJwtException e) {
            log.warn("만료된 JWT 토큰: {}", e.getMessage());
            handleExpiredToken(request, response, e);
        } catch (JwtException | CredentialExpiredException e) {
            log.warn("유효하지 않은 JWT 토큰: {}", e.getMessage());
            handleInvalidToken(response, e);
        }
    }

    /**
     * 요청에서 JWT 토큰 추출 메서드
     * Authorization 헤더 또는 쿠키에서 토큰 추출
     * @param request HTTP 요청
     * @return 추출된 토큰 또는 null
     */
    private String extractToken(HttpServletRequest request) {
        // Authorization 헤더에서 토큰 추출 시도
        String bearerToken = request.getHeader(HttpHeaders.AUTHORIZATION);
        if (bearerToken != null && bearerToken.startsWith("Bearer ")) {
            return bearerToken.substring(7);
        }
        
        // 쿠키에서 토큰 추출 시도
        Cookie[] cookies = request.getCookies();
        if (cookies != null) {
            return Arrays.stream(cookies)
                    .filter(cookie -> "access_token".equals(cookie.getName()))
                    .map(Cookie::getValue)
                    .findFirst()
                    .orElse(null);
        }
        
        return null;
    }

    /**
     * 만료된 토큰 처리 메서드
     * 리프레시 토큰을 사용하여 새 액세스 토큰 발급 시도
     * @param request HTTP 요청
     * @param response HTTP 응답
     * @param e 만료 예외
     * @throws IOException IO 예외
     */
    private void handleExpiredToken(HttpServletRequest request, HttpServletResponse response, ExpiredJwtException e) 
            throws IOException {
        log.info("만료된 토큰 처리 시도");
        
        // 리프레시 토큰 추출
        String refreshToken = null;
        Cookie[] cookies = request.getCookies();
        
        if (cookies != null) {
            Optional<Cookie> refreshCookie = Arrays.stream(cookies)
                    .filter(cookie -> "refresh_token".equals(cookie.getName()))
                    .findFirst();
                    
            if (refreshCookie.isPresent()) {
                refreshToken = refreshCookie.get().getValue();
            }
        }
        
        // 리프레시 토큰이 없거나 유효하지 않은 경우
        if (refreshToken == null || !jwtUtility.validateToken(refreshToken)) {
            handleInvalidToken(response, e);
            return;
        }
        
        try {
            // 리프레시 토큰에서 정보 추출
            Claims refreshClaims = jwtUtility.getClaims(refreshToken);
            String username = refreshClaims.getSubject();
            String tokenId = refreshClaims.getId();
            
            // Redis에서 리프레시 토큰 유효성 검증
            String redisKey = "JWT_RToken_" + username + "_" + tokenId;
            if (!redisService.hasKey(redisKey)) {
                throw new JwtException("유효하지 않은 리프레시 토큰");
            }
            
            // 사용자 정보 로드 및 새 액세스 토큰 생성
            var userDetails = userDetailsService.loadUserByUsername(username);
            String newAccessToken = jwtUtility.generateAccessToken(username, userDetails.getAuthorities());
            
            // 새 액세스 토큰을 쿠키에 설정
            Cookie newAccessTokenCookie = new Cookie("access_token", newAccessToken);
            newAccessTokenCookie.setHttpOnly(true);
            newAccessTokenCookie.setSecure(true);
            newAccessTokenCookie.setPath("/");
            newAccessTokenCookie.setMaxAge((int) (jwtUtility.getAccessTokenExpiration() / 1000));
            response.addCookie(newAccessTokenCookie);
            
            // 클라이언트에게 토큰 갱신 응답
            Map<String, Object> tokenResponse = new HashMap<>();
            tokenResponse.put("status", "renewed");
            tokenResponse.put("message", "액세스 토큰이 갱신되었습니다");
            tokenResponse.put("timestamp", LocalDateTime.now().toString());
            
            response.setContentType(MediaType.APPLICATION_JSON_VALUE);
            response.setStatus(HttpStatus.OK.value());
            objectMapper.writeValue(response.getWriter(), tokenResponse);
            
            log.info("액세스 토큰 갱신 완료: 사용자 {}", username);
            
        } catch (Exception refreshError) {
            log.error("토큰 갱신 실패: {}", refreshError.getMessage());
            handleInvalidToken(response, refreshError);
        }
    }

    /**
     * 유효하지 않은 토큰 처리 메서드
     * 인증 오류 응답 반환
     * @param response HTTP 응답
     * @param e 예외
     * @throws IOException IO 예외
     */
    private void handleInvalidToken(HttpServletResponse response, Exception e) throws IOException {
        Map<String, Object> errorResponse = new HashMap<>();
        errorResponse.put("status", "error");
        errorResponse.put("message", "인증 오류: " + e.getMessage());
        errorResponse.put("timestamp", LocalDateTime.now().toString());
        
        response.setContentType(MediaType.APPLICATION_JSON_VALUE);
        response.setStatus(HttpStatus.UNAUTHORIZED.value());
        objectMapper.writeValue(response.getWriter(), errorResponse);
    }

    /**
     * PluggableFilter 인터페이스 구현
     * 필터 설정 메서드
     */
    @Override
    public void configure(HttpSecurity http) throws Exception {
        http.addFilterBefore(this, UsernamePasswordAuthenticationFilter.class);
    }

    /**
     * PluggableFilter 인터페이스 구현
     * 필터 순서 반환 메서드
     */
    @Override
    public int getOrder() {
        return 1; // JWT 검증은 다른 필터보다 먼저 실행되어야 함
    }

    /**
     * PluggableFilter 인터페이스 구현
     * 이 필터 이전에 적용될 필터 클래스 반환
     */
    @Override
    public Class<? extends Filter> getBeforeFilter() {
        return null; // 이 필터 이전에 적용될 특정 필터가 없음
    }

    /**
     * PluggableFilter 인터페이스 구현
     * 이 필터 이후에 적용될 필터 클래스 반환
     */
    @Override
    public Class<? extends Filter> getAfterFilter() {
        return UsernamePasswordAuthenticationFilter.class;
    }
}


// ===================================

// 파일: backend/src/main/java/com/authentication/auth/filter/PathPatternFilterCondition.java
/**
 * @Author: choisimo
 * @Date: 2025-05-05
 * @Description: 경로 패턴 기반 필터 조건
 * @Details: URL 패턴과 HTTP 메소드 기반으로 필터 적용 여부를 결정
 */
    /**
     * 경로 패턴만 지정하는 생성자
     * @param description 조건 설명
     * @param patterns 포함할 URL 패턴 (Ant-style)
package com.authentication.auth.filter;

import jakarta.servlet.http.HttpServletRequest;
import org.springframework.http.HttpMethod;
import org.springframework.util.AntPathMatcher;

import java.util.HashSet;
import java.util.Set;

/**
 * @Author: choisimo
 * @Date: 2025-05-05
 * @Description: 경로 패턴 기반 필터 조건
 * @Details: URL 패턴과 HTTP 메소드 기반으로 필터 적용 여부를 결정
 */
public class PathPatternFilterCondition implements FilterCondition {
    
    private final Set<String> patterns = new HashSet<>();
    private final Set<HttpMethod> methods = new HashSet<>();
    private final AntPathMatcher pathMatcher = new AntPathMatcher();
    private final String description;
    
    /**
     * 경로 패턴만 지정하는 생성자
     * @param description 조건 설명
     * @param patterns 포함할 URL 패턴 (Ant-style)
     */
    public PathPatternFilterCondition(String description, String... patterns) {
        this.description = description;
        for (String pattern : patterns) {
            this.patterns.add(pattern);
        }
    }
    
    /**
     * 경로 패턴과 HTTP 메소드를 지정하는 생성자
     * @param description 조건 설명
     * @param methods 포함할 HTTP 메소드
     * @param patterns 포함할 URL 패턴 (Ant-style)
     */
    public PathPatternFilterCondition(String description, HttpMethod[] methods, String... patterns) {
        this(description, patterns);
        for (HttpMethod method : methods) {
            this.methods.add(method);
        }
    }
    
    /**
     * 패턴 추가
     * @param pattern 추가할 패턴
     * @return 현재 객체 (체이닝용)
     */
    public PathPatternFilterCondition addPattern(String pattern) {
        this.patterns.add(pattern);
        return this;
    }
    
    /**
     * HTTP 메소드 추가
     * @param method 추가할 HTTP 메소드
     * @return 현재 객체 (체이닝용)
     */
    public PathPatternFilterCondition addMethod(HttpMethod method) {
        this.methods.add(method);
        return this;
    }

    @Override
    public boolean shouldNotFilter(HttpServletRequest request) {
        String requestPath = request.getRequestURI();
        
        // 어느 하나의 패턴이라도 맞으면 필터 제외
        boolean matchesPattern = patterns.stream()
                .anyMatch(pattern -> pathMatcher.match(pattern, requestPath));
        
        // HTTP 메소드 제한이 없거나, 요청 메소드가 지정된 메소드 중 하나와 일치하면 필터 제외
        boolean matchesMethod = methods.isEmpty() || 
                               methods.contains(HttpMethod.valueOf(request.getMethod()));
        
        return matchesPattern && matchesMethod;
    }

    @Override
    public String getDescription() {
        return description;
    }
    
    @Override
    public String toString() {
        return "PathPatternFilterCondition{" +
                "description='" + description + '\'' +
                ", patterns=" + patterns +
                ", methods=" + methods +
                '}';
    }
}


// ===================================

// 파일: backend/src/main/java/com/authentication/auth/filter/PluggableFilter.java
/**
 * @Author: choisimo
 * @Date: 2025-05-05
 * @Description: 플러그형 필터 인터페이스
 * @Details: 동적으로 추가/제거 가능한 필터를 위한 인터페이스
 */
    /**
     * HttpSecurity에 이 필터를 구성
     * @param http HttpSecurity 객체
     * @throws Exception 구성 중 예외 발생 시
package com.authentication.auth.filter;
import jakarta.servlet.Filter;
import org.springframework.security.config.annotation.web.builders.HttpSecurity;
package com.authentication.auth.filter;

import jakarta.servlet.Filter;
import org.springframework.security.config.annotation.web.builders.HttpSecurity;

/**
 * @Author: choisimo
 * @Date: 2025-05-05
 * @Description: 플러그형 필터 인터페이스
 * @Details: 동적으로 추가/제거 가능한 필터를 위한 인터페이스
 */
public interface PluggableFilter extends Filter {
    
    /**
     * HttpSecurity에 이 필터를 구성
     * @param http HttpSecurity 객체
     * @throws Exception 구성 중 예외 발생 시
     */
    void configure(HttpSecurity http) throws Exception;
    
    /**
     * 필터의 실행 순서 반환
     * 낮은 값이 높은 우선순위를 의미함
     * @return 필터 실행 순서
     */
    int getOrder();
    
    /**
     * 이 필터 이전에 실행되어야 하는 필터 클래스 반환
     * @return 이전 필터 클래스, 없으면 null
     */
    Class<? extends Filter> getBeforeFilter();
    
    /**
     * 이 필터 이후에 실행되어야 하는 필터 클래스 반환
     * @return 이후 필터 클래스, 없으면 null
     */
    Class<? extends Filter> getAfterFilter();
    
    /**
     * 필터 ID 반환 (기본 구현은 클래스명)
     * @return 필터 ID
     */
    default String getFilterId() {
        return this.getClass().getSimpleName();
    }
}
/**
 * @Author: choisimo
 * @Date: 2025-05-05
 * @Description: 플러그형 필터 인터페이스
 * @Details: Spring Security 필터 체인에 쉽게 통합될 수 있는 필터 정의
 */
public interface PluggableFilter extends Filter {
    
    /**
     * HttpSecurity 구성에 현재 필터를 추가
     * @param http HttpSecurity 구성 객체
     * @throws Exception 구성 중 발생할 수 있는 예외
     */
    void configure(HttpSecurity http) throws Exception;
    
    /**
     * 필터 체인 내 순서를 결정하는 우선순위 값
     * 값이 낮을수록 높은 우선순위(먼저 실행)를 가짐
     * @return 순서 값
     */
    int getOrder();
    
    /**
     * 이 필터 이전에 적용되어야 하는 필터 클래스
     * @return 이전 필터 클래스 또는 null
     */
    Class<? extends Filter> getBeforeFilter();
    
    /**
     * 이 필터 이후에 적용되어야 하는 필터 클래스
     * @return 이후 필터 클래스 또는 null
     */
    Class<? extends Filter> getAfterFilter();
}


// ===================================

// 파일: backend/src/main/java/com/authentication/auth/filter/RoleBasedAccessFilter.java
/**
 * @Author: choisimo
 * @Date: 2025-05-05
 * @Description: 역할 기반 접근 제어 필터
 * @Details: 더 세분화된 역할 기반 접근 제어를 구현한 필터
 */
package com.authentication.auth.filter;

import jakarta.servlet.FilterChain;
import jakarta.servlet.ServletException;
import jakarta.servlet.http.HttpServletRequest;
import jakarta.servlet.http.HttpServletResponse;
import lombok.RequiredArgsConstructor;
import lombok.extern.slf4j.Slf4j;
import org.springframework.security.access.AccessDeniedException;
import org.springframework.security.core.Authentication;
import org.springframework.security.core.context.SecurityContextHolder;
import org.springframework.stereotype.Component;
import org.springframework.web.filter.OncePerRequestFilter;

import java.io.IOException;
import java.util.HashMap;
import java.util.Map;
import java.util.function.Predicate;

/**
 * @Author: choisimo
 * @Date: 2025-05-05
 * @Description: 역할 기반 접근 제어 필터
 * @Details: 더 세분화된 역할 기반 접근 제어를 구현한 필터
 */
@Slf4j
@Component
@RequiredArgsConstructor
public class RoleBasedAccessFilter extends OncePerRequestFilter implements PluggableFilter {

    // URI 패턴에 따른 접근 제어 규칙 맵
    private final Map<Predicate<String>, Predicate<Authentication>> accessRules = new HashMap<>();
    
    // 생성자에서 접근 제어 규칙 초기화
    public RoleBasedAccessFilter() {
        // 관리자 전용 경로 설정
        accessRules.put(
            uri -> uri.startsWith("/admin"),
            auth -> auth.getAuthorities().stream()
                        .anyMatch(a -> a.getAuthority().equals("ROLE_ADMIN"))
        );
        
        // 사용자 전용 경로 설정
        accessRules.put(
            uri -> uri.startsWith("/user"),
            auth -> auth.getAuthorities().stream()
                        .anyMatch(a -> a.getAuthority().equals("ROLE_USER") || 
                                       a.getAuthority().equals("ROLE_ADMIN"))
        );
        
        // API 경로 설정
        accessRules.put(
            uri -> uri.startsWith("/api/reports"),
            auth -> auth.getAuthorities().stream()
                        .anyMatch(a -> a.getAuthority().equals("ROLE_ANALYST") || 
                                       a.getAuthority().equals("ROLE_ADMIN"))
        );
    }

    @Override
    protected void doFilterInternal(HttpServletRequest request, HttpServletResponse response,
                                   FilterChain filterChain) throws ServletException, IOException {
        
        String uri = request.getRequestURI();
        Authentication authentication = SecurityContextHolder.getContext().getAuthentication();
        
        // 인증되지 않은 요청은 다음 필터로 넘김 (인증 필터에서 처리)
        if (authentication == null || !authentication.isAuthenticated()) {
            filterChain.doFilter(request, response);
            return;
        }
        
        // URI에 맞는 접근 규칙 적용
        for (Map.Entry<Predicate<String>, Predicate<Authentication>> rule : accessRules.entrySet()) {
            if (rule.getKey().test(uri)) {
                if (!rule.getValue().test(authentication)) {
                    log.warn("역할 기반 접근 거부: 사용자={}, URI={}", 
                            authentication.getName(), uri);
                    throw new AccessDeniedException("해당 리소스에 접근할 권한이 없습니다.");
                }
                break;
            }
        }
        
        filterChain.doFilter(request, response);
    }
    
    @Override
    public void configure(HttpSecurity http) throws Exception {
        http.addFilterAfter(this, AuthorizationFilter.class);
    }

    @Override
    public int getOrder() {
        return 400; // AuthorizationFilter 다음 순서
    }

    @Override
    public Class<? extends Filter> getBeforeFilter() {
        return AuthorizationFilter.class;
    }

    @Override
    public Class<? extends Filter> getAfterFilter() {
        return null;
    }
}


// ===================================

// 파일: backend/src/main/java/com/authentication/auth/filter/securityFilterOrder.java
/**
 * @Author : choisimo 
 * @Date : 2025-05-05
 * @Description : SecurityFilterOrder enum class
 * @Details : 필터 체인에서 필터의 순서를 지정하는 열거형 클래스
 */
    /**
     * 필터 실행 순서를 나타내는 enum
     * order 값이 낮을수록 우선순위가 높음
     */
package com.authentication.auth.filter;

import java.util.HashMap;
import java.util.Map;

import lombok.Getter;

/**
 * @Author : choisimo 
 * @Date : 2025-05-05
 * @Description : SecurityFilterOrder enum class
 * @Details : 필터 체인에서 필터의 순서를 지정하는 열거형 클래스
 */

@Getter
public enum SecurityFilterOrder {
    /**
     * 필터 실행 순서를 나타내는 enum
     * order 값이 낮을수록 우선순위가 높음
     */
    AUTHENTICATION_FILTER(100),
    AUTHORIZATION_FILTER(200),
    SNS_REQUEST_FILTER(300);

    // 필터 순서 값
    private final int order;
    
    // order 값으로 필터를 빠르게 조회하기 위한 맵 (BigO(1))
    private static final Map<Integer, SecurityFilterOrder> ORDER_MAP = new HashMap<>();

    static {
        for (SecurityFilterOrder filter : SecurityFilterOrder.values()) {
            ORDER_MAP.put(filter.order, filter);
        }
    }

    SecurityFilterOrder(int order) {
        this.order = order;
    }

    /**
     * 순서 값으로 필터 열거형을 조회
     * @param order 필터 순서 값
     * @return 해당 순서의 필터 열거형
     * @throws IllegalArgumentException 유효하지 않은 순서값 입력 시
     */
    public static SecurityFilterOrder fromOrder(int order) {
        SecurityFilterOrder filter = ORDER_MAP.get(order);
        if (filter == null) {
            throw new IllegalArgumentException("유효하지 않은 필터 순서: " + order);
        }
        return filter;
    }

    /**
     * 문자열을 안전하게 필터 열거형으로 변환
     * @param name 필터 이름
     * @return 해당 이름의 필터 열거형, 없으면 기본값 반환
     */
    public static SecurityFilterOrder safeValueOf(String name) {
        try {
            return SecurityFilterOrder.valueOf(name);
        } catch (IllegalArgumentException e) {
            return SecurityFilterOrder.AUTHENTICATION_FILTER; // 기본값
        }
    }
}


// ===================================

// 파일: backend/src/main/java/com/authentication/auth/filter/SecurityFilterOrder.java
/**
 * @Author: choisimo
 * @Date: 2025-05-05
 * @Description: 보안 필터 순서 상수
 * @Details: 필터 체인 내에서 필터의 실행 순서를 정의하는 열거형
 */
package com.authentication.auth.filter;

/**
 * @Author: choisimo
 * @Date: 2025-05-05
 * @Description: 보안 필터 순서 상수
 * @Details: 필터 체인 내에서 필터의 실행 순서를 정의하는 열거형
 */
public enum SecurityFilterOrder {
    
    // 값이 낮을수록 먼저 실행됨
    REQUEST_LOGGING_FILTER(50),
    CORS_FILTER(100),
    CSRF_FILTER(200),
    AUTHENTICATION_FILTER(300),
    JWT_VERIFICATION_FILTER(400),
    AUTHORIZATION_FILTER(500),
    SESSION_MANAGEMENT_FILTER(600),
    EXCEPTION_TRANSLATION_FILTER(700);
    
    private final int order;
    
    SecurityFilterOrder(int order) {
        this.order = order;
    }
    
    public int getOrder() {
        return order;
    }
}


// ===================================

// 파일: backend/src/main/java/com/authentication/auth/filter/snsRequestFilter.java
package com.authentication.auth.filter;

import com.authentication.auth.DTO.token.tokenDto;
import com.authentication.auth.configuration.token.jwtUtility;
import com.authentication.auth.domain.users;
import com.authentication.auth.others.constants.SecurityConstants;
import com.authentication.auth.service.oauth2.oauth2Service;
import com.authentication.auth.service.oauth2.snsTokenValidator;
import com.authentication.auth.service.redis.redisService;

import jakarta.servlet.FilterChain;
import jakarta.servlet.ServletException;
import jakarta.servlet.http.Cookie;
import jakarta.servlet.http.HttpServletRequest;
import jakarta.servlet.http.HttpServletResponse;
import lombok.extern.slf4j.Slf4j;
import org.springframework.beans.factory.annotation.Value;
import org.springframework.security.core.Authentication;
import org.springframework.security.core.authority.SimpleGrantedAuthority;
import org.springframework.security.core.context.SecurityContextHolder;
import org.springframework.stereotype.Component;
import org.springframework.web.filter.OncePerRequestFilter;

import java.io.IOException;
import java.security.SecureRandom;
import java.text.ParseException;
import java.text.SimpleDateFormat;
import java.util.Collections;
import java.util.Date;
import java.util.Map;
import java.util.Random;

@Slf4j
@Component
public class snsRequestFilter implements PluggableFilter {

    private final JwtUtility jwtUtility;
    private final RedisService redisService;


    @Value("${site.domain}")
    private String domain;

    public snsRequestFilter(jwtUtility jwtUtility, redisService redisService, snsTokenValidator snsTokenValidator, oauth2Service oauth2Service) {
        this.jwtUtility = jwtUtility;
        this.redisService = redisService;
        this.snsTokenValidator = snsTokenValidator;
        this.oauth2Service = oauth2Service;
    }

    @Override
    protected void doFilterInternal(HttpServletRequest request, HttpServletResponse response, FilterChain filterChain) throws ServletException, IOException {

        String providerHeader = request.getHeader("provider"); // SNS 정보 제공자 추가하기
        String authorizationHolder = request.getHeader(SecurityConstants.TOKEN_HEADER);
        log.info("authorizationHolder logging for test {}", authorizationHolder);

        log.info("current SNS providerHeader is {} ", providerHeader);

        if (providerHeader == null || "server".equals(providerHeader)) {
            filterChain.doFilter(request, response);
            return;
        }

        if (!isBearerToken(authorizationHolder)) {
            log.error("authorization is null");
            filterChain.doFilter(request, response);
            return;
        }

        String JWT = extractToken(authorizationHolder);

        if (JWT == null) {
            filterChain.doFilter(request, response);
            return;
        }

        if (jwtUtility.validateJWT(JWT)) {
            setAuthentication(JWT);
        } else {
            handleRefreshToken(request, response, JWT, providerHeader);
        }

        filterChain.doFilter(request, response);
    }


    private void handleRefreshToken(HttpServletRequest request, HttpServletResponse response, String JWT, String providerHeader) throws IOException {
        String snsRefreshToken = jwtUtility.checkSnsCookie(request, response);
        if (snsRefreshToken == null) {
            log.warn("no refresh token exists in cookies .. ");
            return;
        }

        String userId = getUserIdFromJWT(JWT);
        if (RedisMatchSnsRToken(userId, snsRefreshToken)) {
            refreshTokenAndAuthenticate(request, response, snsRefreshToken, providerHeader, userId);
        } else {
            log.warn("sns refreshToken does not exist in redis .. ");
        }
    }

    private void refreshTokenAndAuthenticate(HttpServletRequest request, HttpServletResponse response, String snsRefreshToken, String providerHeader, String userId) throws IOException {
        Map<String, String> newTokens = snsTokenValidator.getNewTokenByRefreshToken(snsRefreshToken, providerHeader);
        String newSnsAccessToken = newTokens.get("access_token");

        if (newSnsAccessToken == null) {
            log.error("access token does not exist");
            return;
        }

        Map<String, Object> snsUserProfile = getSnsUserProfile(newSnsAccessToken, providerHeader);
        if (snsUserProfile == null) {
            log.error("cannot get any sns userProfiles");
            return;
        }

        String oauthId = extractOauthId(snsUserProfile, providerHeader);
        redisService.saveRToken(oauthId, providerHeader, snsRefreshToken);

        users user = oauth2Service.saveOrUpdateOauth2User(providerHeader, oauthId, snsUserProfile);
        tokenDto accessToken = jwtUtility.createToken(user.getUserId(), user.getNickname(), Collections.singletonList(new SimpleGrantedAuthority(user.getRole().name())));
        loginResponse(response, accessToken.getAccessToken(), snsRefreshToken, providerHeader);

        setAuthentication(accessToken.getAccessToken());
    }

    private String extractOauthId(Map<String, Object> snsUserProfile, String providerHeader) {
        return switch (providerHeader) {
            case "naver" -> ((Map<String, Object>) snsUserProfile.get("response")).get("id").toString();
            case "kakao" -> snsUserProfile.get("id").toString();
            default -> snsUserProfile.get("sub").toString();
        };
    }


    private String getUserIdFromJWT(String JWT) {
        return (String) jwtUtility.getClaimsFromAccessToken(JWT).get("userId");
    }



    private boolean RedisMatchSnsRToken(String userId, String RToken) {
        return redisService.findRToken(userId, "server", RToken);
    }

    private Map<String, Object> getSnsUserProfile(String access_token, String provider) {
        Map<String, Object> userProfile = null;
        switch (provider) {
            case "kakao" :
                userProfile = oauth2Service.getKakaoUserProfile(access_token);
                break;
            case "naver" :
                userProfile = oauth2Service.getNaverUserProfile(access_token);
                break;
            case "google" :
                userProfile = oauth2Service.getGoogleUserProfile(access_token);
                break;
            default:
                throw new IllegalArgumentException("Unsupported provider: " + provider);
        }
        return userProfile;
    }

    private void loginResponse(HttpServletResponse response, String accessToken, String refreshToken, String provider) {
        Cookie newCookie = new Cookie(provider + "_refreshToken", refreshToken);
        newCookie.setHttpOnly(true);
        newCookie.setDomain(domain);
        newCookie.setPath("/");
        response.addCookie(newCookie);

        response.addHeader(SecurityConstants.TOKEN_HEADER, SecurityConstants.TOKEN_PREFIX + accessToken);
    }


    private Date parseBirthday(String birthday) {
        if (birthday != null && birthday.length() == 5) {
            try {
                SimpleDateFormat sdf = new SimpleDateFormat("MM-dd");
                Date date = sdf.parse(birthday);
                return date;
            } catch (ParseException e) {
                log.error("Error parsing birthday: ", e);
            }
        }
        return null; // Implement proper parsing if different format
    }


    private String generateRandomString(int length) {
        final String characters = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789";
        Random random = new SecureRandom();
        StringBuilder sb = new StringBuilder(length);

        for (int i = 0; i < length; i++) {
            sb.append(characters.charAt(random.nextInt(characters.length())));
        }

        return sb.toString();
    }

    private String extractToken(String authorizationHolder) {
        return authorizationHolder != null ? authorizationHolder.split(" ")[1] : null;
    }


    private boolean isBearerToken(String authorization) {
        return authorization != null && authorization.startsWith("Bearer ");
    }

    private void setAuthentication(String JWT) {
        try {
            Authentication authentication = jwtUtility.getAuthentication(JWT);
            SecurityContextHolder.getContext().setAuthentication(authentication);
            log.info("유효한 SNS authorization access_token");
        } catch (Exception e) {
            log.error("인증 실패!!");
        }
    }
        
        @Override
        public void configure(HttpSecurity http) throws Exception {
            http.addFilterBefore(this, JwtVerificationFilter.class);
        }
    
        @Override
        public int getOrder() {
            return 150; // AuthenticationFilter와 JwtVerificationFilter 사이 순서
        }
    
        @Override
        public Class<? extends Filter> getBeforeFilter() {
            return AuthenticationFilter.class;
        }
    
        @Override
        public Class<? extends Filter> getAfterFilter() {
            return JwtVerificationFilter.class;
        }
}


// ===================================

// 파일: backend/src/main/java/com/authentication/auth/filter/SnsRequestFilter.java
/**
 * SNS 로그인 요청 처리 필터
 * 소셜 미디어 인증 요청을 처리하고 리다이렉션
 */
package com.authentication.auth.filter;

import jakarta.servlet.FilterChain;
import jakarta.servlet.ServletException;
import jakarta.servlet.http.HttpServletRequest;
import jakarta.servlet.http.HttpServletResponse;
import lombok.RequiredArgsConstructor;
import lombok.extern.slf4j.Slf4j;
import org.springframework.stereotype.Component;

import java.io.IOException;

/**
 * SNS 로그인 요청 처리 필터
 * 소셜 미디어 인증 요청을 처리하고 리다이렉션
 */
@Slf4j
@Component
@RequiredArgsConstructor
public class SnsRequestFilter extends AbstractSecurityFilter {

    private final ApiChecker apiChecker;

    public SnsRequestFilter(ApiChecker apiChecker) {
        super(SecurityFilterOrder.SNS_REQUEST_FILTER);
        this.apiChecker = apiChecker;
    }

    @Override
    protected void doFilterInternal(HttpServletRequest request, HttpServletResponse response, FilterChain chain)
            throws IOException, ServletException {
        
        String requestURI = request.getRequestURI();
        
        // SNS 인증 관련 경로 처리
        if (requestURI.startsWith("/api/auth/social/")) {
            // SNS 제공자 추출 (예: /api/auth/social/google)
            String provider = requestURI.substring("/api/auth/social/".length());
            
            log.debug("SNS 인증 요청 감지: {}", provider);
            
            // SNS 별 인증 처리 로직 구현
            // 예: 요청 파라미터 검증, 리다이렉션 URL 생성 등
            
            // 인증 코드가 포함된 경우 토큰 교환 처리
            String code = request.getParameter("code");
            if (code != null && !code.isEmpty()) {
                log.debug("인증 코드 처리: {}", code);
                // 인증 코드로 액세스 토큰 교환 로직 구현
            }
        }
        
        // 다음 필터로 요청 전달
        chain.doFilter(request, response);
    }

    @Override
    protected boolean shouldNotFilter(HttpServletRequest request) {
        String requestURI = request.getRequestURI();
        
        // SNS 인증 경로만 필터링
        if (requestURI.startsWith("/api/auth/social/")) {
            return false; // 필터 적용
        }
        
        // 다른 모든 경로는 이 필터를 건너뜀
        return true;
    }
}


// ===================================

// 파일: backend/src/main/java/com/authentication/auth/others/constants/SecurityConstants.java
/**
 * 보안 관련 상수를 정의하는 Enum 클래스
 * JWT 토큰, 인증, 인가 관련 상수 정의
 */
    AUTH_WHITE_LIST("AUTH_WHITE_LIST", "/api/auth/**,/public/**,/api/v1/health,/swagger-ui/**,/v3/api-docs/**");
    
    private final String key;
    private final String value;
    
    // 값 탐색을 위한 매핑
package com.authentication.auth.others.constants;

import java.util.HashMap;
import java.util.Map;
import java.util.Optional;

/**
 * 보안 관련 상수를 정의하는 Enum 클래스
 * JWT 토큰, 인증, 인가 관련 상수 정의
 */
public enum SecurityConstants {

    TOKEN_TYPE("TOKEN_TYPE", "JWT"),
    TOKEN_HEADER("TOKEN_HEADER", "Authorization"),
    TOKEN_PREFIX("TOKEN_PREFIX", "Bearer "),
    TOKEN_TYPE_REFRESH("TOKEN_TYPE_REFRESH", "refreshJWT"),
    
    ACCESS_TOKEN_EXPIRATION("ACCESS_TOKEN_EXPIRATION", "1800"), // 30분(초 단위)
    REFRESH_TOKEN_EXPIRATION("REFRESH_TOKEN_EXPIRATION", "2592000"), // 30일(초 단위)
    COOKIE_NAME("COOKIE_NAME", "refresh_token"),
    COOKIE_SECURE("COOKIE_SECURE", "true"),
    COOKIE_HTTP_ONLY("COOKIE_HTTP_ONLY", "true"),
    COOKIE_PATH("COOKIE_PATH", "/"),
    COOKIE_DOMAIN("COOKIE_DOMAIN", ""),
    REMEMBER_ME_KEY("REMEMBER_ME_KEY", "rememberMeKey"),
    REMEMBER_ME_VALIDITY("REMEMBER_ME_VALIDITY", "1209600"), // 14일(초 단위)
    CORS_ALLOWED_ORIGINS("CORS_ALLOWED_ORIGINS", "*"),
    CORS_ALLOWED_METHODS("CORS_ALLOWED_METHODS", "GET,POST,PUT,DELETE,OPTIONS"),
    CSRF_HEADER_NAME("CSRF_HEADER_NAME", "X-CSRF-TOKEN"),
    CSRF_PARAMETER_NAME("CSRF_PARAMETER_NAME", "_csrf"),
    LOGIN_URL("LOGIN_URL", "/api/auth/login"),
    LOGOUT_URL("LOGOUT_URL", "/api/auth/logout"),
    SIGNUP_URL("SIGNUP_URL", "/api/auth/signup"),
    AUTH_WHITE_LIST("AUTH_WHITE_LIST", "/api/auth/**,/public/**,/api/v1/health,/swagger-ui/**,/v3/api-docs/**");
    
    private final String key;
    private final String value;
    
    // 값 탐색을 위한 매핑
    private static final Map<String, SecurityConstants> BY_KEY = new HashMap<>();
    private static final Map<String, SecurityConstants> BY_VALUE = new HashMap<>();
    
    // 정적 초기화 블록으로 매핑 초기화
    static {
        for (SecurityConstants constant : values()) {
            BY_KEY.put(constant.getKey(), constant);
            BY_VALUE.put(constant.getValue(), constant);
        }
    }
    
    /**
     * SecurityConstants 생성자
     * @param key 상수 키
     * @param value 상수 값
     */
    SecurityConstants(String key, String value) {
        if (key == null || key.isEmpty() || value == null || value.isEmpty()) {
            throw new IllegalArgumentException("키와 값은 null이거나 빈 문자열일 수 없습니다.");
        }
        this.key = key;
        this.value = value;
    }
    
    /**
     * 상수 키를 반환합니다.
     * @return 상수 키
     */
    public String getKey() {
        return key;
    }
    
    /**
     * 상수 값을 반환합니다.
     * @return 상수 값
     */
    public String getValue() {
        return value;
    }
    
    /**
     * 상수 값을 정수로 반환합니다.
     * @return 정수로 변환된 상수 값
     * @throws NumberFormatException 상수 값이 정수로 변환될 수 없는 경우
     */
    public int getIntValue() {
        return Integer.parseInt(value);
    }
    
    /**
     * 상수 값을 long으로 반환합니다.
     * @return long으로 변환된 상수 값
     * @throws NumberFormatException 상수 값이 long으로 변환될 수 없는 경우
     */
    public long getLongValue() {
        return Long.parseLong(value);
    }
    
    /**
     * 상수 값을 boolean으로 반환합니다.
     * @return boolean으로 변환된 상수 값
     */
    public boolean getBooleanValue() {
        return Boolean.parseBoolean(value);
    }
    
    /**
     * 키로 SecurityConstants를 찾습니다.
     * @param key 찾으려는 상수의 키
     * @return 해당 키에 매핑된 SecurityConstants 또는 null
     */
    public static SecurityConstants fromKey(String key) {
        return BY_KEY.get(key);
    }
    
    /**
     * 값으로 SecurityConstants를 찾습니다.
     * @param value 찾으려는 상수의 값
     * @return 해당 값을 가진 SecurityConstants 또는 null
     */
    public static SecurityConstants fromValue(String value) {
        return BY_VALUE.get(value);
    }
    
    /**
     * 키로 SecurityConstants를 안전하게 찾습니다.
     * @param key 찾으려는 상수의 키
     * @return 해당 키에 매핑된 SecurityConstants를 담고 있는 Optional
     */
    public static Optional<SecurityConstants> getByKey(String key) {
        return Optional.ofNullable(fromKey(key));
    }
    
    /**
     * 값으로 SecurityConstants를 안전하게 찾습니다.
     * @param value 찾으려는 상수의 값
     * @return 해당 값을 가진 SecurityConstants를 담고 있는 Optional
     */
    public static Optional<SecurityConstants> getByValue(String value) {
        return Optional.ofNullable(fromValue(value));
    }
    
    /**
     * Enum 상수를 문자열로 반환합니다.
     * @return 키와 값을 포함한 문자열 표현
     */
    @Override
    public String toString() {
        return String.format("%s[key=%s, value=%s]", name(), key, value);
    }
    
    /**
     * 모든 SecurityConstants를 문자열로 출력합니다.
     * 디버깅 용도로 유용합니다.
     * @return 모든 보안 상수에 대한 문자열 표현
     */
    public static String printAll() {
        StringBuilder sb = new StringBuilder("SecurityConstants:\n");
        for (SecurityConstants constant : values()) {
            sb.append(constant.toString()).append("\n");
        }
        return sb.toString();
    }
}
    }
}


// ===================================

// 파일: backend/src/main/java/com/authentication/auth/repository/AuthProviderRepository.java



// ===================================

// 파일: backend/src/main/java/com/authentication/auth/repository/usersRepository.java
package com.career_block.auth.repository;

import com.authentication.auth.domain.User;
import com.authentication.auth.domain.users;

import org.springframework.data.jpa.repository.JpaRepository;
import org.springframework.data.jpa.repository.Modifying;
import org.springframework.data.jpa.repository.Query;
import org.springframework.transaction.annotation.Transactional;

import java.util.Optional;

public interface usersRepository extends JpaRepository<users, Long> {

    User findByUserId(String userId);
    boolean existsByEmail(String email);
    boolean existsByUserIdOrNickname(String userId, String nickname);
    boolean existsByNickname(String nickname);

    boolean existsByUserId(String userId);

    @Modifying
    @Transactional
    @Query("UPDATE users u SET u.userPw = :password WHERE u.userId = :userId")
    int updatePassword(String userId, String password);

    Optional<User> findByProviderAndProviderId(String provider, String providerId);
}


// ===================================

// 파일: backend/src/main/java/com/authentication/auth/service/oauth2/oauth2Service.java
package com.career_block.auth.service.oauth2;

import jakarta.servlet.http.Cookie;
import jakarta.servlet.http.HttpServletResponse;
import lombok.RequiredArgsConstructor;
import lombok.extern.slf4j.Slf4j;
import org.springframework.beans.factory.annotation.Value;
import org.springframework.http.*;
import org.springframework.security.core.authority.SimpleGrantedAuthority;
import org.springframework.stereotype.Service;
import org.springframework.transaction.annotation.Transactional;
import org.springframework.util.LinkedMultiValueMap;
import org.springframework.util.MultiValueMap;
import org.springframework.web.client.HttpClientErrorException;
import org.springframework.web.client.RestTemplate;

import com.authentication.auth.DTO.token.tokenDto;
import com.authentication.auth.configuration.token.jwtUtility;
import com.authentication.auth.domain.Role;
import com.authentication.auth.domain.users;
import com.authentication.auth.others.nickNameGenerator;
import com.authentication.auth.others.constants.SecurityConstants;
import com.authentication.auth.repository.usersRepository;
import com.authentication.auth.service.redis.redisService;

import java.net.URLDecoder;
import java.nio.charset.StandardCharsets;
import java.security.SecureRandom;
import java.text.ParseException;
import java.text.SimpleDateFormat;
import java.util.*;


@Slf4j
@Service
@RequiredArgsConstructor
public class oauth2Service {

    @Value("${spring.security.oauth2.client.registration.kakao.client-id}")
    private String kakaoClientId;

    @Value("${spring.security.oauth2.client.registration.kakao.client-secret}")
    private String kakaoClientSecret;

    @Value("${spring.security.oauth2.client.registration.kakao.redirect-uri}")
    private String kakaoRedirectUri;

    @Value("${spring.security.oauth2.client.registration.naver.client-id}")
    private String naverClientId;

    @Value("${spring.security.oauth2.client.registration.naver.client-secret}")
    private String naverClientSecret;

    @Value("${spring.security.oauth2.client.registration.naver.redirect-uri}")
    private String naverRedirectUri;

    @Value("${spring.security.oauth2.client.registration.google.client-id}")
    private String googleClientId;

    @Value("${spring.security.oauth2.client.registration.google.client-secret}")
    private String googleClientSecret;

    @Value("${spring.security.oauth2.client.registration.google.redirect-uri}")
    private String googleRedirectUri;

    @Value("${site.domain}")
    private String domain;

    private final usersRepository usersRepository;
    private final redisService redisService;
    private final jwtUtility jwtUtility;
    private final nickNameGenerator nickNameGenerator;


    public Map<String, String> getKakaoTokens(String tempCode) {
        log.info("current : getKakaoTokens");

        String url = "https://kauth.kakao.com/oauth/token";

        RestTemplate restTemplate = new RestTemplate();

        HttpHeaders headers = new HttpHeaders();
        headers.add("Content-Type", "application/x-www-form-urlencoded");

        MultiValueMap<String, String> params = new LinkedMultiValueMap<>();
        params.add("grant_type", "authorization_code");
        params.add("client_id", kakaoClientId);
        params.add("redirect_uri", kakaoRedirectUri);
        params.add("code", tempCode);
        params.add("client_secret", kakaoClientSecret);

        HttpEntity<MultiValueMap<String, String>> entity = new HttpEntity<>(params, headers);

        try {
            ResponseEntity<Map> response = restTemplate.exchange(url, HttpMethod.POST, entity, Map.class);

            if (response.getBody() != null && response.getBody().containsKey("access_token") && response.getBody().containsKey("refresh_token")) {
                return Map.of(
                        "access_token", response.getBody().get("access_token").toString(),
                        "refresh_token", response.getBody().get("refresh_token").toString()
                );
            } else {
                throw new RuntimeException("액세스 토큰을 가져오지 못했습니다.");
            }
        } catch (Exception e) {
            log.error("Error while requesting tokens: ", e);
            throw e;
        }
    }

    public Map<String, Object> getKakaoUserProfile(String accessToken) {
        log.info("current : getKakaoUserProfile");

        String url = "https://kapi.kakao.com/v2/user/me";

        RestTemplate restTemplate = new RestTemplate();

        HttpHeaders headers = new HttpHeaders();
        headers.add("Authorization", "Bearer " + accessToken);

        log.info("Requesting user profile with accessToken: {}", accessToken);

        HttpEntity<Void> entity = new HttpEntity<>(headers);

        try {
            ResponseEntity<Map> response = restTemplate.exchange(url, HttpMethod.GET, entity, Map.class);

            if (response.getBody() != null) {
                return response.getBody();
            } else {
                throw new RuntimeException("사용자 프로필을 가져오지 못했습니다.");
            }
        } catch (Exception e) {
            log.error("Error while requesting user profile: ", e);
            throw e;
        }
    }

    public Map<String, String> getNaverTokens(String tempCode, String state) {
        log.info("current : getNaverTokens");

        String url = "https://nid.naver.com/oauth2.0/token";

        RestTemplate restTemplate = new RestTemplate();

        HttpHeaders headers = new HttpHeaders();
        headers.add("Content-Type", "application/x-www-form-urlencoded");

        MultiValueMap<String, String> params = new LinkedMultiValueMap<>();
        params.add("grant_type", "authorization_code");
        params.add("client_id", naverClientId);
        params.add("redirect_uri", naverRedirectUri);
        params.add("code", tempCode);
        params.add("client_secret", naverClientSecret);
        params.add("state", state);

        log.info("Requesting tokens with params: {}", params);

        HttpEntity<MultiValueMap<String, String>> entity = new HttpEntity<>(params, headers);

        try {
            ResponseEntity<Map> response = restTemplate.exchange(url, HttpMethod.POST, entity, Map.class);

            log.info("Response from Naver: {}", response);

            if (response.getStatusCode() == HttpStatus.OK) {
                Map<String, Object> responseBody = response.getBody();
                log.info("responseBody info : {}", responseBody.toString());

                if (responseBody != null && responseBody.containsKey("access_token") && responseBody.containsKey("refresh_token")) {
                    log.info("Received tokens: {}", responseBody);
                    return Map.of(
                            "access_token", responseBody.get("access_token").toString(),
                            "refresh_token", responseBody.get("refresh_token").toString()
                    );
                } else {
                    log.error("Response body is missing required tokens: {}", responseBody);
                    throw new RuntimeException("액세스 토큰을 가져오지 못했습니다.");
                }
            } else {
                log.error("Failed to get tokens, status code: {}, response: {}", response.getStatusCode(), response.getBody());
                throw new RuntimeException("액세스 토큰을 가져오지 못했습니다.");
            }
        } catch (Exception e) {
            log.error("Error while requesting tokens: ", e);
            throw e;
        }
    }


    public Map<String, Object> getNaverUserProfile(String accessToken) {
        log.info("current : getNaverUserProfile");

        String url = "https://openapi.naver.com/v1/nid/me";

        RestTemplate restTemplate = new RestTemplate();

        HttpHeaders headers = new HttpHeaders();
        headers.add("Authorization", "Bearer " + accessToken);

        log.info("Requesting user profile with accessToken: {}", accessToken);

        HttpEntity<Void> entity = new HttpEntity<>(headers);

        try {
            ResponseEntity<Map> response = restTemplate.exchange(url, HttpMethod.GET, entity, Map.class);

            if (response.getBody() != null) {
                return response.getBody();
            } else {
                throw new RuntimeException("사용자 프로필을 가져오지 못했습니다.");
            }
        } catch (Exception e) {
            log.error("Error while requesting user profile: ", e);
            throw e;
        }
    }

    public Map<String, String> getGoogleTokens(String tempCode) {
        log.info("current : getGoogleTokens");

        String url = "https://oauth2.googleapis.com/token";

        RestTemplate restTemplate = new RestTemplate();

        HttpHeaders headers = new HttpHeaders();
        headers.add("Content-Type", "application/x-www-form-urlencoded");

        String decode =URLDecoder.decode(tempCode, StandardCharsets.UTF_8);

        MultiValueMap<String, String> params = new LinkedMultiValueMap<>();
        params.add("grant_type", "authorization_code");
        params.add("client_id", googleClientId);
        params.add("redirect_uri", googleRedirectUri);
        params.add("code", decode);
        params.add("client_secret", googleClientSecret);
        params.add("access_type", "offline");
        params.add("prompt", "consent");

        log.info("Requesting tokens with params: {}", params);

        HttpEntity<MultiValueMap<String, String>> entity = new HttpEntity<>(params, headers);

        try {
            ResponseEntity<Map> response = restTemplate.exchange(url, HttpMethod.POST, entity, Map.class);

            if (response.getBody() != null && response.getBody().containsKey("access_token") && response.getBody().containsKey("refresh_token")) {
                log.info("Received tokens: {}", response.getBody());
                return Map.of(
                        "access_token", response.getBody().get("access_token").toString(),
                        "refresh_token", response.getBody().get("refresh_token").toString()
                );
            } else {
                log.info("response.getBody() :  {}", response.getBody());
                throw new RuntimeException("액세스 토큰을 가져오지 못했습니다.");
            }

        } catch (HttpClientErrorException e) {
            if (e.getStatusCode() == HttpStatus.BAD_REQUEST) {
                log.error("Oauth 2.0 compliance error: {}", e.getResponseBodyAsString());
            } else {
                log.error("Error while requesting tokens : ", e);
            }
            throw e;
        }
    }

    public Map<String, Object> getGoogleUserProfile(String accessToken) {
        log.info("current : getGoogleUserProfile");

        String url = "https://www.googleapis.com/oauth2/v3/userinfo";

        RestTemplate restTemplate = new RestTemplate();

        HttpHeaders headers = new HttpHeaders();
        headers.add("Authorization", "Bearer " + accessToken);

        log.info("Requesting user profile with accessToken: {}", accessToken);

        HttpEntity<Void> entity = new HttpEntity<>(headers);

        try {
            ResponseEntity<Map> response = restTemplate.exchange(url, HttpMethod.GET, entity, Map.class);

            if (response.getBody() != null) {
                return response.getBody();
            } else {
                throw new RuntimeException("사용자 프로필을 가져오지 못했습니다.");
            }
        } catch (Exception e) {
            log.error("Error while requesting user profile: ", e);
            throw e;
        }
    }

    @Transactional
    public users saveOrUpdateOauth2User(String provider, String oauthId, Map<String, Object> userProfile) {
        Optional<users> optionalUser = usersRepository.findByProviderAndProviderId(provider, oauthId);
        users user;
        if (optionalUser.isPresent()) {
            user = optionalUser.get();
            log.info("user found for {}", optionalUser.get().getUserId());
            updateUserDetails(user, userProfile, provider);
        } else {
            log.info("user not found, creating new user");
            user = createUser(provider, userProfile);
        }
        return usersRepository.save(user);
    }


    private void updateUserDetails(users user, Map<String, Object> userProfile, String provider) {
        log.info("updateUserDetails 호출");

        String newName = null;
        String newNickname = null;
        String newProfileImage = null;
        String newGender = null;
        String newPhone = null;
        String newBirthDate = null;
        String newEmail = null;

        String defaultString = "";
        String defaultGender = "N/A";
        String defaultPhone = "000-0000-0000";

        switch (provider) {
            case "kakao":
                Map<String, Object> properties = (Map<String, Object>) userProfile.get("properties");
                newNickname = (String) properties.get("nickname");
                newProfileImage = (String) properties.get("profile_image");
                Map<String, Object> kakaoAccount = (Map<String, Object>) userProfile.get("kakao_account");
                newEmail = (String) kakaoAccount.get("email");
                break;
            case "naver":
                Map<String, Object> response = (Map<String, Object>) userProfile.get("response");
                newName = (String) response.get("name");
                newNickname = (String) response.get("nickname");
                newProfileImage = (String) response.get("profile_image");
                newEmail = (String) response.get("email");
                newGender = (String) response.get("gender");
                newPhone = (String) response.get("mobile_e164");
                newBirthDate = (String) response.get("birthday");
                break;
            case "google":
                newName = (String) userProfile.get("name");
                newProfileImage = (String) userProfile.get("picture");
                newEmail = (String) userProfile.get("email");
                newGender = defaultGender;
                newPhone = defaultPhone;
                newBirthDate = defaultString;
                break;
        }

        if (newName != null && !newName.equals(user.getUserName())) {
            user.setUserName(newName);
        }

        if (newNickname != null && !newNickname.equals(user.getNickname())) {
            user.setNickname(newNickname);
        }

        if (newProfileImage != null && !newProfileImage.equals(user.getProfile())) {
            user.setProfile(newProfileImage);
        }

        if (newGender != null && !newGender.equals(user.getGender())) {
            user.setGender(newGender);
        }

        if (newPhone != null && !newPhone.equals(user.getPhone())) {
            user.setPhone(newPhone);
        }

        if (newBirthDate != null && !newBirthDate.equals(user.getBirthDate())) {
            user.setBirthDate(parseBirthday(newBirthDate));
        }

        if (newEmail != null && !newEmail.equals(user.getEmail())) {
            user.setEmail(newEmail);
        }
    }

    private users createUser(String provider, Map<String, Object> userProfile) {

        log.info("createUser 호출");

        String randomPassword = generateRandomString(13);
        String randomUserId = generateRandomString(13);

        String name = null;
        String nickname = null;
        String profileImage = null;
        String email = null;
        String providerId = null;
        String gender = null;
        String phone = null;
        String birthDate = null;

        String defaultString = "";
        String defaultGender = "N/A"; // Example default gender
        String defaultPhone = "000-0000-0000"; // Example default phone number


        log.info("provider [{}] 의 userProfile : {}", provider, userProfile);

        switch (provider) {
            case "kakao":
                Map<String, Object> properties = (Map<String, Object>) userProfile.get("properties");
                log.info("createUser [kakao] properties : {}", properties);
                providerId = String.valueOf(userProfile.get("id"));
                nickname = (String) properties.get("nickname");
                profileImage = (String) properties.get("profile_image");
                Map<String, Object> kakaoAccount = (Map<String, Object>) userProfile.get("kakao_account");
                email = (String) kakaoAccount.get("email");
                break;
            case "naver":
                Map<String, Object> response = (Map<String, Object>) userProfile.get("response");
                log.info("createUser [naver] response : {}", response);
                providerId = (String) response.get("id");
                name = (String) response.get("name");
                nickname = (String) response.get("nickname");
                profileImage = (String) response.get("profile_image");
                email = (String) response.get("email");
                gender = (String) response.get("gender");
                phone = (String) response.get("mobile_e164");
                birthDate = (String) response.get("birthday");
                break;
            case "google":
                log.info("createUser [google] userProfile : {}", userProfile);
                providerId = (String) userProfile.get("sub"); // Google uses "sub" for user ID
                name = (String) userProfile.get("name");
                profileImage = (String) userProfile.get("picture");
                email = (String) userProfile.get("email");
                gender = defaultGender; // Google does not provide gender directly
                phone = defaultPhone; // Google does not provide phone directly
                birthDate = defaultString; // Google does not provide birthdate directly
                break;
        }

        return users.builder()
                .userId(randomUserId)
                .userPw(randomPassword)
                .userName(name != null ? name : defaultString)
                .nickname(nickname != null ? nickname : defaultString)
                .email(email != null ? email : defaultString)
                .profile(profileImage != null ? profileImage : defaultString)
                .gender(gender != null ? gender : defaultGender)
                .phone(phone != null ? phone : defaultPhone)
                .birthDate(birthDate != null ? parseBirthday(birthDate) : null)
                .provider(provider)
                .providerId(providerId != null ? providerId : "")
                .role(Role.USER)
                .build();
    }

    @Transactional
    public ResponseEntity<?> handleOauth2Login(Map<String, String> requestBody, HttpServletResponse response, String provider) {
        log.info("current : handleOauth2Login{}", provider);

        String tempCode = requestBody.get("tempCode");

        if (tempCode == null) {
            log.error("there is no tempCode needed for {} login", provider);
            return ResponseEntity.status(HttpStatus.BAD_REQUEST).body("there is no tempCode needed for " + provider + " login");
        }

        try {
            Map<String, String> tokens;
            Map<String, Object> userProfile;

            switch (provider) {
                case "kakao":
                    tokens = getKakaoTokens(tempCode);
                    userProfile = getKakaoUserProfile(tokens.get("access_token"));
                    break;
                case "naver":
                    String state = requestBody.get("state");
                    if (state == null) {
                        log.error("there is no state needed for naver login");
                        return ResponseEntity.status(HttpStatus.BAD_REQUEST).body("there is no state for naver login");
                    }
                    tokens = getNaverTokens(tempCode, state);
                    userProfile = getNaverUserProfile(tokens.get("access_token"));
                    log.info("Naver user profile: {}", userProfile); // Log the entire user profile
                    break;
                case "google":
                    tokens = getGoogleTokens(tempCode);
                    userProfile = getGoogleUserProfile(tokens.get("access_token"));
                    break;
                default:
                    throw new IllegalArgumentException("Unsupported provider: " + provider);
            }

            String snsAccessToken = tokens.get("access_token");
            String refreshToken = tokens.get("refresh_token");

            if (snsAccessToken == null || refreshToken == null) {
                log.error("access token or refresh token does not exist");
                return ResponseEntity.status(HttpStatus.NO_CONTENT).body("access token or refresh token does not exist");
            }

            if (userProfile == null) {
                log.error("userProfile does not exist");
                return ResponseEntity.status(HttpStatus.NOT_FOUND).body("user info does not exist");
            }

            // extract userId based on provider
            String oauthId = switch (provider) {
                case "naver" -> ((Map<String, Object>) userProfile.get("response")).get("id").toString();
                case "kakao" -> userProfile.get("id").toString();
                case "google" -> userProfile.get("sub").toString();
                default -> throw new IllegalArgumentException("Unsupported provider: " + provider);
            };

            if (oauthId == null) {
                log.error("id를 파싱하는데 문제가 생긴 것 같습니다 ㅠㅠ");
            }

            // Redis에 refresh token 저장
            redisService.saveRToken(oauthId, provider, refreshToken);

            // Oauth2 사용자 확인 후 저장 또는 업데이트 하기
            users user = saveOrUpdateOauth2User(provider, oauthId, userProfile);

            // 서버 자체 access_token 생성
            tokenDto accessToken = jwtUtility.buildToken(user.getUserId(), user.getNickname(), Collections.singletonList(new SimpleGrantedAuthority(user.getRole().name())));

            loginResponse(response, accessToken.getAccessToken(), refreshToken, provider);

            //return ResponseEntity.ok(userProfile);
            return ResponseEntity.ok(Map.of(
                    "access_token", accessToken.getAccessToken(),
                    "userProfile", userProfile
            ));

        } catch (HttpClientErrorException e){
            if (e.getStatusCode() == HttpStatus.BAD_REQUEST && e.getResponseBodyAsString().contains("invalid_grant")) {
                log.error("{} 로그인 실패 - 재 사용된 인증 코드 입니다. ", provider);
                return ResponseEntity.status(HttpStatus.BAD_REQUEST).body("재사용된 인증 코드입니다.");
            }
            log.error("{} 로그인 실패!", provider, e);
            return ResponseEntity.status(HttpStatus.INTERNAL_SERVER_ERROR).body(provider + "로그인 실패!");
        } catch (Exception e) {
            log.error("{} 로그인 실패! ", provider, e);
            return ResponseEntity.status(HttpStatus.INTERNAL_SERVER_ERROR).body(provider + " 로그인 실패!");
        }
    }


    private void loginResponse(HttpServletResponse response, String accessToken, String refreshToken, String provider) {
        Cookie newCookie = new Cookie(provider + "_refreshToken", refreshToken);
        newCookie.setHttpOnly(true);
        newCookie.setDomain(domain);
        newCookie.setPath("/");
        response.addCookie(newCookie);

        response.addHeader(SecurityConstants.TOKEN_HEADER, SecurityConstants.TOKEN_PREFIX + accessToken);
    }


    private Date parseBirthday(String birthday) {
        if (birthday != null && birthday.length() == 5) {
            try {
                SimpleDateFormat sdf = new SimpleDateFormat("MM-dd");
                Date date = sdf.parse(birthday);
                return date;
            } catch (ParseException e) {
                log.error("Error parsing birthday: ", e);
            }
        }
        return null; // Implement proper parsing if different format
    }


    private String generateRandomString(int length) {
        final String characters = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789";
        Random random = new SecureRandom();
        StringBuilder sb = new StringBuilder(length);

        for (int i = 0; i < length; i++) {
            sb.append(characters.charAt(random.nextInt(characters.length())));
        }

        return sb.toString();
    }
}


// ===================================

// 파일: backend/src/main/java/com/authentication/auth/service/oauth2/snsTokenValidator.java
package com.career_block.auth.service.oauth2;

import lombok.extern.slf4j.Slf4j;
import org.springframework.beans.factory.annotation.Value;
import org.springframework.http.*;
import org.springframework.stereotype.Service;
import org.springframework.util.LinkedMultiValueMap;
import org.springframework.util.MultiValueMap;
import org.springframework.web.client.RestTemplate;

import java.util.HashMap;
import java.util.Map;

@Slf4j
@Service
public class snsTokenValidator {


    @Value("${kakao.token.validate.url}")
    private String kakaoValidateURL;

    @Value("${naver.token.validate.url}")
    private String naverValidateURL;

    @Value("${google.token.validate.url}")
    private String googleValidateURL;

    @Value("${spring.security.oauth2.client.registration.kakao.client-id}")
    private String kakaoClientId;

    @Value("${spring.security.oauth2.client.registration.kakao.client-secret}")
    private String kakaoClientSecret;

    @Value("${spring.security.oauth2.client.registration.kakao.redirect-uri}")
    private String kakaoRedirectUri;

    @Value("${spring.security.oauth2.client.registration.naver.client-id}")
    private String naverClientId;

    @Value("${spring.security.oauth2.client.registration.naver.client-secret}")
    private String naverClientSecret;

    @Value("${spring.security.oauth2.client.registration.naver.redirect-uri}")
    private String naverRedirectUri;

    @Value("${spring.security.oauth2.client.registration.google.client-id}")
    private String googleClientId;

    @Value("${spring.security.oauth2.client.registration.google.client-secret}")
    private String googleClientSecret;

    @Value("${spring.security.oauth2.client.registration.google.redirect-uri}")
    private String googleRedirectUri;

    @Value("${site.domain}")
    private String domain;

    private final RestTemplate restTemplate;

    public snsTokenValidator(RestTemplate restTemplate) {
        this.restTemplate = restTemplate;
    }


    public boolean validateToken(String token, String provider) {
        log.info("provider : [{}] token validation start", provider);
        return switch (provider) {
            case "kakao" -> kakaoValidateToken(token);
            case "naver" -> naverValidateToken(token);
            case "google" -> googleValidateToken(token);
            default -> false;
        };
    }

    public Map<String, String> getNewTokenByRefreshToken(String refreshToken, String provider) {
        String url = null;
        MultiValueMap<String, String> params = new LinkedMultiValueMap<>();
        RestTemplate restTemplate = new RestTemplate();
        HttpHeaders headers = new HttpHeaders();
        headers.add("Content-Type", "application/x-www-form-urlencoded");

        switch (provider) {
            case "kakao":
                url = "https://kauth.kakao.com/oauth/token";
                params.add("grant_type", "refresh_token");
                params.add("client_id", kakaoClientId);
                params.add("refresh_token", refreshToken);
                params.add("client_secret", kakaoClientSecret);
                break;
            case "naver":
                url = "https://nid.naver.com/oauth2.0/token";
                params.add("grant_type", "refresh_token");
                params.add("client_id", naverClientId);
                params.add("refresh_token", refreshToken);
                params.add("client_secret", naverClientSecret);
                break;
            case "google":
                url = "https://oauth2.googleapis.com/token";
                params.add("grant_type", "refresh_token");
                params.add("client_id", googleClientId);
                params.add("refresh_token", refreshToken);
                params.add("client_secret", googleClientSecret);
                break;
            default:
                throw new IllegalArgumentException("Unsupported provider: " + provider);
        }

        HttpEntity<MultiValueMap<String, String>> entity = new HttpEntity<>(params, headers);
        ResponseEntity<Map> response = restTemplate.exchange(url, HttpMethod.POST, entity, Map.class);

        if (response.getStatusCode() == HttpStatus.OK && response.getBody() != null) {
            Map<String, String> tokens = new HashMap<>();
            tokens.put("access_token", response.getBody().get("access_token").toString());
            if (response.getBody().containsKey("refresh_token")) {
                tokens.put("refresh_token", response.getBody().get("refresh_token").toString());
            }
            return tokens;
        } else {
            throw new RuntimeException("Failed to get sns tokens for provider: " + provider);
        }
    }



    private boolean kakaoValidateToken(String token) {
        String url = kakaoValidateURL;
        HttpHeaders headers = new HttpHeaders();
        headers.set("Authorization", "Bearer " + token);
        HttpEntity<String> entity = new HttpEntity<>(headers);
        try {
            ResponseEntity<String> response = restTemplate.exchange(url, HttpMethod.GET, entity, String.class);
            return response.getStatusCode().is2xxSuccessful();
        } catch (Exception e) {
            log.error("카카오 토큰 검증 중 에러 발생", e);
            return false;
        }
    }

    private boolean naverValidateToken(String token) {
        String url = naverValidateURL;
        HttpHeaders headers = new HttpHeaders();
        headers.set("Authorization", "Bearer " + token);
        HttpEntity<String> entity = new HttpEntity<>(headers);
        try {
            ResponseEntity<String> response = restTemplate.exchange(url, HttpMethod.GET, entity, String.class);
            return response.getStatusCode().is2xxSuccessful();
        } catch (Exception e) {
            log.error("네이버 토큰 검증 중 에러 발생", e);
            return false;
        }
    }

    private boolean googleValidateToken(String token) {
        String url = googleValidateURL + "?id_token=" + token;
        try {
            ResponseEntity<String> response = restTemplate.getForEntity(url, String.class);
            return response.getStatusCode().is2xxSuccessful();
        } catch (Exception e) {
            log.error("구글 토큰 검증 중 에러 발생", e);
            return false;
        }
    }
}


// ===================================

// 파일: backend/src/main/java/com/authentication/auth/service/redis/redisService.java
package com.career_block.auth.service.redis;

import lombok.RequiredArgsConstructor;
import lombok.extern.slf4j.Slf4j;
import org.springframework.beans.factory.annotation.Value;
import org.springframework.data.redis.core.RedisTemplate;
import org.springframework.stereotype.Component;
import org.springframework.transaction.annotation.Transactional;
import org.springframework.web.servlet.mvc.method.annotation.SseEmitter;

import java.util.Collections;
import java.util.List;
import java.util.Objects;
import java.util.Set;
import java.util.concurrent.TimeUnit;

@Slf4j
@RequiredArgsConstructor
@Component
public class redisService {

    @Value("${REFRESH_TOKEN_VALIDITY}")
    private long refreshExpire;

    @Value("${ACCESS_TOKEN_VALIDITY}")
    private long accessExpire;

    private final RedisTemplate<String, String> redisTemplate;


    private String RefreshTokenToRedisKey(String userId, String provider, String RToken) {
        if (userId == null || provider == null || RToken == null ||
                userId.isEmpty() || provider.isEmpty() || RToken.isEmpty()) {
            throw new RuntimeException("error while convert Refresh Token into REDIS_KEY..");
        }
        return provider + "_RToken_" + userId;
    }

    private String AccessTokenToRedisKey(String RToken) {
        if (RToken == null || RToken.isEmpty()){
            throw new RuntimeException("error while convert access Token into REDIS_KEY..");
        }
        return "_accessToken_" + RToken.substring(10);
    }

    @Transactional
    public boolean saveRToken(String userId, String provider, String RToken) {
        String REDIS_KEY = RefreshTokenToRedisKey(userId, provider, RToken);
        try {
            redisTemplate.opsForValue().set(REDIS_KEY, RToken, refreshExpire, TimeUnit.SECONDS);
            log.info("Redis RToken save success for provider: {}", provider);
            return true;
        } catch (Exception e) {
            log.error("Redis has failed to save Refresh Token for provider {} and for userId {}", provider, userId, e);
            return false;
        }
    }

    @Transactional
    public boolean saveAccessToken(String RToken, String accessToken, String userId) {
        String REDIS_KEY = AccessTokenToRedisKey(RToken);
        try {
            redisTemplate.opsForValue().set(REDIS_KEY, accessToken, accessExpire, TimeUnit.SECONDS);
            return true;
        } catch (Exception e) {
            log.error("Redis has failed to save Access Token for userId {}", userId);
            return false;
        }
    }

    @Transactional
    public String getAccessToken(String RToken) {
        String REDIS_KEY = AccessTokenToRedisKey(RToken);
        try {
            String accessToken = redisTemplate.opsForValue().get(REDIS_KEY);

            if (accessToken == null) {
                log.warn("No access Token INFO");
                return null;
            }

            return accessToken;
        } catch (Exception e) {
            log.error("Failed to get AccessToken INFO from REDIS");
            return null;
        }
    }

    @Transactional
    public boolean isRTokenExist(String userId, String provider, String RToken) {
        String REDIS_KEY = RefreshTokenToRedisKey(userId, provider, RToken);
        try {
            Boolean exists = redisTemplate.hasKey(REDIS_KEY);
            return exists != null && exists;
        } catch (Exception e) {
            log.error("REDIS key searching failed for provider: {}", provider, e);
            return false;
        }
    }


    @Transactional
    public boolean deleteRToken(String userId, String provider, String RToken) {
        String REDIS_KEY = RefreshTokenToRedisKey(userId, provider, RToken);
        try {
            Boolean removed = redisTemplate.delete(REDIS_KEY);
            return removed != null && removed;
        } catch (Exception e) {
            log.error("Failed to delete RToken for provider: {}", provider, e);
            return false;
        }
    }


    @Transactional
    public List<String> getAllRTokens(String userId, String provider) {
        String pattern = provider + "_RToken_" + userId + "_";
        Set<String> keys = redisTemplate.keys(pattern);
        if (keys == null || keys.isEmpty()){
            return Collections.emptyList();
        }
        return redisTemplate.opsForValue().multiGet(keys);
    }


    @Transactional
    public boolean changeRToken(String userId, String provider, String RToken, String newRToken) {
        try {
            deleteRToken(userId, provider, RToken);
            saveRToken(userId, provider, newRToken);
            log.info("{}'s RToken has been changed for provider: {}", userId, provider);
            return true;
        } catch (Exception e) {
            log.error("Failed to change RToken for provider: {}", provider, e);
            return false;
        }
    }


    @Transactional
    public boolean saveEmailCode(String email, String code) {
        if (email == null || email.isEmpty() || code == null || code.isEmpty()){
            log.error("essential parameter or parameters is null");
            return false;
        }
        try {
            redisTemplate.opsForValue().set(email, code, 1800, TimeUnit.SECONDS);
            return true;
        } catch (Exception e) {
            log.error("Failed to save email code for email: {}", email);
            return false;
        }
    }


    @Transactional(readOnly = true)
    public boolean checkEmailCode(String email, String code) {
        if (email == null || email.isEmpty() || code == null || code.isEmpty()){
            log.error("essential parameter or parameters is null");
            return false;
        }
        try {
            return (Objects.equals(code, redisTemplate.opsForValue().get(email)));
        } catch (Exception e) {
            log.error("Failed to check Email Code for email : {}", email);
            return false;
        }
    }

    @Transactional
    public boolean findRToken(String userId, String provider, String RToken) {
        try {
            String key = RefreshTokenToRedisKey(userId, provider, RToken);
            return Boolean.TRUE.equals(redisTemplate.opsForSet().isMember(key, RToken));
        } catch (Exception e) {
            log.error("redis key search failed", e);
            return false;
        }
    }


}


// ===================================

// 파일: backend/src/main/java/com/authentication/auth/service/security/principalDetailService.java
package com.career_block.auth.service.security;

import lombok.RequiredArgsConstructor;
import lombok.extern.slf4j.Slf4j;
import org.springframework.security.core.userdetails.UserDetails;
import org.springframework.security.core.userdetails.UserDetailsService;
import org.springframework.security.core.userdetails.UsernameNotFoundException;
import org.springframework.stereotype.Service;

import com.authentication.auth.DTO.token.principalDetails;
import com.authentication.auth.domain.users;
import com.authentication.auth.repository.usersRepository;

@Slf4j
@Service
@RequiredArgsConstructor
public class principalDetailService implements UserDetailsService {

    private final usersRepository repository;

    @Override
    public UserDetails loadUserByUsername(String username) throws UsernameNotFoundException {
        users user = repository.findByUserId(username);
        return new principalDetails(user);
    }
}


// ===================================

// 파일: backend/src/main/java/com/authentication/auth/service/smtp/emailService.java
package com.career_block.auth.service.smtp;

import lombok.RequiredArgsConstructor;
import lombok.extern.slf4j.Slf4j;
import org.springframework.beans.factory.annotation.Value;
import org.springframework.mail.javamail.JavaMailSender;
import org.springframework.mail.javamail.MimeMessageHelper;
import org.springframework.stereotype.Service;
import org.springframework.transaction.annotation.Transactional;

import com.authentication.auth.DTO.smtp.customEmailRequest;
import com.authentication.auth.DTO.smtp.customEmailToAllRequest;
import com.authentication.auth.repository.usersRepository;

import javax.mail.MessagingException;
import javax.mail.internet.MimeMessage;
import java.util.UUID;

@Slf4j
@Service
@RequiredArgsConstructor
public class emailService {

    @Value("${server.email.sender}")
    private String sender_email;
    private final usersRepository usersRepository;
    private final JavaMailSender mailSender;

    private String randomNum() {
        String rand = UUID.randomUUID().toString().replace("-", "");
        String result = "";
        for (int i = 0; i < 8; i++){
            result += rand.charAt(i);
        }
        return result;
    }


    public String joinEmail(String email){
        String rand = randomNum();
        String from_email = sender_email;
        String to_email = email;
        String title = "회원 가입 인증 이메일 입니다.";

        // HTML 이메일 컨텐츠
        String content =
                "<div style=\"font-family: Arial, sans-serif; max-width: 600px; margin: 0 auto; padding: 30px; border: 1px solid #e0e0e0; border-radius: 8px; background-color: #ffffff; box-shadow: 0 4px 8px rgba(0, 0, 0, 0.05);\">\n" +
                        "    <h2 style=\"color: #4c5baf; text-align: center; margin-bottom: 20px;\">\uD83C\uDF89 Career Block 에 오신 것을 환영합니다!</h2>\n" +
                        "\n" +
                        "    <p style=\"font-size: 16px; color: #333333; line-height: 1.6; margin-bottom: 20px;\">\n" +
                        "        가입해주셔서 진심으로 감사합니다! 아래의 이메일 인증 코드를 사용하여 가입을 완료해주세요.\n" +
                        "    </p>\n" +
                        "\n" +
                        "    <div style=\"text-align: center; margin: 30px 0;\">\n" +
                        "        <span style=\"display: inline-block; font-size: 28px; font-weight: bold; color: #4c5baf; padding: 15px 30px; border: 2px dashed #4c5baf; border-radius: 5px; background-color: #f0f4ff;\">\n" +
                        "            " + rand + "\n" +
                        "        </span>\n" +
                        "    </div>\n" +
                        "\n" +
                        "    <p style=\"font-size: 16px; color: #333333; line-height: 1.6;\">\n" +
                        "        위 코드를 인증 페이지에 입력하여 가입을 완료해주세요. 이 코드의 유효 시간은 30분 입니다.\n" +
                        "    </p>\n" +
                        "\n" +
                        "    <p style=\"font-size: 14px; color: #666666; line-height: 1.6; margin-top: 30px;\">\n" +
                        "        만약 Career Block 가입을 시도하지 않았다면, 이 메시지를 무시해 주세요.\n" +
                        "    </p>\n" +
                        "\n" +
                        "    <hr style=\"border-top: 1px solid #e0e0e0; margin-top: 40px; margin-bottom: 20px;\">\n" +
                        "\n" +
                        "    <p style=\"text-align: center; font-size: 12px; color: #999999;\">\n" +
                        "        © 2024 Career Block. All rights reserved.\n" +
                        "    </p>\n" +
                        "</div>\n";

        mailSend(from_email, to_email, title, content);
        return rand;
    }


    public String changePwEmail(String email){
        String rand = randomNum();
        String from_email = sender_email;
        String to_email = email;
        String title = "비밀번호 변경 이메일입니다.";
        String content =
                "<!DOCTYPE html>" +
                        "<html>" +
                        "    <head>" +
                        "        <meta charset='UTF-8'>" +
                        "        <title>비밀번호 변경 안내</title>" +
                        "        <style>" +
                        "            body { font-family: Arial, sans-serif; margin: 0; padding: 20px; background-color: #f6f6f6; }" +
                        "            .container { background-color: #ffffff; padding: 40px; border-radius: 10px; box-shadow: 0 2px 4px rgba(0, 0, 0, 0.1); }" +
                        "            h1 { color: #333333; }" +
                        "            p { color: #666666; }" +
                        "            .button { display: inline-block; padding: 10px 20px; color: #ffffff; background-color: #007bff; text-decoration: none; border-radius: 5px; }" +
                        "        </style>" +
                        "    </head>" +
                        "    <body>" +
                        "        <div class='container'>" +
                        "            <h1>비밀번호 변경 안내</h1>" +
                        "            <p>비밀번호를 잊어버리셨군요!</p>" +
                        "            <p>아래의 임시 비밀번호를 사용하여 비밀번호를 변경하세요:</p>" +
                        "            <h2>" + rand + "</h2>" +
                        "            <p><a href='gcp.nodove.com' class='button'>비밀번호 변경하기</a></p>" +
                        "        </div>" +
                        "    </body>" +
                        "</html>";
        mailSend(from_email, to_email, title, content);
        return rand;
    }




    public void mailSend(String from_email, String to_email, String title, String content) {
        MimeMessage message = mailSender.createMimeMessage();
        try {
            MimeMessageHelper helper = new MimeMessageHelper(message, true, "utf-8");
            helper.setFrom(from_email);
            helper.setTo(to_email);
            helper.setSubject(title);
            helper.setText(content, true);
            mailSender.send(message);

        } catch(MessagingException e){
            log.error("messagingException", e);
        }
    }

    @Transactional
    public void sendCustomEmail(customEmailRequest request) {
        try {
            String from_email = sender_email;
            String to_email = request.getEmail();
            String title = request.getTitle();
            String content = request.getContent();
            mailSend(from_email, to_email, title, content);
        } catch (Exception e) {
            log.error("message send Exception : ", e);
        }
    }

    @Transactional
    public void sendCustomEmailToAll(customEmailToAllRequest request) {

    }

    public boolean checkIsExistEmail(String userEmail){
        return usersRepository.existsByEmail(userEmail);
    }

}


// ===================================

// 파일: backend/src/main/java/com/authentication/auth/service/sse/sseService.java
package com.career_block.auth.service.sse;

import lombok.extern.slf4j.Slf4j;
import org.springframework.security.core.parameters.P;
import org.springframework.stereotype.Service;
import org.springframework.web.servlet.mvc.method.annotation.SseEmitter;

import java.io.IOException;
import java.util.List;
import java.util.concurrent.ConcurrentHashMap;
import java.util.concurrent.CopyOnWriteArrayList;

@Slf4j
@Service
public class sseService {

    // 사용자 ID를 키로, SseEmitter 목록을 값으로 저장
    private final ConcurrentHashMap<String, List<SseEmitter>> emittersMap = new ConcurrentHashMap<>();


    // SseEmitter 저장
    public boolean saveSseEmitter(String userId, SseEmitter emitter) {
        if (userId == null || userId.isEmpty() || emitter == null) {
            log.error("userId or emitter is null");
            return false;
        }

        emittersMap.computeIfAbsent(userId, k -> new CopyOnWriteArrayList<>()).add(emitter);

        // 연결 종료 시 제거
        emitter.onCompletion(() -> removeEmitter(userId, emitter));
        emitter.onTimeout(() -> removeEmitter(userId, emitter));
        emitter.onError((e) -> removeEmitter(userId, emitter));

        log.info("SseEmitter saved for userId: {}", userId);
        return true;
    }


    // SseEmitter 제거
    public void removeEmitter(String userId, SseEmitter emitter){
        List<SseEmitter> emitters = emittersMap.get(userId);
        if (emitters != null) {
            emitters.remove(emitter);
            if (emitters.isEmpty()) {
                emittersMap.remove(userId);
            }
        }
    }


    // 특정 사용자에게 이벤트 전송
    public void sendEventToUser(String userId, Object data) {
        List<SseEmitter> emitters = emittersMap.get(userId);
        if (emitters != null) {
            emitters.forEach(emitter -> {
                try {
                    emitter.send(SseEmitter.event().name("message").data(data));
                } catch (IOException e) {
                    log.error("Error sending event to userId: {}", userId, e);
                    removeEmitter(userId, emitter);
                }
            });
        }
    }


    // 모든 사용자에게 이벤트 전송
    public void sendEventToAll(Object data) {
        emittersMap.forEach((userId, emitters) -> {
            sendEventToUser(userId, data);
        });
    }


}


// ===================================

// 파일: backend/src/main/java/com/authentication/auth/service/token/tokenService.java
package com.career_block.auth.service.token;

import jakarta.servlet.http.HttpServletRequest;
import jakarta.servlet.http.HttpServletResponse;
import lombok.RequiredArgsConstructor;
import lombok.extern.slf4j.Slf4j;
import org.springframework.http.HttpStatus;
import org.springframework.http.ResponseEntity;
import org.springframework.stereotype.Service;
import org.springframework.transaction.annotation.Transactional;

import com.authentication.auth.DTO.token.tokenRefreshRequest;
import com.authentication.auth.configuration.token.jwtUtility;
import com.authentication.auth.service.redis.redisService;

import java.io.IOException;

@Slf4j
@Service
@RequiredArgsConstructor
public class tokenService {


    private final jwtUtility jwtUtility;
    private final redisService redisService;

    @Transactional
    public ResponseEntity<?> refreshToken(HttpServletRequest httpRequest, HttpServletResponse httpResponse, tokenRefreshRequest request) throws IOException {

        String expiredToken = request.getExpiredToken();
        String provider = request.getProvider();

        if (jwtUtility.validateJWT(expiredToken)) {
            // token 갱신
            String newToken = jwtUtility.refreshToken(expiredToken);

            // Redis에 갱신된 토큰 저장
            String userId = jwtUtility.getUserIdFromToken(newToken);

            String RToken = jwtUtility.checkCookie(httpRequest, httpResponse, provider);
            if(!redisService.isRTokenExist(userId, provider, RToken)){
                return ResponseEntity.status(HttpStatus.NOT_ACCEPTABLE).body("There is no refresh token in REDIS");
            }

            return ResponseEntity.status(HttpStatus.OK).body(newToken);
        } else {
            return ResponseEntity.status(HttpStatus.NOT_ACCEPTABLE).body("not a valid token");
        }
    }
}


// ===================================

// 파일: backend/src/main/java/com/authentication/auth/service/users/userService.java
package com.career_block.auth.service.users;

import lombok.RequiredArgsConstructor;
import lombok.extern.slf4j.Slf4j;
import org.springframework.http.HttpStatus;
import org.springframework.http.ResponseEntity;
import org.springframework.security.crypto.bcrypt.BCryptPasswordEncoder;
import org.springframework.stereotype.Service;
import org.springframework.transaction.annotation.Transactional;

import com.authentication.auth.DTO.users.joinRequest;
import com.authentication.auth.domain.Role;
import com.authentication.auth.domain.users;
import com.authentication.auth.repository.usersRepository;

@Slf4j
@Service
@RequiredArgsConstructor
public class userService {

    private final usersRepository usersRepository;
    private final BCryptPasswordEncoder passwordEncoder;

    @Transactional
    public ResponseEntity<?> join(joinRequest request){
        if (usersRepository.existsByUserIdOrNickname(request.getUserId(), request.getNickname())) {
            log.error("이미 존재하는 아이디 혹은 닉네임 입니다.");
            return ResponseEntity.status(HttpStatus.CONFLICT).build();
        }

        try {
            joinRequest joinRequestBuilder = joinRequest.builder()
                    .userId(request.getUserId())
                    .userPw(passwordEncoder.encode(request.getUserPw()))
                    .userName(request.getUserName())
                    .nickname(request.getNickname())
                    .phone(request.getPhone())
                    .email(request.getEmail())
                    .role(Role.USER)
                    .birthDate(request.getBirthDate())
                    .gender(request.getGender())
                    .isPrivate(request.isPrivate())
                    .profile(request.getProfile() != null ? request.getProfile() : "대충 이미지")
                    .build();
            users joinUser = joinRequestBuilder.toEntity();
            usersRepository.save(joinUser);
            return ResponseEntity.status(HttpStatus.OK).build();
        } catch (Exception e) {
            log.error("회원 가입 실패", e);
            return ResponseEntity.status(HttpStatus.INTERNAL_SERVER_ERROR).build();
        }
    }


    @Transactional
    public String getEmailByUserId(String userId){
        try{
            users user = usersRepository.findByUserId(userId);
            return user.getEmail();
        } catch (Exception e){
            log.error("이메일 찾기 실패", e);
            return null;
        }
    }


    @Transactional
    public void UpdateUserPassword(String userId, String temporalPassword) {
        try {
            int updateCount = usersRepository.updatePassword(userId, passwordEncoder.encode(temporalPassword));
            if (updateCount == 0) throw new Exception("비밀번호 변경 실패! 사용자를 찾을 수 없음");
        } catch (Exception e) {
            log.error("비밀번호 변경 실패", e);
        }
    }



    @Transactional
    public boolean checkUserIdIsDuplicate(String userId) {
        return usersRepository.existsByUserId(userId);
    }

    @Transactional
    public boolean checkNickNameIsDuplicate(String nickname) {
        return usersRepository.existsByNickname(nickname);
    }



}


// ===================================

