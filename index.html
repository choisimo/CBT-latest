<!DOCTYPE html>
<html lang="ko">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>마음 일기 API 명세서</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700&display=swap" rel="stylesheet">
    <style>
        body {
            font-family: 'Inter', sans-serif;
            background-color: #f9fafb; /* Tailwind gray-50 */
        }
        .container {
            max-width: 1200px;
            margin: 0 auto;
            padding: 20px;
        }
        h1, h2, h3, h4 {
            color: #1f2937; /* Tailwind gray-800 */
            margin-bottom: 0.75em;
        }
        h1 { font-size: 2.25rem; font-weight: 700; border-bottom: 2px solid #e5e7eb; padding-bottom: 0.5rem; margin-bottom: 1.5rem; }
        h2 { font-size: 1.875rem; font-weight: 600; margin-top: 2.5rem; border-bottom: 1px solid #d1d5db; padding-bottom: 0.5rem;}
        h3 { font-size: 1.5rem; font-weight: 600; margin-top: 2rem; }
        h4 { font-size: 1.25rem; font-weight: 600; margin-top: 1.5rem; }
        table {
            width: 100%;
            border-collapse: collapse;
            margin-bottom: 1.5rem;
            box-shadow: 0 1px 3px 0 rgba(0, 0, 0, 0.1), 0 1px 2px 0 rgba(0, 0, 0, 0.06);
            border-radius: 0.5rem;
            overflow: hidden;
        }
        th, td {
            border: 1px solid #e5e7eb; /* Tailwind gray-200 */
            padding: 0.75rem 1rem;
            text-align: left;
            vertical-align: top;
        }
        th {
            background-color: #f3f4f6; /* Tailwind gray-100 */
            font-weight: 600;
            color: #374151; /* Tailwind gray-700 */
        }
        td:first-child {
            font-weight: 500;
            width: 25%;
            color: #4b5563; /* Tailwind gray-600 */
        }
        pre {
            background-color: #1f2937; /* Tailwind gray-800 */
            color: #d1d5db; /* Tailwind gray-300 */
            padding: 1rem;
            border-radius: 0.375rem;
            overflow-x: auto;
            font-size: 0.875rem;
            line-height: 1.6;
            margin-top: 0.5rem;
        }
        code {
            font-family: 'Menlo', 'Monaco', 'Consolas', "Liberation Mono", "Courier New", monospace;
        }
        .toc ul {
            list-style-type: none;
            padding-left: 0;
        }
        .toc li a {
            text-decoration: none;
            color: #2563eb; /* Tailwind blue-600 */
            transition: color 0.3s ease;
        }
        .toc li a:hover {
            color: #1d4ed8; /* Tailwind blue-700 */
            text-decoration: underline;
        }
        .badge {
            display: inline-block;
            padding: 0.25em 0.6em;
            font-size: 0.75em;
            font-weight: 700;
            line-height: 1;
            text-align: center;
            white-space: nowrap;
            vertical-align: baseline;
            border-radius: 0.25rem;
        }
        .badge-get { background-color: #22c55e; color: white; } /* Tailwind green-500 */
        .badge-post { background-color: #3b82f6; color: white; } /* Tailwind blue-500 */
        .badge-put { background-color: #f59e0b; color: white; } /* Tailwind amber-500 */
        .badge-delete { background-color: #ef4444; color: white; } /* Tailwind red-500 */

        /* Navigation styles */
        .nav-container {
            position: sticky;
            top: 0;
            background-color: white;
            z-index: 50;
            padding: 1rem 0;
            box-shadow: 0 2px 4px rgba(0,0,0,0.1);
        }
        .nav-menu {
            display: flex;
            gap: 1rem;
            overflow-x: auto;
            padding-bottom: 0.5rem; /* For scrollbar space if needed */
            white-space: nowrap;
        }
        .nav-menu a {
            padding: 0.5rem 1rem;
            border-radius: 0.375rem;
            text-decoration: none;
            color: #374151; /* Tailwind gray-700 */
            font-weight: 500;
            transition: background-color 0.2s ease-in-out, color 0.2s ease-in-out;
        }
        .nav-menu a:hover, .nav-menu a.active {
            background-color: #e0e7ff; /* Tailwind indigo-100 */
            color: #4338ca; /* Tailwind indigo-700 */
        }

        /* Scrollspy active state for TOC */
        .toc-item.active > a {
            font-weight: bold;
            color: #1d4ed8; /* Tailwind blue-700 */
        }
    </style>
</head>
<body class="bg-gray-50 text-gray-800">
    <div class="nav-container">
        <div class="container">
            <nav id="top-nav" class="nav-menu">
                </nav>
        </div>
    </div>

    <div class="container">
        <header>
            <h1>마음 일기 API 명세서 (Auth 서버 및 연관 API 중심)</h1>
        </header>

        <aside class="toc bg-white p-6 rounded-lg shadow mb-8 float-left mr-8 w-1/4 sticky top-28">
            <h2 class="text-xl font-semibold mb-4">목차</h2>
            <ul id="toc-list">
                </ul>
        </aside>

        <main class="w-3/4 float-right">
            <section id="api-개요">
                <h2>1. API 개요</h2>
                <table>
                    <thead>
                        <tr>
                            <th>항목</th>
                            <th>설명</th>
                        </tr>
                    </thead>
                    <tbody>
                        <tr>
                            <td>기본 URL</td>
                            <td><code>https://your-api-domain.com</code></td>
                        </tr>
                        <tr>
                            <td>버전</td>
                            <td>v1.2</td>
                        </tr>
                        <tr>
                            <td>인증 방식</td>
                            <td>Bearer Token (JWT)</td>
                        </tr>
                        <tr>
                            <td>응답 형식</td>
                            <td>JSON</td>
                        </tr>
                    </tbody>
                </table>
            </section>

            <section id="인증-api">
                <h2>2. 인증 API</h2>
                <article id="인증-상태-확인">
                    <h3>2.1. 인증 상태 확인 (테스트용)</h3>
                    <table>
                        <tr><td>메소드</td><td><span class="badge badge-get">GET</span></td></tr>
                        <tr><td>엔드포인트</td><td><code>/auth_check</code></td></tr>
                        <tr><td>설명</td><td>현재 요청이 유효한 인증 토큰을 가지고 있는지 확인합니다.</td></tr>
                        <tr><td>인증</td><td>Bearer Token 필요</td></tr>
                        <tr><td>응답 코드</td><td>200: 인증됨<br>401: 인증되지 않음</td></tr>
                    </table>
                </article>
                <article id="jwt-토큰-재발급">
                    <h3>2.2. JWT 토큰 재발급</h3>
                    <table>
                        <tr><td>메소드</td><td><span class="badge badge-post">POST</span></td></tr>
                        <tr><td>엔드포인트</td><td><code>/auth/api/protected/refresh</code></td></tr>
                        <tr><td>설명</td><td>만료된 Access Token과 유효한 Refresh Token을 사용하여 새로운 Access Token을 발급받습니다.</td></tr>
                        <tr><td>요청 본문</td><td><pre><code>{
  "expiredToken": "string",
  "provider": "string" // 예: "server", "google"
}</code></pre></td></tr>
                        <tr><td>응답 코드</td><td>200: 토큰 재발급 성공<br>401: Refresh Token이 없거나 유효하지 않음<br>406: 요청이 유효하지 않거나 Redis에 Refresh Token이 없음</td></tr>
                        <tr><td>응답 헤더</td><td>Authorization: Bearer {새로운 액세스 토큰}</td></tr>
                        <tr><td>응답 본문</td><td><pre><code>{
  "access_token": "new_eyJhbGciOiJIUzUxMiJ9..."
}</code></pre></td></tr>
                    </table>
                </article>
            </section>

            <section id="사용자-관리-api">
                <h2>3. 사용자 관리 API</h2>
                <article id="회원-가입">
                    <h3>3.1. 회원 가입</h3>
                    <table>
                        <tr><td>메소드</td><td><span class="badge badge-post">POST</span></td></tr>
                        <tr><td>엔드포인트</td><td><code>/api/public/join</code></td></tr>
                        <tr><td>설명</td><td>새로운 사용자를 등록합니다. 이메일 인증 코드가 사전에 검증되어야 합니다.</td></tr>
                        <tr><td>요청 본문</td><td><pre><code>{
  "userId": "newUser123",
  "userPw": "password123!",
  "userName": "홍길동",
  "nickname": "쾌활한다람쥐",
  "phone": "010-1234-5678",
  "email": "user@example.com",
  "role": "USER", // 기본값: USER
  "birthDate": "1990-01-01",
  "gender": "male",
  "isPrivate": false,
  "profile": "https://zrr.kr/iPHf", // 프로필 이미지 URL
  "code": "A1B2C3D4" // 이메일 인증 코드
}</code></pre></td></tr>
                        <tr><td>응답 코드</td><td>200: 회원 가입 성공<br>400: 잘못된 요청<br>409: 충돌 (이미 존재하는 아이디/닉네임)<br>500: 서버 오류</td></tr>
                        <tr><td>응답 본문</td><td><pre><code>{
  "status": "success",
  "message": "회원가입이 성공적으로 완료되었습니다.",
  "data": null
}</code></pre></td></tr>
                    </table>
                </article>
                <article id="로그인">
                    <h3>3.2. 로그인</h3>
                    <table>
                        <tr><td>메소드</td><td><span class="badge badge-post">POST</span></td></tr>
                        <tr><td>엔드포인트</td><td><code>/api/auth/login</code></td></tr>
                        <tr><td>설명</td><td>사용자 ID와 비밀번호로 로그인하고 JWT 토큰을 발급받습니다. (컨트롤러: <code>TokenController.java</code>)
<p class="mt-2 text-sm text-orange-600"><em>참고: 현재 <code>TokenController.java</code>의 로그인 관련 로직은 실제 인증을 수행하지 않는 <strong>플레이스홀더</strong> 상태입니다. 실제 Spring Security <code>AuthenticationManager</code>를 사용한 인증 로직 구현이 필요합니다.</em></p>
</td></tr>
                        <tr><td>요청 본문</td><td><pre><code>{
  "userId": "newUser123",
  "password": "password123!"
}</code></pre></td></tr>
                        <tr><td>응답 코드</td><td>200: 로그인 성공 (현재 플레이스홀더 기준)<br>400: 잘못된 요청<br>401: 로그인 실패 (현재 플레이스홀더 기준)</td></tr>
                        <tr><td>응답 헤더</td><td>Authorization: Bearer {액세스 토큰}<br>Set-Cookie: refreshToken=xxxxxx; Path=/; Domain=your-cookie-domain.com; HttpOnly; Secure</td></tr>
                        <tr><td>응답 본문</td><td><pre><code>{
  "access_token": "dummy.access.token"
}</code></pre></td></tr>
                    </table>
                </article>
                <article id="프로필-이미지-업로드">
                    <h3>3.3. 프로필 이미지 업로드</h3>
                     <table>
                        <tr><td>메소드</td><td><span class="badge badge-post">POST</span></td></tr>
                        <tr><td>엔드포인트</td><td><code>/api/public/profileUpload</code></td></tr>
                        <tr><td>설명</td><td>사용자 프로필 이미지를 업로드하고 이미지 URL을 반환받습니다.</td></tr>
                        <tr><td>요청 본문</td><td>multipart/form-data 형식<br>profile: 이미지 파일</td></tr>
                        <tr><td>응답 코드</td><td>200: 업로드 성공<br>400: 잘못된 파일<br>500: 서버 오류</td></tr>
                        <tr><td>응답 본문</td><td><pre><code>{
  "status": "success",
  "message": "프로필 이미지가 성공적으로 업로드되었습니다.",
  "data": {
    "fileName": "https://your-file-server.com/attach/profile/xxxx_profile.jpg"
  }
}</code></pre></td></tr>
                    </table>
                </article>
                <article id="사용자-id-중복-체크">
                    <h3>3.4. 사용자 ID 중복 체크</h3>
                    <table>
                        <tr><td>메소드</td><td><span class="badge badge-post">POST</span></td></tr>
                        <tr><td>엔드포인트</td><td><code>/api/public/check/userId/IsDuplicate</code></td></tr>
                        <tr><td>설명</td><td>제공된 사용자 ID가 이미 사용 중인지 확인합니다.</td></tr>
                        <tr><td>요청 본문</td><td><pre><code>{
  "userId": "newUser123"
}</code></pre></td></tr>
                        <tr><td>응답 코드</td><td>200: 중복 체크 결과</td></tr>
                        <tr><td>응답 본문</td><td><pre><code>{
  "status": "success",
  "message": "사용자 ID 중복 확인이 완료되었습니다.",
  "data": false
}</code></pre></td></tr>
                    </table>
                </article>
                <article id="닉네임-중복-체크">
                    <h3>3.5. 닉네임 중복 체크</h3>
                    <table>
                        <tr><td>메소드</td><td><span class="badge badge-post">POST</span></td></tr>
                        <tr><td>엔드포인트</td><td><code>/api/public/check/nickname/IsDuplicate</code></td></tr>
                        <tr><td>설명</td><td>제공된 닉네임이 이미 사용 중인지 확인합니다.</td></tr>
                        <tr><td>요청 본문</td><td><pre><code>{
  "nickname": "쾌활한다람쥐"
}</code></pre></td></tr>
                        <tr><td>응답 코드</td><td>200: 중복 체크 결과</td></tr>
                        <tr><td>응답 본문</td><td><pre><code>{
  "status": "success",
  "message": "닉네임 중복 확인이 완료되었습니다.",
  "data": false
}</code></pre></td></tr>
                    </table>
                </article>
                <article id="사용자-토큰-쿠키-정리">
                    <h3>3.6. 사용자 토큰 쿠키 정리 (로그아웃)</h3>
                    <table>
                        <tr><td>메소드</td><td><span class="badge badge-post">POST</span></td></tr>
                        <tr><td>엔드포인트</td><td><code>/api/public/clean/userTokenCookie</code></td></tr>
                        <tr><td>설명</td><td>클라이언트의 refreshToken 쿠키를 만료시켜 제거합니다.</td></tr>
                        <tr><td>응답 코드</td><td>200: 쿠키 정리 성공</td></tr>
                        <tr><td>응답 본문</td><td><pre><code>{
  "status": "success",
  "message": "리프레시 토큰이 성공적으로 삭제되었습니다.",
  "data": null
}</code></pre></td></tr>
                    </table>
                </article>
            </section>

            <section id="oauth2-api">
                <h2>4. OAuth2 API</h2>
                <article id="oauth2-소셜-로그인-콜백-처리">
                    <h3>4.1. OAuth2 소셜 로그인 콜백 처리</h3>
                    <table>
                        <tr><td>메소드</td><td><span class="badge badge-post">POST</span></td></tr>
                        <tr><td>엔드포인트</td><td><code>/api/public/oauth2/callback/{provider}</code></td></tr>
                        <tr><td>설명</td><td>소셜 프로바이더로부터 인증 후 리디렉션되는 엔드포인트. 각 프로바이더(kakao, naver, google)에 대해 이 경로로 POST 요청을 보냅니다.</td></tr>
                        <tr><td>경로 파라미터</td><td>provider: 소셜 로그인 프로바이더 (kakao, naver, google)</td></tr>
                        <tr><td>요청 본문</td><td><pre><code>{
  "tempCode": "abcdef123456", // 소셜 프로바이더로부터 발급받은 임시 코드
  "state": "xyz789uvw" // CSRF 방어용 상태 값 (Naver 로그인 시 필요)
}</code></pre></td></tr>
                        <tr><td>응답 코드</td><td>200: 소셜 로그인 성공<br>400: 잘못된 요청<br>500: 서버 내부 오류</td></tr>
                        <tr><td>응답 헤더</td><td>Authorization: Bearer {액세스 토큰}<br>Set-Cookie: {provider}_refreshToken=xxxxxx; Path=/; Domain=your-cookie-domain.com; HttpOnly; Secure</td></tr>
                        <tr><td>응답 본문</td><td><pre><code>{
  "access_token": "string",
  "userProfile": {
    // 사용자 프로필 정보
  }
}</code></pre></td></tr>
                    </table>
                </article>
            </section>

            <section id="이메일-api">
                <h2>5. 이메일 API</h2>
                <article id="이메일-인증-코드-발송">
                    <h3>5.1. 이메일 인증 코드 발송</h3>
                    <table>
                        <tr><td>메소드</td><td><span class="badge badge-post">POST</span></td></tr>
                        <tr><td>엔드포인트</td><td><code>/api/public/emailSend</code></td></tr>
                        <tr><td>설명</td><td>회원가입 등을 위한 이메일 인증 코드를 발송합니다.</td></tr>
                        <tr><td>요청 본문</td><td><pre><code>{
  "email": "user@example.com"
}</code></pre></td></tr>
                        <tr><td>응답 코드</td><td>200: 이메일 전송 성공<br>400: 이미 가입된 이메일<br>500: 이메일 전송 실패</td></tr>
                        <tr><td>응답 본문</td><td><pre><code>{
  "message": "A temporary code has been sent to your email"
}</code></pre></td></tr>
                    </table>
                </article>
                <article id="커스텀-이메일-발송">
                    <h3>5.2. 커스텀 이메일 발송 (관리자/내부용)</h3>
                    <table>
                        <tr><td>메소드</td><td><span class="badge badge-post">POST</span></td></tr>
                        <tr><td>엔드포인트</td><td><code>/api/private/customEmailSend</code></td></tr>
                        <tr><td>설명</td><td>지정된 수신자에게 커스텀 제목과 내용으로 이메일을 발송합니다.</td></tr>
                        <tr><td>인증</td><td>Bearer Token 필요</td></tr>
                        <tr><td>요청 본문</td><td><pre><code>{
  "email": "user@example.com",
  "content": "이메일 내용",
  "title": "이메일 제목"
}</code></pre></td></tr>
                        <tr><td>응답 코드</td><td>200: 이메일 전송 성공<br>400: 잘못된 요청<br>500: 이메일 전송 실패</td></tr>
                        <tr><td>응답 본문</td><td><pre><code>{
  "message": "custom email send success"
}</code></pre></td></tr>
                    </table>
                </article>
                <article id="이메일-인증-코드-확인">
                    <h3>5.3. 이메일 인증 코드 확인</h3>
                    <table>
                        <tr><td>메소드</td><td><span class="badge badge-post">POST</span></td></tr>
                        <tr><td>엔드포인트</td><td><code>/api/public/emailCheck</code></td></tr>
                        <tr><td>설명</td><td>발송된 이메일 인증 코드의 유효성을 확인합니다.</td></tr>
                        <tr><td>요청 본문</td><td><pre><code>{
  "email": "user@example.com",
  "code": "A1B2C3D4"
}</code></pre></td></tr>
                        <tr><td>응답 코드</td><td>202: 이메일 코드 유효<br>401: 이메일 코드 무효</td></tr>
                        <tr><td>응답 본문</td><td><pre><code>{
  "message": "email code is valid"
}</code></pre></td></tr>
                    </table>
                </article>
                <article id="임시-비밀번호-이메일-전송-인증된-사용자">
                    <h3>5.4. 임시 비밀번호 이메일 전송 (인증된 사용자)</h3>
                    <table>
                        <tr><td>메소드</td><td><span class="badge badge-post">POST</span></td></tr>
                        <tr><td>엔드포인트</td><td><code>/api/protected/sendEmailPassword</code></td></tr>
                        <tr><td>설명</td><td>현재 로그인된 사용자의 이메일로 임시 비밀번호를 발송합니다.</td></tr>
                        <tr><td>인증</td><td>Bearer Token 필요</td></tr>
                        <tr><td>응답 코드</td><td>200: 임시 비밀번호 전송 성공<br>500: 임시 비밀번호 전송 실패</td></tr>
                        <tr><td>응답 본문</td><td><pre><code>{
  "message": "A temporary password has been sent to your email"
}</code></pre></td></tr>
                    </table>
                </article>
                <article id="아이디로-이메일-찾아-임시-비밀번호-전송">
                    <h3>5.5. 아이디로 이메일 찾아 임시 비밀번호 전송</h3>
                    <table>
                        <tr><td>메소드</td><td><span class="badge badge-post">POST</span></td></tr>
                        <tr><td>엔드포인트</td><td><code>/api/public/findPassWithEmail</code></td></tr>
                        <tr><td>설명</td><td>사용자 ID를 기반으로 등록된 이메일을 찾아 임시 비밀번호를 발송합니다.</td></tr>
                        <tr><td>요청 본문</td><td><pre><code>{
  "userId": "newUser123"
}</code></pre></td></tr>
                        <tr><td>응답 코드</td><td>200: 임시 비밀번호 전송 성공<br>500: 임시 비밀번호 전송 실패</td></tr>
                        <tr><td>응답 본문</td><td><pre><code>{
  "message": "A temporary password has been sent to your email"
}</code></pre></td></tr>
                    </table>
                </article>
            </section>

            <section id="sse-api">
                <h2>6. SSE API</h2>
                <article id="sse-구독">
                    <h3>6.1. SSE (Server-Sent Events) 구독</h3>
                    <table>
                        <tr><td>메소드</td><td><span class="badge badge-get">GET</span></td></tr>
                        <tr><td>엔드포인트</td><td><code>/api/protected/sse/subscribe</code></td></tr>
                        <tr><td>설명</td><td>서버로부터 실시간 이벤트 스트림을 구독합니다.</td></tr>
                        <tr><td>인증</td><td>Bearer Token 필요</td></tr>
                        <tr><td>요청 헤더</td><td>Last-Event-ID: 마지막으로 수신한 이벤트 ID (선택적)</td></tr>
                        <tr><td>응답 코드</td><td>200: SSE 구독 성공<br>401: 인증 실패<br>500: 서버 오류</td></tr>
                        <tr><td>응답 형식</td><td>text/event-stream</td></tr>
                        <tr><td>응답 예시</td><td><pre><code>id: 123
event: INIT
data: {"message": "Subscription successful"}

id: 124
event: message
data: {"content": "New notification!"}</code></pre></td></tr>
                    </table>
                </article>
                <article id="특정-사용자에게-더미-sse-데이터-전송">
                    <h3>6.2. 특정 사용자에게 더미 SSE 데이터 전송 (테스트용)</h3>
                     <table>
                        <tr><td>메소드</td><td><span class="badge badge-post">POST</span></td></tr>
                        <tr><td>엔드포인트</td><td><code>/api/public/dummyData/{user_id}</code></td></tr>
                        <tr><td>설명</td><td>지정된 사용자 ID에게 SSE 이벤트를 발생시킵니다.</td></tr>
                        <tr><td>경로 파라미터</td><td>user_id: SSE 이벤트를 수신할 사용자의 ID</td></tr>
                        <tr><td>요청 본문</td><td><pre><code>{
  "message": "Hello from server!"
}</code></pre></td></tr>
                        <tr><td>응답 코드</td><td>200: 더미 데이터 전송 성공<br>400: 잘못된 요청</td></tr>
                    </table>
                </article>
            </section>

            <section id="관리자-필터-api">
                <h2>7. 관리자 필터 관리 API</h2>
                <p class="mb-4">이 API를 통해 관리자는 시스템 내에서 플러그형 필터를 관리하고 구성할 수 있습니다. 이러한 필터는 정의된 조건에 따라 요청을 가로챌 수 있으므로 보안 규칙이나 요청 처리 동작을 동적으로 수정할 수 있습니다. 모든 엔드포인트는 <code>ADMIN</code> 역할이 필요합니다. 기본 경로는 <code>/api/admin/filters</code> 입니다.</p>
                <article id="admin-모든-필터-가져오기">
                    <h3>7.1. 등록된 모든 필터 가져오기</h3>
                    <table>
                        <tr><td>메소드</td><td><span class="badge badge-get">GET</span></td></tr>
                        <tr><td>엔드포인트</td><td><code>/api/admin/filters</code></td></tr>
                        <tr><td>설명</td><td>현재 등록된 모든 플러그형 필터 및 적용된 조건 목록을 검색합니다.</td></tr>
                        <tr><td>인증</td><td>Bearer Token (ADMIN 역할) 필요</td></tr>
                        <tr><td>응답 코드</td><td>200: 성공<br>401: 권한 없음<br>403: 금지됨</td></tr>
                        <tr><td>응답 본문 (성공 200)</td><td><pre><code>{
  "filters": [
    {
      "filterId": "jwtVerificationFilter",
      "filterClassName": "JwtVerificationFilter",
      "conditions": [
        {
          "id": "uuid1-jwt-public",
          "description": "public paths",
          "patterns": ["/public/**"],
          "methods": []
        }
      ]
    }
    // ... 추가 필터 정보
  ]
}</code></pre></td></tr>
                    </table>
                </article>

                <article id="admin-필터-조건-추가">
                    <h3>7.2. 필터에 조건 추가</h3>
                    <table>
                        <tr><td>메소드</td><td><span class="badge badge-post">POST</span></td></tr>
                        <tr><td>엔드포인트</td><td><code>/api/admin/filters/{filterId}/conditions</code></td></tr>
                        <tr><td>설명</td><td>지정된 필터에 새 <code>PathPatternFilterCondition</code>을 추가합니다. 이 조건은 필터 동작이 변경될 수 있는 (예: 건너뛰기) URL 패턴 및 HTTP 메소드를 정의합니다.</td></tr>
                        <tr><td>인증</td><td>Bearer Token (ADMIN 역할) 필요</td></tr>
                        <tr><td>경로 변수</td><td><code>filterId</code> (문자열): 조건을 추가할 필터의 고유 ID (예: "jwtVerificationFilter")</td></tr>
                        <tr><td>요청 본문</td><td><pre><code>{
  "description": "Allow public access to specific API endpoints",
  "patterns": ["/api/public/version", "/api/public/health"],
  "methods": ["GET"]
}</code></pre></td></tr>
                        <tr><td>응답 코드</td><td>200: 성공<br>400: 잘못된 요청 (예: 잘못된 요청 본문)<br>401: 권한 없음<br>403: 금지됨<br>404: 필터를 찾을 수 없음</td></tr>
                        <tr><td>응답 본문 (성공 200)</td><td><pre><code>{
  "message": "Condition added successfully to filter jwtVerificationFilter"
}</code></pre></td></tr>
                    </table>
                </article>

                <article id="admin-필터-조건-제거">
                    <h3>7.3. 필터에서 조건 제거</h3>
                    <table>
                        <tr><td>메소드</td><td><span class="badge badge-delete">DELETE</span></td></tr>
                        <tr><td>엔드포인트</td><td><code>/api/admin/filters/{filterId}/conditions/{conditionId}</code></td></tr>
                        <tr><td>설명</td><td>조건의 고유 ID를 사용하여 지정된 필터에서 특정 조건을 제거합니다.</td></tr>
                        <tr><td>인증</td><td>Bearer Token (ADMIN 역할) 필요</td></tr>
                        <tr><td>경로 변수</td><td><code>filterId</code> (문자열): 필터 ID.<br><code>conditionId</code> (문자열): 제거할 조건의 고유 ID.</td></tr>
                        <tr><td>응답 코드</td><td>200: 성공<br>401: 권한 없음<br>403: 금지됨<br>404: 필터 또는 조건을 찾을 수 없음</td></tr>
                        <tr><td>응답 본문 (성공 200)</td><td><pre><code>{
  "message": "Condition uuid1-jwt-public removed successfully from filter jwtVerificationFilter"
}</code></pre></td></tr>
                    </table>
                </article>

                <article id="admin-필터-상태-설정">
                    <h3>7.4. 필터 상태 설정 (활성화/비활성화)</h3>
                    <table>
                        <tr><td>메소드</td><td><span class="badge badge-post">POST</span></td></tr>
                        <tr><td>엔드포인트</td><td><code>/api/admin/filters/{filterId}/status</code></td></tr>
                        <tr><td>설명</td><td>특정 필터를 활성화하거나 비활성화합니다. <br> - 필터 <strong>활성화</strong>는 해당 로직에 따라 요청을 처리함을 의미합니다 (특정 조건으로 인해 건너뛰지 않는 한). <br> - 필터 <strong>비활성화</strong>는 요청을 처리하지 않음을 의미합니다.</td></tr>
                        <tr><td>인증</td><td>Bearer Token (ADMIN 역할) 필요</td></tr>
                        <tr><td>경로 변수</td><td><code>filterId</code> (문자열): 필터 ID.</td></tr>
                        <tr><td>쿼리 파라미터</td><td><code>action</code> (문자열): 수행할 작업. "enable" 또는 "disable"이어야 합니다.</td></tr>
                        <tr><td>응답 코드</td><td>200: 성공<br>400: 잘못된 요청 (예: 잘못된 작업 매개변수)<br>401: 권한 없음<br>403: 금지됨<br>404: 필터를 찾을 수 없음</td></tr>
                        <tr><td>응답 본문 (성공 200)</td><td><pre><code>{
  "message": "Filter jwtVerificationFilter enabled" // 또는 "Filter jwtVerificationFilter disabled"
}</code></pre></td></tr>
                    </table>
                </article>
            </section>
            
            <section id="데이터-모델">
                <h2>8. 데이터 모델</h2>
                <article id="인증-및-사용자-모델">
                    <h3>8.1. 인증 및 사용자 모델</h3>
                    <table>
                        <thead><tr><th>모델</th><th>설명</th><th>주요 필드</th></tr></thead>
                        <tbody>
                            <tr><td>JoinRequest</td><td>회원가입 요청</td><td>userId, userPw, userName, nickname, phone, email, role, birthDate, gender, isPrivate, profile, code</td></tr>
                            <tr><td>LoginRequest</td><td>로그인 요청</td><td>userId, password</td></tr>
                            <tr><td>LoginResponse</td><td>로그인 응답</td><td>access_token</td></tr>
                            <tr><td>TokenRefreshRequest</td><td>토큰 갱신 요청</td><td>expiredToken, provider</td></tr>
                            <tr><td>TokenRefreshResponse</td><td>토큰 갱신 응답</td><td>access_token</td></tr>
                            <tr><td>OAuth2CallbackRequest</td><td>OAuth2 콜백 요청</td><td>tempCode, state</td></tr>
                            <tr><td>OAuth2LoginUrlResponse</td><td>OAuth2 로그인 URL 응답</td><td>login_url</td></tr>
                            <tr><td>OAuth2LoginResponse</td><td>OAuth2 로그인 응답</td><td>access_token, userProfile</td></tr>
                        </tbody>
                    </table>
                </article>
                <article id="이메일-모델">
                    <h3>8.2. 이메일 모델</h3>
                    <table>
                        <thead><tr><th>모델</th><th>설명</th><th>주요 필드</th></tr></thead>
                        <tbody>
                            <tr><td>EmailRequest</td><td>이메일 요청</td><td>email</td></tr>
                            <tr><td>EmailSendResponse</td><td>이메일 전송 응답</td><td>message</td></tr>
                            <tr><td>CustomEmailRequest</td><td>커스텀 이메일 요청</td><td>email, content, title</td></tr>
                            <tr><td>EmailCheckDto</td><td>이메일 확인 요청</td><td>email, code</td></tr>
                            <tr><td>EmailCheckResponse</td><td>이메일 확인 응답</td><td>message</td></tr>
                        </tbody>
                    </table>
                </article>
                <article id="데이터모델-일기-및-분석-모델">
                    <h3>8.3. 일기 및 분석 모델 (참고용 - 현재 비활성 API)</h3>
                    <table>
                        <thead><tr><th>모델</th><th>설명</th><th>주요 필드</th></tr></thead>
                        <tbody>
                            <tr><td>DiaryCreateRequest</td><td>일기 생성 요청</td><td>title, content</td></tr>
                            <tr><td>DiaryResponse</td><td>일기 응답</td><td>id, userId, title, content, createdAt, updatedAt</td></tr>
                            <tr><td>DiaryUpdateRequest</td><td>일기 수정 요청</td><td>title, content</td></tr>
                            <tr><td>DiaryListItem</td><td>일기 목록 항목</td><td>id, title, createdAt, emotionStatus</td></tr>
                            <tr><td>DiaryDetailResponse</td><td>일기 상세 응답</td><td>id, userId, title, content, alternativeThoughtByAI, createdAt, updatedAt, analysis</td></tr>
                            <tr><td>DiaryAnalysisResult</td><td>일기 분석 결과</td><td>id, emotionDetection, automaticThought, promptForChange, alternativeThought, status, analyzedAt</td></tr>
                            <tr><td>DiaryAnalysisRequestResponse</td><td>일기 분석 요청 응답</td><td>message, diaryId, trackingId</td></tr>
                        </tbody>
                    </table>
                </article>
                <article id="데이터모델-설정-모델">
                    <h3>8.4. 설정 모델 (참고용 - 현재 비활성 API)</h3>
                    <table>
                        <thead><tr><th>모델</th><th>설명</th><th>주요 필드</th></tr></thead>
                        <tbody>
                            <tr><td>SettingItem</td><td>설정 항목</td><td>settingKey, value, dataType, description, isUserEditable</td></tr>
                            <tr><td>SettingsListResponse</td><td>설정 목록 응답</td><td>settings</td></tr>
                            <tr><td>SettingsUpdateRequestItem</td><td>설정 수정 요청 항목</td><td>settingKey, newValue</td></tr>
                            <tr><td>SettingsUpdateRequest</td><td>설정 수정 요청</td><td>settingsToUpdate</td></tr>
                            <tr><td>SettingsUpdateResponse</td><td>설정 수정 응답</td><td>message, updatedSettings</td></tr>
                        </tbody>
                    </table>
                </article>
                <article id="오류-모델">
                    <h3>8.5. 오류 모델</h3>
                    <table>
                        <thead><tr><th>모델</th><th>설명</th><th>주요 필드</th></tr></thead>
                        <tbody>
                            <tr><td>ErrorResponse</td><td>오류 응답</td><td>timestamp, status, error, message, path</td></tr>
                        </tbody>
                    </table>
                </article>
                <article id="데이터모델-admin-filter-모델">
                    <h3>8.6. Admin Filter 모델</h3>
                     <table>
                        <thead><tr><th>모델</th><th>설명</th><th>주요 필드</th></tr></thead>
                        <tbody>
                            <tr><td>FilterInfo</td><td>등록된 필터 정보</td><td>filterId, filterClassName, conditions (List&lt;ConditionInfo&gt;)</td></tr>
                            <tr><td>ConditionInfo</td><td>필터 조건 정보</td><td>id, description, patterns (Set&lt;String&gt;), methods (Set&lt;String&gt;)</td></tr>
                            <tr><td>FilterListResponse</td><td>모든 필터 목록 응답</td><td>filters (List&lt;FilterInfo&gt;)</td></tr>
                            <tr><td>AddConditionRequest</td><td>필터 조건 추가 요청</td><td>description (String), patterns (Set&lt;String&gt;), methods (Set&lt;HttpMethod&gt;)</td></tr>
                            <tr><td>MessageResponse</td><td>일반 메시지 응답</td><td>message (String)</td></tr>
                        </tbody>
                    </table>
                </article>
                <article id="공통-응답-모델">
                    <h3>8.7. 공통 응답 모델 (Common Response Models)</h3>
                    <table>
                        <thead><tr><th>모델</th><th>설명</th><th>주요 필드</th></tr></thead>
                        <tbody>
                            <tr><td>ApiResponse&lt;T&gt;</td><td>공통 API 응답 구조</td><td>status (String), message (String), data (T)</td></tr>
                        </tbody>
                    </table>
                </article>
            </section>
        </main>
        <div style="clear:both;"></div>
    </div>

    <footer class="text-center p-8 mt-12 border-t border-gray-200 text-gray-500">
        마음 일기 API 명세서 &copy; 2024
    </footer>

    <script>
        // JavaScript for dynamic TOC and Scrollspy
        document.addEventListener('DOMContentLoaded', function () {
            const tocList = document.getElementById('toc-list');
            const topNav = document.getElementById('top-nav');
            const sections = document.querySelectorAll('main section');
            const articles = document.querySelectorAll('main article'); // For more granular TOC

            // Populate TOC
            sections.forEach((section, sectionIndex) => {
                const sectionTitleElement = section.querySelector('h2');
                if (!sectionTitleElement) return;

                const sectionTitle = sectionTitleElement.textContent;
                const sectionId = section.id;

                const sectionListItem = document.createElement('li');
                sectionListItem.classList.add('toc-item', 'mb-2');
                const sectionLink = document.createElement('a');
                sectionLink.href = `#${sectionId}`;
                sectionLink.textContent = sectionTitle;
                sectionLink.classList.add('block', 'hover:text-blue-600', 'transition-colors');
                sectionListItem.appendChild(sectionLink);
                
                // Top navigation link for main sections
                const topNavLink = document.createElement('a');
                topNavLink.href = `#${sectionId}`;
                topNavLink.textContent = sectionTitle.split('. ')[1]; // Get title without number
                topNav.appendChild(topNavLink);


                const subList = document.createElement('ul');
                subList.classList.add('ml-4', 'mt-1');

                const sectionArticles = section.querySelectorAll('article');
                sectionArticles.forEach((article, articleIndex) => {
                    const articleTitleElement = article.querySelector('h3');
                    if (!articleTitleElement) return;

                    const articleTitle = articleTitleElement.textContent;
                    const articleId = article.id;

                    const articleListItem = document.createElement('li');
                    articleListItem.classList.add('toc-item', 'mb-1');
                    const articleLink = document.createElement('a');
                    articleLink.href = `#${articleId}`;
                    articleLink.textContent = articleTitle;
                    articleLink.classList.add('text-sm', 'text-gray-600', 'hover:text-blue-500', 'transition-colors');
                    articleListItem.appendChild(articleLink);
                    subList.appendChild(articleListItem);
                });

                if (subList.children.length > 0) {
                    sectionListItem.appendChild(subList);
                }
                tocList.appendChild(sectionListItem);
            });

            // Scrollspy
            const tocLinks = document.querySelectorAll('.toc-item a');
            const topNavLinks = document.querySelectorAll('#top-nav a');
            const allNavLinks = Array.from(tocLinks).concat(Array.from(topNavLinks));

            const observerCallback = (entries) => {
                entries.forEach(entry => {
                    const id = entry.target.getAttribute('id');
                    const correspondingTocLink = document.querySelector(`.toc-item a[href="#${id}"]`);
                    const correspondingTopNavLink = document.querySelector(`#top-nav a[href="#${id}"]`);

                    if (entry.isIntersecting) {
                        allNavLinks.forEach(link => link.classList.remove('active'));
                        if (correspondingTocLink) correspondingTocLink.parentElement.classList.add('active');
                        if (correspondingTopNavLink) correspondingTopNavLink.classList.add('active');
                    } else {
                         if (correspondingTocLink) correspondingTocLink.parentElement.classList.remove('active');
                         if (correspondingTopNavLink) correspondingTopNavLink.classList.remove('active');
                    }
                });
            };

            const observerOptions = {
                rootMargin: '-20% 0px -70% 0px', // Adjust to highlight when section is in the middle part of viewport
                threshold: 0.1
            };

            const observer = new IntersectionObserver(observerCallback, observerOptions);
            document.querySelectorAll('main section[id], main article[id]').forEach(el => observer.observe(el));
        });
    </script>
</body>
</html>
